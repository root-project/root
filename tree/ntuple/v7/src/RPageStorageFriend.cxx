/// \file RPageStorageFriend.cxx
/// \ingroup NTuple ROOT7
/// \author Simon Leisibach <simon.satoshi.rene.leisibach@cern.ch>
/// \date 2019-10-04
/// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback
/// is welcome!

/*************************************************************************
 * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/

#include <ROOT/RNTupleOptions.hxx>
#include <ROOT/RPageStorage.hxx>
#include <ROOT/RPageStorageFriend.hxx>

#include <ROOT/RLogger.hxx>

#include <TError.h>

#include <memory>
#include <unordered_map>

ROOT::Experimental::Detail::RPageSourceFriend::RPageSourceFriend(std::string_view ntupleName,
                                                                 std::vector<std::string> locationVec,
                                                                 const RNTupleReadOptions &options)
   : RPageSource{ntupleName, options}
{
   for (const auto &location : locationVec) {
      fSources.emplace_back(Create(ntupleName, location, options));
      fSources.back()->Attach();
   }

   fUnsafe = CompareFileMetaData();
   InitializeMemberVariables();
}

ROOT::Experimental::Detail::RPageSourceFriend::RPageSourceFriend(std::string_view ntupleName,
                                                                 std::vector<RPageSource *> sources,
                                                                 const RNTupleReadOptions &options)
   : RPageSource{ntupleName, options}
{
   for (const auto &s : sources) {
      fSources.emplace_back(s->Clone());
      fSources.back()->Attach();
   }

   fUnsafe = CompareFileMetaData();
   InitializeMemberVariables();
}

ROOT::Experimental::Detail::RPageSourceFriend::RPageSourceFriend(std::string_view ntupleName,
                                                                 std::vector<std::unique_ptr<RPageSource>> &&sources,
                                                                 const RNTupleReadOptions &options)
   : RPageSource{ntupleName, options}, fSources{std::move(sources)}
{
   fUnsafe = CompareFileMetaData();
   InitializeMemberVariables();
}

bool ROOT::Experimental::Detail::RPageSourceFriend::CompareFileMetaData()
{
   auto &desc = fSources.at(0)->GetDescriptor();
   for (std::size_t i = 1; i < fSources.size(); ++i) {
      // checks only number of clusters
      if (desc.GetNClusters() != fSources.at(i)->GetDescriptor().GetNClusters()) {
         R__WARNING_HERE("NTuple") << "The meta-data (number of clusters) of the files do not match. A nullptr was "
                                      "returned, please make sure all files have the same number of clusters!";
         return true;
      }
      // checks if clusters are compatible with each other for usage in RPageStorageFriend
      for (std::size_t i = 0; i < desc.GetNClusters(); ++i) {
         if (!desc.GetClusterDescriptor(i).BeFriendAble(fSources.at(i)->GetDescriptor().GetClusterDescriptor(i))) {
            R__WARNING_HERE("NTuple")
               << "The meta-data of the clusters of the files do not match. A nullptr was returned, please make sure "
                  "all the clusters in all files have the same number of entries!";
            return true;
         }
      }
   }

   // No need to check for common field names if the RNTupleModel is not generated by the descriptor.
   if (fOptions.UsesUserGeneratedModel())
      return false;

   // Checks if 2 RPageSources have a common field name. From a runtime perspective, sorting and then comparing adjacent
   // fieldNames would be faster. But for better readability of code another implementation was chosen.
   for (std::size_t i = 0; i < fSources.size(); ++i) {
      for (std::size_t j = i + 1; j < fSources.size(); ++j) {
         if (fSources.at(i)->GetDescriptor().CommonFieldNameExists(fSources.at(j)->GetDescriptor())) {
            R__WARNING_HERE("NTuple") << "The files contain multiple fields with the same field name! A nullptr was "
                                         "returned, please make sure all fields have unique names!";
            return true;
         }
      }
   }
   return false;
}

void ROOT::Experimental::Detail::RPageSourceFriend::InitializeMemberVariables()
{
   // initialize fNColumnPerSource
   fNColumnPerSource.resize(fSources.size() + 1);
   for (std::size_t i = 0; i < fSources.size(); ++i) {
      fNColumnPerSource.at(i + 1) = fNColumnPerSource.at(i) + fSources.at(i)->GetDescriptor().GetNColumns();
   }
}

ROOT::Experimental::RNTupleDescriptor ROOT::Experimental::Detail::RPageSourceFriend::DoAttach()
{
   RNTupleDescriptorBuilder descBuilder;
   const auto &zeroDescriptor = fSources.at(0)->GetDescriptor();
   descBuilder.SetNTuple(zeroDescriptor);
   descBuilder.AddFieldsAndColumnsFromDescriptor(fSources.at(0)->GetDescriptor());
   descBuilder.AddClustersFromDescriptor(fSources.at(0)->GetDescriptor());

   for (std::size_t i = 1; i < fSources.size(); ++i) {
      descBuilder.AddFriendInfo(fSources.at(i)->GetDescriptor());
   }
   return descBuilder.MoveDescriptor();
}

std::unique_ptr<ROOT::Experimental::Detail::RPageSource> ROOT::Experimental::Detail::RPageSourceFriend::Clone() const
{
   std::vector<RPageSource *> sourceVec;
   for (const auto &s : fSources) {
      sourceVec.emplace_back(s.get());
   }
   return std::make_unique<RPageSourceFriend>(fNTupleName, sourceVec, fOptions);
}

ROOT::Experimental::Detail::RPage
ROOT::Experimental::Detail::RPageSourceFriend::PopulatePage(ColumnHandle_t columnHandle, NTupleSize_t globalIndex)
{
   std::size_t sourceId = 0;
   for (; sourceId < fNColumnPerSource.size(); ++sourceId) {
      if (columnHandle.fId < (int)fNColumnPerSource.at(sourceId + 1)) {
         break;
      }
   }
   columnHandle.fId -= fNColumnPerSource.at(sourceId);
   RPage page{fSources.at(sourceId)->PopulatePage(columnHandle, globalIndex)};

   if (fPageMapper.find(page.GetBuffer()) == fPageMapper.end()) {
      fPageMapper.emplace(page.GetBuffer(), PageInfoFriend{sourceId, 1});
   } else {
      fPageMapper.at(page.GetBuffer()).fNSamePagePopulated += 1;
   }
   return page;
}

ROOT::Experimental::Detail::RPage
ROOT::Experimental::Detail::RPageSourceFriend::PopulatePage(ColumnHandle_t columnHandle,
                                                            const RClusterIndex &clusterIndex)
{
   std::size_t sourceId = 0;
   for (; sourceId < fNColumnPerSource.size(); ++sourceId) {
      if (columnHandle.fId < (int)fNColumnPerSource.at(sourceId + 1)) {
         break;
      }
   }
   columnHandle.fId -= fNColumnPerSource.at(sourceId);
   RPage page{fSources.at(sourceId)->PopulatePage(columnHandle, clusterIndex)};

   if (fPageMapper.find(page.GetBuffer()) == fPageMapper.end()) {
      fPageMapper.emplace(page.GetBuffer(), PageInfoFriend{sourceId, 1});
   } else {
      fPageMapper.at(page.GetBuffer()).fNSamePagePopulated += 1;
   }
   return page;
}

void ROOT::Experimental::Detail::RPageSourceFriend::ReleasePage(RPage &page)
{
   if (page.IsNull())
      return;
   auto mapIterator = fPageMapper.find(page.GetBuffer());
   if (mapIterator == fPageMapper.end())
      R__ASSERT(false && "Page could not be assigned to source and released.");
   fSources.at(mapIterator->second.fSourceId)->ReleasePage(page);
   // Sometimes malloc allocates the same memory location as a previous malloc.
   // To avoid a collision of keys for such cases, the entry is deleted from std::unordered_map when released.
   if (mapIterator->second.fNSamePagePopulated-- == 1)
      fPageMapper.erase(mapIterator);
}
