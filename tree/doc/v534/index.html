<br/>
<hr/>
<a name="tree"></a>
<h3>Tree Libraries</h3>

<h4>Performance</h4>
<ul>
<li>Automatic support for multiple <tt>TTreeCache</tt> per <tt>TFile</tt>.<p/>
Multiple <tt>TTreeCache</tt> per <tt>TFile</tt> for reading are supported by using the existing <tt>TTree::SetCacheSize(Long64_t)</tt> interface.<p/>
In addition, a <tt>TTreeCache</tt> for a <tt>TTree</tt> can be added using <tt>TFile::SetCacheRead(TFileCacheRead*, TObject*)</tt>, where the second (optional) argument is a pointer to the <tt>TTree</tt>. The cache can be removed by setting the pointer to 0.  In that case the user will have to take ownership for the cache.<p/>
Similarily, a pointer to the <tt>TTreeCache</tt> for a <tt>TTree</tt> can be obtained using <tt>TFile::GetCacheRead(TObject*)</tt>.
</li>
<li>In <tt>TBuffer::Expand</tt>, when shrinking the buffer do not shrink below the size of the
data already accumulated in the buffer (i. no less than the value of <tt>TBuffer::Length</tt>).
<p/>
In <tt>TBranch::SetBasketSize</tt>, instead of using the hard minimum of 100, use
100 + the length of the branch name (as 100 is too small to hold the
basket's key information for any branch name larger than 30 characters).</li>

</ul>

<h4>Reading form text file</h4>

Reworked <tt>TTree::ReadStream</tt> and <tt>TTree::ReadFile</tt> mainly to fix delimited reading of string columns:
<ul>
<li><tt>TLeaf::ReadValue</tt> now takes an optional delimiter argument that is ignored for all but TLeafC. Here, input stops when reading this character, instead of at the first whitespace.
Use that in TTree::ReadStream() to delimit reading of TLeafC.</li>
<li><tt>TTree::ReadStream</tt> now tokenizes the row itself, and passes a stringstream containing nothing but the current column to <tt>TLeaf::ReadValue</tt>.</li>
<li>Separate concepts of number of input line (for communication with user) and number of good lines (as returned).</li>
<li>Fix windows files leaving '\n' in branch names when reading them from the file.</li>
<li>Add error message for TLeaf::ReadValue(), i.e. if ReadValue() is called on a derived class that doesn't implement it.</li>
<li>Updated and clarified the documentation</li>
</ul>

<h4>TEntryList</h4>
<ul>
<li>Add new methods to find the base location of files and to modify it.
  This allows to relocate the entry-lists to be able to use them of a
  system where the files have a different absolute path.
  The most relevant new methods are:
<ul>
    <li><tt>TEntryList::Scan(const char *fn)</tt>
      Shows the root common paths for the files of the TEntryLists in 'fn'</li>
    <li><pre lang="cxx">TEntryList::Relocate(const char *fn, const char *newroot,
                           const char *oldroot = 0, const char *enlnm = 0)</pre>
      Relocates all paths starting with 'oldroot' to 'newroot' for the
      entry-list 'enlnm' in file 'fn'.</li>
</ul>
</li>
<li>Remove 'protocol+server' from file tagging and matching, i.e. use
  only filepath+anchor; in this way a list is valid even after re-staging
  of the dataset files, which typically changes the end-point data servers.</li>
<li>Entry-lists created with the full path should still be matched correctly.</li>
</ul>

<h4>Miscellaneous</h4>
<ul>
<li>Repaired the behavior of <tt>TTreeCache</tt> when the TTree has a dramatic dynamic range with a lots of very small entriesat the beginning and very large entries at the end, the size in bytes of the cluster for the later entries will be very large (because of the cluster size in entries is large!).  TTreeCache::FillBuffer was always attempting to load complete clusters not matter the
size (even with the size was larger than 2GB!).

This patch resolves the issue by limiting the amount of memory used to:
<ol>
<li>The requested size if more than one cluster fits in the cache.</li>
<li>Twice the requested size if at least one basket per branch fits in the cache.</li>
<li>Four time the requested size in the case where the cache can not even hold one basket per branch.</li>
</ol>
The filling will restart at the next cluster boundary in the case a) and will
restart at the maximum of entry number read in the cache in the case b) and c).
Baskets that are below this boundary and did not fit in the cache will be read
individually.</li>
<li>Repaired the basket flushing frequency when the <tt>TTree</tt> has already more than one cluster size.</li>
<li>Repaired binning of string histogram generated by  <tt>TTree::Draw.</tt></li>
<li>Many bug fixes and fix for issues discovery by Coverity, see change log for more details.</li>
<li>In <tt>TTree::MakeProxy</tt> add proper support for top level stl collection of objects and for stl collection of objects that are 'empty' in the file (and thus we know nothing about its content).</li>
<li>Avoid deficiency in <tt>hadd</tt>  when the resulting <tt>TTree</tt> is longer than the <tt>AutoSave</tt> length *and* the <tt>TFileMerger</tt> needs to handle the input files in more than one pass for example when there is more than 1000 input files or the -n option is passed to <tt>hadd</tt>.</li>
<li>Fix support for emulated class that derived from an abstract class.
This can happen when reading a file containing an ancient
class layout where the derived class is no longer provided in the
compiled code but the abstract base class is still provided.

It also happens when using schema evolution rules on a class derived
from an abstract base class (in which case the system introduce
implicitly an emulated class deriving from the same base classes
as the evolved from class).  To fix the issue, we introduce the <tt>TClass::GetStreamerInfoAbstractEmulated</tt>
which will return a StreamerInfo representing an emulated version of the
class even if it is loaded.</li>

</ul>


