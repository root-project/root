<br/>
<hr/>
<a name="tree"></a> 
<h3>Tree</h3>
<ul>
<li>Introduce TBranch::Set/GetMakeClass to independently set each branch in MakeClass mode 
and to have a good place to switch the ReadLeaves function appropriately (to and from
the MakeClass mode (also known as the decomposed object mode)).   This can also be
used to reset the mode of some branch with a MakeClass/MakeSelector file.
</li>
<li>Dramatically reduce the amount of memory allocation induces by the management of the TBasket and TBuffer
for each branch.  Instead of creating one TBasket object and one TBuffer object and its associated memory buffer
for each onfile basket of each branch, we now create only one TBasket and one TBuffer object for the lifetime of
each branch.  The memory buffer associated with the TBuffer object is also created once and rarely reallocated;
it is reallocated only when the buffer size is reset (for example by the AutoFlush mechanism) and when the user
object do not fit in the currently allocated memory (but we do not shrink it after that.  The same minization 
is applied to the scratch area used to read the compressed version of a basket from the file.</li>
<li>In TTree and TChain LoadTree fReadEntry is now set to -1 in case of failure to find the proper row.</li>
<li>In TTree::CloneTree, TChain::Merge and TTree::CopyEntries introduces more flexibility
in the handling of the case where a TTreeIndex is 'missing' in one or more of the 
TTree objects being collated.   If the tree or any of the underlying tree of the chain has an index, 
that index and any index in the subsequent underlying TTree objects will be merged. There are currently three 'options' 
to control this merging:
   <ul>
   <li>NoIndex             : all the TTreeIndex object are dropped.</li>
   <li>DropIndexOnError    : if any of the underlying TTree object do no have a TTreeIndex,
                             they are all dropped.</li>
   <li>AsIsIndexOnError [default]: In case of missing TTreeIndex, the resulting TTree index has gaps.</li>
   <li>BuildIndexOnError : If any of the underlying TTree object do no have a TTreeIndex,
                           all TTreeIndex are 'ignored' and the mising piece are rebuilt.</li>
   </ul>
   Previously the index were kept only if the first files had an index and if there was any missing index,
   the resulting index had gaps (the default was similar to AsIsIndexOnError).   The new default is BuildIndexOnError  ; i.e.
we now attempt by default to build the missing indices.
</li>
<li>Warning: The TTreeCache is no longer enabled by default in a TChain to align the behavior with a TTree.  You need to call
TTree::SetCacheSize to enable the TTreeCache.</li> 
<li>Correct and clarify the relationship between AutoFlush and AutoSave:
   <ul>
   <li>Both the AutoFlush and AutoSave interval can be specified in
terms of bytes (a negative value for fAutoFlush or fAutoSave)
or in terms of the number of entries (positive values).</li>
   <li>An AutoFlush is always done with an AutoSave.</li>
   <li>If the interval specified for AutoSave is less than that for
AutoFlush, the AutoSave interval is used for both.</li>
   <li>If the AutoFlush interval is less than the AutoSave interval,
the AutoSave interval is adjusted to the largest integer
multiple of the AutoFlush interval that is less than or equal
to the original value of the AutoSave interval.</li>
   </ul>
</li>
<li>Update MakeProxy so that the resulting skeleton is useable with Proof.</li>
<li>Replace the ReadLeaves virtual function by a fReadLeaves pointer to member function,
this allows the customization of the ReadLeaves function at run-time depending on the
underlying user class layout in TBranchElement.  This removes many if statements whose
'answer' is known at initialization time.
</li>
<li>Add support for 'array' formula in TTree::Query.</li>
<li>Set the initial value of fCacheSize to zero to indicate clearly that the TreeCache is disabled.</li>
<li>In TChain::SetEntryList use only the treename to lookup the (sub)entryList (instead subdir/treename).</li>
<li>Add support for the branch creation syntax:
<pre style="border:gray 1px solid;padding:0.5em 2em;background:#ffe">   TString rootString;
   t->Branch("rootString","TString",&amp;rootString, 1600, 0);</pre>
which is 'natural' as it uses the legacy syntax (branch_name,class_name, user_data)
but did not work because 'rootString' is an object rather than a pointer to an
object. (However the simplier form:
<pre style="border:gray 1px solid;padding:0.5em 2em;background:#ffe">   t->Branch("rootString",&amp;rootString, 1600, 0);</pre>
works/worked fine).
</li>
<li>And many other bug fixes, security fixes, thread safety and performance improvements ; see the svn log for details.</li>
</ul>
<h4>TTree Scan and Draw</h4>
<ul>
<li>Insured that the generated histogram as an integral bin width when plotting a string or integer.</li>
<li>Improved the output of TTree::Scan by inserting a blank space whenever a value is not available because there is no proper row in a friend.
(Previously it was re-printing the previous value).  This required changes in </li>
</ul>
