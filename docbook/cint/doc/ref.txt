doc/ref.txt

Reference manual for cint/makecint.

       Masaharu Goto (cint@pcroot.cern.ch)
       Copyright (c) 1995~2004 Masaharu Goto

 This document explains cint/makecint features and functionalities 
in an alphabetical order. 

==========================================================================
==========================================================================
==========================================================================
$CINTSYSDIR

 $CINTSYSDIR is an environment variable that contains name of directory
where CINT is installed.
A user must set CINTSYSDIR environment variable before using CINT.
Cint and makecint refers to files under $CINTSYSDIR at run time.
If $CINTSYSDIR is not properly set, cint and makecint will fail obtaining
platform dependent information or standard header files.
Platform dependent information is stored in $CINTSYSDIR/MAKEINFO and
standard header files exist under $CINTSYSDIR/include directory.

 Following examples show how to setup CINTSYSDIR and PATH environment variables
in UNIX and Windows-NT/95.

Example: UNIX, using either sh,ksh,bash, add following description to .profile

CINTSYSDIR=[CINT_install_directory]
PATH=$PATH:$CINTSYSDIR
MANPATH=$MANPATH:$CINTSYSDIR/doc
export PATH CINTSYSDIR MANPATH


Example: UNIX, using csh, add following description to .login

setenv CINTSYSDIR [CINT_install_directory]
setenv PATH ($PATH $CINTSYSDIR)
setenv MANPATH ($MANPATH $CINTSYSDIR/doc)


Example: Windows-NT/95, add following description to AUTOEXEC.BAT

SET CINTSYSDIR=C:\CINT
SET PATH=%CINTSYSDIR%;%PATH%


==========================================================================
$CINTSYSDIR/G__ci.h

  G__ci.h is a header file for CINT API.
G__ci.h must be included when using CINT API in a precompiled library.
-I$CINTSYSDIR option must be given to makecint when including G__ci.h.


Example:

  $ makecint -mk Makefile -o src -H src.h -C++ src.cxx -I$CINTSYSDIR
  $ make -f Makefile


  // src.h /////////////////////////////////////////////////////////////
  #include "G__ci.h"  // G__ci.h must be included
  void f();


  // src.cxx /////////////////////////////////////////////////////////////
  #include "src.h"
  void f() {
    G__loadfile("mysrc.C"); // API function is used
  }


==========================================================================
$CINTSYSDIR/MAKEINFO

 $CINTSYSDIR/MAKEINFO is an ASCII file containing platform dependent 
information.
$CINTSYSDIR/MAKEINFO is created at installation by setup script.
It is important to have appropreate MAKEINFO file because cint and makecint
refers to this file at run time for following information.

 * Name of C/C++ preprocessor command is obtained from MAKEINFO if -p or +P,-P
   command line option is given to cint and makecint. Preprocessor command 
   is set to CPREP (in case of C) and CPPPREP (in case of C++).

 * MAKEINFO is copied as header part of Makefile when running makecint.
   Makecint will add application specific description after that.

 * CHDRPOST, CPPHDRPOST, CSRCPOST, CPPSRCPOST, DLLPOST variables in MAKEINFO
   are refered by makecint and cint with -c[-1|-2] option. These variables
   determines file extension of header, source and DLL files.


 You can also set default behavior of Cint command line input by setting
INPUTMODE and INPUTMODELOCK in $CINTSYSDIR/MAKEINFO. Refer to INPUTMODE for
the detail.


SEE ALSO: platform dependency file, INPUTMODE

==========================================================================
$CINTSYSDIR/src/Api.h

 $CINTSYSDIR/src/Api.h contains definision of CINT ERTTI(Extensive Run Time 
Type Identification).
Api.h must be included when ERTTI API is used in a precompiled library.
-I$CINTSYSDIR and -I$CINTSYSDIR/src must be given to makecint when doing this.


SEE ALSO: ERTTI 

==========================================================================
#!

 You can run C++ source file as a command in Linux/UNIX environment if you
have #! command at the beginning of your script. This technique is popular 
in Linux/UNIX script programming.  In case of Cint, you have to have space
character between the #! and interpreter name. 

Example:
	  $ cat HelloWorld.cxx
	  #! /usr/local/bin/cint
	  int main() {
	    printf("Hello World\n");
	    return 0;
	  }

	  $ chmod +x HelloWorld.cxx
	  $ HelloWorld.cxx


Limitation:
  As described alread, you have to have space character between the #! and
  interpreter name. 

  If you give -p(preprocessor) option, the preprocessor will complain about #!
  because C/C++ preprocessor doesn't know about #!.


==========================================================================
#pragma

 ANSI C/C++ standard defines #pragma as a mean to implement platform dependent
functionality.
CINT defines several #progma statement to implement special functionality.

 A user can define new #pragma statement by using G__addpragma() API.


SEE ALSO: G__addpragma()

==========================================================================
#pragma ANSI

  #pragma ANSI statement can be used in a parameter information file (= header 
file given to makecint by -h and -H option).
#pragma ANSI will force subsequent function prototypes to be registered as
ANSI C/C++ style function in a precompiled library.
Usually #pragma ANSI is not necessary because this is a default state.
#pragma ANSI is only necessary after #pragma K&R.


SEE ALSO: #pragma K&R

==========================================================================
#pragma autocompile [on|off]

 #pragma autocompile statement will turn on/off effect of #pragma compile 
statement. Default is on.
If '#pragma autocompile off' appears in a source file, #pragma compile and
#pragma endcompile statements are ignored.


SEE ALSO: #pragma compile


==========================================================================
#pragma bytecode

  Functions enclosed by '#pragma bytecode' and '#pragma endbytecode' will
be compiled to a bytecode at loading time.
These functions are accelerated especially when they are called multiple 
times in a loop.
  This feature is experimental and premature.
Bytecode function has to comply following limitations.
 + must be 80 lines or less
 + must not have class/struct object as local variable or parameter 
 + must not have reference type variable as local variable or paramter
 + may be a little slower if a bytecode function contains big loop.
These limitations will be cleared in future revision.


Example:

  #pragma bytecode
  // Compile a function to bytecode that is called multiple times in a loop
  int BytecodeFunc(char *s,double d) {
    int result;
    result = sprintf(s,"BytecodeFunc %g\n",d);
    return(result);
  }
  #pragma endbytecode
  
  // function containing big loop may be faster without #pragma bytecode
  int InterpretedFunc() {
    int result;
    for(int i=0;i<1000;i++) {
      result += i;
    }
    return(result);
  }
  
  main() {
    char buf[100];
    for(int i=0;i<100;i++) {
      BytecodeFunc(buf,i*1.2);
      printf("%s\n",buf);
    }
    printf("%d\n",InterpretedFunc());
  }


==========================================================================
#pragma Ccomment [on|off]

 #pragma Ccomment statement turns on/off C comment handling in ROOT
comment string handling. Difference of Ccomment on and off are subtle.
Ccomment on will remove ending '*/' from comment string.

  /* myheader.h */
  struct A {
   int a;  /* integer a */
  };                /*  ^^ this part is removed  */

Example:

  #pragma Ccomment on
  #include "myheader.h"  /* C header */
  #pragma Ccomment off

==========================================================================
#pragma compile

 Source code that is enclosed by '#pragma compile' and '#pragma endcompile'
will be compiled as native code and dynamically loaded.
A user can enjoy native code performance in an interpreted source file.
This feature is only available with DLL or shared library capability of
the operating system. makecint will be implicitly used behind.
Source code surrounded by '#pragma compile' and '#pragma endcompile' must
be a complete C or C++ source.
Multiple pairs of '#pragma compile' and '#pragma endcompile' can be used.
If '#pragma endcompile' is omitted, everything after '#pragma compile'
will be compiled.
CINT must be installed with C/C++ compiler to utilize #pragma compile
statement.

 In above process, following files are implicitly created by Cint. 

  G__AC[xxx].C        : Source code enclosed by #pragma compile/endcompile
  G__AC[xxx].dll      : Dynamic Link Lib for G__AC[xxx].C
  G__AC[xxx].mak      : Makefile for making G__AC[xxx].dll
  G__cpp_G__AC[xxx].C : Dictionary code for G__AC[xxx].C
  G__cpp_G__AC[xxx].h : Dictionary code for G__AC[xxx].C
  G__cpp_G__AC[xxx].o : Object file for G__AC[xxx].dll

Cint checks if contents of G__AC[xxx].C is changed or not. It re-compiles
G__AC[xxx].dll only when there is a change.
Those files are left undeleted even after Cint session is terminated. Please
delete those files manually.


Example: In example below, loop() function will be compiled to a native code.

  /*  auto.c */
  main(int argc,char **argv) {
    loop(atoi(argv[1]));
    endfunc();
  }
  
  # pragma compile  /* following part is compiled */
  int sum=0;
  loop(int num) {
    int i=0;
    for(i=num;num>0;num--) sum += num;
  }
  #pragma endcompile
  
  endfunc() {
    printf("end of execution sum=%d\n",sum);
  }


==========================================================================
#pragma do_not_include "filename" ;

  This statement avoids inclusion of specified file. This statement is useful
at making cint dictionary from a simple header file but it includes 
complicated system header file.  Specifying the system header file name with
this statement, you can avoid problems loading it.

Example:
    // myfile1.h
    #include <windows.h>
    #include <stdafx.h>
    void my_simple_func(BYTE x);

    // myLinkDef.h
    #ifdef __MAKECINT__
    #pragma do_not_include "windows.h" // avoid loadingg windows.h
    #pragma do_not_include "stdafx.h"  // avoid loadingg windows.h
    typedef BYTE short; // define dummy typedef for dictionary generation
    #endif

    $ makecint -mk Makefile -dl mylib.dll -H myfile1.h myLinkDef.h


==========================================================================
#pragma endbytecode

Refer to #pragma bytecode 


==========================================================================
#pragma endcompile

Refer to #pragma compile 


==========================================================================
#pragma eval [expression] ;

  [expression] is evaluated whenever this line is parsed.
Do not use this statement. This statement exists for debugging CINT only.


==========================================================================
#pragma extra_include "filename" ;

  This statement is added for ROOT framework.  Specified filename will be
included in rootcint generated dictionary code. 
Ask Philippe Canal<pcanal@fnal.fnal.gov> for the detail.


==========================================================================
#pragma if defined([macro])
#pragma ifdef [macro]
#pragma ifndef [macro]
#pragma elif defined([macro])
#pragma endif

  #pragma if, ifdef, ifndef, elif and endif statements behaves the same as
ordinary #if,#ifdef, #ifndef,#elif and #endif preprocessor statements.
If -p or +P,-P command line option is given to cint or makecint, source and
header files are processed by C/C++ preprocessor prior to the interpretation.
In such case, #pragma if,ifdef, ifndef, elif and endif statements are ignored
in the preprocessor and left for cint to handle.
 An ordinary user does not need to use these statements often.


==========================================================================
#pragma include "[DLL_or_Header]"

 #pragma include statement behaves the same as ordinary #include statement.
It is recommended to use #pragma include when loading DLL(Dynamic Link Library)
in source file.
If -p or +P,-P command line option is given to cint or makecint, source and
header files are processed by C/C++ preprocessor prior to the interpretation.
In such case, #pragma include statement is ignored in the preprocessor and
left for cint to handle.
So, use #pragma include whenever you do not want include file to be processed
by C/C++ preprocessor.


Example: Following example loads DLL fft.dl in source file.

  #include <stdio.h>
  #pragma include <fft.dl>
  
  main() {
    ...
  }

==========================================================================
#pragma include_noerr "[DLL_or_Header1]"  <#on_error "[DLL_or_Header2]">

 #pragma include_noerr statement behaves similary to '#pragma include' 
statement. Difference is that #pragma include_noerr does not trap an 
error when specified file is not found.
 If [DLL_or_Header1] is not found  and  optional argument 
'#on_error "[DLL_or_Header2]"' is given, [DLL_or_Header2] will be loaded. 
Error is trapped if this file is not found.

Example: Following example loads DLL fft.dl and array.dl in source file.

  #include <stdio.h>
  #pragma include_noerr <fft.dl>
  #pragma include_noerr <array.dl>  #on_error <array.c>
  
  main() {
    ...
  }

==========================================================================
#pragma includepath "[path]"

 #pragma includepath statement add header file include path.
It has the same effect as giving -I[includepath] command line option.
#pragma includepath statement accepts one path name at a time.
If you have multiple include pathes to add, you need multiple #pragma
include statements.


Example: Following example adds /home/proj/include and /usr/myinclude as 
include pathes.

  #pragma includepath "/home/proj/include"
  #pragma includepath "/usr/myinclude"
  #include <mylib.h>
  
  
==========================================================================
#pragma K&R

 #pragma K&R statement turns off parameter checking of precompiled functions.
Function parameter types are usually checked when calling precompiled 
functions.
Parameter type checking is turned off for functions declared after 
#pragma K&R statement in parameter information file (header file given to
makecint by -h or -H option).
There are such library that depends on the old K&R compiler does not check
parameters and calls function only by name matching.
#pragm K&R is introduced to support such library emulating K&R style 
programming.
The K&R mode is active until #pragma ANSI statement appears.
#pragma K&R and #pragma ANSI statement can only appear in parameter 
information files.

Example: Giving following prog.h to makecint with -c-2 option, f1() and f3() 
are handled as ANSI function. Parameter types will be checked at run time. 
For f2() which is surrounded by #pragma K&R and #pragma ANSI, parameter
type checking is omitted when it is used in an interpreted source code.


    $ makecint -mk Makefile -o obj -h prog.h -C prog.c
  
  /* prog.h */
  #ifdef __CINT__

  long f1(int a,double b);
  #pragma K&R
  unsigned short f2();
  #pragma ANSI
  int f3(short c,float d);
  
  #else
  
  long f1();
  unsigned short f2();
  int f3();
  
  #endif
  

==========================================================================
#pragma link [C|C++|off] all [class|function|global|typedef];
#pragma link [C|C++|off] [class|struct|union|enum|namespace|protected] [name];
#pragma link [C|C++|off] [global|typedef] [name];
#pragma link [C|C++|off] [nestedclass|nestedtypedef];
#pragma link [C++|off] operators classname;
#pragma link [C++|C|off|MACRO] function [name]<(argtypes)>;
#pragma link [C++|C|off|MACRO] function [classname]::[name]<(argtypes)>;
#pragma link off all methods;
#pragma link [C|C++|off] defined_in [filename];
#pragma link [C|C++|off] defined_in [class|struct|namespace] [name];
#pragma link [C|C++|off] all_function   [classname];
#pragma link [C|C++|off] all_datamember [classname];

 #pragma link statement selectively turns on/off symbol table registeration
of classes, global functions, global variables and typedefs.
All of the classes, global functions, global variables and typedefs in the
global scope are registered to the symbol table by default.
A user can turn the registeration on/off by using '#pragma link' statement. 
 #pragma link statement can only appear in parameter information file which
is given to makecint with -h or -H option. (or given to cint with -c-1 or
-c-2 option) 
If used with -h option of makecint (or -c-2 option of cint), 
'#pragma link C' , '#pragma link off' and '#pragma link MACRO' can be used. 
If used with -H option of makecint (or -c-1 option of cint), 
'#pragma link C++' , '#pragma link off' and '#pragma link MACRO' can be used.

If you want to add nested classes or nested typedefs in the precompiled
symbol table, use '#pragma link [C|C++|off] [nestedclass|nestedtypedef];'.

You can optionally specify argument type for '#pragma link [C++|C|off] 
function' statement in order to select one from several overloaded functions.
If you omit argument type, all function with specified [name] will be 
affected.

'#pragma link [C++|C] function' and '#pragma link MACRO function' behaves
similarly. '#pragma link [C++|C] function' assumes target to be real
function which has pointer to it. Pointer to registered function is refered. 
On the other hand, '#pragma link MACRO function' assumes target to be macro 
function.  Pointer to function is not refered.

'#pragma link [C|C++|off] defined_in [class|struct|namespace] [name];'
controls all of the object defined in speciic scope. When using this pragma, 
it is recommended to use '#pragma link C++ nestedclass; tool. Otherwise, 
definitions in enclosed scope does not appear in the dictionary.

'#pragma link [C++|off] operators classname;'
will turn on/off symbol table registration of the operators that are
declared in the declaring scope of 'classname' (and any of its enclosing
scope) and take at least one argument that is a reference, pointer, or value 
argument of type 'classname'

Example: In following example, symbol table registeration of classes, 
functions, global variables and typedefs are once turned off by 
'#pragma link off ...' statements. Then registeration of selected class, 
function, global variabl and typedef are turned on by '#pragma link C++ ...' 
statement.


    $ makecint -mk Makefile -o obj -H myprog.h -C++ myprog.C

  /* myprog.h */
  class A { };
  class B { class D; };
  class C { typedef int I; };
  double f1();
  A f2();
  B f3(int x,char* c);
  B f3(A& x);
  A i;
  double d;
  short s;
  typedef int Int_t;
  #ifndef __MAKECINT__
  #define pwr(x) (x*x)
  #else
  double pwr(double x);	
  #endif
  
  #pragma link off all class;
  #pragma link off all function;
  #pragma link off all global;
  #pragma link off all typedef;
  #pragma link C++ class B;
  #pragma link C++ function f2;
  #pragma link C++ function f3(int,char*);
  #pragma link C++ global s;
  #pragma link C++ Int_t;
  #pragma link C++ nestedtypedef;
  #pragma link C++ nestedclass;
  #pragma link MACRO function pwr;


==========================================================================
#pragma link [C|C++|off] all [class|function|global|typedef];

This pragma statement turns on/off dictinoary generation for all classes,
structs, namespaces, global variables, global functions and typedefs.

Example:

  // some C++ header definition

  #ifdef __MAKECINT__
  // turns off dictionary generation for all
  #pragma link off all class;
  #pragma link off all function;
  #pragma link off all global;
  #pragma link off all typedef;
  #endif


==========================================================================
#pragma link [C|C++|off] [class|class+protected|struct|union|enum|namespace] [name];

This pragma statement selectively turns on/off dictionary generation for
specified classs,struct,union,enum or namespace. Dictinoary of all 
public members of class and struct will be generated. 

If 'class+protected' flag is used, dictionary for protected members 
will also be generated. However, dictinoary for protected constructor 
and destructor will not be generated. This 'class+protected' flag will
help you only for plain protected member access, but not for virtual
function resolution.

If you use 'namespace' flag,  it is recommended to add 
'#pragma link nestedclass;' and '#pragma link nestedtypedef;' also.

Behavior of 'class', 'struct' and 'namespace' flag are identical. 

Example:
  // some C++ header definition

  #ifdef __MAKECINT__
  #pragma link off all class;
  #pragma link C++ class A;
  #pragma link C++ class B;
  #pragma link C++ class C<int>;
  #pragma link C++ class+protected D;
  #pragma link C++ namespace project1;
  #pragma link nestedclass;
  #pragma link nestedtypedef;
  #endif


==========================================================================
#pragma link [C|C++|off] [global|typedef] [name];

This pragma statement selectively turns on/off dictionary generation for
global variable and typedef.

Example: 
  // some C/C++ header definition

  #ifdef __MAKECINT__
  #pragma link off all global;
  #pragma link off all typedef;
  #pragma link C++ global a;
  #pragma link C++ typedef Int_t;
  #endif


==========================================================================
#pragma link [C|C++|off] [nestedclass|nestedtypedef];

This pragma statement turns on dictionary generation for nested class and
nested typedef. 

Example:
  // some C/C++ header definition

  #ifdef __MAKECINT__
  #pragma link C++ nestedclass;
  #pragma link C++ nestedtypedef;
  #endif


==========================================================================
#pragma link [C++|C|off|MACRO] function [fname]<(argtypes)>;
#pragma link [C++|C|off|MACRO] function [classname]::[fname]<(argtypes)>;

This pragma turns on/off dictionary generation for specified function or
member function. You can provide only function name or with complete 
argument types. If you omit argument type, all function with specified 
[name] will be affected. If complete argument types are specified, one
that has exactly same argument list will be affected.

'#pragma link [C++|C] function' and '#pragma link MACRO function' behaves 
similarly. '#pragma link [C++|C] function' assumes target to be real 
function which has pointer to it. Pointer to registered function is 
refered. On the other hand, '#pragma link MACRO function' assumes target 
to be macro function.  Pointer to function can not be referenced in this
case.


Example:

   void f(int a);
   void f(double a);
   int g(int a,double b);
   int g(double x);
   #define max(a,b) (a>b?a:b)

   class A {
    public:
     int h(double y);
     int h(int a,double b);
   };

   #ifdef __MAKECINT__
   #pragma link off all functions;
   #pragma link C++ function f;
   #pragma link C++ function g(int,double);
   #pragma link C++ MACRO max;
   #pragma link C++ class A;
   #pragma link off function A::h(double);
   #endif


NEW BEHAVIOR FOR MEMBER FUNCTION TEMPLATE (cint5.15.61):

 Until 5.15.60, in order to generate dictionary for a member function, not 
only for the member function but class itself has to be turned on for the 
linkage. There was a inconvenience when generating dictinoary for template
member function afterwards.
From cint5.15.61, a new behavior is introduced. If link for a member function 
is specified, dictionary is generated even if link to the belonging class is 
off.  For example, if you originally have A.h as follows, and generate 
dictionary for that.

   // A.h
   template<class T> class A {
    public:
     template<class E> void f(E& x) { ... }
   };
   #ifdef __MAKECINT__
   #pragma link C++ class A<int>;
   #endif

     $ makecint -mk makeA -dl A.dll -H A.h
     $ make -f makeA

Then prepare another header file and instantiate template member function
of A. You can generate dictionary for the newly instantiated template 
member function only.

   // B.h
   #include "A.h"
   class B { ... };
   #ifdef __MAKECINT__
   #pragma link off defined_in A.h;
   #pragma link C++ function A<int>::f(B&);
   #endif

     $ makecint -mk makeB -dl B.dll -H B.h
     $ make -f makeB


==========================================================================
#pragma link off all methods;

This pragma turns off dictionary generation of all the member functions in
all classes.

Example:

  #ifdef __MAKECINT__
  #pragma link off all methods;
  #endif


==========================================================================
#pragma link [C|C++|off] all_function   [classname];
#pragma link [C|C++|off] all_datamember [classname];

Those pragam statements control linking of all the member function or
data member for a specified class.

At this momement, there should be no needs to use those statements.

Example:

  #ifdef __MAKECINT__
  #pragma link off all_function   A;
  #pragma link off all_datamember A;
  #endif


SEE ALSO: #pragma link function

==========================================================================
#pragma link [C|C++|off] defined_in [filename];

This pragma statement turns on/off dictionary generation of the object
defined in specific file.

Example:
    // file1.h
    // any C++ header definition

    // file2.h
    #ifdef __MAKECINT__
    #pragma link off all classes;
    #pragma link off all functions;
    #pragma link off all globals;
    #pragma link off all typedef;
    #pragma link C++ defined_in file1.h;
    #endif


==========================================================================
#pragma link [C|C++|off] defined_in [scope_name];
#pragma link [C|C++|off] defined_in [class|struct|namespace] [scope_name];

This pragma statement turns on/off dictionary generation of the object 
defined in specfic scope. [scope_name] should be class name, struct name or
namespace name. When using this pragma, it is recommended to use 
'#pragma link C++ nestedclass' too. Otherwise, definitions in enclosed 
scope does not appear in the dictionary.

Example:  

    namespace ns {
      int a;
      double b;
    };

    #ifdef __MAKECINT__
    #pragma link C++ defined_in ns;
    #pragma link C++ nestedclass;
    #endif


==========================================================================
#pragma link default [on|off]

This statements controls default link mode for makecint(cint -c-1|-c-2) 
and rootcint.  By truning default 'on' , all language constructs in given
header files will be included in generated Cint dictionary(interface 
method source file).   If default is set to 'off', nothing will be included
in the generated dictionary. Linkage to each item must be explicitly
set by '#pragma link [C|C++|off] [class|function|global]' statement.
This pragma statement must be given before cint/rootcint reads any C/C++
definitions from header files.

For pure Cint, default is on. For ROOT, including $ROOTSYSDIR/bin/cint,
default is off.  

This feature was added from cint5.15.57. Before this version, you had to
explicitly use '#pragma link off [class|function|global];' statements in
ROOT's LinkDef.h file. From 5.15.57, you can omit them.  


Example:  

    #ifdef __MAKECINT__
    #pragma link default off;
    #endif

    class A {
      int a;
      double b;
    };

    class B {
      int d;
      double e;
    };

    #ifdef __MAKECINT__
    #pragma link C++ class A; // only class A is linked, not B
    #endif


==========================================================================
#pragma link postprocess [filename] [action];

'#pragma link [C++|C|off]' is good enough for most of the case to control
precompiled object linkage to the interpreter, however, there are cases 
that you need more specialized control of linkage. 
'#pragma link postprocess' statement allows you to control precompiled
object linkage in flexible way.  It allows you to describe linkage rules 
in C++ macro using CINT ERTTI API.

The most common usage would be to switch on/off operator functions for
mathematical container class. All kinds of operators can be defined in
template container class, however, only ones that defined in element
class can be instantiated. It is needed to conditionally turn on/off
linkage of operator functions regarding property of the element class.
This is already implemented in stl/G__postprocess.h. In most of the case
you can simply specify something like below at the end of LinkDef file.

  #pragma link postprocess G__postprocess.h postprocess("MyArray");


Example: In following example, you define template class A with operator+
and operator-. It is instantiated by elements like int, int*, B, B*, C, C*.
Validity of each operator function is evaluated in stl/G__postprocess.h
and linkage is controlled on and off. Refer to stl/G__postprocess.h for
more detail.

  // t335.h ////////////////////////////////////////////
  template<class T> 
  class A {
    T a;
  public:
    A(const T& ain) { a=ain; }
    //A& operator=(const T& ain) { a=ain; return(*this); }
    A operator+(const A& x) {
      A z(a+x.a);
      return(z);
    }
    friend A<T> operator-(const A<T>& x,const A<T>& y) ;
  };
  
  template<class T>
  A<T> operator-(const A<T>& x,const A<T>& y) {
    T dif = x.a-y.a;
    A<T> z(dif);
    return(z);
  }
  
  class B {
   public:
  };
  
  class C {
    int a;
   public:
      C(int ain=0) { a = ain; }
    C operator+(const C& x) {
      C z(a+x.a);
      return(z);
    }
    friend C operator-(const C& x,const C& y) ;
  };
  
  C operator-(const C& x,const C& y) {
    int dif=x.a-y.a;
    C z(dif);
    return(z);
  }
  
  #ifdef __MAKECINT__
  #pragma link C++ class A<int>;
  #pragma link C++ class A<int*>;
  #pragma link C++ class A<B>;
  #pragma link C++ class A<B*>;
  #pragma link C++ class A<C>;
  #pragma link C++ class A<C*>;
  
  #pragma link postprocess G__postprocess.h G__postprocess("A");
  #endif
  // end of t335.h /////////////////////////////////////


==========================================================================
#pragma mask_newdelete [value];

 '#pragma mask_newdelete' statement sets flags to mask operator new/delete
 genneration in a dictionary source code. 
  When making cint dictionary or interface method source code, it usually
 overloads global new and delete operators. If you have yourown new/delete
 operator, you may want to elimitate new and delete from the dictionary
 source code. Above message indicates, status of new/delete operator 
 masking.  Mask flag is shown as hex number. In rootcint, -M0x1c is set 
 by default.

    #define G__IS_OPERATOR_NEW      0x01
         Global operator new is found in user header file. Cint automatically
        stops generating operator new function in the dictionary.

    #define G__IS_OPERATOR_DELETE   0x02
         Global operator delete is found in user header file. Cint 
        automatically stops generating operator delete function in the 
        dictionary.

    #define G__MASK_OPERATOR_NEW    0x04
         Cint does not generate operator new function in the dictionary
        because it is explicitly masked by -M0x4 command line option.

    #define G__MASK_OPERATOR_DELETE 0x08
         Cint does not generate operator new function in the dictionary
        because it is explicitly masked by -M0x8 command line option.

    #define G__NOT_USING_2ARG_NEW   0x10
         Cint uses operator new function with 1 argument in dictionary
        source code.

 From cint5.14.60, a new scheme is introduced. In the new method, 
 following flags dominates others. This scheme is intended to fix 
 problems associated with global operator new/delete.

    #define G__DUMMYARG_NEWDELETE        0x100
	  If this flag is set, a new operator new/delete scheme
	 is turned on. With this scheme, cint dictionary generates
	 following functions.

            void* operator new(size_t size,[DLLID]_tag* p);
            void operator delete(void *p,[DLLID]_tag* x);
            static void G__operator_delete(void *p);

    #define G__DUMMYARG_NEWDELETE_STATIC 0x200
          This flag makes operator new a static function. So,
	 following functions will be generated.

            static void* operator new(size_t size,[DLLID]_tag* p);
            static void operator delete(void *p,[DLLID]_tag* x);
            static void G__operator_delete(void *p);


 The value given to '#pragma mask_newdelete' is ORed with the flag set
 by '-cint -M[value]' option of makecint. (Refer to makecint.txt)

 Default value is 0x100 for pure CINT and 0x1c for ROOTCINT.

Example:
    #pragma mask_newdelete 0x10; 

SEE ALSO: doc/makecint.txt -M option,  doc/message.txt


==========================================================================
#pragma message [Message]

 '#pragma message' statement displays message string to stderr.

==========================================================================
#pragma permanent_link [DllFilename]

 '#pragma permanent_link' links specified DLL or shared library as part of
cint system. Once the DLL is linked, it will not be unlinked until cint
process is terminated.  DLL file will be searched in normal include search
paths.  In case specified file is not found, this statement does not generate
error and continue processing the source file.

Example:
    #pragma permanent_link pthread.dll


SEE ALSO:  #pragma include_noerr

==========================================================================
#pragma preprocess [filename_prefix]


 Cint normally reads source file directly. This is called one-path 
processing. The one-path processing has some limitation in define macro.
To eliminate define macro limitations, a user sometimes needs to use 
official C/C++ preprocessor prior to interpretation. Invokation of the 
C/C++ preprocessor is done automatically by cint.
 #pragma preprocess specifies that include files start with
[filename_prefix] should be processed by C/C++ preprocessor before cint
reads them. 


Example: In following example, include files start with X11/X go through
preprocessor than read by cint. myheader.h is directly read by cint.

  #pragma preprocess X11/X
  #include "X11/Xlib.h"
  #include "X11/Xutil.h"
  #include "myheader.h"


SEE ALSO: -p option, +P,-P suboption, one-path processing,
          two-path processing, preprocessor statements

==========================================================================
#pragma preprocessor [on|off]

 Cint normally reads source file directly. This is called one-path 
processing. The one-path processing has some limitation in define macro.
To eliminate define macro limitations, a user sometimes needs to use 
official C/C++ preprocessor prior to interpretation. Invokation of the 
C/C++ preprocessor is done automatically by cint.
 Include files which are enclosed by '#pragma preprocessor on' and
'#pragma preprocessor off' are preprocessed by C/C++ preprocesso prior to
interpretation.

Example: In following example, only myheader2.h and myheader3.h are processed 
by C/C++ preprocessor.  myheader1.h and myheader4.h are directly read by cint.

  #include <stdio.h>
  #include "myheader1.h"
  #pragma preprocessor on
  #include "myheader2.h"
  #include "myheader3.h"
  #pragma preprocessor off
  #include "myheader4.h"


SEE ALSO: -p option, +P,-P suboption, one-path processing,
          two-path processing, preprocessor statements

==========================================================================
#pragma security [level0-5]

 #pragma security statement sets security and robustness mode of cint.
Security mode is normally set by -q[levelN] command line option.
-q option can set only one security level for all of the source files
given to cint.
 Using #pragma security statement in source file enables having different
security level in different source file. 
#pragma security statement can appear only once at the begenning of source
or header file.


Example: In following example, security level1 is set to prog1.c. Casting to a
pointer is prohibited. Security level0 is set to prog2.c to allow casting
to pointer from long integer. 


  $ cint -qlevel1 prog2.c prog1.c

  /* prog1.c */
  #pragma security level1
  void main() {
    void *p = f2(0x4152368);
  }
  
  /* prog2.c */
  #pragma security level0
  void* f2(long l) {
    return((void*)l);
  }


SEE ALSO: security mode

==========================================================================
#pragma setertti

 #pragma setertti will setup symbol table for Extensive Run Time Type
Identivication API. This is a special statement which only appears in 
$CINTSYSDIR/ertti.h header file. Ordinaly user should not use this statement.

==========================================================================
#pragma setstdio

 #pragma setstdio will setup starnderd I/O file pointers in the interpreter
environment. This is a special statement which only appears in 
$CINTSYSDIR/stdio.h header file. Ordinaly user should not use this statement.

==========================================================================
#pragma setstream

 #pragma setstream will setup symbol table for iostream library in the
interpreter environment. This is a special statement which only appears in
$CINTSYSDIR/iostream.h header file. Ordinaly user should not use this 
statement.

==========================================================================
#pragma stub [C|C++|off] all functions;
#pragma stub [C|C++|off] function [name];

 #pragma stub statement registers specified function as STUB function in 
a precompiled library. This statement can only be used in parameter
information file.
 It is usually unnecessary to use this statement because -i and -i++ 
command line option of makecint provide the same functionality.

==========================================================================
__CINT__

 __CINT__ is a macro which is internally defined within cint interpreter.
This macro can be used to distinguish cint from other C/C++ processing
system. __CINT__ can not be disabled by #undef statement.

Example:

  #ifdef __CINT__
  #pragma include "myprog.dll"
  #else
  #include "myprog.h"
  #endif


==========================================================================
__CINT_INTERNAL_CPP__

 __CINT_INTERNAL_CPP__ is a macro which is internally defined within cint 
interpreter. This macro can be used to distinguish between external C/C++
preprocessor and one embedded in Cint parser. Latter one has limitation in
macro handling. When -p or +P option is used, external C/C++ preprocessor
which is designated in $CINTSYSDIR/MAKEINFO is used. __CINT_INTERNAL_CPP__ 
is not defined. Without -p or +P option, __CINT_INTERNAL_CPP__ is defined.


Example:

  #ifdef __CINT_INTERNAL_CPP__
  /* dummy */
  #else
  #include "/usr/include/sys/cdefs.h"
  #endif


==========================================================================
__cplusplus

 __cplusplus is a macro which is internally defined within cint interpreter
when interpreting C++ source code. __cplusplus is defined if source file
has following extensions.

   .C  .cc  .CC .hh .HH .wc .WC .cxx .CXX .cpp .CPP .hxx .HXX .hpp .HPP

It is not defined if source file has following filename extension.

   .c

It is context dependent if source file has following filename extensions.

   .h  .H

If -A option is given, __cplusplus is always defined regardless of filename
extension.  If -K option is given, __cplusplus is never defined reglardless
of filename extension.

Note:

 It is quite popular to use __cplusplus macro like following example.
This kind of structure is problematic for Cint. A special workaround is
implemented from cint5.15.106.

	#ifdef __cplusplus
	extern "C" {
	#endif

	void c_function() ;

	#ifdef __cplusplus
	}
	#endif



==========================================================================
__MAKECINT__

 __MAKECINT__ macro is defined when processing parameter information files.
__MAKECINT__ macro is explicitly given to 'cint -c[-1|-2]' from command line.
This macro can be used to distinguish makecint from other C/C++ processing
system.

Example:

  #ifdef __MAKECINT__
  #pragma link C++ function myfunc;
  #endif

SEE ALSO: parameter information file

==========================================================================
==========================================================================
==========================================================================
ANSI style function header

 cint can read both ANSI and K&R style function header. 
Cint does run-time parameter type checking for ANSI style function.
K&R style function is called with simple function name match.
ANSI style function is called only if type of parameter matches to 
C++ function overloading rule.
If a function with no parameter is declared as f() it is regarded as
K&R style. ANSI style function must be explicitly declared as f(void).
Hence, f1() and f2() in following example behaves differently.


Example:

  int f1() {}     // interpreted as K&R style function
  int f2(void) {} // interpreted as ANSI style function

  main()
  {
    f1(1); // call f1() successfully
    f2(1); // No match to f2(int), ERROR
  }

==========================================================================
archived library

 Archived library is a kind of precompiled library which is archived with
cint core as monolithic executable file. 
Archived library contains following components.

   * user program
   * interface method to the user program
   * interface method start-up program $CINTSYSDIR/main/G__setup.c
   * interpreter core, $CINTSYSDIR/src/G__ci.a
   * main() function

 Interface method registers symbols in user program to cint symbol table.
It is automatically generated by makecint or 'cint -c[-1|-2]'.
 User program must not include main() function because cint main() function 
$CINTSYSDIR/main/G__cppmain.o is linked by default. 
You must give -m option to makecint if you want to use different main() 
function.
In this case, cint must be explicitly initialized by G__iniy_cint() API.


SEE ALSO: DLL, precompiled library, G__init_cint()

==========================================================================
==========================================================================
==========================================================================
cint

 When written in lower case letter "cint", points C/C++ interpreter object.
Executable object $CINTSYSDIR/cint is a default C/C++ interpreter which only
includes ANSI C standard library and C++ iostream library.
You can create derivertive of cint by using makecint.
These derivartives have different name, however, same user inferface as cint.


==========================================================================
CINT

 When written in all upper case letter "CINT", points entire cint/makecint
system.


==========================================================================
CINTSYSDIR

  REFER to $CINTSYSDIR 

==========================================================================
==========================================================================
==========================================================================
debugger interface

 cint is not only an interpreter but also a source code debugger.
cint's debugger interface provides full set of debugger capability,
like step execution, break point, stack trace, source code trace, class
and function browsing, etc...
Debugger interface is invoked at following occasion.

       * When main() function is not found in given source files
       * When cint is invoked with step mode command line option -S,-s
       * Break point event
       * Keyboard interrupt by CTL-C or Break key
       * When debugger interface function G__pause() is called explicitly
       * Bus error, segmentation violation 


SEE ALSO: G__pause() , G__atpause , debugger usage

==========================================================================
debugger prompt

 Debugger prompt is a command prompt displayed by debugger interface. 
It usually looks as follows,

  FILE:xyz.C LINE:16 cint>


SEE ALSO: debugger interface, G__pause(), G__atpause, debugger usage

==========================================================================
DLL(Dynamic Link Library)

 DLL(Dynamic Link Library) is a kind of precompiled library which can be
dynamically linked/unlinked with cint at run time.
DLL can be linked in the same way as you load source file.
DLL module has to have file extension  .dl .dll .DLL .sl or .so because cint
distinguishes between source file and DLL by file extension.
DLL module contains following components.

   * user program
   * interface method to the user program

 Interface method registers symbols in user program to cint symbol table.
It is automatically generated by makecint or 'cint -c[-1|-2]'.



 In UNIX environment, DLL is implemented by shared library management routine.
If operating system does not have shared library facility, DLL feature of
CINT can not be used. Precompiled library can be embedded only as archived
library in that case.
 In Windows-95/NT, CINT utilizes Windows API to link DLL.

 CCDLLOPT, LDDLLOPT, LDOPT, SYSMACRO and DLLPOST variables in 
$CINTSYSDIR/MAKEINFO must be setup properly to use DLL.
There are currently following combination of SYSMACRO setting.

    SYSMACRO = -DG__SHAREDLIB -DG__OSFDLL
             Use OSF compliant dlopen(), dlsym(), dlclose() or emulated
             version.

    SYSMACRO = -DG__SHAREDLIB -DG__HPUXCPPDLL
             Use HP-UX cxxshl_load(),shl_findsym(),cxxshl_unload() 

    SYSMACRO = -DG__SHAREDLIB
             Use HP-UX shl_load(),shl_findsym(),shl_unload() 

    SYSMACRO = -DG__SHAREDLIB -D_WINDOWS
             Use Win32 API LoadLibrary(),GetProcAddress(),FreeLibrary()


SEE ALSO: interface method, precompiled library 

==========================================================================
==========================================================================
==========================================================================
Environment dependent macros

 Following macros are defined depending on the OS/CPU/Compiler/Framework
that Cint runs.  A user can test those macros by #ifdef statement in an
interpreted source code.

# Operating System dependent macros

   OS               macro             value
   -------------------------------------------------------------------------
   Linux            G__LINUX          same as __linux__        
   FreeBSD          G__FBSD           same as __FreeBSD__      
   HP-UX            G__HPUX           same as __hpux           
   Sun/Solaris      G__SUN            same as __sun            
   Windows          G__WIN32          same as _WIN32           
   Apple            G__APPLE          same as __APPLE__
   IBM AIX          G__AIX            same as _AIX             
   SGI IRIX         G__SGI            same as __sgi            
   Cygwin           G__CYGWIN         51                       


# CPU architecture dependent macros

   CPU              macro             value
   -------------------------------------------------------------------------
   HP-PA            G__hppa           same as __hppa__         
   Intel x86        G__i386           same as __i386__         
   Intel 860        G__i860           same as __i860__         
   Intel 960        G__i960           same as __i960__         
   Intel IA64       G__ia64           same as __ia64__         
   Motorola 68k     G__m68k           same as __m68k__         
   Motorola 88k     G__m88k           same as __m88k__         
   Motorola PPC     G__ppc            same as __ppc__          
   IBM      PPC     G__PPC            same as __PPC__          
   IBM S390         G__s390           same as __s390__         
   MIPS             G__mips           same as __mips__         
   DEC/Compac Alpha G__alpha          same as __alpha__        
   Sun Sparc        G__sparc          same as __sparc__        
   ARC              G__arc            same as __arc__          
   M32R             G__m32r           same as __M32r__         
   Hitachi SH       G__sh             same as __SH__           
   ARM              G__arm            same as __arm__          
   

# Compiler dependent macros

   Compiler         macro             value
   -------------------------------------------------------------------------
   gcc/g++          G__GNUC           same as __GNUC__         
   gcc/g++          G__GNUC_MINOR     same as __GNUC_MINOR__   
   HP aCC           G__HP_aCC         same as __HP_aCC__       
   Sun CC           G__SUNPRO_CC      same as __SUNPRO_CC      
   Sun C            G__SUNPRO_C       same as __SUNPRO_C       
   MS VC++          G__VISUAL         1
   MS VC++          G__MSC_VER        same as _MSC_VER         
                         1100:VC++5.0,1200:VC++6.0,1300:VC++7.0,1310:VC++7.1
   Symantec C++     G__SYMANTEC       same as __SC__           
   Borland C++      G__BORLAND        same as __BORLANDC__     
   Borland C++      G__BCPLUSPLUS     same as __BCPLUSPLUS__   
   Borland C++ 5.5  G__BORLANDCC5     505
   KCC              G__KCC            same as __KCC            
   Intel C++        G__INTEL_COMPILER same as __INTEL_COMPILER 


# Library dependent macros

   Library          macro             value
   -------------------------------------------------------------------------
   GNU LIBC         G__GLIBC          same as __GLIBC__        
   GNU LIBC         G__GLIBC_MINOR    same as __GLIBC_MINOR__  


# Framework dependent macros

   Framework        macro             value
   -------------------------------------------------------------------
   ROOT             G__ROOT           1


==========================================================================
ERTTI(Extensive Run Time Type Identification)

  CINT's ERTTI (Extensive Run Time Type Identification) is a special 
enhancement requested by Rene Brun and Fons Rademakers in CERN(European 
Laboratory for Particle Physics).
ERTTI API consists of 8 classes, which is an interface to C/C++ interpreter
symbol table.
ERTTI API classes can be used both in interpreter environment and precompiled
library.
<ertti.h> must be included to use ERTTI in interpreter environment.
-I$CINTSYSDIR/src and -I$CINTSYSDIR option must be given from command line
and <Api.h> must be included to use ERTTI in precompiled library.

  See alos to explanation about following ERTTI API classes.

      G__ClassInfo
      G__BaseClassInfo
      G__DataMemberInfo
      G__MethodInfo
      G__MethodArgInfo
      G__TypeInfo
      G__TypedefInfo
      G__CallFunc
      G__SourceFileInfo
      G__IncludePathInfo

Every ERTTI class has member function 'long Property()'. This function returns
property of concerned symbol as combination of following bit patter.

  #define G__BIT_ISTAGNUM          0x0000000f
  #define G__BIT_ISCLASS           0x00000001
  #define G__BIT_ISSTRUCT          0x00000002
  #define G__BIT_ISUNION           0x00000004
  #define G__BIT_ISENUM            0x00000008
  #define G__BIT_ISTYPEDEF         0x00000010
  #define G__BIT_ISFUNDAMENTAL     0x00000020
  #define G__BIT_ISABSTRACT        0x00000040
  #define G__BIT_ISVIRTUAL         0x00000080
  #define G__BIT_ISPUREVIRTUAL     0x00000100
  #define G__BIT_ISPUBLIC          0x00000200
  #define G__BIT_ISPROTECTED       0x00000400
  #define G__BIT_ISPRIVATE         0x00000800
  #define G__BIT_ISPOINTER         0x00001000
  #define G__BIT_ISARRAY           0x00002000
  #define G__BIT_ISSTATIC          0x00004000
  #define G__BIT_ISDEFAULT         0x00008000
  #define G__BIT_ISREFERENCE       0x00010000
  #define G__BIT_ISDIRECTINHERIT   0x00020000
  #define G__BIT_ISCCOMPILED       0x00040000
  #define G__BIT_ISCPPCOMPILED     0x00080000
  #define G__BIT_ISCOMPILED        0x000c0000
  #define G__BIT_ISCONSTANT        0x00100000
  #define G__BIT_ISVIRTUALBASE     0x00200000
  #define G__BIT_ISPCONSTANT       0x00400000
  #define G__BIT_ISGLOBALVAR       0x00800000
  #define G__BIT_ISLOCALVAR        0x01000000
  #define G__BIT_ISBYTECODE        0x02000000
  #define G__BIT_ISEXPLICIT        0x04000000


==========================================================================
ertti.h

 ertti.h is a header file which must be included to use ERTTI API in 
interpreter environment.


SEE ALSO: ERTTI 

==========================================================================
Exception handling

 Cint supports exception handling. A user can include standard <exception> 
header and make use of std::exception and std::bad_exception classes. When
using exceptions, it is highly recommended that your exception class is
derived from std::exception. This way you can catch an exception thrown
by a compiled code in an interpreted code.

 Following limitations apply to Cint exception handling.

 - If try, catch blocks are used in interpreted code, that portion can not
  be bytecode optimized. 

 - Throw only classes, not fundamental types. Cint is unable to catch 
  fundamental type exceptions, such as integer and pointer. 

 - Derive your class from std::exception and precompile it using makecint.
  Cint can, somehow, interpret your exception class. But it is safer to
  compile it.

 - With Windows Visual C++ 6.0, Cint has limitation resolving thrown
  exception type. 

 There are 2 examples in demo directory.

SEE ALSO: demo/exception/README.txt, demo/makecint/exception/README.txt


==========================================================================
extern "[dllname]" { ... }

 You can load global function from DLL without makecint/rootcint if you use
Intel 32bit CPU with gcc3.2, VC++ or BC++.  You need to load DLL and specify
function interface by extern "[dllname]" clause. You can access C global
functions. For gcc3.2 and VC++, you can also access C++ global functions. 
However, C++ function may sometimes fail because of incomplete emulation of 
gcc/VC++ name mangling.

Limitation: 
 This feature is convenient, however, capability is very limited. 
Makecint/rootcint still have significant advantage.

 Only fundamental types can be used as return and argument type. class
and struct objects can not be used.  

 Cint compiled with gcc can load DLL compiled by gcc and VC++. BC++ DLL is 
not tested, but it probably works. 
 Cint compiled with VC++ can load DLL compiled by gcc, VC++ and BC++. When 
loading gcc DLL, you need to add a directory containing Cygwin.dll to %path% 
environment variable. 
 Cint compiled with BC++ can load DLL compiled by BC++. There may be a way
to load gcc and VC++ DLLs, but no investigation is done yet.


Example: 

  ### Compiled source and header file ###################################

  // userdll.h
  #ifdef _WIN32
  #define EXPORT __declspec(dllexport)
  #else
  #define EXPORT
  #endif
  extern "C" {
    EXPORT void f1();
    EXPORT int f2(int a,double b,void* p);
  }
  EXPORT void f3(int *a,const int* b);

  // userdll.cxx
  #include "userdll.h"
  extern "C" {
    void f() { /* whatever */ }
    int f2(int a,double b,void* p) { /* whatever */ return 0; }
  }
  void f3(int* a,const int* b) { *a = *b+1; } // C++ function

  ### Create DLL ########################################################
  $    g++ -shared -o userdll.dll  userdll.cxx       # in case of g++
  c:\> cl /LD /ouserdll.dll userdll.cxx              # in case of VC++
  c:\> bcc32 -WD -P -euserdll.dll userdll.cxx        # in case of BC++

  
  ### Interpreted source ################################################
  // script.cxx
  extern "userdll.dll" {
    void f1();
    int f2(int a,double b,void* p);
  #if defined(G__VISUAL) || defined(G__GNUC)
    void f3(int *a,const int* b); 
  #endif
  }

  int main() {
    f1();
    int x = f2(123,3.14,NULL);
    int y;
  #if defined(G__VISUAL) || defined(G__GNUC)
    f3(&y,&x); // C++ function may fail
  #endif
    return 0;
  }

  ### Running Cint ######################################################
  c:\>  cint script.cxx


==========================================================================
==========================================================================
==========================================================================
file extention 

 cint recognizes following file extensions. cint does not check file 
extension strictly except for DLL.

    * C/C++ header file
          .h .H

    * C++ header file
          .hxx .HXX .hpp .HPP

    * C source file
          .c

    * C++ soruce file
          .C .cc .CC .cxx .CXX .cpp .CPP

    * DLL (Dynamic Link Library)
          .dl .dll .DLL .sl .so


==========================================================================
==========================================================================
==========================================================================
G__[????]

 CINT reserves symbol name starts with 'G__'.  Symbol name start with G__
must not be used. It may cause name conflict.


==========================================================================
G__add_ipath()

void G__add_ipath(const char* ipath)

G__add_ipath() API adds include path. It as same effect as -I command line
option. 

Example:
   G__add_ipath("/usr/local/mylib");
   G__add_ipath("/home/x/y");


SEE ALSO: G__delete_ipath()

==========================================================================
G__addpragma()

void G__addpragma(char *comname,void (*p2f)(char*));

 G__addpragma() API adds user defined #praga statement to cint parser.
It takes command keyword followed by #pragma and pointer to callback
function. The callback function must take string argument (char*).
String given to matching #pragma statement is given to the callback function
as argument.
G__addpragma() API can be used only in compiled program. 
WildC++ interpreter , merger of CINT and Tcl/Tk, is implemented using
this API.
(Refer to $CINTSYSDIR/lib/WildCard or $CINTSYSDIR/lib/wintcldl directory)


Example: Embedding MyCmd.c as precompiled library will add '#pragma MyCommand'
statement in the cint parser.
-B command line option of makecint registers user specific initialization
routine. 
When interpreting Example.C using MyCmd C/C++ interpreter, MyCallBack() 
function should parse lines between '#pragma MyCommad' and 
'#pragma endMyCommand'.


   $ makecint -mk Makefile -o MyCmd -h MyCmd.h -C MyCmd.c -B MyCommandInit 
   $ make
   $ MyCmd Example.C


  /* MyCmd.c */
  #include <stdio.h>
  void MyCallBack(char *args) {
    printf("MyCommand callback with argument %s\n",args);
    /* source file must be parsed here */
  }
  void MyCommandInit() {
    G__addpragma("MyCommand",MyCallBack);
  }


  /* MyCmd.h */
  void MyCallBack(char *args);
  void MyCommandInit();


  // Example.C
  main() {
    // C/C++ statements here
    // This part is given as callback function argument
    //                    |
    //                -----------
    #pragma MyCommand abc def efg
      This part is parsed by MyCallBack function.
      #pragma endMyCommand must be detected by the callback function.
    #pragma endMyCommand
    // Back to C/C++ statement
  }

==========================================================================
G__AllocConsole

int G__AllocConsole(void);

 This API generates new console window for Windows based application.  Pure
Windows program does not have any console window. In order to use Cint's
debugger capability, you need to create a new console window.

 Behavior of G__AllocConsole may depend on an internal flag inside Cint.
In order for G__AllocConsole to surely generate a new console window, call
G__setautoconsole() or G__FreeConsole() API before the G__AllocConsole. 

Windows only

Example:
  void f() {
    G__setautoconsole(0);
    G__AllocConsole();
  }


SEE ALSO: G__FreeConsole, G__setautoconsole

==========================================================================
G__ateval()

int G__ateval([anytype] obj);

 If you define G__ateval() function with an appropreate argument type, 
that function is evaluated when you evaluate value of object from interactive
interface. For example, if you have following source file.

   // ateval.cxx
   #include <string>
   int G__ateval(string& x) {
     cout << x << endl;
     return(0);
   }
   int G__ateval(int x) {
     cout << x << endl;
     return(1);
   }

and you load it as

   $  cint ateval.cxx
   cint> .
   cint> string a="abcdefg"
   cint> int x=12345
   cint> a
   abcde                              ## output of G__ateval(string&)
   (string)137023776                  ## output of cint interactive interface
   cint> x
   12345                              ## output of G__ateval(int)
   cint>

If you return 0 from G__ateval(), default output from cint interactive
interface will be displayed. If 1, it will not.


==========================================================================
G__atpause

void (*G__atpause)();

 G__atpause is a global variable that stores pointer to function which is
called when debugger interface is invoked.
G__atpause can be used only in precompiled library. Default value is NULL.
If non-zero value is set to G__atpause, cint takes it as a pointer to function
which should be called before displaying debugger prompt.
$CINTSYSDIR/G__ci.h must be included to use G__atpause feature.

Example: In following example, file buffer is flushed at before displaying
debugger prompt.


  $ makecint -mk Makefile -I$CINTSYSDIR -o mycint -m -C thisfile.c
  $ make
  $ mycint

/* thisfile.c */
#include "G__ci.h"   /* G__atpause is defined in G__ci.h */

FILE *fp;

void flushfiles() {
      fflush(fp);
}

main() {
      G__init_cint("cint");    /* initialize cint */
      G__atpause = flushfiles; /* assign to G__atpause */
      fp=fopen("something","w");
      fprintf(fp,"print something\n");
      G__pause(); /* flushfile is called */
      fclose(fp);
}


SEE ALSO: G__set_atpause(), debugger interface, G__pause(), debugger usage

==========================================================================
G__BaseClassInfo

 G__BaseClassInfo is an ERTTI API class which provides inheritance information
of class and struct.
<ertti.h> must be included to use ERTTI in an interpreter environment.
-I$CINTSYSDIR and -I$CINTSYSDIR/src command line option must be given to
cint and <Api.h> must be included to use ERTTI in precompiled library.

Interface of G__BaseClassInfo class is shown below. 
Constructor takes G__ClassInfo object as an argument.
Base class tree is iterated by G__BaseClassInfo::Next() member function.

  class G__BaseClassInfo : public G__ClassInfo {
   public:
    // initialization and reset
    G__BaseClassInfo(G__ClassInfo &a);
    void Init(G__ClassInfo &a);
  
    // get base-class information
    long Offset() ;
    long Property();
    int IsValid();
  
    // iteration
    int Next();
  
    // other specification
       .
  };


Example: Following example displays all of the base classes inherited by
ifstream class.


   $ cint  DispInherit.C
   ifstream inheritance information
    public: offset=0    fstreambase
      virtual  public: offset=0    ios
    virtual  public: offset=0    ios
    public: offset=4    istream
      virtual  public: offset=4    ios
    virtual  public: offset=0    ios
   $


   // DispInherit.C
   #include <iostream.h>
   #ifdef __CINT__
   #include <ertti.h>
   #else
   #include <Api.h>
   #endif
   display_inheritance(char *classname,long offset,int level) {
     G__ClassInfo cls(classname);
     G__BaseClassInfo base(cls);
     long property;
     while(base.Next()) {
       property=base.Property();
       for(int i=0;i<level;i++) putchar(' ');
       if(property&G__BIT_ISDIRECTINHERIT) printf("Direct  ");
       else                                printf("        ");
       if(property&G__BIT_ISVIRTUAL)   printf(" virtual ");
       if(property&G__BIT_ISPUBLIC)    printf(" public: ");
       if(property&G__BIT_ISPROTECTED) printf(" protected: ");
       if(property&G__BIT_ISPRIVATE)   printf(" private: ");
       printf("offset=%-3d  %s\n",base.Offset()+offset,base.Name());
       display_inheritance(base.Name(),base.Offset(),level+2);
     }
   }

   main() {
     char *classname="ifstream";
     printf("%s inheritance information\n",classname);
     display_inheritance(classname,0,0);
   }


SEE ALSO: ERTTI, G__ClassInfo,G__BaseClassInfo,G__MethodInfo,
          G__MethodArgInfo ,G__DataMemberInfo,G__TypeInfo,G__TypedefInfo,
          G__CallFunc

==========================================================================
G__calc()

[anytype] G__calc(const char* expression)   // interpreter environment
G__value G__calc(const char* expression)    // precompiled library environment

 G__calc() API evaluates C/C++ expression and returns its' value. 
In interpreter enviroment, type of the return value is automatically 
converted to suitable type without explicit type casting.
In precompiled library environment, it returns G__value object which
can be converted to long or double type object by G__double() or G__int()
API.
If G__calc() API is used in precompiled library, you should include
$CINTSYSDIR/G__ci.h.

 G__calc() can not evaluate declaration and conditional statement. If you
want to evaluate declarations and conditional statements, use G__exec_text()
instead.


Example: G__calc() used in interpreter environment

// interpreted source code
#include <stdio.h>
double f(float f) {
  printf("f=%g\n",f);
  return((double)f);
}

int main() {
   double d;
   d=G__calc("f(3.141592*1.5)");
   char home[100];
   strcpy(home,G__calc("getenv(\"HOME\")"));
   printf("home=%s\n",home);
   return 0;
}


Example: G__calc() used in precompiled library

// must be compiled with -I$CINTSYSDIR 
#include <stdio.h>
#include "G__ci.h"
double f(float f) {
  printf("f=%g\n",f);
  return((double)f);
}

void f2(float& a1) { // how to pass reference type
  printf("a1=%g\n",a1);
}

g() {
   double d;
   d=G__double(G__calc("f(3.141592*1.5)"));

   float x;
   char tmp[100];
   sprintf(tmp,"f2(*(float*)(%ld))",&x); // passing reference
   G__calc(tmp);

   char home[100];
   strcpy(home,(char*)G__int(G__calc("getenv(\"HOME\")")));
   printf("home=%s\n",home);
}



SEE ALSO: G__value , G__exec_text(), G__load_text()

==========================================================================
G__CallFunc

 G__CallFunc is an ERTTI API class which provides mean of calling
function which is registered to interpreter symbol table.
Same thing can be done by G__calc() API, however, G__CallFunc works
more efficiently when used repeatedly in a loop.
<ertti.h> must be included to use ERTTI in an interpreter environment.
-I$CINTSYSDIR and -I$CINTSYSDIR/src command line option must be given to
cint and <Api.h> must be included to use ERTTI in precompiled library.

Interface of G__CallFunc class is shown below. 
Unlike the other ERTTI classes, G__CallFunc can only be used in precompiled
library environment.

class G__CallFunc {
 public:
  // initialization and reset
  G__CallFunc() ;
  void Init() ;

  // set function and argument by string 
  void SetFunc(G__ClassInfo* cls,char* fname,char* args,long* poffset);
  void SetArgs(char* args);

  // set function and argument by pointer and value
  void SetFunc(G__InterfaceMethod f);
  void SetArg(long l) ;
  void SetArg(double d) ;

  // get pointer to interface method
  G__InterfaceMethod InterfaceMethod();

  // execute function
  void Exec(void *pobject) ;
  long ExecInt(void *pobject) ;
  double ExecDouble(void *pobject) ;

  // other specification
     .
};


Example1:
  Following example calls 'operator<<(double a) by using G__CallFunc class.


   $ makecint -mk Mkf -o cf -H cf.h -C++ cf.C -I$CINTSYSDIR -I$CINTSYSDIR/src
   $ make -f Mkf
   $ cf main.C
   3.14
   $


   // main.C
   #include <iostream.h>
   main() {
     callfuncexample();
   }

   // cf.h
   #include <iostream.h>
   #ifdef __CINT__
   #include <ertti.h>
   #else
   #include <Api.h>
   #endif
   void callfuncexample() ;

   // cf.C
   #include "cf.h"
   void callfuncexample() {
     G__ClassInfo cls("ostream");
     long offset;
     G__CallFunc func;
     func.SetFunc(&cls,"operator<<","3.14",&offset);
     *(ostream*)func.ExecInt((void*)(&cout)+offset) << endl;
   }


Example2:
  Find member function by name and parameter list in string.


   TCanvas c[10];
   void *address;
   long offset;
   G__CallFunc func;
   G__ClassInfo canvas("TCanvas");
   // set pointer to interface method and argument
   func.SetFunc(&canvas,"Draw","\"ABC\",1234,3.14",&offset);
   // call function
   for(int i=0;i<10;i++) {
     address = (void*)(&c[i]) + offset;
     func.Exec(address);
   }
   // reset everything
   func.Init();


Example3:
  Find member function by name and argument type in string, put actual 
  parameter by G__CallFunc::SetArg.

   TCanvas c[10];
   void *address;
   long offset;
   G__CallFunc func;
   G__ClassInfo canvas("TCanvas");
   // set pointer to interface method
   func.SetFunc(canvas.GetMethod("Draw","char*,int,double",&offset).InterfaceMethod());
   // set arguments
   char *title="ABC";
   func.SetArg((long)title);
   func.SetArg((long)1234);
   func.SetArg((double)3.14);
   // call function
   for(int i=0;i<10;i++) {
     address = (void*)(&c[i]) + offset;
     func.Exec(address);
   }

   // change arguments on same member function
   func.ResetArg();
   title="DEF";
   func.SetArg((long)title);
   func.SetArg((long)5678);
   func.SetArg((double)6.28);
   // call function
   for(int i=0;i<10;i++) {
     address = (void*)(&c[i]) + offset;
     func.Exec(address);
   }

   // reset everything
   func.Init();
 

Example4:
   #include <stdio.h>
   #include <ertti.h>

   class B {
     int sz;
     double *d;
    public:
     //B(int s) : sz(s+1) { printf("B(%d)\n",s); d = new double[sz]; }
     B(int s) { sz=s; printf("B(%d)\n",s); d = new double[sz]; }
     ~B() { printf("~B()\n"); delete[] d; }
     void Set(double offset, double step) {
       printf("Set(%g,%g)\n",offset,step);
       for(int i=0;i<sz;i++) d[i] = offset + step*i;
     }
     void disp() const {
       printf("disp() ");
       for(int i=0;i<sz;i++) printf("%g ",d[i]);
       printf("\n");
     }
     double Get(int s) const { return(d[s]); }
     void Set(int s,double v) { d[s]=v; }
   };
   
   void test3(const char* name) {
     printf("test3(%s)\n",name);
     long offset;
     G__ClassInfo cl(name+1);
     G__CallFunc ctor;
     G__CallFunc set;
     G__CallFunc disp;
     G__CallFunc dtor;
     ctor.SetFuncProto(&cl,name+1,"int",&offset);
     set.SetFuncProto(&cl,"Set","double,double",&offset);
     disp.SetFuncProto(&cl,"disp","",&offset);
     dtor.SetFuncProto(&cl,name,"",&offset);
   
     printf("%s %d\n",cl.Name(),cl.IsValid());
     printf("ctor %d\n",ctor.IsValid());
     printf("set %d\n",set.IsValid());
     printf("disp %d\n",disp.IsValid());
     printf("dtor %d\n",dtor.IsValid());
   
     for(int i=0;i<3;i++) {
       ctor.SetArg((long)(i+5));
       set.SetArg((double)i);
       set.SetArg((double)i/10);
       offset = ctor.ExecInt((void*)0);
       set.Exec((void*)offset);
       disp.Exec((void*)offset);
       dtor.Exec((void*)offset);
       ctor.ResetArg();
       set.ResetArg();
     }
   }
   
   int main() {
     test3("~B");
     return 0;
   }




SEE ALSO: ERTTI, G__ClassInfo,G__BaseClassInfo,G__MethodInfo
         ,G__MethodArgInfo,G__DataMemberInfo,G__TypeInfo
         ,G__TypedefInfo,G__CallFunc


==========================================================================
G__charformatter

char* G__charformatter(int ifmt,char* buf);


G__charformatter is a special API for handling printf like string formatting.
It implicitly takes variable arguments from interpreted function. First
argument takes position of formatting string in the interpreted function.
ifmt=0 if formatting string is given as the 1st argument of the interpreted 
function, ifmt=1 if 2nd.  Memory buffer must be given as 2nd argument of
G__charformatter.  This API is for expert use only.


Example: 
   int my_printf(char *format ...) {
     char temp[1024];
     return(printf("%s",G__charformatter(0,temp)));
   }
   int my_fprintf(FILE *fp,char *format ...) {
     char temp[1024];
     return(fprintf(fp,"%s",G__charformatter(1,temp)));
   }


==========================================================================
G__ClassInfo

 G__ClassInfo is an ERTTI class which provides class/struct/union/enum
information.
Property of class, struct, union and enum types can be obtained.
<ertti.h> must be included to use ERTTI in an interpreter environment.
-I$CINTSYSDIR and -I$CINTSYSDIR/src command line option must be given to
cint and <Api.h> must be included to use ERTTI in precompiled library.

Interface of G__ClassInfo class is shown below. 
If default constructor is used, information about all existing class,struct,
union,enum can be iterated by G__ClassInfo::Next() member function.
If class name is given to constructor, G__ClassInfo object is immediately
initialized to specified class,struct,union or enum type.

class G__ClassInfo {
 public:
  // initialization and reset
  G__ClassInfo();
  G__ClassInfo(const char *classname);
  G__ClassInfo(G__ClassInfo& x);
  ~G__ClassInfo();
  void Init();
  void Init(const char *classname);

  // test equality
  int operator==(const G__ClassInfo& a);
  int operator!=(const G__ClassInfo& a);

  // get class information
  const char *Name() ;
  const char *Fullname();
  const char *Title() ;
  int Size() ; 
  long Property();
  int NDataMembers();
  int NMethods();
  long IsBase(const char *classname);
  long IsBase(G__ClassInfo& a);
  G__ClassInfo EnclosingClass() ;
  int Linkage();
  const char *FileName() ;
  int LineNumber() ;
  G__InterfaceMethod GetInterfaceMethod(const char *fname,const char *arg
					,long* poffset);
  G__MethodInfo GetMethod(const char *fname,const char *arg,long* poffset);
  G__DataMemberInfo GetDataMember(const char *name,long* poffset);
  void SetGlobalcomp(int globalcomp);
  void SetProtectedAccess(int protectedaccess);
  int IsValid();

  // iteration
  int Next();

  // other specification
     .
};


Example: Following example displays information about iostream class.

   $ cint classes.C
   class ostream  size=36  NMethods=24  NDataMembers=0
   class streambuf  size=80  NMethods=19  NDataMembers=0
   class ostream  size=36  NMethods=24  NDataMembers=0
   class ios  size=32  NMethods=27  NDataMembers=30
   enum io_state  size=4  NMethods=0  NDataMembers=0
   enum open_mode  size=4  NMethods=0  NDataMembers=0
   enum seek_dir  size=4  NMethods=0  NDataMembers=0
          .
          .
          .

   
   // classes.C
   #include <stdio.h>
   #include <iostream.h>
   #ifdef __CINT__
   #include <ertti.h>
   #else
   #include <Api.h>
   #endif
   
   void display(G__ClassInfo& cls) {
     long property = cls.Property();
     if(property&G__BIT_ISCLASS)  printf("class ");
     if(property&G__BIT_ISSTRUCT) printf("struct ");
     if(property&G__BIT_ISUNION)  printf("uinon ");
     if(property&G__BIT_ISENUM)   printf("enum ");
     printf("%s  size=%d  NMethods=%d  NDataMembers=%d\n"
	   ,cls.Name(),cls.Size(),cls.NMethods(),cls.NDataMembers());
   }
   
   void oneclass(char* classname) {
     G__ClassInfo cls(classname);
     display(cls);
   }
   
   void allclasses() {
     G__ClassInfo cls;
     // scan all defined classes
     while(cls.Next()) {
       display(cls);
     }
   }
   
   main() {
     // display only specific class
     oneclass("ostream");
     allclasses();
   }


SEE ALSO: ERTTI, G__ClassInfo,G__BaseClassInfo,G__MethodInfo
         ,G__MethodArgInfo,G__DataMemberInfo,G__TypeInfo
         ,G__TypedefInfo,G__CallFunc

==========================================================================
G__DataMemberInfo

 G__DataMemberInfo is an ERTTI API class which provides information about
global variable and data member.
<ertti.h> must be included to use ERTTI in an interpreter environment.
-I$CINTSYSDIR and -I$CINTSYSDIR/src command line option must be given to
cint and <Api.h> must be included to use ERTTI in precompiled library.

Interface to G__DateMemberInfo is shown below.
If default constructor is used, G__DataMemberInfo is initialized to
give global variable information.
All the global variables can be iterated by G__DataMemberInfo::Next()
member function.
If G__ClassInfo object is given to the constructor, it is initiazlied to
give data member information.
All the data member to that class can be iterated by G__DataMemberInfo::Next()
member function.

Cint handles constant value macro as global variable. 
Hence, G__DataMemberInfo can give information about macro. 
But if -p or +P,-P option is used, macro information is stripped by
preprocessor before it is read by cint, macro information can not be
get by G__DataMemberInfo.

class G__DataMemberInfo {
 public:
  // initialization and reset
  G__DataMemberInfo();
  G__DataMemberInfo(class G__ClassInfo &a);
  void Init();
  void Init(class G__ClassInfo &a);

  // get data member information
  const char *Name();
  const char *Title();
  G__TypeInfo* Type();
  long Property();
  long Offset() ;
  int ArrayDim() ;
  int MaxIndex(int dim) ;
  G__ClassInfo* MemberOf();
  int IsValid();

  // iteration
  int Next();

  // other specification
     .
};


Example: Following example displays all of the global variables, then,
displays ios class data member.

   $ cint DatMem.C
   public: FILE* stdout;
   public: FILE* stderr;
   public: FILE* stdin;
   public: #define EOF;
   public: #define NULL;
   public: FILE* G__dumpfile;
   public: #define G__STDIO_H;
   public: #define _IOFBF;
   public: #define _IOLBF;
      .
      .
   public: enum io_state goodbit;
   public: enum io_state eofbit;
   public: enum io_state failbit;
   public: enum io_state badbit;
   public: enum io_state hardfail;
   public: enum ios::open_mode in;
   public: enum ios::open_mode out;
   public: enum ios::open_mode ate;
   public: enum ios::open_mode app;
   public: enum ios::open_mode trunc;
      .
      .


   // DatMem.C
   #include <stdio.h>
   #ifdef __CINT__
   #include <ertti.h>
   #else
   #include <Api.h>
   #endif
   
   void display(G__DataMemberInfo& dat) {
     long property = dat.Property();
     if(property&G__BIT_ISPUBLIC)    printf("public: ");
     if(property&G__BIT_ISPROTECTED) printf("protected: ");
     if(property&G__BIT_ISPRIVATE)   printf("private: ");
     if(property&G__BIT_ISCONSTANT)  printf("const ");
     printf("%s %s;\n",dat.Type()->Name(),dat.Name());
   }
   
   void globalvariable() {
     G__DataMemberInfo dat;
     while(dat.Next()) {
       display(dat);
     }
   }
   
   void datamember(char *classname) {
     G__ClassInfo cls(classname);
     G__DataMemberInfo dat(cls);
     while(dat.Next()) {
       display(dat);
     }
   }
   
   main() {
     globalvariable();
     G__loadfile("iostream.h");
     datamember("ios");
   }


SEE ALSO: ERTTI, G__ClassInfo,G__BaseClassInfo,G__MethodInfo
          ,G__MethodArgInfo,G__DataMemberInfo,G__TypeInfo
          ,G__TypedefInfo,G__CallFunc

==========================================================================
G__delete_ipath()

int G__delete_ipath(const char* path);

G__delete_ipath() API deletes include path set by -I command line option or 
G__add_ipath() API.  Returns 1 if successful, otherwise 0.

Example:
   G__delete_ipath("/usr/local/mylib");
   G__delete_ipath("/home/x/y");


SEE ALSO: G__add_ipath()


==========================================================================
G__getipathentry()

struct G__includepath *G__getipathentry();

To be documented.


==========================================================================
G__deletevariable()

int G__deletevariable(const char *varname);

  G__deletevariable() API deletes global variable in interpreter's 
symbol table.
If deleted object is a class or struct, destructor is called properly.
Returns 1 if successful, 0 if failed.


Example:

double d=123;
main() {
  G__deletevariable("d"); 
}


==========================================================================
G__double()

double G__double(G__value buf)

 G__double() API converts G__value object to double.
G__double() can only be used in precompiled library enrironment.
$CINTSYSDIR/G__ci.h must be included to use G__double() API.


SEE ALSO: G__calc(), G__value 

==========================================================================
G__dumpfile

FILE* G__dumpfile;

 G__dumpfile is a predefined global variable in Cint interpreter. It is
set to NULL by default.  When writable file pointer is set, Cint dumps
function call history and trace coverage to the file. This variable is
automatically set by -d command line option. Alternatively, a user can
set this manually for starting the dump at any time. 


SEE ALSO: -d option (cint)

==========================================================================
G__exec_tempfile()

[anytype] G__exec_tempfile(const char* file);   // from interpreted code
G__value G__exec_tempfile(const char* file);    // from precompiled code

G__exec_tempfile() opens temporary source file and execute
it  in  the  current  context.   The tempfile can contain,
variable   declaration,   struct,union,enum    definition.
expression,  loop and control statement and cannot contain
function definition.  G__exec_tempfile() executes a state-
ment or statement list surrounded by '{' , '}' and returns
the last evaluated value.


Example:
    G__exec_tempfile("tmp.C");


{    // example of tempfile, tmp.C
  int i;
  double ary[100];
  for(i=0;i<100;i++) ary[i] = i;
}

Then in the main program, you can execute above  statement
by G__exec_tempfile.


SEE ALSO: G__calc(), G__exec_text(), G__load_text()

==========================================================================
G__exec_text()

[anytype] G__exec_text(const char* unnamedmacro);   // from interpreted code
G__value G__exec_text(const char* unmamedmacro);    // from precompiled code

 G__exec_text() API evaluates C/C++ statements and returns its' value. 
In interpreter enviroment, type of the return value is automatically 
converted to suitable type without explicit type casting.
In compiled code , it returns G__value object which can be converted 
to long or double type object by G__double() or G__int() API.
If G__exec_text() API is used in precompiled library, you should include
$CINTSYSDIR/G__ci.h.

 Unlike G__calc() API, G__exec_text() can evaluate declaration and 
conditional statement. However, because G__exec_text() uses temporary
file, execution can be slower than G__calc().


Example:
    G__exec_text("int i");
    G__exec_text("for(i=0;i<10;i++) printf(\"i=%d\n\",i);");
    G__exec_text("i");


SEE ALSO: G__calc(), G__exec_tempfile(), G__load_text()

==========================================================================
G__exec_text_str()

char* G__exec_text_str(const char* unnamedmacro,char* result);

 G__exec_text_str() API is a version of G__exec_text which returns result
as string. G__exec_text(unnamedmacro) is called inside, then result is 
converted to string.

Example:
    char result[512];
    G__exec_text_str("int i",result);
    printf("%s\n",result);
    G__exec_text_str("i",result);
    printf("%s\n",result);


==========================================================================
G__findsym()

void* G__findsym(const char *symname);

 G__findsym() API searches symbols in explicitly loaded DLL (or shared 
library).  DLL can be loaded by G__loadfile() API. If you want to get a
handle to procedure included in the loaded DLL, you can use this API. 
G__findsym() can be used both in the interpreter and compiled code.
Supporse you have compiled program as shown below.

   // mylib.h
   extern "C" void my_func() {
      ...
   }

And you create Cint DLL

  $  makecint -mk Makefile -dl mylib.dll -H mylib.h
  $  make -f Makefile

Then you can get handle of my_func() as follows,

  $  cint mylib.dll
  cint> p G__findsym("my_func")
  (void*)0x401324dc
  cint>

This operation is almost platform independent  except for following 
conditions.

 1) For Win32 and IBM AIX, you need to explicitly export the symbols you
   wnat to access. Otherwise, you can not get desired handle.
 2) Some compiler requires '_' (underscore) before the symbol name.
 3) If you want to get handle to C++ function, you need to know name 
   mangling rule of specific compiler. If you want to avoid name mangling
   you have to declare the function 'extern "C"'.


Note:
 You can not get handle if DLL is implicitly linked with Cint.


==========================================================================
G__ForceBytecodecompilation()

int G__ForceBytecodecompilation(char *funcname,char *param);

This API forces specified function to be optimized as bytecode. Giving name
and parameter type(s) of the function, Cint searches appropriate function
and compiles it into bytecode. Compilation may not always succeed. In case
it fails, this function returns non-zero value.

Example:

   // test.cxx
   void f(int x,double a) {
     ...
   }

   int main() {
     G__ForceBytecodecompilation("f","int,double");
     f();
     return 0;
   }


==========================================================================
G__free_p2fsetup()

void G__free_p2fsetup(void);


 G__free_p2fsetup() API frees pointer to dictionary initialization
routine  registered by G__set_p2fsetup() API. See example in 
G__set_p2fsetup() section.


SEE ALSO: G__set_p2fsetup()


==========================================================================
G__FreeConsole

int G__FreeConsole(void);

 This API deletes console window for Windows based application.  Windows
based program may not have a console window.  If console window is not needed,
you can call this API.

Windows only

Example:
  void f() {
    G__setautoconsole(0);
    G__AllocConsole();
        ...
    G__FreeConsole();
  }


SEE ALSO: G__AllocConsole, G__setautoconsole

==========================================================================
G__get_sym_underscore

int G__get_sym_underscore(void);

 This API informs you if Cint requires '_' for linking C symbols in DLL
or shared library. If return value is 1, '_' is needed. If 0, '_' is not
needed. 


SEE ALSO: G__set_sym_underscore

==========================================================================
G__getexitcode()

int G__getexitcode(void);


 G__getexitcode() API returns argument to exit() function which is called
in Cint interpreter. This API can only be used in compiled code. You can
call this API only once because the exit eode is reset to zero after this
function is called.


==========================================================================
G__getmakeinfo()

char* G__getmakeinfo(char *item);


 G__getmakeinfo() API reads $CINTSYSDIR/MAKEINFO file to extract specified
platform dependent parameter. For example, if you want to extract name of
C++ compiler, you do

  printf("%s\n",G__getmakeinfo("CPP"));

Here are some interesting values you can get from MAKEINFO.

   "CC"      : C compiler name
   "CPP"     : C++ compiler name
   "LD"      : linker name
   "CPREP"   : C preprocessor name
   "CPPPREP" : C++ preprocessor name
   "DLLPOST" : DLL or shared library file extension


SEE ALSO: $CINTSYSDIR/MAKEINFO, Platform dependency file

==========================================================================
G__getoptimizemode()

int G__getoptimizemode();

G__getoptimizemode() returns bytecode optimization mode currently set.


SEE ALSO:  G__optimizemode , doc/bytecode.txt

==========================================================================
G__IncludePathInfo

 G__IncludePathInfo is an ERTTI API class which gives you include path
information. G__IncludePathInfo gives include path name given by -I option
and '#pragma includepath [path];' statement. Public interface of this class
is shown below.


   class G__IncludePathInfo {
    public:
     G__IncludePathInfo();
     void Init();
     const char *Name(); 
     long Property();
     int IsValid();
     int Next();
   };


Example:

   #ifdef __CINT__
   #include <ertti.h>
   #else
   #include <Api.h>
   #endif

   main() {
     G__IncludePathInfo ipath;
     while(ipath.Next()) {
       printf("%s\n",ipath.Name());
     }
   }


==========================================================================
G__init_cint()

int G__init_cint(const char *command)


 G__init_cint() API explicitly initializes cint interpreter core.
Normally, cint main() function implicitly initializes the interpreter.
But if main() function is included in user program, the interpreter must
be explicitly initialized by G__init_cint() API. 
 G__init_cint() takes command string as an argument which requires same
format as you invoke cint from command line.
Initialized interperter can be terminated by G__scratch_all() API.
G__init_cint()/G__scratch_all() pair can be used multiple time in a
single process.

 Alternative way to initialize and start Cint is to use G__main() and 
G__setothermain() API. Those APIs are used in G__init_cint.

 G__init_cint() API can only be used in precompiled library environment.
$CINTSYSDIR/G__ci.h must be included. 

  Return value of G__init_cint() is shown in table below.

 +---------------------------------------------------------------------------+
 | G__INIT_CINT_SUCCESS      | 0 | Initialization successful. main() function|
 |                           |   | was not found in loaded source code.      |
 +---------------------------+---+-------------------------------------------+
 | G__INIT_CINT_SUCCESS_MAIN | 1 | Initialization successful. main() function|
 |                           |   | was found in loaded source code and       |
 |                           |   | executed.                                 |
 +---------------------------+---+-------------------------------------------+
 | G__INIT_CINT_FAILURE      |-1 | Initialization failed.                    |
 +---------------------------------------------------------------------------+
                   Table  Return value of G__init_cint() 

Example: Following example initializes cint interpreter core twice by using
G__init_cint() API.

  $ makecint -m -I$CINTSYSDIR -mk Makefile -o mycint -C mycint.c 
  $ make
  $ mycint

/* mycint.c,  must be compiled with -I$CINTSYSDIR */
#include "G__ci.h"
main() {
   G__init_cint("cint -qlevel1 source1.C");
   G__calc("f1()");
   G__scratch_all();

   switch(G__init_cint("cint source2.C lib.C")) {
   case G__INIT_CINT_SUCCESS: /* initialization done */
     G__calc("f2()");
     G__calc("lib()");
     G__scratch_all();
     break;
   case G__INIT_CINT_SUCCESS_MAIN: /* initialization + main() exec done */
     G__scratch_all();
     break;
   case G__INIT_CINT_FAILURE: /* falied initialization */
     break;
   }
}


SEE ALSO: -m command link option of makecint
          G__main() , G__setothermain() , 
          G__set_p2fsetup() , G__free_p2fsetup()

==========================================================================
G__input()

char* G__input(const char *prompt);

 G__input() reads keyboard input. It returns pointer to static char buffer
declared in G__pause(). G__input uses GNU readline library for command line
completion and history management. 

Example: 

main() {  // example program
  char *command;
  while(1) {
    command = G__input("input command > ");
    if(strcmp(command,"exit")==0) exit();
    system(command);
  }
}


==========================================================================
G__int()

long G__int(G__value buf)

 G__int() API converts G__value object to long integer.
G__int() can only be used in precompiled library enrironment.
$CINTSYSDIR/G__ci.h must be included to use G__int() API.


SEE ALSO: G__calc(), G__value 

==========================================================================
G__IsInMacro()

int G__IsInMacro(void)

G__IsInMacro() API checks if cint execution is G__exec_tempfile() context
(Macro mode), or normal source code interpretation mode. For example,


// macro source which is executed in G__exec_tempfile context
{
  printf("%d\n",G__IsInMacro()); // prints '1'
}


// C++ source file which is executed in normal interpretation mode
f() {
  printf("%d\n",G__IsInMacro()); // prints '0'
}


G__IsInMacro() is used in CINT and ROOT system software  to  switch
internal operational mode.


==========================================================================
G__isinterpretedp2f()

int G__isinterpretedp2f(void *p2f)

 Because the interpreter environment and C/C++ compiler has different 
processing system, special care is needed to deal with a pointer to function
in a compiled code. When pointer to function is evaluated in interpreter
environment, it returns either 1) pointer to an interpreted function, 2)
pointer to an interface method of a compiled global function, 3) pointer to
a true compiled function, or 4) pointer to a bytecode function. 
G__isinterpretedp2f() judges which of above case is the given pointer.
Return value is shown in a table below.

 This function is only valid for global functions. If you use this API for 
ANSI C library function, it may return G__UNKNOWNFUNC.

 It is unneccessary to use G__isinterpretedp2f() API in interpreter environment
because cint will automatically distinguish between the pointer and handle it
properly.

 +--------------------------------------------------------------------------+
 | G__UNKNOWNFUNC             | 0 | Unknown pointer which does not exist in |
 |                            |   | the cint global function table          |
 +----------------------------+---+-----------------------------------------+
 | G__INTERPRETEDFUNC         | 1 | Pointer to an interpreted function      |
 |                            |   |                                         |
 +----------------------------+---+-----------------------------------------+
 | G__COMPILEDINTERFACEMETHOD | 2 | Pointer to an interface method of user  |
 |                            |   | embedded precompiled global function    |
 +----------------------------+---+-----------------------------------------+
 | G__COMPILEDTRUEFUNC        | 3 | Pointer to a true compiled function     |
 |                            |   |                                         |
 +----------------------------+---+-----------------------------------------+
 | G__BYTECODEFUNC            | 4 | Pointer to a bytecode function that is  |
 |                            |   | optimized by cint                       |
 +--------------------------------------------------------------------------+
                Table  Return value of G__isinterpretedp2f()


Example: 

   #include <iostream.h>

   #include "Api.h"   // -I$CINTSYSDIR/src -I$CINTSYSDIR

   DoFCN(void *p2f,char* a,double b) {
     char *fname;
     // reconstruct function name
     fname=G__p2f2funcname(p2f);
     if(fname) {
       G__ClassInfo globalscope;
       G__MethodInfo method;
       long dummy;
       // resolve function overloading
       method=globalscope.GetMethod(fname,"char*,double",&dummy);
       if(method.IsValid()) {
         int (*p)(char*,double);
         char temp[200];
         int result;
         // get pointer to function again after overloading resolution
         p2f=method.PointerToFunc();
         // check what kind of pointer is it
         switch(G__isinterpretedp2f(p2f)) {
         case G__INTERPRETEDFUNC: // reconstruct function call as string
           sprintf(temp,"%s(%ld,%g)",(char*)p2f,a,b);
           result=G__int(G__calc(temp));
           break;
         case G__BYTECODEFUNC: // calling bytecode function
           G__CallFunc func;
           func.SetBytecode((struct G__bytecodefunc*)p2f);
           func.SetArg((long)a);
           func.SetArg((double)b);
           result=func.ExecDouble((void*)NULL);
           break;
         case G__COMPILEDINTERFACEMETHOD: // using interface method
           G__CallFunc func;
           func.SetFunc((G__InterfaceMethod)p2f);
           func.SetArg((long)a);
           func.SetArg((double)b);
           result=func.ExecDouble((void*)NULL);
           break;
         case G__COMPILEDTRUEFUNC: // using true pointer to function
           result=(*p2f)(a,b);
           break;
         case G__UNKNOWNFUNC: // this case will never happen
           result=(*p2f)(a,b);
           break;
         }
         cout << "result=" << result << endl;
       }
       else {
         cerr << "no overloading parameter matches" << endl;
       }
     }
     else {
       cerr << "unknown pointer to function" << endl;
     }
   }


Example2:

   $ makecint -mk mkf -dl lib1.dll -I$CINTSYSDIR -I$CINTSYSDIR/src -H lib1.h
   $ make -f mkf
   $ cint main.cxx

   ////////////////////////////////////////////////////////////////
   // lib1.h
   #include <iostream.h>
   #include "Api.h"   // -I$CINTSYSDIR/src -I$CINTSYSDIR
   //////////////////////////////////////////////////////////////
   // FunctionObject for double f(int*,double)
   //////////////////////////////////////////////////////////////
   class FunctionObject {
     G__ClassInfo globalscope;
     G__MethodInfo method;
     G__CallFunc func;
     long dummy;
     void *regeneratedp2f;
     int mode;
    public:
     void Init(void *p2f) {
       char *fname;
       // reconstruct function name
       fname=G__p2f2funcname(p2f);
       if(fname) {
         // resolve function overloading
         method=globalscope.GetMethod(fname,"int*,double",&dummy);
         if(method.IsValid()) {
	   // get pointer to function again after overloading resolution
	   regeneratedp2f=method.PointerToFunc();
	   // check what kind of pointer is it
	   mode = G__isinterpretedp2f(regeneratedp2f);
	   switch(mode) {
	   case G__INTERPRETEDFUNC: // reconstruct function call as string
	     break;
	   case G__BYTECODEFUNC: // calling bytecode function
	     func.SetBytecode((struct G__bytecodefunc*)regeneratedp2f);
	     break;
	   case G__COMPILEDINTERFACEMETHOD: // using interface method
	     func.SetFunc((G__InterfaceMethod)regeneratedp2f);
	     break;
	   case G__COMPILEDTRUEFUNC: // using true pointer to function
              break;
	   case G__UNKNOWNFUNC: // this case will never happen
              break;
	   }
         }
         else {
	   cerr << "no overloading parameter matches" << endl;
         }
        }
       else {
         cerr << "unknown pointer to function" << endl;
       }
     }

     double Do(int* a,double b) {
       double result;
       char temp[200];
       switch(mode) {
       case G__INTERPRETEDFUNC: // reconstruct function call as string
         sprintf(temp,"%s((int*)%ld,%g)",(char*)regeneratedp2f,(long)a,b);
         result=G__int(G__calc(temp));
         break;
       case G__BYTECODEFUNC: // calling bytecode function
       case G__COMPILEDINTERFACEMETHOD: // using interface method
         func.ResetArg();
         func.SetArg((long)a);
         func.SetArg((double)b);
         result=func.ExecDouble((void*)NULL);
         break;
       case G__COMPILEDTRUEFUNC: // using true pointer to function
       case G__UNKNOWNFUNC: // this case will never happen
         double (*p)(int*,double) ;
         p = (double (*)(int*,double))regeneratedp2f;
         result=(*p)(a,b);
         break;
       default:
      result = 0;
         break;
       }
       return result;
     }
   };
   
   //////////////////////////////////////////////////////////////
   // Plug in functions
   //////////////////////////////////////////////////////////////
   double f1(int* a,double b) {
     double result = b*(*a);
     return result;
   }
   
   double f2(int* a,double b) {
     double result = b+(*a);
     return result;
   }
   
   //////////////////////////////////////////////////////////////
   // main test
   //////////////////////////////////////////////////////////////
   void test(void* p2f,int n) {
     FunctionObject fx;
     fx.Init(p2f);
     double sum=0;
     int a;
     double b=0.1;
   
     for(int i=0;i<n;i++) {
       a = i;
       sum += fx.Do(&a,b);
     }
     cout << "sum = " << sum << endl;
   
   }
   // end of lib1.h
   ////////////////////////////////////////////////////////////////
   

   //////////////////////////////////////////////////////////////////
   // main.cxx
   #include "lib1.dll"
   
   //////////////////////////////////////////////////////////////
   // Plug in functions
   //////////////////////////////////////////////////////////////
   double f3(int* a,double b) {
     double result = b-(*a);
     return result;
   }
   
   double f4(int* a,double b) {
     double result = b*(*a)*2;
     return result;
   }
   
   int main() {
     test(f1,1000000);
     test(f2,1000000);
     test(f3,100000);
     test(f4,100000);
   }
   // end of main.cxx
   ///////////////////////////////////////////////////////////////////



==========================================================================
G__LockCpp()

void G__LockCpp()

G__LockCpp() API enforces all source code to be handled as C++ regardless of
file name extension.  Same effect as -A command line option.


SEE ALSO: cint -A option


==========================================================================
G__lasterror_filename()

char* G__lasterror_filename()

G__lasterror_filename() API returns filename which last cint error occured.


==========================================================================
G__lasterror_linenum()

char* G__lasterror_linenum()

G__lasterror_filename() API returns line number which last cint error occured.


==========================================================================
G__load_text()

char* G__load_text(const char *namedmacro)

 G__load_text() API loads null terminated string as source code. It can 
contain any kind of C/C++ syntax that Cint supports. The text is saved
into a temporary file and read by Cint. The tempoprary file is automatically
removed when it is unloaded.

 G__load_text() returns name of the temporary file in a static buffer. You
can use that name for unloading.  In an event of failure, G__load_text() 
returns 0.


Example:

  // example unnamed macro doit.cxx
  {
    char *p;
    p=G__load_text("class A{public: 
                             A() {printf(\"A()\n\");} 
                             ~A() {printf(\"~A()\n\");} };
                    void f(){ printf(\"f()\n\"); }");
    if(p) {
      G__exec_text("A x");
      G__exec_text("f()");
      G__unloadfile(p);
    }
  }

  
  // Running it
  $ cint
  cint> x doit.cxx
  A()
  f()
  ~A()
  (const int)0
  cint>


SEE ALSO: G__loadfile(), G__unloadfile(), G__exec_text()

==========================================================================
G__loadfile()

int G__loadfile(const char *filename)

 G__loadfile() API loads source code or DLL(Dynamic Link Library) at run-time.
If file extention is .sl  , .dl , .dll or .DLL , the file is linked as DLL.
Otherwise, the file is loaded as source or header file.
G__loadfile("[filename]") behaves the same as '#pragma include "[filename]"'.
It first searches current working directory for given file name.
If not found it searches directories specified as include path by -I
command line option.
If not found either, it searches $CINTSYSDIR/include directory.
G__loadfile() can be used both in interpreted code and precompiled library.

G__loadfile() returns 0 (G__LOADFILE_SUCCESS) when successful, 
1 (G__LOADFILE_DUPLICATE) if specified file is already loaded,
-1 (G__LOADFILE_FAILURE) or -2 (G__LOADFILE_FATAL) if it fails.

  +-----------------------------------------------------------------------+
  | G__LOADFILE_SUCCESS   |  0 | load file success                        |
  +-----------------------+----+------------------------------------------+
  | G__LOADFILE_DUPLICATE |  1 | specified file is already loaded         |
  +-----------------------+----+------------------------------------------+
  | G__LOADFILE_FAILURE   | -1 | load file failed                         |
  +-----------------------+----+------------------------------------------+
  | G__LOADFILE_FATAL     | -2 | unrecoverble error occured during load   |
  +-----------------------------------------------------------------------+
                     Table.  Return value of G__loadfile()


SEE ALSO: G__unloadfile(), G__load_text(), xtdebugger command 'L' 

==========================================================================
G__loadsystemfile()

int G__loadsystemfile(char *sysdllname)

G__loadsystemfile() API loads permanently loaded DLL(Dynamic Link Library).
Once loaded with this API, that DLL remains loaded even if G__unloadfile()
is called. 

This API is added by Fons Rademaker's request for ROOT2.23 support.


==========================================================================
G__main()

int G__main(int argc,char **argv)


 G__main() API explicitly initializes cint interpreter core.
Normally, cint main() function implicitly initializes the interpreter.
But if main() function is included in user program the interpreter must
be initialized explicitly by G__main() API. 
 G__main() takes array of command string as arguments which requires same
format as you invoke cint from command line. 

 Alternative way to initialize and start Cint is to use G__init_cint() API.
G__init_cint() uses G__main() inside.

 G__setothermain() must be called before calling G__main(). Setting 
G__setothermain(0), G__main() initializes, starts and terminates interpreter
automatically. In this case, after G__main() you can not use the interpreter.
If you set G__setothermain(2), G__main() leave the interpreter alive. You
can use the interpreter until it is explicitly terminated bby G__scratch_all()
API. 

 G__init_cint() behaves the same as G__setothermain(2) + G__main(argc,argv).

 Also, be aware of G__set_p2fsetup() and G__free_p2fsetup(). Those let 
Cint recognize definition of user defined library.


Example1:

   #include <stdio.h>
   extern "C" {(0), 
   extern void G__setothermain(int othermain);
   extern int G__main(int argc,char **argv);
   }

   int main(int argc,char **argv)
   {
     int result;
     G__setothermain(0);
     result=G__main(argc,argv);
     // interpreter is terminated here
     return(result);
   }


Example2:

   #include <stdio.h>
   extern "C" {
   extern void G__setothermain(int othermain);
   extern int G__main(int argc,char **argv);
   extern void G__scratch_all(void);
   }

   int main(int argc,char **argv)
   {
     int result;
     G__setothermain(2);
     result=G__main(argc,argv);
     // interpreter is still alive, you can use other Cint APIs
     G__scratch_all();
     return(result);
   }


SEE ALSO: G__setothermain() 
          G__set_p2fsetup() , G__free_p2fsetup()
          G__init_cint()


==========================================================================
G__MethodArgInfo

 G__MethodArgInfo is an ERTTI API class which provides information about
function arguments.
<ertti.h> must be included to use ERTTI in an interpreter environment.
-I$CINTSYSDIR and -I$CINTSYSDIR/src command line option must be given to
cint and <Api.h> must be included to use ERTTI in precompiled library.

Interface to G__MethodArgInfo is shown below.
G__MethodArgInfo object must be initialized by G__MethodInfo object.
Call G__MethodArgInfo::Next() method to get argument information one by one.


class G__MethodArgInfo {
 public:
  // initialization and reset
  G__MethodArgInfo();
  G__MethodArgInfo(class G__MethodInfo &a);
  void Init(class G__MethodInfo &a);

  // get member function argument information
  const char *Name();
  G__TypeInfo* Type() { return(&type); }
  long Property();
  char *DefaultValue();
  G__MethodInfo* ArgOf() { return(belongingmethod); }
  int IsValid();

  // iteration
  int Next();

  // other specification
     .
};


Example: Following example displays type and name of function argument.

   void displayparam(G__MethodInfo& func) {
     long property;
     G__MethodArgInfo arg(func);
     int state=0;
     printf("(");
     while(arg.Next()) {
       if(state) printf(",");
       state=1;
       property=arg.Property();
       if(property&G__BIT_ISCONSTANT) printf("const ");
       printf("%s",arg.Type()->Name());
       if(arg.Name()) printf(" %s",arg.Name());
       if(arg.DefaultValue()) printf("=%s",arg.DefaultValue());
     }
     printf(");\n");
   }


SEE ALSO: ERTTI, G__ClassInfo,G__BaseClassInfo,G__MethodInfo,G__MethodArgInfo
          ,G__DataMemberInfo,G__TypeInfo,G__TypedefInfo,G__CallFunc 

==========================================================================
G__MethodInfo

 G__MethodInfo is an ERTTI API class which provides information about
global function and member function.
<ertti.h> must be included to use ERTTI in an interpreter environment.
-I$CINTSYSDIR and -I$CINTSYSDIR/src command line option must be given to
cint and <Api.h> must be included to use ERTTI in precompiled library.

Interface to G__MethodInfo is shown below.
If default constructor is used, G__MethodInfo is initializaed to give
global function information.
All the global function can be iterated by G__MethodInfo::Next()
member function.
If G__ClassInfo object is given to the constructor, it is initialized to
give member function information.
All the member function can be iterated by G__MethodInfo::Next()
member function.


class G__MethodInfo {
 public:
  // initialization and reset
  G__MethodInfo();
  G__MethodInfo(G__ClassInfo &a);
  void Init();
  void Init(G__ClassInfo &a);

  // get member function information
  const char *Name();
  const char *Title();
  G__TypeInfo* Type();
  long Property();
  int NArg();
  int NDefaultArg();
  G__InterfaceMethod InterfaceMethod();
  void* PointerToFunc();
  G__ClassInfo* MemberOf();
  const char *FileName();
  int LineNumber();
  int Size();
  int IsBusy();
  int IsValid();

  // iteration
  int Next();

  // other specification
     .
};


Example: Following example displays all of the global functions and 
member function of ios class.


   $ cint Func.C
   public: void G__list_class();
   public: void G__list_class(char* classname);
   public: void G__list_memvar(char* classname);
   public: void G__list_memfunc(char* classname);
   public: void G__InitGetSpecialObject(G__pMethodSpecialObject pmethod);
   public: void G__InitGetSpecialValue(G__pMethodSpecialValue pmethod);
   public: void displayparam(class G__MethodInfo& func);
   public: void display(class G__MethodInfo& func);
   public: void globalfunc();
      .
      .
      .



   #include <stdio.h>
   #ifdef __CINT__
   #include <ertti.h>
   #else
   #include <Api.h>
   #endif
   
   void displayparam(G__MethodInfo& func) {
     long property;
     G__MethodArgInfo arg(func);
     int state=0;
     printf("(");
     while(arg.Next()) {
       if(state) printf(",");
       state=1;
       property=arg.Property();
       if(property&G__BIT_ISCONSTANT) printf("const ");
       printf("%s",arg.Type()->Name());
       if(arg.Name()) printf(" %s",arg.Name());
       if(arg.DefaultValue()) printf("=%s",arg.DefaultValue());
     }
     printf(");\n");
   }
   
   void display(G__MethodInfo& func) {
     long property = func.Property();
     if(property&G__BIT_ISPUBLIC)    printf("public: ");
     if(property&G__BIT_ISPROTECTED) printf("protected: ");
     if(property&G__BIT_ISPRIVATE)   printf("private: ");
     if(property&G__BIT_ISCONSTANT)  printf("const ");
     printf("%s %s",func.Type()->Name(),func.Name());
     displayparam(func);
   }
   
   void globalfunc() {
     G__MethodInfo func;
     while(func.Next()) {
       display(func);
     }
   }
   
   void memberfunc(char *classname) {
     G__ClassInfo cls(classname);
     G__MethodInfo func(cls);
     while(func.Next()) {
       display(func);
     }
   }
   
   main() {
     globalfunc();
     G__loadfile("iostream.h");
     memberfunc("ios");
   }


SEE ALSO: ERTTI, G__ClassInfo,G__BaseClassInfo,G__MethodInfo,G__MethodArgInfo
          ,G__DataMemberInfo,G__TypeInfo,G__TypedefInfo,G__CallFunc 

==========================================================================
G__optimizemode()

int G__optimizemode(int optimizelevel);
 
G__optimizemode() sets bytecode optimization mode. Optimization mode ranges
from 0 to 5. Default is 4. 


SEE ALSO:  G__getoptimizemode , doc/bytecode.txt


==========================================================================
G__p2f2funcname()

char* G__p2f2funcname(void* p2f)

 G__p2f2funcname() returns name of a function from a given pointer to 
function.
This function is only valid for user embedded or user interpreted global
functions.
If this function is used on ANSI C library function or CINT API function,
return value is always (char*)NULL.


SEE ALSO G__interpretedp2f() 

==========================================================================
G__pause()

int G__pause(char *prompt)

 G__pause() explicitly starts cint's debugger interface.
It displays debugger prompt and waits for user input.
G__pause() returns non-zero value when 'i' (ignore) or 'q' (quit) command
is given. 
Otherwise, it returns 0.

 G__pause() API can be used in both interpreted code and precompiled
library.
$CINTSYSDIR/G__ci.h must be included when using CINT API in precompiled
library.


  +------------------------------------------------------------------------+
  | G__PAUSE_NORMAL    | 0 | Normal return value                           |
  +--------------------+---+-----------------------------------------------+
  | G__PAUSE_IGNORE    | 1 | When 'i' command (ignore) is given            |
  +--------------------+---+-----------------------------------------------+
  | G__PAUSE_STEPOVER  | 3 | When 'S' command (step over) is given         |
  +------------------------------------------------------------------------+
                 Table.  Return value of G__pause()


Example: Following example shows 2 uses of G__pause() API. THe first one
simply calls G__pause(). This behaves the same as setting break point to
the position of G__pause(). Second example uses G__pause() in a while
loop which tests G__pause() against 0. The condition is true until user
inputs 'i' or 'q' command from the debugger interface.


main() {
      .
  G__pause();            // Behaves the same as setting break point here.
      .
  while(0==G__pause()) ; // Loops here until 'i' or 'q' command is given
}


SEE ALSO: debugger command 

==========================================================================
G__process_cmd()


int G__process_cmd(char *line,char *prompt,int *more,int *err,G__value *rslt);

G__process_cmd() executes cint debugger interface command. 

CAUTION:
 This API is only for expert's use. Do not use this API unless you really
understand the detail.


==========================================================================
G__reloadfile()

int G__reloadfile(const char *file);

G__reloadfile() API loads source code or DLL(Dynamic Link Library) at run-time.
It operates similary to G__loadfile(). 

If specified file is already loaded, G__reloadfile() unloads all files
loaded after specified one, then reloads all unloaded files again. While 
G__loadfile() reloads specified one only.


SEE ALSO: G__loadfile(), G__unloadfile(), G__load_text()

==========================================================================
G__scratch_all()

void G__scratch_all(void)

 G__scratch_all() API terminates the interpreter and frees heap memory 
used by it.
The interpreter should not be used after G__scratch_all() is called.
To resume the interpreter, user needs to call G__init_cint().

 G__scratch_all() can only be used in precompiled library.
$CINTSYSDIR/G__ci.h must be included to use CINT API in precompiled library.


SEE ALSO: G__init_cint() 

==========================================================================
G__set_aterror()

void G__set_aterror(void (*p2f)())

G__set_aterror() API sets callback routine for error handling. If set,
callback function is called whenever cint error occurs.
NULL, pointer to interpreted function or pointer to compiled function
can be set.


==========================================================================
G__set_atpause()

void G__set_atpause(void (*p2f)())

G__set_atpause() API sets callback routine for G__pause() API.
If set, callback function is called whenever G__pause() API is called.
NULL, pointer to interpreted function or pointer to compiled function
can be set.


SEE ALSO: G__atpause

==========================================================================
G__set_autoloading()   ### DELETED ### DO NOT USE THIS

void G__set_autoloading(int (*p2f)(char*))

G__set_autoloading sets a function to recover from command line input.
If undefined class is used in command line input, Cint uses this
function to find appropriate shared library and ask user if he/she
wants to load it. If you do not use this API, default function G__autoloading 
(in cint/src/pause.c) is set.  For example,

   cint> .
   cint> TUnknown *x
   Error: Symbol TUnknown is not defined in current scope ...
   TUnknown.dll exists. Do you want to load it(y/n)?  y
   !!!Dictionary position rewound... !!!error recovered!!!
   TUnknown.dll loaded
   cint>

This API can only be used in compiled code.  Only for expert use.

==========================================================================
G__set_class_autoloading_callback

void G__set_class_autoloading_callback(int (*p2f)(char* classname,char* libname));

This API sets callback function for autoloading.


SEE ALSO: G__set_class_autoloading_table

==========================================================================
G__set_class_autoloading_table

void G__set_class_autoloading_table(char* classname,char* libname);

This API sets class-name vs library-name table for library autoloading.
If such table is setup, the library is automatically loaded when class name
is referenced in script or command line.

Example:

  void init() {
    G__set_class_autoloading_table("TMyClass1","MyLib1.dll");
    G__set_class_autoloading_table("TMyClass2","MyLib1.dll");
    G__set_class_autoloading_table("TMyClass3","MyLib1.dll");
    G__set_class_autoloading_table("TYourClass1","YourLib1.dll");
    G__set_class_autoloading_table("TYourClass2","YourLib1.dll");
  }

  void script() {
    TMyClass2 a;  // MyLib1.dll is loaded
    TMyClass1 b;  
    TYourClass3 c; // YouLib1.dll is loadedk
    ...
  }

  int main() {
    init();
    script();
  }

SEE ALSO: G__set_class_autoloading_callback

==========================================================================
G__set_history_size

void G__set_history_size(int s);

G__set_history_size() API changes size of command input history file.
Default is 30.



==========================================================================
G__setautoconsole()

void G__setautoconsole(int autoconsole);

 This API sets a special flag to automatically console window at any stdio
access from the Cint interpreter in Windows environment. If autoconsole 
flag is set to 1, console window will be automatically generated.

Windows only

Example:
  void f() {
    G__setautoconsole(1);
        ...
    printf("abc\n");   // console window appears automatically
        ...
    G__FreeConsole();
  }


SEE ALSO: G__AllocConsole, G__FreeConsole

==========================================================================
G__setbreakpoint()

int G__setbreakpoint(char *breakline,char *breakfile);

G__setbreakpoint() sets break point for interpreted source code. You can
set break point in a couple of different ways.  0 is returned if break point
is set successfully.  If 1 is returned, Cint fails to set break point.

1. by function name
  If you give function name to breakline argument, Cint looks for matching
  function and break point is set at the beginning of that function. The
  breakfile argument is ignored. For example,
     G__setbreakpoint("myfunc","");
     G__setbreakpoint("MyClass::memfunc","");

2. by line number
  If the first character in breakline string is a digit, Cint consider the
  information as line number.  Break point is set at specified line number.
  If breakfile argument is also specified, break point is set at a specific
  line of the source file. If breakfile does not contain any information, 
  break points are set at specified line of every source file. For example,
     G__setbreakpoint("11","mysrc.cxx");
     G__setbreakpoint("100","");


==========================================================================
G__set_emergencycallback()

void G__set_emergencycallback(void (*p2f)())

G__set_emergencycallback() API sets callback routine for emergency purpose.
The callback function is called when 'save' command is given from command
line.  This API can be used only in compiled code. Argument must be NULL
or a pointer to compiled function.


==========================================================================
G__set_eolcallback()

void G__set_eolcallback(void (*eolcallback)(const char* fname,int linenum))

This feature has been there, but not ready for public use yet.


==========================================================================
G__set_errmsgcallback()

void G__set_errmsgcallback(void (*p2f)(char *msg))

G__set_errmsgcallback() API sets callback routine for error message display.
If set, callback function is called whenever cint displays error message.
This API can be used only in compiled code.  Argument must be NULL or 
a pointer to compiled function.

You must define G__ERRORCALLBACK macro when you compile Cint. If you use
UNIX, add -DG__ERRORCALLBACK to OTHMACRO in platform dependency file.

If you use MS VC++, you need to do a couple of things in order to activate
this API. First, you need to open a project c:\cint\src\libcint\libcint.mdp.
Then, bring up a project setting dialog by 'Project->Settings...' pull down
menu.  Select 'C/C++' tag.  Select 'Preprocessor' category. There, you find
an entry for preprocessor definitions. Add G__ERRORCALLBACK there.  Another
thing you must do is to add 'G__set_errormsgcallback @125' at the end of 
c:\cint\src\libcint\libcint.def.


==========================================================================
G__set_beforeparse_hook()

typedef void G__parse_hook_t ();
G__parse_hook_t* G__set_beforeparse_hook(G__parse_hook_t* hook);

To be documented.


==========================================================================
G__set_ioctortype_handler()

G__set_ioctortype_handler(int (*p2f)(const char*));

To be documented.


==========================================================================
G__set_ignoreinclude()

typedef int (*G__IgnoreInclude)(const char* fname,const char* expandedfname);
void G__set_ignoreinclude(G__IgnoreInclude p2f);

G__set_ignoreinclude() API sets callback routine for G__loadfile() API.
If set, G__loadfile() lets the callback function to decide whether to
actually load the file or ignore it.


==========================================================================
G__set_p2fsetup()

void G__set_p2fsetup(void (*p2f)());


 G__set_p2fsetup() API registers pointer to dictionary initialization
routine.  This API must be called before G__main() or G__init_cint()
API , in order to let Cint recognize definition of user defined library.
Registered information must be freed using G__free_p2fsetup().

 Dictionary for user defined library is generated by 'cint -c-1' for C++
and 'cint -c-2' for C. Name of initialization routine is G__cpp_setup()
for C++ and G__c_setup() for C.  If -N[DLLID] option is given to Cint,
names will be G__cpp_setup[DLLID]() and G__c_setup[DLLID]().


Example:

  Suppose you have User.h and User.cxx, 

   $  makecint -mk Makefile -o user -H User.h -C++ User.cxx
   $  make -f Makefile

 Alternatively, you can use 'cint -c-1' as follows.

   $  cint -w0 -zUser -NUser -nG__cpp_User.cxx -D__MAKECINT__ -c-1 -A User.h

  Uou will have dictionary source file G__cpp_User.cxx. At the end of 
 G__cpp_User.cxx, you will find G__cpp_setup() or G__cpp_setupUser().
 Give pointer to this function to G__set_p2fsetup().


   #include <stdio.h>
   extern "C" {
   extern void G__setothermain(int othermain);
   extern int G__main(int argc,char **argv);
   extern void G__set_p2fsetup(void (*p2f)());
   extern void G__free_p2fsetup();
   extern void G__cpp_setupUser();
   }

   int main(int argc,char **argv)
   {
     int result;
     G__set_p2fsetup(G__cpp_setupUser);
     G__setothermain(2);
     result=G__main(argc,argv);
     // Do other things with G__calc() and G__exec_text() API.
     G__scratch_all();
     G__free_p2fsetup();
     return(result);
   }


SEE ALSO: 
          G__main() , G__setothermain() 
          G__free_p2fsetup()
          G__init_cint()

==========================================================================
G__set_smartunload()

void G__set_smartunload(int smartunload);

G__set_smartunload() API sets a flag to enable source file smart unloading.


==========================================================================
G__set_sym_underscore

void G__set_sym_underscore(int sym_underscore);

 This API sets if Cint requires '_' for linking C symbols in DLL
or shared library. If 1 is set, '_' is needed. If 0, '_' not needed. 


SEE ALSO: G__get_sym_underscore

==========================================================================
G__setothermain()

void G__setothermain(int othermain)


 G__setothermain() API selects initialization mode for G__main().
 G__setothermain() must be called before calling G__main(). Setting 
G__setothermain(0), G__main() initializes, starts and terminates interpreter
automatically. In this case, after G__main() you can not use the interpreter.
If you set G__setothermain(2), G__main() leave the interpreter alive. You
can use the interpreter until it is explicitly terminated bby G__scratch_all()
API.

 See code example in G__main() section.


SEE ALSO: G__main() 
          G__set_p2fsetup() , G__free_p2fsetup()
          G__init_cint()


==========================================================================
G__exit()

void G__exit(int rtn);

To be documented


==========================================================================
G__SourceFileInfo

 G__SourceFileInfo is an ERTTI API class which gives you source file 
information.   Public interface of this class is shown below.


   class G__SourceFileInfo {
    public:
     G__SourceFileInfo();
     G__SourceFileInfo(int filenin);
     void Init();
     const char *Name(); 
     const char *Prepname(); 
     FILE* fp();
     int MaxLine();
     G__SourceFileInfo& IncludedFrom();
     long Property();
     int IsValid();
     int Next();
   };


Example:

   #ifdef __CINT__
   #include <ertti.h>
   #else
   #include <Api.h>
   #endif

   main() {
     G__SourceFileInfo src;
     while(src.Next()) {
       printf("%s lines=%d  fp=0x%x\n",src.Name(),src.MaxLine(),src.fp());
     }
   }

==========================================================================
G__stepmode()

int G__stepmode(int on_off);

G__stepmode() turns on/off step execution mode. This API can be used both
from interpreted and precompiled code.


==========================================================================
G__tracemode()

int G__tracemode(int on_off);
 
G__tracemode() turns on/off source code trace mode. This API can be used
both from interpreted and precompiled code.


==========================================================================
G__TypeInfo

 G__TypeInfo is an ERTTI API class which provides information about
object type.
<ertti.h> must be included to use ERTTI in an interpreter environment.
-I$CINTSYSDIR and -I$CINTSYSDIR/src command line option must be given to
cint and <Api.h> must be included to use ERTTI in precompiled library.

Interface to G__TypeInfo is shown below.
G__TypeInfo distinguishes among fundamental types, class, struct, union, 
enum and typedef information associated with object, function and function 
argument.

class G__TypeInfo : public G__ClassInfo  {
 public:
  // initialization and reset
  G__TypeInfo();
  G__TypeInfo(const char *typenamein);
  void Init(const char *typenamein);

  // test equality
  int operator==(const G__TypeInfo& a);
  int operator!=(const G__TypeInfo& a);

  // get type information
  const char *Name();
  const char *TrueName();
  int Size(); 
  long Property();
  int IsValid();
  void *New();
  int Type() { return(type); }

 private:
  // iteration is prohibited
  int Next();

  // other specification
     .
};


Example: Following example displays information about ostream class.

   $ cint DispType.C
   name=class ostream  truename=class ostream  size=36

   // DispType.C
   #include <iostream.h>
   #include <stdio.h>
   #ifdef __CINT__
   #include <ertti.h>
   #else
   #include <Api.h>
   #endif

   main() {
     long property;
     G__TypeInfo t("ostream");
     property=t.Property();
     if(property&G__BIT_ISTYPEDEF) printf("typedef ");
     printf("name=%s  truename=%s  size=%d\n",t.Name(),t.TrueName(),t.Size());
   }



 SEE ALSO:  ERTTI, G__ClassInfo,G__BaseClassInfo,G__MethodInfo,G__MethodArgInfo
,G__DataMemberInfo,G__TypeInfo,G__TypedefInfo,G__CallFunc 

==========================================================================
G__TypedefInfo

 G__TypedefInfo is an ERTI API class which provides information about
typedef.
<ertti.h> must be included to use ERTTI in an interpreter environment.
-I$CINTSYSDIR and -I$CINTSYSDIR/src command line option must be given to
cint and <Api.h> must be included to use ERTTI in precompiled library.

Interface to G__TypedefInfo is shown below.


class G__TypedefInfo : public G__TypeInfo {
 public:
  // initialization and reset
  G__TypedefInfo();
  G__TypedefInfo(const char *typenamein);
  void Init();
  void Init(const char *typenamein);

  // get typedef information
  const char *Title() ;
  int IsValid();

  // iteration
  int Next();

  // other specification
     .
};


Example: Following example displays information about all typedefs.

   #include <iostream.h>
   #include <stdio.h>
   #ifdef __CINT__
   #include <ertti.h>
   #else
   #include <Api.h>
   #endif
   
   main() {
     long property;
     G__TypedefInfo t;
     char buf[80];
     while(t.Next()) {
       strcpy(buf,t.TrueName());
       printf("typedef %s %s;\n",buf,t.Name());
     }
   }


SEE ALSO: ERTTI, G__ClassInfo,G__BaseClassInfo,G__MethodInfo,G__MethodArgInfo
          ,G__DataMemberInfo,G__TypeInfo,G__TypedefInfo,G__CallFunc 

==========================================================================
G__unloadfile()

int G__unloadfile(const char *filename)

 G__unloadfile() API unloads source code or DLL(Dynamic Link Library) at 
run-time.  Cint loads/unloads source/DLL files in stack-wise way. All the
source/DLL files loaded after specified one will be unloaded at once.
G__unloadfile() can be used both in interpreted code and precompiled library.

G__unloadfile() returns 0 (G__UNLOADFILE_SUCCESS) when successful, 
-1 (G__UNLOADFILE_FAILURE) if it fails.

  +-----------------------------------------------------------------------+
  | G__UNLOADFILE_SUCCESS |  0 | unload file success                      |
  +-----------------------+----+------------------------------------------+
  | G__UNLOADFILE_FAILURE | -1 | unload file failed                       |
  +-----------------------------------------------------------------------+
                     Table.  Return value of G__unloadfile()


SEE ALSO: G__loadfile(), G__load_text(), debugger command 'L' 


==========================================================================
G__SetCatchException

void G__SetCatchException(int mode);

This API turns on/off if C++ exception handling (try..catch) is used when
calling compiled C++ code from the interpreter. 



==========================================================================
G__SetUseCINTSYSDIR

void G__SetUseCINTSySDIR(int UseCINTSYSDIR);

Only valid in ROOT/CINT environment under compiled code. This API sets a 
flag to use environment variable $CINTSYSDIR over the $ROOTSYSDIR for 
searching CINT system files. If set to 1, $CINTSYSDIR is used, if 0, 
$ROOTSYS is used.  Default is 0.

Example:
     #include "G__ci.h"
     void StartCint() {
       G__SetUserCINTSYSDIR(1);
       G__init_cint("cint");
        ...
       G__scratch_all();
     }


==========================================================================
G__value

 G__value is a type defined in $CINTSYSDIR/G__ci.h. G__value is an internal
representation of arbitrary C/C++ object value. It is also a return value
of G__calc(), G__exec_text() and argument of G__double(), G__int() API.
Do not refer directly into G__value object, but always use those API to
refer the internals.


SEE ALSO: G__calc(), G__exec_text(), G__double(), G__int()

==========================================================================
G__virtualinfo

When compiling Stub class using '-i++' option or '#pragma stub' command,
you can add G__virtualinfo as public data member. This enables you to 
inherit an interpreted class from a Stub class. For example,


// compiled code
  #include <stdio.h>
  class CompiledClass {
   public:
    void vfunc1() { printf("CompiledClass::vfunc1()\n"); }
  };
  
  void f(CompiledClass* p) {
    p->vfunc1(); // virtual function call from compiled code
  }


// stub code (compiled)
  class StubClass : public CompiledClass {
   public:
    void vfunc1();
   
    long G__virtualinfo; // add this in order to inherit an interpreted class
                         // from a Stub class
  };


// interpreted code
  void StubClass::vfunc1() { printf("StubClass::vfunc1()\n"); }
  
  class InterpretedClass : public StubClass {
   public:
    void vfunc1() { printf("InterpretedClass::vfunc1()\n"); }
  };
  
  void g() {
    CompiledClass px[3];
    px[0] = new CompiledClass;
    px[1] = new StubClass;
    px[2] = new InterpretedClass;
    for(int i=0;i<3;i++) {
      f(px[i]); // mixed interpreted/compiled virtual function resolution
    }
    for(int i=0;i<3;i++) {
      // LIMITATION, THIS DOES NOT WORK.
      px[i]->vfunc1(); // virtual function call from interpreted code
    }
  }



==========================================================================
==========================================================================
==========================================================================
INPUTMODE

 You can set default behavior of Cint command line input by setting INPUTMODE
and INPUTMODELOCK in $CINTSYSDIR/MAKEINFO. If those variables are omitted,
behavior is backward compatible.


  INPUTMODE     = [value]
      [value]
       C++      : Takes C++ statement without 'p' or '{' '}'. ';' is needed
		  at the end of every statement.
          Example:
	    cint> printf("abc\n");
            abc
	    (const int)4
	    cint> { printf("abc\n"); }
            abc
	    (const int)4
	    cint> .p printf("abc\n")
            abc
	    (const int)4
	    cint> 1+2
	    end with ';', '@':abort > +3;
	    (const int)6
	    cint> .class
	      ... display list of classes ...

       root     : Takes C++ statement without 'p' or '{' '}'. ';' can be
		  omitted for single line statement.
          Example:
	    cint> printf("abc\n")
            abc
	    (const int)4
	    cint> { printf("abc\n"); }
            abc
	    (const int)4
	    cint> .p printf("abc\n")
            abc
	    (const int)4
	    cint> 1+2
	    (const int)3
	    cint> .class
	      ... display list of classes ...

       cint     : Takes Cint command without '.'. C++ statement must be 
		  enclosed by '{' '}'.
          Example:
	    cint> { printf("abc\n"); }
            abc
	    (const int)4
	    cint> p printf("abc\n")
            abc
	    (const int)4
	    cint> p 1+2
	    (const int)3
	    cint> class
	      ... display list of classes ...

  INPUTMODELOCK = [value]
      [value]
       on       : Lock input mode. You can not change input mode by '.','..' 
       off      : You can change input mode by '.','..'


Example1:
   # Default setting, compatible to conventional cint
   INPUTMODE     = cint
   INPUTMODELOCK = off

Example2:
   # Default setting for ROOT, compatible to conventional ROOT/CINT
   INPUTMODE     = root
   INPUTMODELOCK = on

Example3:
   # Use C++ mode and the mode can not be changed
   INPUTMODE     = C++
   INPUTMODELOCK = on


SEE ALSO: $CINTSYSDIR/MAKEINFO

==========================================================================
INPUTMODELOCK

  See INPUTMODE

==========================================================================
==========================================================================
==========================================================================
makecint

 makecint is a tool that makes precompiled library for Cint. If you give
necessary information to makecint as command line option, it creates a
Makefile for compiling and linking Cint precompiled library.


SEE ALSO: doc/makecint.txt

==========================================================================
MAKEINFO

 Refer to $CINTSYSDIR/MAKEINFO

==========================================================================
==========================================================================
==========================================================================
Platform dependency file

 Platform dependency file is a file that specifies CPU and/or Operating
System dependent information. Platform dependency file is used when compiling
Cint core and copied and used as $CINTSYSDIR/MAKEINFO file. Many examples
of platform dependency files exist under $CINTSYSDIR/platform directory.


SEE ALSO: platform/README.txt

==========================================================================
Precompiled library

 Precompiled library is a native code program that is built into and 
made accessible from Cint. Normally, precompiled library is created by
makecint (or rootcint in case of ROOT framework).

 There are 2 kinds of precompiled libraries.

  - Archived Library
      Archived library is statically linked with Cint core. Only one 
     archived library can be linked to Cint at a time. Archived library
     is used less often because Dynamic Link Library is , in most cases,
     better and convenient.

  - Dynamic Link Library
      Dynamic Link Library is dynamically loaded and unloaded with Cint core.
     Multiple Dynamic Link Library can be loaded at once.


SEE ALSO: doc/makecint.txt
          demo/makecint/README.txt, demo/makecint/*/README.txt

==========================================================================
==========================================================================
==========================================================================
STUB 

 For cint/makecint, STUB means a class or function that can be used in 
compiled code and its' implementation is interpreted. Concept of STUB
is shown as below by comparison with precompiled library.


        Interpreted code                 Compiled code    
              |                                |
              |calls                           |calls
              |                                |
              V                                V
        Compiled code                    Interpretedd code
          (Precompiled library)            (STUB)


SEE ALSO: doc/makecint.txt (-i++/-i option)
          demo/makecint/Stub/README.txt, demo/makecint/Stub2/README.txt

==========================================================================
==========================================================================
==========================================================================

