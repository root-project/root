<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0">
<title>Adding a Class</title>

<sect1>
<title>The Role of TObject</title>
<para>The light-weight <emphasis role="bold"><code>TObject</code></emphasis> class provides the default behavior and protocol for the objects in the ROOT system. Specifically, it is the primary interface to classes providing object I/O, error handling, inspection, introspection, and drawing. The interface to this service is via abstract classes.</para>

<sect2>
<title>Introspection, Reflection and Run Time Type Identification</title>
<para>Introspection, which is also referred to as reflection, or run time type identification (RTTI) is the ability of a class to reflect upon itself or to "look inside itself. ROOT implements reflection with the <emphasis role="bold"><code>TClass</code></emphasis>         class. It provides all the information about a class, a full description of data members and methods, including the comment field and the method parameter types. A class with the <code>ClassDef</code> macro has the ability to obtain a <emphasis role="bold"><code>TClass</code></emphasis> with the <code>IsA</code> method.</para>

<programlisting language="c++">TClass *cl = obj-&gt;IsA();
</programlisting>

<para>It returns a <emphasis role="bold"><code>TClass</code></emphasis>. In addition, an object can directly get the class name and the base classes by:</para>

<programlisting language="c++">const char* name = obj-&gt;ClassName(); 
</programlisting>

<para>If the class is a descendent of <emphasis role="bold"><code>TObject</code></emphasis>, you can check if an object inherits from a specific class, you can use the <code>InheritsFrom</code> method. This method returns <code>kTrue</code> if the object inherits from the specified class name or <emphasis role="bold"><code>TClass</code></emphasis>.</para>

<programlisting language="c++">Bool_t b = obj-&gt;InheritsFrom("TLine");  
Bool_t b = obj-&gt;InheritsFrom(TLine::Class());  
</programlisting>

<para>ROOT and <code>CINT</code> rely on reflection and the class dictionary to identify the type of a variable at run time. With <emphasis role="bold"><code>TObject</code></emphasis> inheritance come some methods that use Introspection to help you see the data in the object or class. For instance:</para>

<programlisting language="c++">obj-&gt;Dump(); // lists all data members and <code>their current valsue</code>
obj-&gt;Inspect(); // opens a window to browse data members
obj-&gt;DrawClass(); // Draws the class inheritance tree
</programlisting>

<para>For an example of <code>obj-&gt;Inspect()</code>, see "Inspecting Objects".</para>
</sect2>

<sect2>
<title>Collections</title>
<para>To store an object in a ROOT collection, it must be a descendent of <emphasis role="bold"><code>TObject</code></emphasis>. This is convenient if you want to store objects of different classes in the same collection and execute the method of the same name on all members of the collection. For example, the list of graphics primitives are in a ROOT collection called <emphasis role="bold"><code>TList</code></emphasis>. When the canvas is drawn, the <code>Paint</code> method is executed on the entire collection. Each member may be a different class, and if the <code>Paint</code> method is not implemented, <emphasis role="bold"><code>TObject</code></emphasis><code>::Paint</code> will be executed.</para>
</sect2>

<sect2>
<title>Input/Output</title>
<para>The <emphasis role="bold"><code>TObject</code></emphasis><code>::Write</code> method is the interface to the ROOT I/O system. It streams the object into a buffer using the <code>Streamer</code> method. It supports cycle numbers and automatic schema evolution. See “Input/Output”.</para>
</sect2>

<sect2>
<title>Paint/Draw</title>
<para>These graphics methods are defaults; their implementation in <emphasis role="bold"><code>TObject</code></emphasis> does not use the graphics subsystem. The <emphasis role="bold"><code>TObject</code></emphasis><code>::Draw</code> method is simply a call to <code>AppendPad</code>. The <code>Paint</code> method is empty. The default is provided so that one can call <code>Paint</code> in a collection. The method <code>GetDrawOption</code> returns the draw option that was used when the object was drawn on the canvas. This is especially relevant with histograms and graphs.</para>
</sect2>

<sect2>
<title>Clone/DrawClone</title>
<para>Two useful methods are <code>Clone</code> and <code>DrawClone</code>. The <code>Clone</code> method takes a snapshot of the object with the <code>Streamer</code> and creates a new object. The <code>DrawClone</code> method does the same thing and in addition draws the clone. </para>
</sect2>

<sect2>
<title>Browse</title>
<para>This method is called if the object is browse-able and is to be displayed in the object browser. For example the <emphasis role="bold"><code>TTree</code></emphasis> implementation of <code>Browse</code>, calls the Browse method for each branch. The <emphasis role="bold"><code>TBranch</code></emphasis><code>::Browse</code>         method displays the name of each leaf. For the object's <code>Browse</code> method to be called, the <code>IsFolder()</code>         method must be overridden to return true. This does not mean it has to be a folder, it just means that it is browse-able.</para>
</sect2>

<sect2>
<title>SavePrimitive</title>
<para>This method is called by a canvas on its list of primitives, when the canvas is saved as a script. The purpose of <code>SavePrimitve</code> is to save a primitive as a C++ statement(s). Most ROOT classes implement the <code>SavePrimitive</code> method. It is recommended that the <code>SavePrimitive</code> is implemented in user defined classes if it is to be drawn on a canvas. Such that the command <emphasis role="bold"><code>TCanvas</code></emphasis><code>::SaveAs(Canvas.C)</code>         will preserve the user-class object in the resulting script.</para>
</sect2>

<sect2>
<title>GetObjectInfo</title>
<para>This method is called when displaying the event status in a canvas. To show the event status window, select the <code>Options</code> menu and the <code>EventStatus</code> item.  This method returns a string of information about the object at position (x, y). Every time the cursor moves, the object under the cursor executes the <code>GetObjectInfo</code> method. The string is then shown in the status bar. There is a default implementation in <emphasis role="bold"><code>TObject</code></emphasis>, but it is typically overridden for classes that can report peculiarities for different cursor positions (for example the bin contents in a TH1). </para>
</sect2>

<sect2>
<title>IsFolder</title>
<para>By default an object inheriting from <emphasis role="bold"><code>TObject</code></emphasis> is not brows-able, because <emphasis role="bold"><code>TObject</code></emphasis><code>::IsFolder()</code> returns <code>kFALSE</code>. To make a class browse-able, the <code>IsFolder</code> method needs to be overridden to return <code>kTRUE</code>. In general, this method returns <code>kTRUE</code> if the object contains browse-able objects (like containers or lists of other objects).</para>
</sect2>

<sect2>
<title>Bit Masks and Unique ID</title>
<para>A <emphasis role="bold"><code>TObject</code></emphasis> descendent inherits two data members: <code>fBits</code> and <code>fUniqueID</code>. <code>fBits </code>is 32-bit data member used with a bit mask to get object information. Bits 0 – 13 are reserved as global bits, bits 14 – 23 can be used in different class hierarchies. </para>

<programlisting language="c++">enum EObjBits {
   kCanDelete     = BIT(0),  <emphasis role="italic">//if can be deleted</emphasis>
   kMustCleanup   = BIT(3),  <emphasis role="italic">//if destructor must call 
                             // RecursiveRemove()</emphasis>
   kObjInCanvas   = BIT(3),  <emphasis role="italic">//for backward compatibility only</emphasis>
   kIsReferenced  = BIT(4),  <emphasis role="italic">//if referenced by TRef or TRefArray</emphasis>
   kHasUUID       = BIT(5),  <emphasis role="italic">//if has a TUUID, fUniqueID=UUIDNumber</emphasis>
   kCannotPick    = BIT(6),  <emphasis role="italic">//if cannot be picked in a pad</emphasis>
   kNoContextMenu = BIT(8),  <emphasis role="italic">//if does not want a context menu</emphasis>
   kInvalidObject = BIT(13)  <emphasis role="italic">//object ctor succeeded but the object
                             // should not be used</emphasis>

};
</programlisting>        
        
        
<para>For example, the bits <code>kMustCleanup</code> and <code>kCanDelete</code> are used in <emphasis role="bold"><code>TObject</code></emphasis>. See “The kCanDelete Bit” and “The kMustCleanup Bit”. They can be set by any object and should not be reused. Make sure to no overlap in any given hierarchy them. The bit 13 (<code>kInvalidObject</code>) is set when an object could not be read from a ROOT file. It will check this bit and will skip to the next object on the file. </para>
<para>
The <emphasis role="bold"><code>TObject</code></emphasis> constructor initializes the <code>fBits</code> to zero depending if the object is created on the stack or
allocated on the heap. When the object is created on the stack, the <code>kCanDelete</code> bit is set to false to protect from deleting objects on the stack. The
high 8 bits are reserved for the system usage; the low 24 bits are user settable. <code>fUniqueID</code> is a data member used to give a unique identification number to an object.
It is initialized to zero by the <emphasis role="bold"><code>TObject</code></emphasis> constructor. ROOT does not use this data member.
The two data members (<code>fBits</code> and <code>fUniqueID</code>) are streamed out when writing an object to disk. If you do not use them, you can save some space
and time by specifying:
</para>

<programlisting language="c++">MyClass::Class()-&gt;IgnoreTObjectStreamer();
</programlisting>

<para>This sets a bit in the <emphasis role="bold"><code>TClass</code></emphasis> object. If the file is compressed, the savings are minimal since most values are zero; however, it saves some space when the file is not compressed. A call to<code> IgnoreTObjectStreamer</code> also prevents the creation of two additional branches when splitting the object. If left alone, two branches called <code>fBits</code> and <code>fUniqueID</code> will appear.</para>
</sect2>
</sect1>

<sect1>
<title>Motivation</title>
<para>If you want to integrate and use your classes with ROOT, to enjoy features like, extensive RTTI (Run Time Type Information) and ROOT object I/O and inspection, you have to add the following line to your class header files:  </para>

<programlisting language="c++">ClassDef(ClassName,ClassVersionID);  <emphasis role="italic">//The class title</emphasis>
</programlisting>

<para>For example in <code>TLine.h</code> we have:</para>

<programlisting language="c++">ClassDef(TLine,1);                   <emphasis role="italic">//A line segment</emphasis>
</programlisting>

<para>The <emphasis role="bold"><code>ClassVersionID</code></emphasis> is used by the ROOT I/O system. It is written on the output stream and during reading you can check this version ID and take appropriate action depending on the value of the ID. See “Streamers”. Every time you change the data members of a class, you should increase its <code>ClassVersionID</code> by one. The <code>ClassVersionID</code> should be <code>&gt;=1</code>. Set <code>ClassVersionID=0</code> in case you don't need object I/O. To be able to generate properly documentation for your classes using <emphasis role="bold"><code>THtml</code></emphasis> you must add the statement:</para>

<programlisting language="c++">
ClassImp(ClassName)
</programlisting>

<para>For example in <code>TLine</code><code>.cxx</code>:</para>

<programlisting language="c++">ClassImp(TLine)
</programlisting>

<para>Note that you should provide a default constructor for your classes, i.e. a constructor with zero parameters or with one or more parameters all with default values in case you want to use object I/O. If do not provide such a default contructor, you MUST implement an I/O constructor. If not you will get a compile time error. See the “The Default Constructor” paragraph in this chapter.  The <code>ClassDef</code> and <code>ClassImp</code> macros are defined in the file <code>Rtypes.h</code>. This file is referenced by all ROOT include files, so you will automatically get them if you use a ROOT include file.</para>

<sect2>
<title>Template Support</title>
<para>In ROOT version 3.03 and older, ROOT provided special <code>ClassDef</code> and <code>ClassImp</code> macros for classes with two and three template arguments. In ROOT version 3.04 and above, the macros <code>ClassDef</code> and <code>ClassImp</code> can be used directly even for a class template. <code>ClassImp</code> is used to register an implementation file in a class. For class templates, the <code>ClassImp</code> can only be used for a specific class template instance. </para>

<programlisting language="c++">ClassImp(MyClass1&lt;double&gt;);
</programlisting>

<para>For multiple template arguments, you will need to use an intermediary <code>typedef</code>:</para>

<programlisting language="c++">typedef MyClass2&lt;int,float&gt; myc_i_f;
ClassImp(myc_i_f);
</programlisting>

<para>You can also register an implementation for all instances of a class template by using <code>templateClassImp</code>:</para>

<programlisting language="c++">templateClassImp(MyClass3);
</programlisting>

<para>Here are examples of a header and a <code>LinkDef</code> file:</para>

<programlisting language="c++">// in header file MyClass.h
template &lt;typename T&gt; class MyClass1 {
private:
      T  fA;
      ...
public:
      ...
      ClassDef(MyClass1,1)
};
template &lt;typename T1, typename T2&gt; class MyClass2 {
private:
      T1  fA;
      T2  fB;
public:
      ...
      ClassDef(MyClass2,1)
};
template &lt;typename T1, typename T2, typename T3&gt; class MyClass3 {
private:
      T1  fA;
      T2  fB;
      T3  fC;
      ...
public:
      ...
      ClassDef(MyClass3,1)
};
</programlisting>


<programlisting language="c++">// A LinkDef.h file with all the explicit template instances
// that will be needed at link time
#ifdef __CINT__

#pragma link C++ class MyClass1&lt;float&gt;+;
#pragma link C++ class MyClass1&lt;double&gt;+;
#pragma link C++ class MyClass2&lt;float,int&gt;+;
#pragma link C++ class MyClass2&lt;float,double&gt;+;
#pragma link C++ class MyClass3&lt;float,int,TObject*&gt;+;
#pragma link C++ class MyClass3&lt;float,TEvent*,TObject*&gt;+;

#endif
</programlisting>

</sect2>
</sect1>

<sect1>
<title>The Default Constructor</title>
<para>ROOT object I/O requires every class to have either a default constructor or an I/O constructor. A default constructor is a constructor with zero parameters or with one or more parameters all with default values.  An I/O constructor is a constructor with exactly one parameter which type is a pointer to one of the type marked as an 'io constructor type'.  We will come back to this context in a few paragraphs. This default or I/O constructor is called whenever an object is being read from a ROOT database. Be sure that you do not allocate any space for embedded pointer objects in this constructor. This space will be lost (memory leak) while reading in the object. For example:</para>

<programlisting language="c++">class T49Event : public TObject {
private:
Int_t        fId;
TCollection *fTracks;
...
public:
<emphasis role="italic"><code>   // Error space for TList pointer will be lost</code></emphasis>
T49Event() { fId = 0; fTrack = new TList; }
<emphasis role="italic"><code>   // Correct default initialization of pointer</code></emphasis>
T49Event() { fId = 0; fTrack = 0; }
...
};
</programlisting>

<para>The memory will be lost because during reading of the object the pointer will be set to the object it was pointing to at the time the object was written. Create the <code>fTrack</code> list when you need it, e.g. when you start filling the list or in a <emphasis role="bold">not-default</emphasis> constructor.</para>

<programlisting language="c++">...
if (!fTrack) fTrack = new TList;
...
</programlisting>

<para>The constructor actually called by the ROOT I/O can be customized by using the rootcint pragma:</para>

<programlisting language="c++">#pragma link C++ ioctortype UserClass;
</programlisting>

<para>For example, with this pragma and a class named MyClass, the ROOT I/O will call the first of the following 3 constructors which exists and is public:</para>

<programlisting language="c++">MyClass(UserClass*);MyClass(TRootIOCtor*);
MyClass();    <emphasis role="italic"><code>// Or a constructor with all its arguments defaulted.</code></emphasis>
</programlisting>

<para>When more than one pragma ioctortype is used, the first seen as priority. For example with:</para>

<programlisting language="c++">#pragma link C++ ioctortype UserClass1;
#pragma link C++ ioctortype UserClass2;
</programlisting>

<para>We look for the first existing public constructor in the following order:</para>

<programlisting language="c++">MyClass(UserClass1*);
MyClass(UserClass2*);
MyClass(TRootIoCtor*);
MyClass();   <emphasis role="italic"><code>// Or a constructor with all its arguments defaulted.</code></emphasis>
</programlisting>

</sect1>

<sect1>
<title>rootcint: The CINT Dictionary Generator</title>
<para>In the following example, we walk through the steps necessary to generate a dictionary, I/O, and inspect member functions. Let's start with a <emphasis role="bold"><code>TEvent</code></emphasis> class, which contains a collection of <emphasis role="bold"><code>TTracks</code></emphasis>.</para>
<para/>
<para>The <code>TEvent.h</code> header is:</para>

<programlisting language="c++">#ifndef __TEvent__
#define __TEvent__
#include "TObject.h"
class TCollection;
class TTrack;

class TEvent : public TObject {
private:
Int_t        fId;          // event sequential id
Float_t      fTotalMom;    // total momentum
TCollection *fTracks;      // collection of tracks
public:
TEvent() { fId = 0; fTracks = 0; }
TEvent(Int_t id);
~TEvent();
void    AddTrack(TTrack *t);
Int_t   GetId() const { return fId; }
Int_t   GetNoTracks() const;
void    Print(Option_t *opt="");
Float_t TotalMomentum();

ClassDef(TEvent,1);  <code>//Simple event class</code>
};
</programlisting>

<para>The things to notice in these header files are:</para>
<itemizedlist>
<listitem><para>The usage of the <code>ClassDef</code> macro</para></listitem>
<listitem><para>The default constructors of the <emphasis role="bold"><code>TEvent</code></emphasis> and <emphasis role="bold"><code>TTrack</code></emphasis> classes</para></listitem>
<listitem><para>Comments to describe the data members and the comment after the <code>ClassDef</code> macro to describe the class</para></listitem>
</itemizedlist>
<para>These classes are intended for you to create an event object with a certain id, and then add tracks to it. The track objects have a pointer to their event. This shows that the I/O system correctly handles circular references.</para>
<para>The <code>TTrack.h</code> header is:</para>

<programlisting language="c++">#ifndef __TTrack__
#define __TTrack__
#include "TObject.h"

class TEvent;
class TTrack : public TObject {
private:
Int_t    fId;       <code>//track sequential id</code>
TEvent  *fEvent;    <code>//event to which track belongs</code>
Float_t  fPx;       <code>//x part of track momentum</code>
Float_t  fPy;       <code>//y part of track momentum</code>
Float_t  fPz;       <code>//z part of track momentum</code>
public:
 TTrack() { fId = 0; fEvent = 0; fPx = fPy = fPz = 0; }
TTrack(Int_t id, Event *ev, Float_t px,Float_t py,Float_t pz);
Float_t  Momentum() const;
TEvent  *GetEvent() const { return fEvent; }
void     Print(Option_t *opt="");

<code>   ClassDef (TTrack,1); </code><emphasis role="italic"><code> //Simple track class</code></emphasis>
};

#endif
</programlisting>

<para>Next is the implementation of these two classes. </para>
<para><code>TEvent.cxx</code>:</para>

<programlisting language="c++">#include &lt;iostream.h&gt;

#include "TOrdCollection.h"
#include "TEvent.h"
#include "TTrack.h"

ClassImp(TEvent)

...
</programlisting>

<para/>
<para><code>TTrack.cxx:</code></para>

<programlisting language="c++">#include &lt;iostream.h&gt;

#include "TMath.h"
#include "Track.h"
#include "Event.h"

ClassImp(TTrack)
...
</programlisting>

<para>Now using <code>rootcint</code> we can generate the dictionary file. </para>
<para>Make sure you use a unique filename, because <code>rootcint</code> appends it to the name of static function <code>(G__cpp_reset_tabableeventdict()</code> and<code> G__set_cpp_environmenteventdict ()</code>).</para>

<programlisting language="c++">rootcint eventdict.cxx -c TEvent.h TTrack.h
</programlisting>

<para>Looking in the file <code>eventdict.cxx</code> we can see, besides the many member function calling stubs (used internally by the interpreter), the<code> Streamer()</code> and<code> ShowMembers() </code>methods for the two classes. <code>Streamer()</code> is used to stream an object to/from a <emphasis role="bold"><code>TBuffer</code></emphasis> and <code>ShowMembers()</code> is used by the <code>Dump()</code> and <code>Inspect()</code> methods of <emphasis role="bold"><code>TObject</code></emphasis>. Here is the <code>TEvent::Streamer</code> method:</para>

<programlisting language="c++">void TEvent::Streamer(TBuffer &amp;R__b) {
   // Stream an object of class TEvent.
if (R__b.IsReading()) {
Version_t R__v = R__b.ReadVersion();
TObject::(R__b);
R__b &gt;&gt; fId;
R__b &gt;&gt; fTotalMom;
R__b &gt;&gt; fTracks;
} else {
R__b<emphasis role="bold">.</emphasis>WriteVersion(TEvent::IsA());
TObject::Streamer(R__b);
R__b &lt;&lt; fId;
R__b &lt;&lt; fTotalMom;
R__b &lt;&lt; fTracks;
}
}
</programlisting>

<para>The <emphasis role="bold"><code>TBuffer</code></emphasis> class overloads the <code>operator&lt;&lt;()</code> and <code>operator&gt;&gt;()</code> for all basic types and for pointers to objects. These operators write and read from the buffer and take care of any needed byte swapping to make the buffer machine independent. During writing, the <emphasis role="bold"><code>TBuffer</code></emphasis> keeps track of the objects that have been written and multiple references to the same object are replaced by an index. In addition, the object's class information is stored. <emphasis role="bold"><code>TEvent</code></emphasis> and <emphasis role="bold"><code>TTracks</code></emphasis> need manual intervention. Cut and paste the generated <code>Streamer()</code> from the <code>eventdict.cxx</code> into the class' source file and modify as needed (e.g. add counter for array of basic types) and disable the generation of the <code>Streamer()</code> when using the <code>LinkDef.h</code> file for next execution of <code>rootcint</code>. In case you do not want to read or write this class (no I/O) you can tell <code>rootcint</code> to generate a dummy <code>Streamer() </code>by changing this line in the source file:  </para>

<programlisting language="c++">ClassDef(TEvent,0);
</programlisting>

<para>If you want to prevent the generation of<code> Streamer()</code>, see the chapter "Adding a Class with a Shared Library". </para>

<sect2>
<title>Dictionaries for STL</title>
<para>Usually, headers are passed to rootcint at the command line. To generate a dictionary for a class from the STL, e.g.</para>
<para><emphasis role="bold">std::vector&lt;MyClass&gt;</emphasis>, you would normally pass the header defining <emphasis role="bold">MyClass</emphasis> and <emphasis role="bold">std::vector</emphasis>. The latter is a compiler specific header and cannot be passed to rootcint directly. Instead, create a little header file that includes both headers, and pass that to rootcint.</para>
<para/>
<para>Often ROOT knows where <emphasis role="bold">MyClass</emphasis> and the templated class (e.g. vector) are defined, for example because the files got <emphasis role="bold">#included</emphasis>. Knowing these header files ROOT can automatically generate the dictionary for any template combination (e.g. <emphasis role="bold">vector&lt;myClass&gt;</emphasis>) when it is needed, by generating files starting with <emphasis role="bold">AutoDict*</emphasis>. You can toggle this feature on or off at the ROOT prompt by executing <emphasis role="bold">.autodict</emphasis>.</para>
<para/>
</sect2>
</sect1>

<sect1>
<title>Adding a Class with a Shared Library</title>
<para><emphasis role="bold">Step 1: </emphasis>Define your own class in <code>SClass.h</code> and implement it in <code>SClass.cxx</code>. You must provide a default constructor or an I/O constructor for your class.  See the "The Default Constructor" paragraph in this chapter. </para>

<programlisting language="c++">#include &lt;iostream.h&gt;
#include "TObject.h"
class SClass : public TObject {
private:
Float_t   fX;         <code>//x position in centimeters</code>
Float_t   fY;         <code>//y position in centimeters</code>
Int_t     fTempValue; <code>//! temporary state value</code>
public:
SClass()             { fX = fY = -1; }
void Print() const;
void SetX(float x) { fX = x; }
void SetY(float y) { fY = y; }

ClassDef(SClass, 1)
};
</programlisting>

<para><emphasis role="bold">Step 2: </emphasis>Add a call to the <code>ClassDef</code> macro to at the end of the class definition (in the <code>SClass.h</code> file). <code>ClassDef(SClass,1)</code>. Add a call to the <code>ClassImp</code> macro in the implementation file (<code>SClass.cxx</code>): <code>ClassImp(SClass)</code>. </para>

<programlisting language="c++"><emphasis role="italic">// SClass.cxx:</emphasis>
#include "SClass.h"
ClassImp(SClass);
void SClass::Print() const {
cout &lt;&lt; "fX = " &lt;&lt; fX &lt;&lt; ", fY = " &lt;&lt; fY &lt;&lt; endl;
}
</programlisting>

<para>You can add a class without using the <code>ClassDef</code> and <code>ClassImp</code> macros; however, you will be limited. Specifically the object I/O features of ROOT will not be available to you for these classes. See "CINT the C++ Interpreter". The <code>ShowMembers</code> and <code>Streamer</code> method, as well as the <code>&gt;&gt;</code> operator overloads, are implemented only if you use <code>ClassDef</code> and <code>ClassImp</code>. See <code>$ROOTSYS/include/Rtypes.h</code> for the definition of <code>ClassDef</code> and <code>ClassImp</code>. To exclude a data member from the <code>Streamer</code>, add a <code>!</code> as the first character in the comments of the field:</para>

<programlisting language="c++">Int_t     fTempValue; //! temporary state value
</programlisting>

<sect2>
<title>The LinkDef.h File</title>
<para><emphasis role="bold">Step 3: </emphasis>The <code>LinkDef.h</code> file tells <code>rootcint</code> for which classes to generate the method interface stubs.</para>

<programlisting language="c++">#ifdef __CINT__
#pragma link C++ class SClass;
#endif
</programlisting>

<para>Three options can trail the class name:</para>
<itemizedlist>
<listitem><para><code>-</code>  : tells <code>rootcint</code> <emphasis role="bold">not</emphasis> to generate the <code>Streamer</code> method for this class. This is necessary for those classes that need a customized <code>Streamer</code> method. </para></listitem>
</itemizedlist>
<programlisting language="c++">#pragma link C++ class SClass-;<emphasis role="italic">  // no streamer</emphasis>
</programlisting>
<itemizedlist>
<listitem><para><emphasis role="bold"><code>!</code></emphasis>  : tells <code>rootcint</code> <emphasis role="bold">not</emphasis> to generate the <code>operator&gt;&gt;(</code><emphasis role="bold"><code>TBuffer</code></emphasis>         <code>&amp;b,MyClass *&amp;obj)</code> method for this class. This is necessary to be able to write pointers to objects of classes not inheriting from <emphasis role="bold"><code>TObject</code></emphasis>.</para></listitem>
</itemizedlist>
<programlisting language="c++">#pragma link C++ class SClass!;      <emphasis role="italic">// no &gt;&gt; operator</emphasis>
<emphasis role="italic">// or</emphasis>
#pragma link C++ class SClass-!; // no streamer, no &gt;&gt; <code>operator</code>
</programlisting>
<itemizedlist>
<listitem><para><emphasis role="bold">+</emphasis> : in ROOT version 1 and 2 tells <code>rootcint</code> to generate a <code>Streamer</code> with extra byte count information. This adds an integer to each object in the output buffer, but it allows for powerful error correction in case a <code>Streamer</code> method is out of sync with data in the file. The <code>+</code> option is mutual exclusive with both the <code>-</code> and <code>!</code> options. </para></listitem>
</itemizedlist>
<para>IMPORTANT NOTE: In ROOT Version 3, a "+" after the class name tells <code>rootcint</code> to use the new I/O system. The byte count check is always added.</para>

<programlisting language="c++">#pragma link C++ class SClass+; // add byte count
</programlisting>

<para>For information on <code>Streamers</code> see “Input/Output”. To get help on <code>rootcint</code> type on the UNIX command line:
<emphasis role="bold"><code>rootcint -h</code></emphasis> </para>

<sect3>
<title>The Order Matters</title>
<para>When using template classes, the order of the pragma statements matters. For example, here is a template class <code>Tmpl</code> and a normal class <code>Norm</code>, which holds a specialized instance of a <code>Tmpl</code>:</para>

<programlisting language="c++">class Norm {
private:
  Tmpl&lt;int&gt;* fIntTmpl;
public:
  ...
};
</programlisting>

<para>Then in <code>Linkdef.h,</code> the pragma statements must be ordered by listing all specializations before any classes that need them:</para>

<programlisting language="c++">// Correct Linkdef.h ordering
...
#pragma link C++ class Tmpl&lt;int&gt;;
#pragma link C++ class Norm; 
...
</programlisting>

<para>And not vice versa:</para>

<programlisting language="c++">// Bad Linkdef.h ordering
...
#pragma link C++ class Norm;
#pragma link C++ class Tmpl&lt;int&gt;;
...
</programlisting>

<para>In this case, <code>rootcint</code> generates <code>Norm::Streamer()</code> that makes reference to <code>Tmpl&lt;int&gt;::Streamer()</code>. Then <code>rootcint</code> gets to process <code>Tmpl&lt;int&gt;</code> and generates a specialized <code>Tmpl&lt;int&gt;::Streamer()</code> function. The problem is, when the compiler finds the first <code>Tmpl&lt;int&gt;::Streamer()</code>, it will instantiate it. However, later in the file it finds the specialized version that <code>rootcint</code> generated. This causes the error. However, if the <code>Linkdef.h</code> order is reversed then <code>rootcint</code> can generate the specialized <code>Tmpl&lt;int&gt;::Streamer()</code> before it is needed (and thus never instantiated by the compiler).</para>
</sect3>

<sect3>
<title>Other Useful Pragma Statements</title>
<para>The complete list of pragma statements currently supported by CINT is:</para>

<programlisting language="c++">#pragma link [C|C++|off] all [class|function|global|typedef];
#pragma link [C|C++|off] 
   [class|struct|union|enum|namespace|protected][name];
#pragma link [C|C++|off] [global|typedef][name];
#pragma link [C|C++|off] [nestedclass|nestedtypedef];

#pragma link [C++|C|off|MACRO] function [name]&lt;(argtypes)&gt;;
#pragma link 
   [C++|C|off|MACRO] function [classname]::[name]&lt;(argtypes)&gt;;
#pragma link off all methods;
#pragma link [C|C++|off] defined_in [filename];
#pragma link 
   [C|C++|off] defined_in [class|struct|namespace] [name];
#pragma link [C|C++|off] all_function   [classname];
#pragma link [C|C++|off] all_datamember [classname];
</programlisting>

<para>The <code>[classname]</code> and the <code>[name]</code> can also contain wildcards.  For example:</para>

<programlisting language="c++">#pragma link C++ class MyClass*;
</programlisting>

<para>This will request the dictionary for all the class whose name start with <code>'MyClass'</code> and are already known to CINT (class templates need to have already been instantiated to be considered).</para>

<programlisting language="c++">#pragma link [C|C++|off] all [class|function|global|typedef];
</programlisting>

<para>This pragma statement turns on or off the dictionary generation for all classes, structures, namespaces, global variables, global functions and typedefs seen so far by CINT. Example:</para>

<programlisting language="c++"><emphasis role="italic">// some C++ header definition</emphasis>
#ifdef __MAKECINT__
<emphasis role="italic">// turns off dictionary generation for all</emphasis>
#pragma link off all class;
#pragma link off all function;
#pragma link off all global;
#pragma link off all typedef;
#endif
</programlisting>

<para>The next pragma statement selectively turns on or off the dictionary generation for the specified <code>classs</code>, <code>struct</code>, <code>union</code>, <code>enum</code> or <code>namespace</code>:</para>

<programlisting language="c++">#pragma link 
[C|C++|off][class|class+protected|
struct|union|enum|namespace][name];
</programlisting>

<para>The Dictionary of all public members of class and struct will be generated. If the '<code>class+protected</code>' flag is used, the dictionary for protected members will also be generated. However, dictionary for protected constructor and destructor will not be generated. This '         <code>class+protected</code> ' flag will help you only for plain protected member access, but not for virtual function resolution. </para>
<para>If you use the '<code>namespace</code>' flag, it is recommended to add also:</para>

<programlisting language="c++">#pragma link nestedclass;
#pragma link nestedtypedef;
</programlisting>

<para>The behavior of '<code>class</code>', '<code>struct</code>' and '<code>namespace</code>' flag are identical. Example:</para>

<programlisting language="c++"><emphasis role="italic">// some C++ header definition</emphasis>
#ifdef __MAKECINT__
#pragma link off all class;
#pragma link C++ class A;
#pragma link C++ class B;
#pragma link C++ class C&lt;int&gt;;
#pragma link C++ class+protected D;
#pragma link C++ namespace project1;
#pragma link C++ nestedclass;
#pragma link C++ nestedtypedef;
#endif
</programlisting>

<para>The next pragma statement selectively turns on or off the dictionary generation for global variables and typedef.</para>

<programlisting language="c++">#pragma link [C|C++|off] [global|typedef] [name];
</programlisting>

<para>Example:</para>

<programlisting language="c++"><emphasis role="italic"><code>// some C/C++ header definition</code></emphasis>
#ifdef __MAKECINT__
#pragma link off all global;
#pragma link off all typedef;
#pragma link C++ global a;
#pragma link C++ typedef Int_t;
#endif
</programlisting>

<para>This pragma statement turns on the dictionary generation for nested classes and nested typedefs.</para>

<programlisting language="c++">#pragma link [C|C++|off] [nestedclass|nestedtypedef];
</programlisting>

<para>Example: </para>

<programlisting language="c++"><emphasis role="italic">// some C/C++ header definition</emphasis>
#ifdef __MAKECINT__
#pragma link off all global;
#pragma link off all typedef;
#pragma link C++ global a;
#pragma link C++ typedef Int_t;
#endif
</programlisting>

<para>The next pragma statements turn on or off the dictionary generation for the specified function(s) or member function(s). The list of arguments' type is optional. If you omit argument types, all function with specified [<code>name</code>] will be affected.  If the list of arguments' type is specified, only the function that has exactly same argument list will be affected.</para>

<programlisting language="c++">#pragma link [C++|C|off|MACRO] function [fname]&lt;(argtypes)&gt;;
#pragma link 
[C++|C|off|MACRO] function [classname]::[fname]&lt;(argtypes)&gt;;
</programlisting>

<para>The '<code>#pragma link [C++|C] function</code>' and '<code>#pragma link MACRO function</code>' behaves similarly. The '<code>#pragma link [C++|C] function</code>' assumes the target to be a real function which has pointer to it.  A pointer to registered function is registered. On the other hand, '<code>#pragma link MACRO function</code>' assumes target to be macro function.  Pointer to function cannot be referenced in this case.</para>
<para>For the next example:</para>

<programlisting language="c++">void f(int a);
void f(double a);
int g(int a,double b);
int g(double x);
#define max(a,b) (a&gt;b?a:b)

class A {
public:
int h(double y);
int h(int a,double b);
};
</programlisting>

<para>The pragma statements are:</para>

<programlisting language="c++">#ifdef __MAKECINT__
#pragma link off all functions;
#pragma link C++ function f;
#pragma link C++ function g(int,double);
#pragma link C++ MACRO max;
#pragma link C++ class A;
#pragma link off function A::h(double);
#endif
</programlisting>

<para>Until CINT version 5.15.60, in order to generate dictionary for a member function, not only the member function but also the class itself has to be turned on for the linkage. There was an inconvenience when generating dictionary for template member function afterwards.</para>
<para>From CINT v.5.15.61, a new behavior is introduced. If link for a member function is specified, dictionary is generated even if link to the belonging class is off. For example, if you originally have A.h as follows: </para>

<programlisting language="c++"><emphasis role="italic">// A.h</emphasis>
template&lt;class T&gt; class A {

public:
template&lt;class E&gt; void f(E&amp; x) { ... }
};
</programlisting>

<para>  And generate dictionary for that: </para>

<programlisting language="c++">#ifdef __MAKECINT__
#pragma link C++ class A&lt;int&gt;;
#endif
</programlisting>

<para>Then prepare another header file and instantiate the template member function of A.:</para>

<programlisting language="c++"><emphasis role="italic">// B.h</emphasis>
#include "A.h"

class B {
...
};
</programlisting>

<para> You can generate dictionary for the newly instantiated template member function only.</para>

<programlisting language="c++">#ifdef __MAKECINT__
#pragma link off defined_in A.h;
#pragma link C++ function A&lt;int&gt;::f(B&amp;);
#endif
</programlisting>

<para>The next pragma turns off the dictionary generation of all the member functions in all classes.</para>

<programlisting language="c++">#pragma link off all methods;
</programlisting>

<para>Example:</para>

<programlisting language="c++">#ifdef __MAKECINT__
#pragma link off all methods;
#endif
</programlisting>

<para>The next pragma statements control the linking of all the member functions or data members for a specified class.</para>

<programlisting language="c++">#pragma link [C|C++|off] all_function   [classname];
#pragma link [C|C++|off] all_datamember [classname];
</programlisting>

<para>At this moment, there should be no needs to use those statements. Example:</para>

<programlisting language="c++">#ifdef __MAKECINT__
#pragma link off all_function   A;
#pragma link off all_datamember A;
#endif
</programlisting>

<para>See also: <code>#pragma link function</code>.</para>
<para>The next pragma statement turns on/off dictionary generation of the object defined in specific file. The filename has to be the full pathname of the file. </para>

<programlisting language="c++">#pragma link [C|C++|off] defined_in [filename];
</programlisting>

<para>Example:</para>

<programlisting language="c++"><emphasis role="italic">// file1.h</emphasis>
<emphasis role="italic">// any C++ header definition</emphasis>

<emphasis role="italic">// file2.h</emphasis>

#ifdef __MAKECINT__
#pragma link off all classes;
#pragma link off all functions;
#pragma link off all globals;

#pragma link off all typedef;
#pragma link C++ defined_in file1.h;
#endif
</programlisting>

<para>The next pragma statements turn on or off the dictionary generation of the object defined in a specific scope. The [<code>scope_name</code>] should be <code>class</code> name, <code>struct</code> name or <code>namespace</code> name. When using these pragmas, it is recommended to use also:</para>

<programlisting language="c++">#pragma link C++ nestedclass
</programlisting>

<para>Otherwise, definitions in enclosed scope do not appear in the dictionary.</para>

<programlisting language="c++">#pragma link [C|C++|off] defined_in [scope_name];
#pragma link [C|C++|off] defined_in 
[class|struct|namespace] [scope_name];
</programlisting>

<para>Example:  </para>

<programlisting language="c++">namespace ns {
int a;
double b;
};
</programlisting>

<para>The pragma statements are:</para>

<programlisting language="c++">#ifdef __MAKECINT__
#pragma link C++ defined_in ns;
#pragma link C++ nestedclass;
#endif
</programlisting>

<para>This statements controls default link mode for <code>makecint(cint -c-1|-c-2)</code> and <code>rootcint</code>.</para>

<programlisting language="c++">#pragma link default [on|off]
</programlisting>

<para>By turning default 'on', all language constructs in given header files will be included in generated CINT dictionary (interface method source file). If default is set to 'off', nothing will be included in the generated dictionary. The next statement explicitly set linkage to each item:</para>

<programlisting language="c++">#pragma link [C|C++|off] [class|function|global]
</programlisting>

<para>This pragma statement must be given before <code>cint/rootcint</code> reads any C/C++ definitions from header files. For pure CINT, default is on. For ROOT, including <code>$ROOTSYSDIR/bin/cint</code>, default is off. This feature was added from CINT v.5.15.57. Before this version, you had to use explicitly in the ROOT <code>LinkDef.h</code> file the next statement:</para>

<programlisting language="c++">#pragma link off [class|function|global];
</programlisting>

<para>From 5.15.57, you can omit them. Example:  </para>

<programlisting language="c++">#ifdef __MAKECINT__
#pragma link default off;
#endif

class A {
int a;
double b;
};

class B {
int d;
double e;
};

#ifdef __MAKECINT__
#pragma link C++ class A;      <emphasis role="italic"><code>// only class A is linked, not B</code></emphasis>
#endif
</programlisting>

</sect3>

<sect3>
<title>Compilation</title>
<para><emphasis role="bold">Step 4:</emphasis> Compile the class using the <code>Makefile. </code>In the <code>Makefile</code> call <code>rootcint</code> to make the dictionary for the class. Call it <code>SClassDict.cxx</code>. The <code>rootcint</code> utility generates the methods <code>Streamer</code>, <emphasis role="bold"><code>TBuffer</code></emphasis> &amp;operator&gt;&gt;() and <code>ShowMembers </code>for ROOT classes. </para>

<programlisting language="c++">gmake –f Makefile
</programlisting>

<para>Load the shared library:</para>

<programlisting language="c++">root[] <emphasis role="bold">.L SClass.so</emphasis>
root[] <emphasis role="bold">SClass *sc = new SClass()</emphasis>
root[] <emphasis role="bold">TFile *f = new TFile("Afile.root","UPDATE");</emphasis>
root[] <emphasis role="bold">sc-&gt;Write();</emphasis>
</programlisting>

<para>For more information on <code>rootcint</code> see the <code>$ROOTSYS/test</code> directory <code>Makefile</code>, <code>Event.cxx</code>, and <code>Event.h</code> for an example, or follow this link:  <uri xmlns:xlink="http://root.cern.ch/root/RootCintMan.html">http://root.cern.ch/root/RootCintMan.html</uri></para>
</sect3>
</sect2>
</sect1>

<sect1>
<title>Adding a Class with ACLiC</title>
<para><emphasis role="bold">Step 1:</emphasis> Define your class</para>

<programlisting language="c++">#include "TObject.h"

// define the ABC class and make it inherit from TObject so that 
// we can write ABC to a ROOT file
class ABC : public TObject {

public:
Float_t a, b, c, p;
ABC() : a(0), b(0), c(0), p(0){};

// Define the class for the cint dictionary
ClassDef (ABC,1)
};

// Call the ClassImp macro to give the ABC class RTTI and 
// full I/O capabilities.

#if !defined(__CINT__)
ClassImp(ABC);
#endif
</programlisting>

<para/>
<para/>

<para><emphasis role="bold">Step 2:</emphasis> Load the ABC class in the script.</para>

<programlisting language="c++">// Check if ABC is already loaded
if (!TClass::GetDict("ABC")) {
gROOT-&gt;ProcessLine(".L ABCClass.C++");
}

// Use the Class
ABC *v = new ABC;
v-&gt;p = (sqrt((v-&gt;a * v-&gt;a)+ (v-&gt;b * v-&gt;b)+(v-&gt;c * v-&gt;c)));
</programlisting>

</sect1>
</chapter>



