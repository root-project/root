<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0">
<title>Trees</title>

<sect1>
<title>Why Should You Use a Tree?</title>
<para>In the “Input/Output” chapter, we saw how objects can be saved in ROOT files. In case you want to store large quantities of same-class objects, ROOT has designed the <emphasis role="bold"><code>TTree</code></emphasis> and <emphasis role="bold"><code>TNtuple</code></emphasis> classes specifically for that purpose. The <emphasis role="bold"><code>TTree</code></emphasis> class is optimized to reduce disk space and enhance access speed. A <emphasis role="bold"><code>TNtuple</code></emphasis> is a <emphasis role="bold"><code>TTree</code></emphasis> that is limited to only hold floating-point numbers; a <emphasis role="bold"><code>TTree</code></emphasis> on the other hand can hold all kind of data, such as objects or arrays in addition to all the simple types.</para>
<para>When using a <emphasis role="bold"><code>TTree</code></emphasis>, we fill its branch buffers with leaf data and the buffers are written to disk when it is full. Branches, buffers, and leafs, are explained a little later in this chapter, but for now, it is important to realize that each object is not written individually, but rather collected and written a bunch at a time.</para>
<para>This is where the <emphasis role="bold"><code>TTree</code></emphasis> takes advantage of compression and will produce a much smaller file than if the objects were written individually. Since the unit to be compressed is a buffer, and the <emphasis role="bold"><code>TTree</code></emphasis> contains many same-class objects, the header of the objects can be compressed. </para>
<para>The <emphasis role="bold"><code>TTree</code></emphasis> reduces the header of each object, but it still contains the class name. Using compression, the class name of each same-class object has a good chance of being compressed, since the compression algorithm recognizes the bit pattern representing the class name. Using a <emphasis role="bold"><code>TTree</code></emphasis> and compression the header is reduced to about 4 bytes compared to the original 60 bytes. However, if compression is turned off, you will not see these large savings.</para>
<para>The <emphasis role="bold"><code>TTree</code></emphasis> is also used to optimize the data access. A tree uses a hierarchy of branches, and each branch can be read independently from any other branch. Now, assume that <code>Px</code> and <code>Py</code> are data members of the event, and we would like to compute <code>Px</code><code>2</code><code> + Py</code><code>2</code> for every event and histogram the result. </para>
<para>If we had saved the million events without a <emphasis role="bold"><code>TTree</code></emphasis> we would have to: </para>
<itemizedlist>
<listitem><para>read each event in its entirety into memory</para></listitem>
<listitem><para>extract the <code>Px</code> and <code>Py</code> from the event </para></listitem>
<listitem><para>compute the sum of the squares </para></listitem>
<listitem><para>fill a histogram </para></listitem>
</itemizedlist>
<para>We would have to do that a million times! This is very time consuming, and we really do not need to read the entire event, every time. All we need are two little data members (<code>Px</code> and <code>Py</code>). On the other hand, if we use a tree with one branch containing <code>Px</code> and another branch containing <code>Py</code>, we can read all values of <code>Px</code> and <code>Py</code> by only reading the <code>Px</code> and <code>Py</code> branches. This makes the use of the <emphasis role="bold"><code>TTree</code></emphasis> very attractive.</para>
</sect1>

<sect1>
<title>A Simple TTree</title>
<para>This script builds a <emphasis role="bold"><code>TTree</code></emphasis>         from an ASCII file containing statistics about the staff at CERN. This script, <code>staff.C</code> and its input file <code>staff.dat</code> are in <code>$ROOTSYS/tutorials/tree</code>.</para>

<programlisting language="c++">{
<emphasis role="italic"><code>// example of macro to read data from an ascii file and</code></emphasis>
<emphasis role="italic"><code>// create a root file with an histogram and a TTree</code></emphasis>
<code>   gROOT-&gt;Reset();</code>

<code>// the structure to hold the variables for the branch</code>

<code>  struct staff_t {</code>
<code>                Int_t cat;</code>
<code>                Int_t division;</code>
<code>                Int_t flag;</code>
<code>                Int_t age;</code>
<code>                Int_t service;</code>
<code>                Int_t children;</code>
<code>                Int_t grade;</code>
<code>                Int_t step;</code>
<code>                Int_t nation;</code>
<code>                Int_t hrweek;</code>
<code>                Int_t cost;</code>
<code>   };</code>
<code>   staff_t staff;</code>
<emphasis role="italic"><code>// continued…</code></emphasis>
<emphasis role="italic"><code>// open the ASCII file</code></emphasis>
<code>FILE *fp = fopen("staff.dat","r");</code>
<code>char line[81];</code>
<emphasis role="italic"><code>// create a new ROOT file</code></emphasis>
<code>TFile *f = new TFile("staff.root","RECREATE");</code>
<emphasis role="italic"><code>// create a TTree</code></emphasis>
<code>TTree *tree = new TTree("T","staff data from ascii file");</code>
<emphasis role="italic"><code>// create one branch with all information from the stucture</code></emphasis>
<code>tree-&gt;Branch("staff",&amp;staff.cat,"cat/I:division:flag:age:service:</code>
<code>                           children:grade:step:nation:hrweek:cost");</code>
<emphasis role="italic"><code>// fill the tree from the values in ASCII file</code></emphasis>
<code>while (fgets(&amp;line,80,fp)) {</code>
<code>   sscanf(&amp;line[0],"%d%d%d%d",&amp;staff.cat,&amp;staff.division,&amp;staff.flag,&amp;staff.age);</code>
<code>   sscanf(&amp;line[13],"%d%d%d%d",&amp;staff.service,&amp;staff.children,&amp;staff.grade,</code>
<code>          &amp;staff.step);</code>
<code>   sscanf(&amp;line[24],"%d%d%d",&amp;staff.nation,&amp;staff.hrweek, &amp;staff.cost);</code>
<code>   tree-&gt;Fill();</code>
<code>}</code>
<emphasis role="italic"><code>// check what the tree looks like</code></emphasis>
<code>tree-&gt;Print();</code>
<code>fclose(fp);</code>
<code>f-&gt;Write();</code>
}
</programlisting>

<para>The script declares a structure called <code>staff_t</code>, with several integers representing the relevant attribute of a staff member. It opens the ASCII file, creates a ROOT file and a <emphasis role="bold"><code>TTree</code></emphasis>. Then it creates one branch with the <emphasis role="bold"><code>TTree</code></emphasis><code>::Branch</code> method. The first parameter of the <code>Branch</code> method is the branch name. The second parameter is the address from which the first leaf is to be read. In this example it is the address of the structure <code>staff</code>. Once the branch is defined, the script reads the data from the ASCII file into the <code>staff_t</code> structure and fills the <code>tree</code>.  The ASCII file is closed, and the ROOT file is written to disk saving the <code>tree</code>. Remember, trees and histograms are created in the current directory, which is the file in our example. Hence an <code>f-&gt;Write() </code>saves the tree.</para>
</sect1>

<sect1>
<title>Show an Entry with TTree::Show</title>
<para>An easy way to access one entry of a tree is the use the <emphasis role="bold"><code>TTree</code></emphasis><code>::Show</code> method. For example to look at the 10th entry in the <code>staff.root</code> tree:</para>

<programlisting language="c++"><code>root[]</code> <emphasis role="bold"><code>TFile f("staff.root")</code></emphasis>
<code>root[]</code> <emphasis role="bold"><code>T-&gt;Show(10)</code></emphasis>
<code>======&gt; EVENT:10</code>
<code> Category        = 361</code>
<code> Flag            = 15</code>
<code> Age             = 51</code>
<code> Service         = 29</code>
<code> Children        = 0</code>
<code> Grade           = 7</code>
<code> Step            = 13</code>
<code> Hrweek          = 40</code>
<code> Cost            = 7599</code>
<code> Division        = PS</code>
<code> Nation          = FR </code>
</programlisting>

</sect1>

<sect1>
<title>Print the Tree Structure with TTree::Print</title>
<para>A helpful command to see the tree structure meaning the number of entries, the branches and the leaves, is <emphasis role="bold"><code>TTree</code></emphasis><code>::Print</code>.</para>

<programlisting language="c++"><code>root[]</code> <emphasis role="bold"><code>T</code></emphasis><emphasis role="bold"><code>-&gt;Print()</code></emphasis>
*****************************************************************************
<code>*Tree    :T         : staff data from ascii file                            *</code>
<code>*Entries :3354      : Total = 245417 bytes  File  Size =              59945</code><code>*</code>
<code>*                     Tree compression factor =   2.90                      *</code>
<code>*****************************************************************************</code>
<code>*Br    0 :staff     :Category/I:Flag:Age:Service:Children:Grade:Step:Hrweek:*</code>
<code>*         | Cost                                                            *</code>
<code>*Entries :3354 : Total Size  = 154237 bytes  File Size = 32316              *</code>
<code>*Baskets :   3 : Basket Size =  32000 bytes  Compression= 2.97              *</code>
</programlisting>

</sect1>

<sect1>
<title>Scan a Variable the Tree with TTree::Scan</title>
<para>The <emphasis role="bold"><code>TTree</code></emphasis><code>::Scan</code> method shows all values of the list of leaves separated by a colon. </para>

<programlisting language="c++">root[] <emphasis role="bold"><code>T-&gt;Scan("Cost:Age:C</code></emphasis><emphasis role="bold"><code>hildren")</code></emphasis>
<code>************************************************</code>
<code>*    Row   *      Cost *       Age *  Children *</code>
<code>************************************************</code>
<code>*        0 *     11975 *        58 *         0 *</code>
<code>*        1 *     10228 *        63 *         0 *</code>
<code>*        2 *     10730 *        56 *         2 *</code>
<code>*        3 *      9311 *        61 *         0 *</code>
<code>*        4 *      9966 *        52 *         2 *</code>
<code>*        5 *      7599 *        60 *         0 *</code>
<code>*        6 *      9868 *        53 *         1 *</code>
<code>*        7 *      8012 *        60 *         1 *</code>
<code>…</code>
</programlisting>

</sect1>

<sect1>
<title>The Tree Viewer</title>
<para>The tree viewer is a quick and easy way to examine a tree. To start the tree viewer, open a file and object browser. Right click on a <emphasis role="bold"><code>TTree</code></emphasis> and select <code>StartViewer</code>. You can also start the tree viewer from the command line. First load the viewer library. </para>

<figure><title>Activating the tree viewer</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000EF.png" width="152.4pt" depth="235.3pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<programlisting language="c++"><code>root[]</code><emphasis role="bold"><code> TFile f("staff.root")</code></emphasis>
<code>root[]</code><emphasis role="bold"><code> T-&gt;StartViewer()</code></emphasis>
</programlisting>

<para>If you want to start a tree viewer without a tree, you need to load the tree player library first:</para>

<programlisting language="c++"><code>root[]</code><emphasis role="bold"><code> gSystem-&gt;Load("libTreeViewer.so")</code></emphasis>
<code>root[]</code><emphasis role="bold"><code> new TTreeViewer()</code></emphasis>
</programlisting>

<para>Below is what the tree viewer looks like for the example file <code>staff.root</code>. The left panel contains the list of trees and their branches; in this case there is only one tree. You can add more trees with the File-Open command to open the file containing the new tree, then use the context menu on the right panel, select <code>SetTreeName</code> and enter the name of the tree to add. On the right are the leaves   or variables in the tree. You can double click on any leaf to a histogram it.</para>
<para>The toolbar in the upper part can be used for user commands, changing the drawing option and the histogram name. The lower part contains three picture buttons that draw a histogram, stop the current command, and refresh the tree. </para>
<para/>
<para/>
<para/>

<figure><title>The TreeViewer</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000F0.png" width="398.5pt" depth="185.6pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>The three check buttons toggle the following:</para>
<para><code>Hist</code>- the histogram drawing mode;</para>
<para><code>Scan</code>- enables redirecting of <emphasis role="bold"><code>TTree</code></emphasis><code>::Scan </code>command in an ASCII file;</para>
<para><code>Rec</code> - enables recording of the last issued command.</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/020000F1.jpg" width="27pt" depth="27.1pt"/></imageobject></inlinemediaobject>To draw more than one dimension you can drag and drop any leaf to the   <code>X,Y,Z</code> boxes". Then push the Draw button, witch is marked with the purple icon on the bottom left. </para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000F2.png" width="28.35pt" depth="28.35pt"/></imageobject></inlinemediaobject>
</para>
<para>All commands can be interrupted at any time by pressing this button.</para>
<para/>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/030000F3.png" width="27.6pt" depth="24.75pt"/></imageobject></inlinemediaobject>The method <emphasis role="bold"><code>TTree</code></emphasis><code>::Refresh</code> is called by pressing the refresh button in <emphasis role="bold"><code>TTreeViewer</code></emphasis>. It redraws the current exposed expression. Calling <emphasis role="bold"><code>TTree</code></emphasis><code>::Refresh</code> is useful when a tree is produced by a writer process and    concurrently analyzed by one or more readers.</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/030000F4.png" width="45.7pt" depth="15.65pt"/></imageobject></inlinemediaobject>To add a cut/weight to the histogram, enter an expression in the "cut box". The cut box is the one with the scissor icon.</para>
<para>Below them there are two text widgets for specifying the input and output event lists. A Tree Viewer session is made by the list of user-defined expressions and cuts, applying to a specified tree. A session can be saved using File / <code>SaveSource</code> menu or the <code>SaveSource</code> method from the context menu of the right panel. This will create a macro having as default name <code>treeviewer.C</code> that can be ran at any time to reproduce the session.</para>
<para>Besides the list of user-defined expressions, a session may contain a list of RECORDS. A record can be produced in the following way: dragging leaves/expression on X/Y/Z; changing drawing options; clicking the RED button on the bottom when happy with the histogram</para>
<para>NOTE that just double clicking a leaf will not produce a record: the histogram must be produced when clicking the DRAW button on the bottom-left. The records will appear on the list of records in the bottom right of the tree viewer. Selecting a record will draw the corresponding histogram. Records can be played using the arrow buttons near to the record button. When saving the session, the list of records is being saved as well.</para>
<para>Records have a default name corresponding to the Z: Y: X selection, but this can be changed using <code>SetRecordName()</code> method from the right panel context menu. You can create a new expression by right clicking on any of the<code> E()</code> boxes. The expression can be dragged and dropped into any of the boxes (<code>X,</code> <code>Y,</code> <code>Z,</code> <code>Cut</code>, or <code>Scan</code>). To scan one or more variables, drop them into the Scan box, then double click on the box. You can also redirect the result of the scan to a file by checking the Scan box on top.</para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000F5.png" width="399.7pt" depth="18.6pt"/></imageobject></inlinemediaobject>
</para>
<para>When the "<code>Rec</code>" box is checked, the <code>Draw</code> and <code>Scan</code> commands are recorded in the history file and echoed on the command line. The "Histogram" text box contains the name of the resulting histogram. By default it is <code>htemp</code>. You can type any name, if the histogram does not exist it will create one. The Option text box contains the list of Draw options. See “Draw Options”. You can select the options with the Options menu. The Command box lets you enter any command that you could also enter on the command line. The vertical slider on the far left side can be used to select the minimum and maximum of an event range. The actual start and end index are shown in on the bottom in the status window.</para>
<para>There is an extensive help utility accessible with the Help menu. The <code>IList</code> and <code>OList</code> are to <code>specify</code> an input list of entry indices and a name for the output list respectively. Both need to be of type <emphasis role="bold"><code>TList</code></emphasis> and contain integers of entry indices. These lists are described below in the paragraph "<emphasis role="bold">Error! Reference source not found.</emphasis>". </para>

<figure><title>A couple of graphs</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000F6.png" width="165.7pt" depth="155.15pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000F7.png" width="196.15pt" depth="153.3pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>The first one is a plot of the age distribution, the second a scatter plot of the cost vs. age. The second one was generated by dragging the age leaf into the Y-box and the cost leaf into the X-box, and pressing the Draw button. By default, this will generate a scatter plot. Select a different option, for example <code>"lego"</code> to create a 2D histogram.</para>
</sect1>

<sect1>
<title>Creating and Saving Trees</title>
<para>This picture shows the <emphasis role="bold"><code>TTree</code></emphasis> class:</para>

<figure><title>The TTree class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000F8.png" width="353.15pt" depth="415.25pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>To create a <emphasis role="bold"><code>TTree</code></emphasis> we use its constructor.  Then we design our data layout and add the branches. A tree can be created by giving a name and title:</para>

<programlisting language="c++"><code>TTree t("MyTree","Example Tree")</code>
</programlisting>

<sect2>
<title>Creating a Tree from a Folder Hierarchy</title>
<para>An alternative way to create a tree and organize it is to use folders (see “Folders and Tasks”). You can build a folder structure  and create a tree with branches for each of the sub-folders: </para>

<programlisting language="c++"><code>TTree folder_tree("MyFolderTree","/MyFolder")</code>
</programlisting>

<para>The second argument <code>"/MyFolder" </code>is the top folder, and the "/" signals the <emphasis role="bold"><code>TTree</code></emphasis> constructor that this is a folder not just the title. You fill the tree by placing the data into the folder structure and calling <emphasis role="bold"><code>TTree</code></emphasis><code>::Fill</code>. </para>
</sect2>

<sect2>
<title>Tree and TRef Objects</title>

<programlisting language="c++">MyTree-&gt;BranchRef();
</programlisting>

<para>This call requests the construction of an optional branch supporting table of references (<emphasis role="bold"><code>TRefTable</code></emphasis>). This branch (<emphasis role="bold"><code>TBranchRef</code></emphasis>) will keep all the information needed to find the branches containing referenced objects at each <emphasis role="bold"><code>Tree</code></emphasis><code>::Fill</code>, the branch numbers containing the referenced objects are saved in the table of references. When the Tree header is saved (via <emphasis role="bold"><code>TTree</code></emphasis><code>::Write</code> for example), the branch is saved, keeping the information with the pointers to the branches having referenced objects. Enabling this optional table, allow <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> to automatically load the branches needed to dereference a <emphasis role="bold"><code>TRef</code></emphasis> (or <emphasis role="bold"><code>TRefArray</code></emphasis>) object.</para>
</sect2>

<sect2>
<title>Autosave</title>
<para><code>Autosave</code> gives the option to save all branch buffers every <code>n</code> byte. We recommend using <code>Autosave</code> for large acquisitions. If the acquisition fails to complete, you can recover the file and all the contents since the last <code>Autosave</code>. To set the number of bytes between <code>Autosave</code> you can use the <emphasis role="bold"><code>TTree</code></emphasis><code>::SetAutosave()</code> method. You can also call <emphasis role="bold"><code>TTree</code></emphasis><code>::Autosave</code> in the acquisition loop every <code>n </code>entry.</para>
</sect2>

<sect2>
<title>Trees with Circular Buffers</title>
<para>When a <emphasis role="bold"><code>TTree</code></emphasis> is memory resident, you set it up so that it retains retain only the last few entries. For example, this can be very useful for monitoring purpose.</para>

<programlisting language="c++">void TTree::SetCircular(Long64_t maxEntries)
</programlisting>

<para>where <code>maxEntries</code> is the maximum number of entries to be kept in the buffers. When the number of entries exceeds this value, the first entries in the <emphasis role="bold"><code>Tree</code></emphasis> are deleted and the buffers used again. An example of a script using a circular buffer is shown below:</para>

<programlisting language="c++">void circular() {
gROOT-&gt;cd(); //make sure that the Tree is memory resident
TTree *T = new TTree("T","test circular buffers");
TRandom r;
Float_t px,py,pz;
Double_t random;
UShort_t i;
T-&gt;Branch("px",&amp;px,"px/F");
T-&gt;Branch("py",&amp;py,"py/F");
T-&gt;Branch("pz",&amp;pz,"pz/F");
T-&gt;Branch("random",&amp;random,"random/D");
T-&gt;Branch("i",&amp;i,"i/s");
T-&gt;SetCircular(20000);
for (i = 0; i &lt; 65000; i++) {
r.Rannor(px,py);
pz = px*px + py*py;
random = r.Rndm();
T-&gt;Fill();
}
T-&gt;Print();
}
</programlisting>

</sect2>

<sect2>
<title>Size of TTree in the File</title>
<para>When writing a <emphasis role="bold"><code>TTree</code></emphasis> to a file, if the file size reaches the value stored in the
<emphasis role="bold"><code>TTree</code></emphasis><code>::GetMaxTreeSize()</code>, the current file is closed and a new file is created. If the original file is named
"<code>myfile.root</code>", subsequent files are named "<code>myfile_1.root</code>", "<code>myfile_2.root</code>", etc.</para>
<para>Currently, the automatic change of file is restricted to the case where the tree is in the top level directory. The file should not contain sub-directories.
Before switching to a new file, the tree header is written to the current file, then the current file is closed. To process the multiple files created by <code>ChangeFile()</code>,
one must use a <emphasis role="bold"><code>TChain</code></emphasis>. </para>
<para>The new file name has a suffix "<code>_N</code>" where <code>N</code> is equal to <code>fFileNumber+1</code>. By default a Root session starts with <code>fFileNumber=0</code>.
One can set <code>fFileNumber</code> to a different value via <emphasis role="bold"><code>TTree</code></emphasis><code>::SetFileNumber()</code>. In case a file named "<code>_N</code>"
already exists, the function will try a file named "<code>__N</code>", then "<code>___N</code>", etc. The maximum tree size can be set via the static function
<emphasis role="bold"><code>TTree</code></emphasis><code>::SetMaxTreeSize()</code>. The default value of <code>fgMaxTreeSize</code> is 1.9 GB. If the current file contains
other objects (like <emphasis role="bold"><code>TH1</code></emphasis> and <emphasis role="bold"><code>TTree</code></emphasis>), these objects are automatically moved to the new file.</para>
</sect2>

<sect2>
<title>User Info Attached to a TTree Object</title>
<para>The function <emphasis role="bold"><code>TTree</code></emphasis><code>::GetUserInfo()</code> allows adding any object defined by a user to the tree that is not depending on the entry number. For example:</para>

<programlisting language="c++"><code>tree-&gt;GetUserInfo()-&gt;Add(myruninfo);</code>
</programlisting>

</sect2>

<sect2>
<title>Indexing a Tree</title>
<para>Use <emphasis role="bold"><code>TTree</code></emphasis><code>::BuildIndex()</code>, to build an index table using expressions depending on the value in the leaves. </para>

<programlisting language="c++"><code>tree-&gt;BuildIndex(majorname, minorname);</code>
</programlisting>

<para>The index is built in the following way:</para>
<itemizedlist>
<listitem><para>a pass on all entries is made like in <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw()</code></para></listitem>
<listitem><para>    <code>var1 = majorname</code></para></listitem>
<listitem><para>    <code>var2 = minorname</code></para></listitem>
<listitem><para>    <code>sel  = 231 x majorname + minorname</code></para></listitem>
<listitem><para>    for each entry in the tree the sel expression is evaluated and the results array is sorted into <code>fIndexValues</code></para></listitem>
</itemizedlist>
<para>Once the index is computed, using the <emphasis role="bold"><code>TTree</code></emphasis><code>::GetEntryWithIndex(majornumber, minornumber)</code>         one entry can be retrieved. Example:</para>

<programlisting language="c++"><emphasis role="italic"><code>// to create an index using leaves Run and Event</code></emphasis>
<code>tree.BuildIndex("Run","Event");</code>
<emphasis role="italic"><code>// to read entry corresponding to Run=1234 and Event=56789</code></emphasis>
<code>tree.GetEntryWithIndex(1234,56789);</code>
</programlisting>

<para>Note that <code>majorname</code> and <code>minorname</code> may be expressions using original tree variables e.g.: "<code>run-90000</code>", "<code>event +3*xx</code>". In case an expression is specified, the equivalent expression must be computed when calling <code>GetEntryWithIndex()</code>. To build an index with only <code>majorname</code>, specify <code>minorname="0"</code> (default). </para>
<para>Note that once the index is built, it can be saved with the <emphasis role="bold"><code>TTree</code></emphasis> object with:</para>

<programlisting language="c++"><code>tree.Write();</code>     <emphasis role="italic"><code>//if the file has been open in "update" mode</code></emphasis>
</programlisting>

<para>The most convenient place to create the index is at the end of the filling process just before saving the tree header. If a previous index was computed, it is redefined by this new call. </para>
<para>Note that this function can also be applied to a <emphasis role="bold"><code>TChain</code></emphasis>. The return value is the number of entries in the Index (&lt; 0 indicates failure).</para>
</sect2>
</sect1>

<sect1>
<title>Branches</title>
<para>The organization of branches allows the designer to optimize the data for the anticipated use. The class for a branch is called <emphasis role="bold"><code>TBranch</code></emphasis>. If two variables are independent, and the designer knows the variables will not be used together, they should be placed on separate branches. If, however, the variables are related, such as the coordinates of a point, it is most efficient to create one branch with both coordinates on it. A variable on a <emphasis role="bold"><code>TBranch</code></emphasis> is called a leaf (yes - <emphasis role="bold"><code>TLeaf</code></emphasis>). Another point to keep in mind when designing trees is that branches of the same <emphasis role="bold"><code>TTree</code></emphasis> can be written to separate files. To add a <emphasis role="bold"><code>TBranch</code></emphasis> to a <emphasis role="bold"><code>TTree</code></emphasis> we call the method<emphasis role="bold"><code> TTree</code></emphasis><code>::Branch()</code>. Note that we DO NOT use the <emphasis role="bold"><code>TBranch</code></emphasis> constructor. </para>
<para>The <emphasis role="bold"><code>TTree</code></emphasis><code>::Branch</code> method has several signatures. The branch type differs by what is stored in it. A branch can hold an entire object, a list of simple variables, contents of a folder, contents of a <emphasis role="bold"><code>TList</code></emphasis>, or an array of objects. Let's see some examples. To follow along you will need the shared library <code>libEvent.so</code>. First, check if it is in <code>$ROOTSYS/test</code>. If it is, copy it to your own area. If it is not there, you have to build it by typing make in <code>$ROOTSYS/test</code>.</para>
</sect1>

<sect1>
<title>Adding a Branch to Hold a List of Variables</title>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/030000F9.png" width="58.45pt" depth="81.15pt"/></imageobject></inlinemediaobject>As in the very first example (<code>staff.root</code>) the data we want to save is a list of simple variables, such as integers or floats. In this case, we use the following <emphasis role="bold"><code>TTree</code></emphasis><code>::Branch</code> signature:</para>

<programlisting language="c++"><code>tree-&gt;Branch("Ev_Branch",&amp;event,"temp/F:ntrack/I:nseg:nvtex:flag/i ");</code>
</programlisting>

<para>The first parameter is the branch name. </para>
<para>The second parameter is the address from which the first variable is to be read. In the code above, “event” is a structure with one float and three integers and one unsigned integer. You should not assume that the compiler aligns the elements of a structure without gaps. To avoid alignment problems, you need to use structures with same length members. If your structure does not qualify, you need to create one branch for each element of the structure.</para>
<para>The leaf name is NOT used to pick the variable out of the structure, but is only used as the name for the leaf.  This means that the list of variables needs to be in a structure in the order described in the third parameter. </para>
<para>This third parameter is a string describing the leaf list. Each leaf has a name and a type separated by a "/" and it is separated from the next leaf by a "<code>:</code>".</para>

<programlisting language="c++">&lt;Variable&gt;/&lt;type&gt;:&lt;Variable&gt;/&lt;type&gt;
</programlisting>

<para>The example on the next line has two leafs: a floating-point number called temp and an integer named <code>ntrack</code>. </para>

<programlisting language="c++"><code>"temp/F:ntrack/I:"</code>
</programlisting>

<para>The type can be omitted and if no type is given, the same type as the previous variable is assumed. This leaf list has three integers called <code>ntrack</code>, <code>nseg</code>, and <code>nvtex</code>.</para>

<programlisting language="c++"><code>"ntrack/I:nseg:nvtex"</code>
</programlisting>

<para>There is one more rule: when no type is given for the very first leaf, it becomes a <code>float</code> (F). This leaf list has three floats called <code>temp</code>, <code>mass</code>, and <code>px</code>.</para>

<programlisting language="c++"><code>"temp:mass:px"</code>
</programlisting>

<para>The symbols used for the type are:</para>
<itemizedlist>
<listitem><para><code>C</code>:a character string terminated by the 0 character</para></listitem>
<listitem><para><code>B</code>: an 8 bit signed integer </para></listitem>
<listitem><para><code>b</code>: an 8 bit unsigned integer </para></listitem>
<listitem><para><code>S</code>: a 16 bit signed integer</para></listitem>
<listitem><para><code>s</code>: a 16 bit unsigned integer </para></listitem>
<listitem><para><code>I</code>: a 32 bit signed integer </para></listitem>
<listitem><para><code>i</code>: a 32 bit unsigned integer </para></listitem>
<listitem><para><code>L</code>: a 64 bit signed integer</para></listitem>
<listitem><para><code>l</code>: a 64 bit unsigned integer</para></listitem>
<listitem><para><code>F</code>: a 32 bit floating point </para></listitem>
<listitem><para><code>D</code>: a 64 bit floating point</para></listitem>
</itemizedlist>
<para>The type is used for a byte count to decide how much space to allocate. The variable written is simply the block of bytes starting at the starting address given in the second parameter. It may or may not match the leaf list depending on whether or not the programmer is being careful when choosing the leaf address, name, and type. </para>
<para>By default, a variable will be copied with the number of bytes specified in the type descriptor symbol. However, if the type consists of two characters, the number specifies the number of bytes to be used when copying the variable to the output buffer.  The line below describes <code>ntrack</code> to be written as a 16-bit integer (rather than a 32-bit integer).</para>

<programlisting language="c++">"ntrack/I2"
</programlisting>

<para>With this Branch method, you can also add a leaf that holds an entire array of variables. To add an array of floats use the <code>f[n]</code> notation when describing the leaf. </para>

<programlisting language="c++"><code>Float_t  f[10];</code>
<code>tree-&gt;Branch("fBranch",f,"f[10]/F");</code>
</programlisting>

<para>You can also add an array of variable length:</para>

<programlisting language="c++"><code>{</code>
<code>   TFile *f = new TFile("peter.root","recreate");</code>
<code>   Int_t nPhot;</code>
<code>   Float_t E[500];</code>
<code>   TTree* nEmcPhotons = new TTree("nEmcPhotons","EMC Photons");</code>
<code>   nEmcPhotons-&gt;Branch("nPhot",&amp;nPhot,"nPhot/I");</code>
<code>   nEmcPhotons-&gt;Branch("E",E,"E[nPhot]/F");</code>
<code>}</code>
</programlisting>

<para>See “Example 2: A Tree with a C Structure” below (<code>$ROOTSYS/tutorials/tree/tree2.C</code>) and <code>staff.C</code> at the beginning of this chapter.</para>
</sect1>

<sect1>
<title>Adding a TBranch to Hold an Object</title>
<para>To write a branch to hold an event object, we need to load the definition of the <code>Event</code> class, which is in <code>$ROOTSYS/test/libEvent.so</code>         <code>(if it doesn’t exist type make in $ROOTSYS/test). </code>An object can be saved in a tree if a ROOT dictionary for its class has been generated and loaded. </para>

<programlisting language="c++"><code>root[] </code><emphasis role="bold"><code>.L libEvent.so</code></emphasis>
</programlisting>

<para>First, we need to open a file and create a tree.</para>

<programlisting language="c++"><code>root[] </code>    <emphasis role="bold"><code>TFile *f = new TFile("AFile.root","RECREATE")</code></emphasis>
<code>root[] </code>    <emphasis role="bold"><code>TTree *tree = new TTree("T","A Root Tree")</code></emphasis>
</programlisting>

<para>We need to create a pointer to an <code>Event</code> object that will be used as a reference in the <emphasis role="bold"><code>TTree</code></emphasis><code>::Branch</code> method. Then we create a branch with the <emphasis role="bold"><code>TTree</code></emphasis><code>::Branch</code> method.</para>

<programlisting language="c++"><code>root[]</code>    <emphasis role="bold"><code> Event *event = new Event()</code></emphasis>
<code>root[] </code>    <emphasis role="bold"><code>tree-&gt;Branch("EventBranch","Event",&amp;event,32000,99)</code></emphasis>
</programlisting>

<para>To add a branch to hold an object we use the signature above. The first parameter is the name of the branch. The second parameter is the name of the class of the object to be stored. The third parameter is the address of a pointer to the object to be stored. </para>
<para>Note that it is an address of a pointer to the object, not just a pointer to the object.</para>
<para>The fourth parameter is the buffer size and is by default 32000 bytes. It is the number of bytes of data for that branch to save to a buffer until it is saved to the file. The last parameter is the split-level, which is the topic of the next section. Static class members are not part of an object and thus not written with the object. You could store them separately by collecting these values in a special "status" object and write it to the file outside of the tree. If it makes sense to store them for each object, make them a regular data member.</para>

<sect2>
<title>Setting the Split-level</title>
<para>To split a branch means to create a sub-branch for each data member in the object. The split-level can be set to 0 to disable splitting or it can be set to a number between 1 and 99 indicating the depth of splitting.</para>
<para>If the split-level is set to zero, the whole object is written in its entirety to one branch. The <emphasis role="bold"><code>TTree</code></emphasis> will look like the one on the right, with one branch and one leaf holding the entire event object. </para>
<informaltable>
<tgroup cols="2">
<colspec colwidth="2317*" colname="column-1"/>
<colspec colwidth="2617*" colname="column-2"/>
<tbody>
<row>
<entry>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/030000FA.png" width="86.75pt" depth="88.2pt"/></imageobject></inlinemediaobject>A tree that is split</para>
</entry>
<entry>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/030000FB.png" width="71.2pt" depth="88.7pt"/></imageobject></inlinemediaobject>A tree that is not split</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>When the split-level is 1, an object data member is assigned a branch. If the split-level is 2, the data member objects will be split also, and a split level of 3 its data members objects, will be split. As the split-level increases so does the splitting depth. The ROOT default for the split-level is 99. This means the object will be split to the maximum.</para>

<sect3>
<title>Memory Considerations when Splitting a Branch</title>
<para>Splitting a branch can quickly generate many branches. Each branch has its own buffer in memory. In case of many branches (say more than 100), you should adjust the buffer size accordingly. A recommended buffer size is 32000 bytes if you have less than 50 branches. Around 16000 bytes if you have less than 100 branches and 4000 bytes if you have more than 500 branches. These numbers are recommended for computers with memory size ranging from 32MB to 256MB. If you have more memory, you should specify larger buffer sizes. However, in this case, do not forget that your file might be used on another machine with a smaller memory configuration.</para>
</sect3>

<sect3>
<title>Performance Considerations when Splitting a Branch</title>
<para>A split branch is faster to read, but slightly slower to write. The reading is quicker because variables of the same type are stored consecutively and the type does not have to be read each time. It is slower to write because of the large number of buffers as described above. See “</para>
<para>Performance Benchmarks” for performance impact of split and non-split mode.</para>
</sect3>

<sect3>
<title>Rules for Splitting</title>
<para>When splitting a branch, variables of different types are handled differently. Here are the rules that apply when splitting a branch.</para>
<itemizedlist>
<listitem><para>If a data member is a basic type, it becomes one branch of class <emphasis role="bold"><code>TBranchElement</code></emphasis>. </para></listitem>
<listitem><para>A data member can be an array of basic types. In this case, one single branch is created for the array.</para></listitem>
<listitem><para>A data member can be a pointer to an array of basic types. The length can vary, and must be specified in the comment field of the data member in the class definition. See “Input/Output”.</para></listitem>
<listitem><para>Pointer data member are not split, except for pointers to a <emphasis role="bold"><code>TClonesArray</code></emphasis>. The <emphasis role="bold"><code>TClonesArray</code></emphasis> (pointed to) is split if the split level is greater than two. When the split level is one, the <emphasis role="bold"><code>TClonesArray</code></emphasis> is not split. </para></listitem>
<listitem><para>If a data member is a pointer to an object, a special branch is created. The branch will be filled by calling the class <code>Streamer</code> function to serialize the object into the branch buffer.</para></listitem>
<listitem><para>If a data member is an object, the data members of this object are split into branches according to the split-level (i.e. split-level &gt; 2). </para></listitem>
<listitem><para>Base classes are split when the object is split. </para></listitem>
<listitem><para>Abstract base classes are never split.</para></listitem>
<listitem><para>All STL containers are supported.</para></listitem>
</itemizedlist>
<programlisting language="c++"><emphasis role="italic"><code>// STL vector of vectors of TAxis*</code></emphasis>
<code>vector&lt;vector&lt;TAxis *&gt; &gt;  fVectAxis;   </code>
<emphasis role="italic"><code>// STL map of string/vector</code></emphasis>
<code>map&lt;string,vector&lt;int&gt; &gt;  fMapString;  </code>
<emphasis role="italic"><code>// STL deque of pair </code></emphasis>
<code>deque&lt;pair&lt;float,float&gt; &gt; fDequePair;</code>
</programlisting>
<itemizedlist>
<listitem><para>As of ROOT 4.01/00, only <code>std::vector</code> of objects can be split.  Support for splitting the other type of STL containers will be introduced in the near future.</para></listitem>
<listitem><para>C-structure data members are not supported in split mode.</para></listitem>
<listitem><para>An object that is not split may be slow to browse.</para></listitem>
<listitem><para>A STL container that is not split will not be accessible in the browser.</para></listitem>
</itemizedlist>
</sect3>
</sect2>

<sect2>
<title>Exempt a Data Member from Splitting</title>
<para>If you are creating a branch with an object and in general you want the data members to be split, but you want to exempt a data member from the split. You can specify this in the comment field of the data member:</para>

<programlisting language="c++"><code>class Event : public TObject {</code>
<code>private:</code>
<code>   EventHeader    fEvtHdr;     </code><emphasis role="italic"><code> //|| Don't split the header</code></emphasis>
</programlisting>

</sect2>

<sect2>
<title>Adding a Branch to Hold a TClonesArray</title>
<para>ROOT has two classes to manage arrays of objects. The <emphasis role="bold"><code>TObjArray</code></emphasis> can manage objects of different classes, and the <emphasis role="bold"><code>TClonesArray</code></emphasis> that specializes in managing objects of the same class (hence the name Clones Array). <emphasis role="bold"><code>TClonesArray</code></emphasis> takes advantage of the constant size of each element when adding the elements to the array. Instead of allocating memory for each new object as it is added, it reuses the memory. Here is an example of the time a <emphasis role="bold"><code>TClonesArray</code></emphasis> can save over a <emphasis role="bold"><code>TObjArray</code></emphasis>. We have 100,000 events, and each has 10,000 tracks, which gives 1,000,000,000 tracks.  If we use a <emphasis role="bold"><code>TObjArray</code></emphasis> for the tracks, we implicitly make a call to new and a corresponding call to delete for each track. The time it takes to make a pair of new/delete calls is about 7 s (10-6). If we multiply the number of tracks by 7 s, (1,000,000,000 * 7 * 10-6) we calculate that the time allocating and freeing memory is about 2 hours. This is the chunk of time saved when a <emphasis role="bold"><code>TClonesArray</code></emphasis> is used rather than a <emphasis role="bold"><code>TObjArray</code></emphasis>. If you do not want to wait 2 hours for your tracks (or equivalent objects), be sure to use a <emphasis role="bold"><code>TClonesArray</code></emphasis> for same-class objects arrays. Branches with <emphasis role="bold"><code>TClonesArrays</code></emphasis> use the same method (<emphasis role="bold"><code>TTree</code></emphasis><code>::Branch</code>) as any other object described above. If splitting is specified the objects in the <emphasis role="bold"><code>TClonesArray</code></emphasis> are split, not the <emphasis role="bold"><code>TClonesArray</code></emphasis> itself.</para>
</sect2>

<sect2>
<title>Identical Branch Names</title>
<para>When a top-level object (say <code>event</code>), has two data members of the same class the sub branches end up with identical names. To distinguish the sub branch we must associate them with the master branch by including a “<code>.</code>” (a dot) at the end of the master branch name. This will force the name of the sub branch to be <code>master.sub</code> branch instead of simply <code>sub</code> branch. For example, a tree has two branches <code>Trigger</code> and <code>MuonTrigger</code>, each containing an object of the same class (<code>Trigger</code>). To identify uniquely the sub branches we add the dot:</para>

<programlisting language="c++"><code>tree-&gt;Branch("Trigger.","Trigger",&amp;b1,8000,1);</code>
<code>tree-&gt;Branch("MuonTrigger.","Trigger",&amp;b2,8000,1);</code>
</programlisting>

<para>If <code>Trigger</code> has three members, <code>T1</code>, <code>T2</code>, <code>T3</code>, the two instructions above will generate sub branches called: <code>Trigger.T1</code>, <code>Trigger.T2</code>, <code>Trigger.T3</code>, <code>MuonTrigger.T1</code>, <code>MuonTrigger.T2</code>, and<code> MuonTrigger.T3</code>.</para>
</sect2>
</sect1>

<sect1>
<title>Adding a Branch with a Folder</title>
<para>Use the syntax below to add a branch from a folder:</para>

<programlisting language="c++"><code>tree-&gt;Branch("/aFolder");</code>
</programlisting>

<para>This method creates one branch for each element in the folder. The method returns the total number of branches created.</para>
</sect1>

<sect1>
<title>Adding a Branch with a Collection</title>
<para>This <code>Branch</code> method creates one branch for each element in the collection.</para>

<programlisting language="c++"><code>tree-&gt;Branch(*aCollection, 8000, 99);</code>
<emphasis role="italic"><code>// Int_t TTree::Branch(TCollection *list, Int_t bufsize,Int_t splitlevel,</code></emphasis>
<emphasis role="italic"><code>//                     const char *name)</code></emphasis>
</programlisting>

<para>The method returns the total number of branches created. Each entry in the collection becomes a top level branch if the corresponding class is not a collection. If it is a collection, the entry in the collection becomes in turn top level branches, etc. The split level is decreased by 1 every time a new collection is found. For example if <code>list</code> is a <emphasis role="bold"><code>TObjArray</code></emphasis>*</para>
<itemizedlist>
<listitem><para>If <code>splitlevel = 1</code>, one top level branch is created for each element of the <emphasis role="bold"><code>TObjArray</code></emphasis>.</para></listitem>
<listitem><para>If <code>splitlevel = 2</code>, one top level branch is created for each array element. If one of the array elements is a <emphasis role="bold"><code>TCollection</code></emphasis>, one top level branch will be created for each element of this collection.</para></listitem>
</itemizedlist>
<para>In case a collection element is a <emphasis role="bold"><code>TClonesArray</code></emphasis>, the special Tree constructor for <emphasis role="bold"><code>TClonesArray</code></emphasis> is called. The collection itself cannot be a <emphasis role="bold"><code>TClonesArray</code></emphasis>. If <code>name</code> is given, all branch names will be prefixed with <code>name_</code>.</para>
<para><emphasis role="underline">IMPORTANT NOTE1</emphasis>: This function should not be called if <code>splitlevel&lt;1</code>.
<emphasis role="underline">IMPORTANT NOTE2:</emphasis> The branches created by this function will have names corresponding to the collection or object names. It is important to give names to collections to avoid misleading branch names or identical branch names. By default collections have a name equal to the corresponding class name, e.g. the default name of <emphasis role="bold"><code>TList</code></emphasis> is “<code>TList</code>”.</para>
</sect1>

<sect1>
<title>Examples for Writing and Reading Trees</title>
<para>The following sections are examples of writing and reading trees increasing in complexity from a simple tree with a few variables to a tree containing folders and complex Event objects. Each example has a named script in the <code>$ROOTSYS/tutorials/tree</code> directory. They are called tree1.C to tree4.C. The examples are:</para>
<itemizedlist>
<listitem><para><code>tree1.C</code>:  a tree with several simple (integers and floating point) variables.</para></listitem>
<listitem><para><code>tree2.C</code>:  a tree built from a C structure (<code>struct</code>). This example uses the <code>Geant3</code> C wrapper as an example of a FORTRAN common block ported to C with a C structure.</para></listitem>
<listitem><para><code>tree3.C:</code> in this example, we will show how to extend a tree with a branch from another tree with the Friends feature. These trees have branches with variable length arrays. Each entry has a variable number of tracks, and each track has several variables. </para></listitem>
<listitem><para><code>tree4.C:</code> a tree with a class (<code>Event</code>). The class Event is defined in <code>$ROOTSYS/test</code>. In this example we first encounter the impact of splitting a branch.</para></listitem>
</itemizedlist>
<para>Each script contains the main function, with the same name as the file (i.e. <code>tree1</code>), the function to write - <code>tree1w</code>, and the function to read - <code>tree1r</code>. If the script is not run in batch mode, it displays the tree in the browser and tree viewer. To study the example scripts, you can either execute the main script, or load the script and execute a specific function. For example:</para>

<programlisting language="c++"><emphasis role="italic"><code>// execute the function that writes, reads, shows the tree</code></emphasis>
<code>root[] </code>    <emphasis role="bold"><code>x tree1.C</code></emphasis>
<emphasis role="italic"><code>// use ACLiC to build shared library, check syntax, execute </code></emphasis>
<code>root[] </code><emphasis role="bold"><code>x tree1.C++ </code></emphasis>
<emphasis role="italic"><code>// Load the script and select a function to execute</code></emphasis>
<code>root[] </code>    <emphasis role="bold"><code>L tree1.C</code></emphasis>
<code>root[] </code>    <emphasis role="bold"><code>tree1w()</code></emphasis>
<code>root[] </code>    <emphasis role="bold"><code>tree1r()</code></emphasis>
</programlisting>

</sect1>

<sect1>
<title>Example 1: A Tree with Simple Variables</title>
<para>This example shows how to write, view, and read a tree with several simple (integers and floating-point) variables.</para>

<sect2>
<title>Writing the Tree</title>
<para>Below is the function that writes the tree (<code>tree1w</code>). First, the variables are defined (<code>px, py, pz,</code> <code>random</code> and <code>ev</code>). Then we add a branch for each of the variables to the tree, by calling the <emphasis role="bold"><code>TTree</code></emphasis><code>::Branch</code> method for each variable. </para>

<programlisting language="c++"><code>void tree1w()</code><code>{</code>

<emphasis role="italic"><code> //create a tree file tree1.root - create the file, the Tree and a few branches</code></emphasis>
<code>   TFile f("tree1.root","recreate");</code>
<code>   TTree t1("t1","a simple Tree with simple variables");</code>
<code>   Float_t px, py, pz;</code>
<code>   Double_t random;</code>
<code>   Int_t ev;</code>
<code>   t1.Branch("px",&amp;px,"px/F");</code>
<code>   t1.Branch("py",&amp;py,"py/F");</code>
<code>   t1.Branch("pz",&amp;pz,"pz/F");   t1.Branch("ev",&amp;ev,"ev/I");</code>

<emphasis role="italic"><code>//fill the tree</code></emphasis>
<code>   for (Int_t i=0; i&lt;10000; i++) {</code>
<code>gRandom-&gt;Rannor(px,py);                             </code>
<code>pz = px*px + py*py;</code>
<code>random = gRandom-&gt;Rndm();</code>
<code> ev = i;</code>
<code>t1.Fill();</code>
<code>   }</code>
<emphasis role="italic"><code>   //save the Tree heade; the file will be automatically closed</code></emphasis>
<emphasis role="italic"><code>   //when going out of the function scope</code></emphasis>
<code>   t1.Write();</code>
<code>}</code>
</programlisting>

<sect3>
<title>Creating Branches with A single Variable</title>
<para>This is the signature of <emphasis role="bold"><code>TTree</code></emphasis><code>::Branch</code> to create a branch with a list of variables:</para>

<programlisting language="c++"><code>TBranch* TTree::Branch(const char* name,void* address, const char* leaflist,</code>
<code>                       Int_t bufsize = 32000)</code>
</programlisting>

<para>The first parameter is the branch name. The second parameter is the address from which to read the value. The third parameter is the leaf list with the name and type of each leaf. In this example, each branch has only one leaf. In the box below, the branch is named <code>px</code> and has one floating point type leaf also called <code>px</code>.</para>

<programlisting language="c++"><code>t1.Branch("px",&amp;px,"px/F");</code>
</programlisting>

</sect3>

<sect3>
<title>Filling the Tree</title>
<para>First we find some random values for the variables. We assign <code>px</code> and <code>py</code> a Gaussian with mean = 0 and sigma = 1 by calling <code>gRandom-&gt;Rannor(px,py)</code>, and calculate<code> pz</code>. Then we call the <emphasis role="bold"><code>TTree</code></emphasis><code>::Fill()</code>         method. The call <code>t1.Fill()</code> fills all branches in the tree because we have already organized the tree into branches and told each branch where to get the value from. After this script is executed we have a ROOT file called <code>tree1.root</code> with a tree called <code>t1</code>. There is a possibility to fill branches one by one using the method <emphasis role="bold"><code>TBranch</code></emphasis><code>::Fill()</code>. In this case you do not need to call <emphasis role="bold"><code>TTree</code></emphasis><code>::Fill()</code> method. The entries can be set by <emphasis role="bold"><code>TTree</code></emphasis><code>::SetEntries(Double_t n)</code>. Calling this method makes sense only if the number of existing entries is null.</para>
</sect3>
</sect2>

<sect2>
<title>Viewing the Tree</title>

<figure><title>The tree1.root file and its tree in the browser</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000FC.png" width="235.25pt" depth="129.7pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<figure><title>A leaf histogram</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000FD.png" width="178.15pt" depth="155.15pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para/>
<para>In the right panel of the ROOT object browse are the branches:  <code>ev</code>, <code>px</code>, <code>py</code>, <code>pz</code>, and <code>random</code>. Note that these are shown as leaves because they are "end" branches with only one leaf. To histogram a leaf, we can simply double click on it in the browser. This is how the tree <code>t1</code> looks in the Tree Viewer. Here we can add a cut and add other operations for histogramming the leaves. See “The Tree Viewer”.  For example, we can plot a two dimensional histogram. </para>

<figure><title>The tree viewer</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000FE.png" width="319.05pt" depth="142.15pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect2>

<sect2>
<title>Reading the Tree</title>
<para>The <code>tree1r</code> function shows how to read the tree and access each entry and each leaf. We first define the variables to hold the read values.</para>

<programlisting language="c++">Float_t px, py, pz;
</programlisting>

<para>Then we tell the tree to populate these variables when reading an entry. We do this with the method <emphasis role="bold"><code>TTree</code></emphasis><code>::SetBranchAddress</code>. The first parameter is the branch name, and the second is the address of the variable where the branch data is to be placed. In this example, the branch name is <code>px</code>. This name was given when the tree was written (see <code>tree1w</code>). The second parameter is the address of the variable <code>px</code>.</para>

<programlisting language="c++"><code>t1-&gt;SetBranchAddress("px",&amp;px);</code>
</programlisting>

<sect3>
<title>GetEntry</title>
<para>Once the branches have been given the address, a specific entry can be read into the variables with the method <emphasis role="bold"><code>TTree</code></emphasis><code>::GetEntry(n)</code>. It reads all the branches for entry (n) and populates the given address accordingly. By default, <code>GetEntry()</code> reuses the space allocated by the previous object for each branch. You can force the previous object to be automatically deleted if you call <code>mybranch.SetAutoDelete(kTRUE)</code> (default is <code>kFALSE</code>). </para>
<para>Consider the example in <code>$ROOTSYS/test/Event.h</code>. The top-level branch in the tree <code>T</code> is declared with:</para>

<programlisting language="c++">Event *event = 0;
<emphasis role="italic"><code>//event must be null or point to a valid object; it must be initialized</code></emphasis>
<code>T.SetBranchAddress("event",&amp;event);</code>
</programlisting>

<para>When reading the Tree, one can choose one of these 3 options:</para>
<para>Option 1:</para>

<programlisting language="c++"><code>for (Int_t i = 0; i&lt;nentries; i++) {</code>
<code> T.GetEntry(i);</code>
<emphasis role="italic"><code>   //the object event has been filled at this point</code></emphasis>
<code> }</code>
</programlisting>

<para>This is the default and recommended way to create an object of the class <code>Event. </code>It will be pointed by <code>event</code>. </para>
<para>At the following entries, <code>event</code> will be overwritten by the new data. All internal members that are <emphasis role="bold"><code>TObject</code></emphasis>* are automatically deleted. It is important that these members be in a valid state when <code>GetEntry</code> is called. Pointers must be correctly initialized. However these internal members will not be deleted if the characters "<code>-&gt;</code>" are specified as the first characters in the comment field of the data member declaration. </para>
<para>The pointer member is read via the <code>pointer-&gt;Streamer(buf)</code>         if “<code>-&gt;</code>“ is specified. In this case, it is assumed that the pointer is never null (see pointer <emphasis role="bold"><code>TClonesArray</code></emphasis><code> *fTracks</code> in the <code>$ROOTSYS/test/Event</code> example). If “<code>-&gt;</code>" is not specified, the pointer member is read via <code>buf &gt;&gt; pointer</code>. In this case the pointer may be null. Note that the option with “<code>-&gt;</code>" is faster to read or write and it also consumes less space in the file.</para>
<para>Option 2 - the option <code>AutoDelete</code> is set:</para>

<programlisting language="c++"><code>TBranch</code><code> *branch = T.GetBranch("event");</code>
<code>branch-&gt;SetAddress(&amp;event);</code>
<code>branch-&gt;SetAutoDelete(kTRUE);</code>
<code>for (Int_t i=0; i&lt;nentries; i++) {</code>
<code>    T.GetEntry(i);   </code><emphasis role="italic"><code>// the object event has been filled at this point</code></emphasis>
<code>}</code>
</programlisting>

<para>At any iteration, the <code>GetEntry</code> deletes the object <code>event</code> and a new instance of <code>Event</code> is created and filled.</para>
<para>Option 3 - same as option 1, but you delete the event yourself:</para>

<programlisting language="c++"><code>for (Int_t i=0; i&lt;nentries; i++) {</code>
<code>    delete event;</code>
<code>    event = 0;  </code>    <emphasis role="italic"><code>//EXTREMELY IMPORTANT</code></emphasis>
<code>    T.GetEntry(i);</code>
<emphasis role="italic"><code>    // the objrect event has been filled at this point</code></emphasis>
<code>}</code>
</programlisting>

<para>It is strongly recommended to use the default option 1. It has the additional advantage that functions like <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> (internally calling <emphasis role="bold"><code>TTree</code></emphasis><code>::GetEntry</code>) will be functional even when the classes in the file are not available. Reading selected branches is quicker than reading an entire entry. If you are interested in only one branch, you can use the <emphasis role="bold"><code>TBranch</code></emphasis><code>::GetEntry</code> method and only that branch is read. Here is the script <code>tree1r</code>:</para>

<programlisting language="c++"><code>void tree1r()</code><code>{</code>
<emphasis role="italic"><code>  //read the Tree generated by tree1w and fill two histograms</code></emphasis>
<emphasis role="italic"><code>  //note that we use "new" to create the TFile and TTree objects,</code></emphasis>
<emphasis role="italic"><code>  //to keep them alive after leaving this function.</code></emphasis>
<code>  TFile *f = new TFile("tree1.root");</code>
<code>  TTree *t1 = (TTree*)f-&gt;Get("t1");</code>
<code>  Float_t px, py, pz;</code>
<code>  Double_t random;</code>
<code>  Int_t ev;</code>
<code>  t1-&gt;SetBranchAddress("px",&amp;px);</code>
<code>  t1-&gt;SetBranchAddress("py",&amp;py);</code>
<code>  t1-&gt;SetBranchAddress("pz",&amp;pz);</code>
<code>  t1-&gt;SetBranchAddress("random",&amp;random);</code>
<code>  t1-&gt;SetBranchAddress("ev",&amp;ev);</code>
<emphasis role="italic"><code>//create two histograms</code></emphasis>
<code>  TH1F *hpx   = new TH1F("hpx","px distribution",100,-3,3);</code>
<code>  TH2F *hpxpy = new TH2F("hpxpy","py vs px",30,-3,3,30,-3,3);</code>
<emphasis role="italic"><code>  //read all entries and fill the histograms</code></emphasis>
<code>  Int_t nentries = (Int_t)t1-&gt;GetEntries();</code>
<code>  for (Int_t i=0; i&lt;nentries; i++) {</code>
<code>    t1-&gt;GetEntry(i);</code>
<code>    hpx-&gt;Fill(px);</code>
<code>    hpxpy-&gt;Fill(px,py);</code>
<code>  }</code>
<emphasis role="italic"><code>  //We do not close the file. We want to keep the generated histograms</code></emphasis>
<emphasis role="italic"><code>  //we open a browser and the TreeViewer</code></emphasis>
<code>  if (gROOT-&gt;IsBatch()) return;</code>
<code>  new TBrowser ();</code>
<code>  t1-&gt;StartViewer();</code>

<emphasis role="italic"><code>  //In the browser, click on "ROOT Files", then on "tree1.root"</code></emphasis>
<emphasis role="italic"><code>  //You can click on the histogram icons in the right panel to draw</code></emphasis>
<emphasis role="italic"><code>  //them in the TreeViewer, follow the instructions in the Help.</code></emphasis>
<code>}</code>
</programlisting>

</sect3>
</sect2>
</sect1>

<sect1>
<title>Example 2: A Tree with a C Structure</title>
<para>The executable script for this example is <code>$ROOTSYS/tutorials/tree/tree2.C. </code>In this example we show:</para>
<itemizedlist>
<listitem><para>how to build branches from a C structure</para></listitem>
<listitem><para>how to make a branch with a fixed length array</para></listitem>
<listitem><para>how to make a branch with a variable length array</para></listitem>
<listitem><para>how to read selective branches</para></listitem>
<listitem><para>how to fill a histogram from a branch</para></listitem>
<listitem><para>how to use <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> to show a 3D plot</para></listitem>
</itemizedlist>
<para>A C structure (<code>struct</code>) is used to build a ROOT tree. In general we discourage the use of C         structures<code>,</code> we recommend using a class instead. However, we do support them for legacy applications written in C or FORTRAN. The example <code>struct</code> holds simple variables and arrays.  It maps to a Geant3 common block <code>/gctrak/. </code>This is the definition of the common block/structure:</para>

<programlisting language="c++"><code>const Int_t MAXMEC = 30;</code>
<emphasis role="italic"><code>// PARAMETER (MAXMEC=30) </code></emphasis>
<emphasis role="italic"><code>// COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7)</code></emphasis>
<emphasis role="italic"><code>//     + ,NMEC,LMEC(MAXMEC) </code></emphasis>
<emphasis role="italic"><code>//     + ,NAMEC(MAXMEC),NSTEP </code></emphasis>
<emphasis role="italic"><code>//     + ,PID,DESTEP,DESTEL,SAFETY,SLENG </code></emphasis>
<emphasis role="italic"><code>//     + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT</code></emphasis>

<code>typedef struct { </code>
<code>  Float_t  vect[7];</code>
<code>  Float_t  getot; </code>
<code>  Float_t  gekin;</code>
<code>  Float_t  vout[7]; </code>
<code>  Int_t    nmec; </code>
<code>  Int_t    lmec[MAXMEC]; </code>
<code>  Int_t    namec[MAXMEC]; </code>
<code>  Int_t    nstep; </code>
<code>  Int_t    pid;</code>
<code>  Float_t  destep; </code>
<code>  Float_t  destel; </code>
<code>  Float_t  safety; </code>
<code>  Float_t  sleng; </code>
<code>  Float_t  step; </code>
<code>  Float_t  snext; </code>
<code>  Float_t  sfield; </code>
<code>  Float_t  tofg; </code>
<code>  Float_t  gekrat; </code>
<code>  Float_t  upwght; </code>
<code>} Gctrak_t;</code>
</programlisting>

<para>When using Geant3, the common block is filled by Geant3 routines at each step and only the <emphasis role="bold"><code>TTree</code></emphasis><code>::Fill</code> method needs to be called. In this example we emulate the Geant3 step routine with the <code>helixStep</code> function. We also emulate the filling of the particle values. The calls to the <code>Branch</code> methods are the same as if Geant3 were used.</para>

<programlisting language="c++"><code>void helixStep(Float_t step, Float_t *vect, Float_t *vout)</code>
<code>{</code>
<emphasis role="italic"><code>  // extrapolate track in constant field</code></emphasis>
<code>   Float_t field = 20;</code><emphasis role="italic"><code> // field in kilogauss</code></emphasis>
<code>   enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};</code>
<code>   vout[kPP] = vect[kPP];</code>

<code>   Float_t h4    = field*2.99792e-4;</code>
<code>   Float_t rho   = -h4/vect[kPP];</code>
<code>   Float_t tet   = rho*step;</code>
<code>   Float_t tsint = tet*tet/6;</code>
<code>   Float_t sintt = 1 - tsint;</code>
<code>   Float_t sint  = tet*sintt;</code>
<code>   Float_t cos1t = tet/2;</code>
<code>   Float_t f1 = step*sintt;</code>
<code>   Float_t f2 = step*cos1t;</code>
<code>   Float_t f3 = step*tsint*vect[kPZ];</code>
<code>   Float_t f4 = -tet*cos1t;</code>
<code>   Float_t f5 = sint;</code>
<code>   Float_t f6 = tet*cos1t*vect[kPZ];</code>

<code>   vout[kX]  = vect[kX]  + (f1*vect[kPX] - f2*vect[kPY]);</code>
<code>   vout[kY]  = vect[kY]  + (f1*vect[kPY] + f2*vect[kPX]);</code>
<code>   vout[kZ]  = vect[kZ]  + (f1*vect[kPZ] + f3);</code>
<code>   vout[kPX] = vect[kPX] + (f4*vect[kPX] - f5*vect[kPY]);</code>
<code>   vout[kPY] = vect[kPY] + (f4*vect[kPY] + f5*vect[kPX]);</code>
<code>   vout[kPZ] = vect[kPZ] + (f4*vect[kPZ] + f6); </code>
<code>}</code>
</programlisting>

<sect2>
<title>Writing the Tree</title>

<programlisting language="c++"><code>void tree2w() {</code>
<emphasis role="italic"><code>   // write tree2 example</code></emphasis>
<emphasis role="italic"><code>   //create a Tree file tree2.root</code></emphasis>
<code>   TFile f("tree2.root","recreate");</code>

<code>   //create the file, the Tree</code>
<code>   TTree t2("t2","a Tree with data from a fake Geant3");</code>
<emphasis role="italic"><code>   // declare a variable of the C structure type</code></emphasis>
<code>   Gctrak_t gstep;</code>

<emphasis role="italic"><code>   // add the branches for a subset of gstep</code></emphasis>
<code>   t2.Branch("vect",gstep.vect,"vect[7]/F");</code>
<code>   t2.Branch("getot",&amp;gstep.getot,"getot/F");</code>
<code>   t2.Branch("gekin",&amp;gstep.gekin,"gekin/F");</code>
<code>   t2.Branch("nmec",&amp;gstep.nmec,"nmec/I");</code>
<code>   t2.Branch("lmec",gstep.lmec,"lmec[nmec]/I");</code>
<code>   t2.Branch("destep",&amp;gstep.destep,"destep/F");</code>
<code>   t2.Branch("pid",&amp;gstep.pid,"pid/I"); </code>

<emphasis role="italic"><code>   //Initialize particle parameters at first point</code></emphasis>
<code>   Float_t px,py,pz,p,charge=0;</code>
<code>   Float_t vout[7];</code>
<code>   Float_t mass  = 0.137;</code>
<code>   Bool_t newParticle = kTRUE;                             </code>
<code>   gstep.step    = 0.1;</code>
<code>   gstep.destep  = 0;</code>
<code>   gstep.nmec    = 0;</code>
<code>   gstep.pid     = 0;</code>

<emphasis role="italic"><code>   //transport particles </code></emphasis>
<code>   for (Int_t i=0; i&lt;10000; i++) {</code>
<emphasis role="italic"><code>//generate a new particle if necessary (Geant3 emulation)</code></emphasis>
<code>if (newParticle) {</code>
<code>px = gRandom-&gt;Gaus(0,.02);</code>
<code>py = gRandom-&gt;Gaus(0,.02);</code>
<code>pz = gRandom-&gt;Gaus(0,.02);</code>
<code>p  = TMath::Sqrt(px*px+py*py+pz*pz);</code>
<code>charge = 1;                                   </code>
<code>if (gRandom-&gt;Rndm() &lt; 0.5) charge = -1;</code>
<code>gstep.pid    += 1;</code>
<code>gstep.vect[0] = 0;</code>
<code>gstep.vect[1] = 0;</code>
<code>gstep.vect[2] = 0;</code>
<code>gstep.vect[3] = px/p;</code>
<code>gstep.vect[4] = py/p;</code>
<code>gstep.vect[5] = pz/p;</code>
<code>gstep.vect[6] = p*charge;</code>
<code>gstep.getot   = TMath::Sqrt(p*p + mass*mass);</code>
<code>gstep.gekin   = gstep.getot - mass;</code>
<code>newParticle   = kFALSE;</code>
<code>}</code>
<emphasis role="italic"><code>// fill the Tree with current step parameters</code></emphasis>
<code>t2.Fill();</code>


<emphasis role="italic"><code>//transport particle in magnetic field (Geant3 emulation)</code></emphasis>
<code>    helixStep(gstep.step, gstep.vect, vout);   </code>
<emphasis role="italic"><code> //make one step</code></emphasis>
<emphasis role="italic"><code>//apply energy loss</code></emphasis>
<code>gstep.destep   = gstep.step*gRandom-&gt;Gaus(0.0002,0.00001);</code>
<code>gstep.gekin -= gstep.destep;</code>
<code>gstep.getot  = gstep.gekin + mass;</code>
<code>gstep.vect[6]= charge*TMath::Sqrt(gstep.getot*gstep.getot - mass*mass);</code>
<code>  gstep.vect[0] = vout[0];</code>
<code>gstep.vect[1] = vout[1];</code>
<code>gstep.vect[2] = vout[2];</code>
<code>gstep.vect[3] = vout[3];                              </code>
<code>gstep.vect[4] = vout[4];                             </code>
<code>gstep.vect[5] = vout[5];</code>
<code>gstep.nmec    = (Int_t)(5*gRandom-&gt;Rndm());</code>
<code>for (Int_t l=0; l&lt;gstep.nmec; l++) gstep.lmec[l] = l;</code>
<code>if  (gstep.gekin &lt; 0.001) newParticle = kTRUE;</code>
<code>if  (TMath::Abs(gstep.vect[2]) &gt; 30) newParticle = kTRUE;</code>
<code>   }</code>
<emphasis role="italic"><code>   //save the Tree header. The file will be automatically </code></emphasis>
<emphasis role="italic"><code>   // closed when going out of the function scope</code></emphasis>
<code>   t2.Write();</code>
<code>}</code>
</programlisting>

<sect3>
<title>Adding a Branch with a Fixed Length Array</title>
<para>At first, we create a tree and create branches for a subset of variables in the C structure<code> Gctrak_t</code>. Then we add several types of branches. The first branch reads seven floating-point values beginning at the address of <code>'gstep.vect'</code>. You do not need to specify <code>&amp;gstep.vect</code>, because in C and C++ the array variable holds the address of the first element. </para>

<programlisting language="c++"><code>t2.Branch("vect",gstep.vect,"vect[7]/F");</code>
<code>t2.Branch("getot",&amp;gstep.getot,"getot/F");</code>
<code>t2.Branch("gekin",&amp;gstep.gekin,"gekin/F");</code>
</programlisting>

</sect3>

<sect3>
<title>Adding a Branch with a Variable Length Array</title>
<para>The next two branches are dependent on each other. The first holds the length of the variable length array and the second holds the variable length array. The <code>lmec</code> branch reads <code>nmec</code> number of integers beginning at the address <code>gstep.lmec</code>.</para>

<programlisting language="c++"><code>t2.Branch("nmec",&amp;gstep.nmec,"nmec/I");</code>
<code>t2.Branch("lmec",gstep.lmec,"lmec[nmec]/I");</code>
</programlisting>

<para>The variable <code>nmec</code> is a random number and is reset for each entry.</para>

<programlisting language="c++"><code>gstep.nmec = (Int_t)(5*gRandom-&gt;Rndm());</code>
</programlisting>

</sect3>

<sect3>
<title>Filling the Tree</title>
<para>In this emulation of Geant3, we generate and transport particles in a magnetic field and store the particle parameters at each tracking step in a ROOT tree.</para>
</sect3>
</sect2>

<sect2>
<title>Analysis</title>
<para>In this analysis, we do not read the entire entry we only read one branch. First, we set the address for the branch to the file <code>dstep</code>, and then we use the <emphasis role="bold"><code>TBranch</code></emphasis><code>::GetEntry</code> method. Then we fill a histogram with the <code>dstep</code> branch entries, draw it and fit it with a Gaussian. In addition, we draw the particle's path using the three values in the vector. Here we use the <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> method. It automatically creates a histogram and plots the 3 expressions (see Trees in Analysis).</para>

<programlisting language="c++"><code>void tree2r() {</code>

<code>   // read the Tree generated by tree2w and fill one histogram</code>
<code>   // we are only interested by the destep branch</code>

<code>   // note that we use "new" to create the TFile and TTree objects because we</code>
<code>   // want to keep these objects alive when we leave this function</code>
TFile *f = new TFile("tree2.root");
TTree *t2 = (TTree*)f-&gt;Get("t2");
static Float_t destep;
TBranch *b_destep = t2-&gt;GetBranch("destep");
b_destep-&gt;SetAddress(&amp;destep);

<code>   //create one histogram</code>
TH1F *hdestep = new TH1F("hdestep","destep in Mev",100,1e-5,3e-5);
<code>   //read only the destep branch for all entries</code>
Int_t nentries = (Int_t)t2-&gt;GetEntries();
for (Int_t i=0;i&lt;nentries;i++) {
b_destep-&gt;GetEntry(i);
<code>      // fill the histogram with the destep entry </code>
hdestep-&gt;Fill(destep);
}

<code>// we do not close the file; we want to keep the generated histograms;</code>
<code>   // we fill a 3-d scatter plot with the particle step coordinates</code>
TCanvas *c1 = new TCanvas("c1","c1",600,800);
c1-&gt;SetFillColor(42);
c1-&gt;Divide(1,2);

c1-&gt;cd(1);
hdestep-&gt;SetFillColor(45);
hdestep-&gt;Fit("gaus");

c1-&gt;cd(2);
gPad-&gt;SetFillColor(37);                                  <emphasis role="italic"><code>// continued…</code></emphasis>
t2-&gt;SetMarkerColor(kRed);
t2-&gt;Draw("vect[0]:vect[1]:vect[2]");
if (gROOT-&gt;IsBatch()) return;

<code>   // invoke the x3d viewer</code>
gPad-&gt;GetViewer3D(“x3d”);
}
</programlisting>

<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000FF.png" width="171.85pt" depth="258.5pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/03000100.png" width="172.55pt" depth="143.4pt"/></imageobject></inlinemediaobject>
</para>
</sect2>
</sect1>

<sect1>
<title>Example 3: Adding Friends to Trees</title>
<para>In this example, we will show how to extend a tree with a branch from another tree with the Friends feature.</para>

<sect2>
<title>Adding a Branch to an Existing Tree</title>
<para>You may want to add a branch to an existing tree. For example, if one variable in the tree was computed with a certain algorithm, you may want to try another algorithm and compare the results. One solution is to add a new branch, fill it, and save the tree. The code below adds a simple branch to an existing tree. Note that the <code>kOverwrite</code> option in the <code>Write</code> method overwrites the existing tree. If it is not specified, two copies of the tree headers are saved.</para>

<programlisting language="c++"><code>void tree3AddBranch() {</code>
TFile f("tree3.root","update");
Float_t new_v;
TTree *t3 = (TTree*)f-&gt;Get("t3");
TBranch *newBranch = t3-&gt; Branch("new_v",&amp;new_v,"new_v/F");
<code>//read the number of entries in the t3</code>
Int_t nentries = (Int_t)t3-&gt;GetEntries();
for (Int_t i = 0; i &lt; nentries; i++){
new_v= gRandom-&gt;Gaus(0,1);
newBranch-&gt;Fill();
}
t3-&gt;Write("",TObject::kOverwrite);     <code>// save only the new version of the tree</code>
}
</programlisting>

<para>Adding a branch is often not possible because the tree is in a read-only file and you do not have permission to save the modified tree with the new branch. Even if you do have the permission, you risk loosing the original tree with an unsuccessful attempt to save the modification. Since trees are usually large, adding a branch could extend it over the 2GB limit. In this case, the attempt to write the tree fails, and the original data is may also be corrupted. In addition, adding a branch to a tree enlarges the tree and increases the amount of memory needed to read an entry, and therefore decreases the performance. For these reasons, ROOT offers the concept of friends for trees (and chains). We encourage you to use <emphasis role="bold"><code>TTree</code></emphasis><code>::AddFriend</code> rather than adding a branch manually.</para>
</sect2>

<sect2>
<title>TTree::AddFriend</title>
<para>A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way it is much like adding another branch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the <emphasis role="bold"><code>TTree</code></emphasis><code>::AddFriend </code>method. The <emphasis role="bold"><code>TTree</code></emphasis> (<code>tree</code>) below has two friends (<code>ft1</code> and <code>ft2</code>) and now has access to the variables <code>a,b,c,i,j,k,l</code> and <code>m</code>.</para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/02000101.jpg" width="180.6pt" depth="82.55pt"/></imageobject></inlinemediaobject>
</para>
<para>The <code>AddFriend</code> method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. <code>AddFriend</code> automatically opens the friend file. If no file name is given, the tree called <code>ft1</code> is assumed to be in the same file as the original tree.</para>

<programlisting language="c++"><code>tree.AddFriend("ft1","friendfile1.root");</code>
</programlisting>

<para>If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:</para>

<programlisting language="c++"><code>tree.AddFriend("tree1 = tree","friendfile1.root");</code>
</programlisting>

<para>Once the tree has friends, we can use <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> as if the friend's variables were in the original tree. To specify which tree to use in the <code>Draw</code> method, use the syntax:</para>

<programlisting language="c++"><code>&lt;treeName&gt;.&lt;branchname&gt;.&lt;varname&gt;</code>
</programlisting>

<para>If the <code>variablename</code> is enough to identify uniquely the variable, you can leave out the tree and/or branch name.</para>
<para>For example, these commands generate a 3-d scatter plot of variable "<code>var</code>" in the <emphasis role="bold"><code>TTree</code></emphasis> <code>tree</code> versus variable <code>v1 in </code><emphasis role="bold"><code>TTree</code></emphasis><code> ft1</code> versus variable <code>v2</code> in <emphasis role="bold"><code>TTree</code></emphasis> <code>ft2</code>.</para>

<programlisting language="c++"><code>tree.AddFriend("ft1","friendfile1.root");</code>
<code>tree.AddFriend("ft2","friendfile2.root");</code>
<code>tree.Draw("var:ft1.v1:ft2.v2");</code>
</programlisting>

<para><inlinemediaobject><imageobject><imagedata fileref="pictures/02000102.jpg" width="126.7pt" depth="102.5pt"/></imageobject></inlinemediaobject>The picture illustrates the access of the tree and its friends with a <code>Draw</code> command.</para>
<para>When <code>AddFriend</code> is called, the ROOT file is automatically opened and the friend tree (<code>ft1)</code> header is read into memory. The new friend (<code>ft1</code>) is added to the list of friends of <code>tree</code>. The number of entries in the friend must be equal or greater to the number of entries of the original tree. If the friend tree has fewer entries, a warning is given and the missing entries are not included in the histogram. </para>
<para>Use <emphasis role="bold"><code>TTree</code></emphasis><code>::GetListOfFriends</code> to retrieve the list of friends from a tree.</para>
<para>When the tree is written to file (<emphasis role="bold"><code>TTree</code></emphasis><code>::Write</code>), the friends list is saved with it. Moreover, when the tree is retrieved, the trees on the friends list are also retrieved and the friendship restored. When a tree is deleted, the elements of the friend list are also deleted. It is possible to declare a friend tree that has the same internal structure (same branches and leaves) as the original tree, and compare the same values by specifying the tree.</para>

<programlisting language="c++"><code>tree.Draw("var:ft1.var:ft2.var")</code>
</programlisting>

<para>The example code is in <code>$ROOTSYS/tutorials/tree/tree3.C</code>. Here is the script:</para>

<programlisting language="c++"><code>void tree3w() {</code>

<code>// Example of a Tree where branches are variable length arrays</code>
<code>// A second Tree is created and filled in parallel.</code>
<code>// Run this script with .x tree3.C </code>
<code>// In the function treer, the first Tree is open. </code>
<code>// The second Tree is declared friend of the first tree.</code>
<code>// TTree::Draw is called with variables from both Trees.</code>
const Int_t kMaxTrack = 500;
Int_t ntrack;
Int_t stat[kMaxTrack];
Int_t sign[kMaxTrack];
Float_t px[kMaxTrack];
Float_t py[kMaxTrack];
Float_t pz[kMaxTrack];
Float_t pt[kMaxTrack];
Float_t zv[kMaxTrack];
Float_t chi2[kMaxTrack];
Double_t sumstat;

<code>   // create the first root file with a tree  </code>
TFile f("tree3.root","recreate");
TTree *t3 = new TTree("t3","Reconst ntuple");
t3-&gt;Branch("ntrack",&amp;ntrack,"ntrack/I");
t3-&gt;Branch("stat",stat,"stat[ntrack]/I");
t3-&gt;Branch("sign",sign,"sign[ntrack]/I");
t3-&gt;Branch("px",px,"px[ntrack]/F");
t3-&gt;Branch("py",py,"py[ntrack]/F");
t3-&gt;Branch("pz",pz,"pz[ntrack]/F");
t3-&gt;Branch("zv",zv,"zv[ntrack]/F");
t3-&gt;Branch("chi2",chi2,"chi2[ntrack]/F");

<code>// create the second root file with a different tree</code>
TFile fr("tree3f.root","recreate");
TTree *t3f = new TTree("t3f","a friend Tree");
t3f-&gt;Branch("ntrack",&amp;ntrack,"ntrack/I");
t3f-&gt;Branch("sumstat",&amp;sumstat,"sumstat/D");
t3f-&gt;Branch("pt",pt,"pt[ntrack]/F");

<code>// Fill the trees</code>
for (Int_t i=0;i&lt;1000;i++) {
Int_t nt = gRandom-&gt;Rndm()*(kMaxTrack-1);
ntrack = nt;
sumstat = 0;
<code> // set the values in each track</code>
for (Int_t n=0;n&lt;nt;n++) {
stat[n] = n%3;
sign[n] = i%2;
px[n]   = gRandom-&gt;Gaus(0,1);
py[n]   = gRandom-&gt;Gaus(0,2);
pz[n]   = gRandom-&gt;Gaus(10,5);
zv[n]   = gRandom-&gt;Gaus(100,2);
chi2[n] = gRandom-&gt;Gaus(0,.01);
sumstat += chi2[n];
pt[n]   = TMath::Sqrt(px[n]*px[n] + py[n]*py[n]);
}
t3-&gt;Fill();
t3f-&gt;Fill();
}
<code>  // Write the two files  </code>
t3-&gt;Print();
f.cd();
t3-&gt;Write();
fr.cd();
t3f-&gt;Write();
}

<code>// Function to read the two files and add the friend</code>
<code>void tree3r()</code>         {
TFile *f = new TFile("tree3.root");
TTree *t3 = (TTree*)f-&gt;Get("t3");
<code>   // Add the second tree to the first tree as a friend</code>
t3-&gt;AddFriend("t3f","tree3f.root");
<code>   // Draw pz which is in the first tree and use pt </code>
<code>   // in the condition. pt is in the friend tree.</code>
t3-&gt;Draw("pz","pt&gt;3");
}

<code>// This is executed when typing .x tree3.C</code>
<code>void tree3()</code>         {
tree3w();
tree3r();
}
</programlisting>

</sect2>
</sect1>

<sect1>
<title>Example 4: A Tree with an Event Class</title>
<para>This example is a simplified version of <code>$ROOTSYS/test/MainEvent.cxx</code> and where Event objects are saved in a tree. The full definition of <code>Event</code> is in <code>$ROOTSYS/test</code>/<code>Event.h</code>. To execute this macro, you will need the library <code>$ROOTSYS/test/libEvent.so</code>. If it does not exist you can build the test directory applications by following the instruction in the <code>$ROOTSYS/test/README</code> file.</para>
<para>In this example we will show</para>
<itemizedlist>
<listitem><para>the difference in splitting or not splitting a branch</para></listitem>
<listitem><para>how to read selected branches of the tree,</para></listitem>
<listitem><para>how to print a selected entry</para></listitem>
</itemizedlist>
<sect2>
<title>The Event Class</title>
<para><code>Event</code> is a descendent of <emphasis role="bold"><code>TObject</code></emphasis>. As such it inherits the data members of <emphasis role="bold"><code>TObject</code></emphasis> and its methods such as <code>Dump()</code> and <code>Inspect() </code>and<code> Write()</code>. In addition, because it inherits from <emphasis role="bold"><code>TObject</code></emphasis> it can be a member of a collection. To summarize, the advantages of inheriting from a <emphasis role="bold"><code>TObject</code></emphasis> are:</para>
<itemizedlist>
<listitem><para>Inherit the <code>Write</code>, <code>Inspect</code>, and <code>Dump</code> methods</para></listitem>
<listitem><para>Enables a class to be a member of a ROOT collection</para></listitem>
<listitem><para>Enables RTTI </para></listitem>
</itemizedlist>
<para>Below is the list of the <code>Event</code> data members. It contains a character array, several integers, a floating-point number, and an <code>EventHeader</code> object. The <code>EventHeader</code> class is described in the following paragraph. <code>Event</code> also has two pointers, one to a <emphasis role="bold"><code>TClonesArray</code></emphasis> of tracks and one to a histogram. The string "<code>-&gt;</code>" in the comment field of the members <code>*fTracks</code> and <code>*fH</code> instructs the automatic <code>Streamer</code> to assume that the objects <code>*fTracks</code> and <code>*fH</code> are never null pointers and that <code>fTracks-&gt;Streamer</code> can be used instead of the more time consuming form <code>R__b &lt;&lt; fTracks</code>.</para>

<programlisting language="c++"><code>class Event : public TObject {</code>
<code>private:</code>
<code>   char            fType[20];</code>
<code>   Int_t           fNtrack;</code>
<code>   Int_t           fNseg;</code>
<code>   Int_t           fNvertex;</code>
<code>   UInt_t          fFlag;</code>
<code>   Float_t         fTemperature;</code>
<code>   EventHeader     fEvtHdr;</code>
<code>   TClonesArray  *fTracks;            //-&gt;</code>
<code>   TH1F          *fH;                 //-&gt;</code>
<code>   Int_t           fMeasures[10];</code>
<code>   Float_t         fMatrix[4][4];</code>
<code>   Float_t       *fClosestDistance;   //[fNvertex] </code>
<code>   static TClonesArray *fgTracks;</code>
<code>   static TH1F         *fgHist; </code>
<code>// … list of methods</code>
<code>   ClassDef(Event,1)  </code><emphasis role="italic"><code>//Event structure</code></emphasis>
<code>};</code>
</programlisting>

</sect2>

<sect2>
<title>The EventHeader Class</title>
<para>The <code>EventHeader</code> class (also defined in <code>Event.h</code>) does not inherit from <emphasis role="bold"><code>TObject</code></emphasis>. Beginning with ROOT 3.0, an object can be placed on a branch even though it does not inherit from <emphasis role="bold"><code>TObject</code></emphasis>. In previous releases branches were restricted to objects inheriting from the <emphasis role="bold"><code>TObject</code></emphasis>. However, it has always been possible to write a class not inheriting from <emphasis role="bold"><code>TObject</code></emphasis> to a tree by encapsulating it in a <emphasis role="bold"><code>TObject</code></emphasis> descending class as is the case in <code>EventHeader</code> and <code>Event</code>. </para>

<programlisting language="c++"><code>class EventHeader {</code>
<code>private:</code>
<code>   Int_t   fEvtNum;</code>
<code>   Int_t   fRun;</code>
<code>   Int_t   fDate;</code>
<code>   // … list of methods</code>
<code>   ClassDef(EventHeader,1)</code>    <emphasis role="italic"><code>  //Event Header</code></emphasis>
<code>};</code>
</programlisting>

</sect2>

<sect2>
<title>The Track Class</title>
<para>The <code>Track</code> class descends from <emphasis role="bold"><code>TObject</code></emphasis> since tracks are in a <emphasis role="bold"><code>TClonesArray</code></emphasis> (i.e. a ROOT collection class) and contains a selection of basic types and an array of vertices. Its <emphasis role="bold"><code>TObject</code></emphasis> inheritance enables <code>Track</code> to be in a collection and in <code>Event</code> is a <emphasis role="bold"><code>TClonesArray</code></emphasis> of <code>Tracks</code>.</para>

<programlisting language="c++"><code>class Track : public TObject {</code>
<code>private:</code>
<code>   Float_t   fPx;         //X component of the momentum</code>
<code>   Float_t   fPy;         //Y component of the momentum</code>
<code>   Float_t   fPz;         //Z component of the momentum</code>
<code>   Float_t   fRandom;     //A random track quantity</code>
<code>   Float_t   fMass2;      //The mass square of this particle</code>
<code>   Float_t   fBx;         //X intercept at the vertex</code>
<code>   Float_t   fBy;         //Y intercept at the vertex</code>
<code>   Float_t   fMeanCharge; //Mean charge deposition of all hits </code>
<code>   Float_t   fXfirst;     //X coordinate of the first point</code>
<code>   Float_t   fXlast;      //X coordinate of the last point</code>
<code>   Float_t   fYfirst;     //Y coordinate of the first point</code>
<code>   Float_t   fYlast;      //Y coordinate of the last point</code>
<code>   Float_t   fZfirst;     //Z coordinate of the first point</code>
<code>   Float_t   fZlast;      //Z coordinate of the last point</code>
<code>   Float_t   fCharge;     //Charge of this track</code>
<code>   Float_t   fVertex[3];  //Track vertex position</code>
<code>   Int_t     fNpoint;     //Number of points for this track</code>
<code>   Short_t   fValid;      //Validity criterion</code>
<code>// method definitions …</code>
<code>   ClassDef(Track,1)      </code>    <code>//A track segment</code>
<code>};</code>
</programlisting>

</sect2>

<sect2>
<title>Writing the Tree</title>
<para>We create a simple tree with two branches both holding <code>Event</code> objects. One is split and the other is not. We also create a pointer to an <code>Event</code> object (<code>event</code>). </para>

<programlisting language="c++"><code>void tree4w() {</code>
<code>   // check to see if the event class is in the dictionary</code>
<code>   // if it is not load the definition in libEvent.so</code>
if (!TClassTable::GetDict("Event")) {
gSystem-&gt;Load("$ROOTSYS/test/libEvent.so");
}
<code>  // create a Tree file tree4.root</code>
TFile f("tree4.root","RECREATE");
<code>// create a ROOT Tree</code>
TTree t4("t4","A Tree with Events");
<code>  // create a pointer to an Event object</code>
Event *event = new Event();
<code> // create two branches, split one</code>
t4.Branch("event_branch", "Event", &amp;event,16000,2);
t4.Branch("event_not_split", "Event", &amp;event,16000,0);

<code>  // a local variable for the event type </code>
char etype[20];

<code> // fill the tree</code>
for (Int_t ev = 0; ev &lt;100; ev++) {
Float_t sigmat, sigmas;
gRandom-&gt;Rannor(sigmat,sigmas);
Int_t ntrack   = Int_t(600 + 600 *sigmat/120.);
Float_t random = gRandom-&gt;Rndm(1);
sprintf(etype,"type%d",ev%5);
event-&gt;SetType(etype);
event-&gt;SetHeader(ev, 200, 960312, random);
event-&gt;SetNseg(Int_t(10*ntrack+20*sigmas));
event-&gt;SetNvertex(Int_t(1+20*gRandom-&gt;Rndm()));
event-&gt;SetFlag(UInt_t(random+0.5));
event-&gt;SetTemperature(random+20.);
for(UChar_t m = 0; m &lt; 10; m++) {
event-&gt;SetMeasure(m, Int_t(gRandom-&gt;Gaus(m,m+1)));
}
<code>// continued…</code>
<code>// fill the matrix</code>
for(UChar_t i0 = 0; i0 &lt; 4; i0++) {
for(UChar_t i1 = 0; i1 &lt; 4; i1++) {
event-&gt;SetMatrix(i0,i1,gRandom-&gt;Gaus(i0*i1,1));
}
}
<code>      // create and fill the Track objects</code>
for (Int_t t = 0; t &lt; ntrack; t++) event-&gt;AddTrack(random);
t4.Fill();      <code>// Fill the tree</code>
event-&gt;Clear(); <code>// Clear before reloading event</code>
}
f.Write();            <code>// Write the file header</code>
t4.Print();           <code>// Print the tree contents</code>
}
</programlisting>

</sect2>

<sect2>
<title>Reading the Tree</title>
<para>First, we check if the shared library with the class definitions is loaded. If not we load it. Then we read two branches, one for the number of tracks and one for the entire event. We check the number of tracks first, and if it meets our condition, we read the entire event. We show the fist entry that meets the condition.</para>

<programlisting language="c++"><code>void tree4r() {</code>
<code>  // check if the event class is in the dictionary</code>
<code>  // if it is not load the definition in libEvent.so</code>
if (!TClassTable::GetDict("Event")) {
gSystem-&gt;Load("$ROOTSYS/test/libEvent.so");
}
<code>// read the tree generated with tree4w </code>

<code>  // note that we use "new" to create the TFile and TTree objects, because we</code>
<code>  // want to keep these objects alive when we</code> leave this function.
TFile *f = new TFile("tree4.root");
TTree *t4 = (TTree*)f-&gt;Get("t4");

<code>  // create a pointer to an event object for reading the branch values.</code>
Event *event = new Event();
<code>  // get two branches and set the branch address</code>
TBranch *bntrack = t4-&gt;GetBranch("fNtrack");
TBranch *branch  = t4-&gt;GetBranch("event_split");
branch-&gt;SetAddress(&amp;event);

Int_t nevent = t4-&gt;GetEntries();
Int_t nselected = 0;
Int_t nb = 0;
<code>  for (Int_t i=0; i&lt;nevent; i++) {</code>
<code>    //read branch "fNtrack"only</code>
<code>    bntrack-&gt;GetEntry(i);  </code>

<code>    //reject events with more than 587 tracks</code>
<code>    if (event-&gt;GetNtrack() &gt; 587)continue;</code>

<code>    //read complete accepted event in memory </code>
<code>    nb += t4-&gt;GetEntry(i);</code>
<code>    nselected++;</code>

<code>    //print the first accepted event</code>
<code>    if (nselected == 1) t4-&gt;Show();</code>
<code>    //clear tracks array</code>
<code>    event-&gt;Clear();</code>
<code>  }</code>

<code>  if (gROOT-&gt;IsBatch()) return;</code>
<code>  new TBrowser();</code>
<code>  t4-&gt;StartViewer();</code>
<code>}   </code>
</programlisting>

<para>Now, let's see how the tree looks like in the tree viewer. </para>

<figure><title>The tree viewer with tree4 example</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/03000103.png" width="334.55pt" depth="299.15pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>You can see the two branches in the tree in the left panel: the event branch is split and hence expands when clicked on. The other branch event not split is not expandable and we can not browse the data members. </para>
<para>The <emphasis role="bold"><code>TClonesArray</code></emphasis> of tracks <code>fTracks</code> is also split because we set the split level to 2. The output on the command line is the result of <code>tree4-&gt;Show()</code>. It shows the first entry with more than 587 tracks:</para>

<programlisting language="c++"><code>======&gt; EVENT:26</code>
<code> event_split     = </code>
<code> fUniqueID       = 0</code>
<code> fBits           = 50331648</code>
<code> fType[20]       = 116 121 112 101 49 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </code>
<code> fNtrack         = 585</code>
<code> fNseg           = 5834</code>
<code> fNvertex        = 17</code>
<code> fFlag           = 0</code>
<code> fTemperature    = 20.044315</code>
<code> fEvtHdr.fEvtNum = 26</code>
<code> fEvtHdr.fRun    = 200</code>
<code> fEvtHdr.fDate   = 960312</code>
<code> fTracks         = 585</code>
<code> fTracks.fUniqueID = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</code>
<code>…</code>
</programlisting>

</sect2>
</sect1>

<sect1>
<title>Example 5: Import an ASCII File into a TTree</title>
<para>The method <emphasis role="bold"><code>TTree</code></emphasis><code>::ReadFile</code> can be used to automatic define the structure of the <emphasis role="bold"><code>TTree</code></emphasis> and read the data from a formatted ascii file.</para>

<programlisting language="c++">Long64_t TTree::ReadFile(const char *filename, const char *branchDescriptor)
</programlisting>

<para>Creates or simply read branches from the file named whose name is passed in <code>'filename'</code>.</para>

<programlisting language="c++"><code>{  gROOT-&gt;Reset();</code>
<code>   TFile *f = new TFile("basic2.root","RECREATE");</code>
<code>   TH1F *h1 = new TH1F("h1","x distribution",100,-4,4);</code>
<code>   TTree *T = new TTree("ntuple","data from ascii file");</code>
<code>   Long64_t nlines = T-&gt;ReadFile("basic.dat","x:y:z");</code>
<code>   printf(" found %lld pointsn",nlines);</code>
<code>   T-&gt;Draw("x","z&gt;2");</code>
<code>   T-&gt;Write();</code>
<code>}</code>
</programlisting>

<para>If <code>branchDescriptor</code> is set to an empty string (the default), it is assumed that the <emphasis role="bold"><code>Tree</code></emphasis> descriptor is given in the first line of the file with a syntax like: <code>A/D:Table[2]/F:Ntracks/I:astring/C</code>.</para>
<para>Otherwise branchDescriptor must be specified with the above syntax.Lines in the input file starting with "#" are ignored. A <emphasis role="bold"><code>TBranch</code></emphasis> object is created for each variable in the expression. The total number of rows read from the file is returned. </para>
</sect1>

<sect1>
<title>Trees in Analysis</title>
<para>The methods <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code>, <emphasis role="bold"><code>TTree</code></emphasis><code>::MakeClass</code>         and         <emphasis role="bold"><code>TTree</code></emphasis><code>::MakeSelector</code> are available for data analysis using trees. The <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> method is a powerful yet simple way to look and draw the trees contents. It enables you to plot a variable (a leaf) with just one line of code. However, the Draw method falls short once you want to look at each entry and design more sophisticated acceptance criteria for your analysis. For these cases, you can use <emphasis role="bold"><code>TTree</code></emphasis><code>::MakeClass</code>. It creates a class that loops over the trees entries one by one. You can then expand it to do the logic of your analysis.</para>
<para>The <emphasis role="bold"><code>TTree</code></emphasis><code>::MakeSelector</code> is the recommended method for ROOT data analysis. It is especially important for large data set in a parallel processing configuration where the analysis is distributed over several processors and you can specify which entries to send to each processor. With <code>MakeClass</code> the user has control over the event loop, with <code>MakeSelector </code>the tree is in control of the event loop.</para>
</sect1>

<sect1>
<title>Simple Analysis Using TTree::Draw</title>
<para>We will use the tree in <code>staff.root</code> that was made by the macro in <code>$ROOTSYS/tutorials/tree/staff.C</code>.</para>
<para>First, open the file and lists its contents.</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>TFile</code></emphasis><emphasis role="bold"><code> f ("staff.root")</code></emphasis>
root[] <emphasis role="bold"><code>f.ls()</code></emphasis>
TFile**         staff.root
TFile*         staff.root
KEY: TTree    T;1     staff data from ascii file
</programlisting>

<para>We can see the <emphasis role="bold"><code>TTree </code></emphasis>"<code>T</code>" in the file. We will use it to experiment with the <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> method, so let’s create a pointer to it:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>TTree *MyTree = </code></emphasis><emphasis role="bold"><code>T</code></emphasis>
</programlisting>

<para>CINT allows us to get simply the object by using it. Here we define a pointer to a <emphasis role="bold"><code>TTree</code></emphasis> object and assign it the value of "<code>T</code>", the <emphasis role="bold"><code>TTree</code></emphasis> in the file. CINT looks for "<code>T</code>" and returns it. To show the different <code>Draw</code> options, we create a canvas with four sub-pads. We will use one sub-pad for each <code>Draw</code> command.</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>TCanvas</code></emphasis><emphasis role="bold"><code> *myCanvas = new TCanvas()</code></emphasis>
root[]<emphasis role="bold"><code> myCanvas-&gt;Divide(2,2)</code></emphasis>
</programlisting>

<para>We activate the first pad with the <emphasis role="bold"><code>TCanvas</code></emphasis><code>::cd</code>         statement:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>myCanvas-&gt;cd(1)</code></emphasis>
</programlisting>

<para>We then draw the variable <code>Cost</code>:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>MyTree-&gt;Draw("</code></emphasis><emphasis role="bold"><code>C</code></emphasis><emphasis role="bold"><code>ost")</code></emphasis>
</programlisting>

<para>As you can see, the last call <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> has only one parameter. It is a string containing the leaf name. A histogram is automatically created as a result of a <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code>. The style of the histogram is inherited from the <emphasis role="bold"><code>TTree</code></emphasis> attributes and the current style (<emphasis role="italic"><emphasis role="bold"><code>gStyle</code></emphasis></emphasis>) is ignored. The <emphasis role="bold"><code>TTree</code></emphasis> gets its attributes from the current <emphasis role="bold"><code>TStyle</code></emphasis> at the time it was created. You can call the method <emphasis role="bold"><code>TTree</code></emphasis><code>::UseCurrentStyle</code> to change to the current style rather than the <emphasis role="bold"><code>TTree</code></emphasis> style. (See <emphasis role="italic"><emphasis role="bold"><code>gStyle</code></emphasis></emphasis>; see also “Graphics and the Graphical User Interface” )</para>
<para>In the next segment, we activate the second pad and draw a scatter plot variables:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>myCanvas-&gt;cd(2)</code></emphasis>
root[] <emphasis role="bold"><code>MyTree-&gt;Draw("</code></emphasis><emphasis role="bold"><code>C</code></emphasis><emphasis role="bold"><code>ost:</code></emphasis><emphasis role="bold"><code>A</code></emphasis><emphasis role="bold"><code>ge")</code></emphasis>
</programlisting>

<para>This signature still only has one parameter, but it now has two dimensions separated by a colon <code>(“x:y”)</code>. The item to be plotted can be an expression not just a simple variable. In general, this parameter is a string that contains up to three expressions, one for each dimension, separated by a colon (“<code>e1:e2:e3</code>”). A list of examples follows this introduction.</para>

<sect2>
<title>Using Selection with TTree:Draw</title>
<para>Change the active pad to 3, and add a selection to the list of parameters of the draw command. </para>

<programlisting language="c++">root[] <emphasis role="bold"><code>myCanvas-&gt;cd(3)</code></emphasis>
root[] <emphasis role="bold"><code>MyTree-</code></emphasis><emphasis role="bold"><code>&gt;Draw("Cost:Age","Nation == "FR"")</code></emphasis>
</programlisting>

<para>This will draw the <code>Cost </code>vs.         <code>Age</code> for the entries where the nation is equal to “<code>FR</code>”. You can use any C++ operator, and some functions defined in <emphasis role="bold"><code>TFormula</code></emphasis>, in the selection parameter. The value of the selection is used as a weight when filling the histogram. If the expression includes only Boolean operations as in the example above, the result is 0 or 1. If the result is 0, the histogram is not filled.  In general, the expression is:</para>

<programlisting language="c++">Selection = "weight *(boolean expression)"
</programlisting>

<para>If the Boolean expression evaluates to true, the histogram is filled with a weight. If the weight is not explicitly specified it is assumed to be 1.</para>
<para>For example, this selection will add 1 to the histogram if x is less than y and the square root of z is less than 3.2. </para>

<programlisting language="c++">"x&lt;y &amp;&amp; sqrt(z)&gt;3.2"
</programlisting>

<para>On the other hand, this selection will add <code>x+y</code> to the histogram if the square root of z is larger than 3.2.</para>

<programlisting language="c++">"(x+y)*(sqrt(z)&gt;3.2)"
</programlisting>

<para>The <code>Draw</code> method has its own parser, and it only looks in the current tree for variables. This means that any variable used in the selection must be defined in the tree. You cannot use an arbitrary global variable in the <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> method. </para>
</sect2>

<sect2>
<title>Using TCut Objects in TTree::Draw</title>
<para>The <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> method also accepts <emphasis role="bold"><code>TCut</code></emphasis><emphasis role="bold"><code>G</code></emphasis> objects. A <emphasis role="bold"><code>TCut</code></emphasis> is a specialized string object used for <emphasis role="bold"><code>TTree</code></emphasis> selections. A <emphasis role="bold"><code>TCut</code></emphasis> object has a name and a title. It does not have any data members in addition to what it inherits from <emphasis role="bold"><code>TNamed</code></emphasis>. It only adds a set of operators to do logical string concatenation. For example, assume:</para>

<programlisting language="c++"><code>TCut cut1 = "x&lt;1"</code>
<code>TCut cut2 = "y&gt;2" </code>
</programlisting>

<para>then</para>

<programlisting language="c++"><code>cut1 &amp;&amp; cut2 </code>
<code>//result is the string "(x&lt;1)&amp;&amp;(y&gt;2)"</code>
</programlisting>

<para>Operators  =,  +=,  +, *,  !,  &amp;&amp;,  ||  are overloaded, here are some examples:</para>

<programlisting language="c++"><code>root[] </code>    <emphasis role="bold"><code>TCut c1 = "x &lt; 1"</code></emphasis>
<code>root[] </code>    <emphasis role="bold"><code>TCut c2 = "y &lt; 0"</code></emphasis>
<code>root[] </code>    <emphasis role="bold"><code>TCut c3 = c1 &amp;&amp; c2</code></emphasis>
<code>root[] </code>    <emphasis role="bold"><code>MyTree.Draw("x", c1)</code></emphasis>
<code>root[] </code>    <emphasis role="bold"><code>MyTree.Draw("x", c1 || "x&gt;0")</code></emphasis>
<code>root[] </code>    <emphasis role="bold"><code>MyTree.Draw("x", c1 &amp;&amp; c2)</code></emphasis>
<code>root[] </code>    <emphasis role="bold"><code>MyTree.Draw("x", "(x + y)" * (c1 &amp;&amp; c2))</code></emphasis>
</programlisting>

</sect2>

<sect2>
<title>Accessing the Histogram in Batch Mode</title>
<para>The <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> method creates a histogram called <code>htemp</code> and puts it on the active pad. In a batch program, the histogram <code>htemp</code> created by default, is reachable from the current pad.</para>

<programlisting language="c++"><emphasis role="italic">// draw the histogram</emphasis>
nt-&gt;Draw("x", "cuts");
<emphasis role="italic">// get the histogram from the current pad</emphasis>
TH1F *htemp = (TH1F*)gPad-&gt;GetPrimitive("htemp");
<emphasis role="italic">// now we have full use of the histogram</emphasis>
htemp-&gt;GetEntries();
</programlisting>

<para>If you pipe the result of the <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> into a histogram, the histogram is also available in the current directory. You can do:</para>

<programlisting language="c++"><code>// Draw the histogram and fill hnew with it</code>
nt-&gt;Draw("x&gt;&gt;hnew","cuts");
<code>// get hnew from the current directory</code>
TH1F *hnew = (TH1F*)gDirectory-&gt;Get("hnew");
<code>// or get hnew from the current Pad</code>
TH1F *hnew = (TH1F*)gPad-&gt;GetPrimitive("hnew");
</programlisting>

</sect2>

<sect2>
<title>Using Draw Options in TTree::Draw</title>
<para>The next parameter is the draw option for the histogram:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>myCanvas-&gt;cd(4)</code></emphasis>
root[] <emphasis role="bold"><code>MyTree-&gt;Draw("</code></emphasis><emphasis role="bold"><code>C</code></emphasis><emphasis role="bold"><code>ost:</code></emphasis><emphasis role="bold"><code>A</code></emphasis><emphasis role="bold"><code>ge","</code></emphasis><emphasis role="bold"><code>N</code></emphasis><emphasis role="bold"><code>ation == </code></emphasis><emphasis role="bold"><code>"FR"</code></emphasis><emphasis role="bold"><code>","surf2”);</code></emphasis>
</programlisting>

<para/>

<figure><title>Using draw options in trees</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/03000104.png" width="251.4pt" depth="209.15pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>The draw options are the same as for <emphasis role="bold"><code>TH1</code></emphasis><code>::Draw</code>. See “Draw Options” where they are listed. In addition to the draw options defined in <emphasis role="bold"><code>TH1</code></emphasis>, there are three more. The <code>'prof'</code> and <code>'profs'</code> draw a profile histogram (<emphasis role="bold"><code>TProfile</code></emphasis>) rather than a regular 2D histogram (<emphasis role="bold"><code>TH2D</code></emphasis>) from an expression with two variables. If the expression has three variables, a <emphasis role="bold"><code>TProfile2D</code></emphasis> is generated.</para>
<para>The '<code>profs</code>' generates a <emphasis role="bold"><code>TProfile</code></emphasis> with error on the spread. The '<code>prof</code>' option generates a <emphasis role="bold"><code>TProfile</code></emphasis> with error on the mean. The "<code>goff</code>" option suppresses generating the graphics.  You can combine the draw options in a list separated by commas. After typing the lines above, you should now have a canvas that looks this.</para>
</sect2>

<sect2>
<title>Superimposing Two Histograms</title>
<para>When superimposing two 2-D histograms inside a script with <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> and using the "<code>same</code>" option, you will need to update the pad between <code>Draw</code> commands. </para>

<programlisting language="c++">{ <code>// superimpose two 2D scatter plots</code>
<code>  // Create a 2D histogram and fill it with random numbers</code>
TH2 *h2 = new TH2D ("h2","2D histo",100,0,70,100,0,20000);
for (Int_t i = 0; i &lt; 10000; i++)
h2-&gt;Fill(gRandom-&gt;Gaus(40,10),gRandom-&gt;Gaus(10000,3000));
<code>// set the color to differentiate it visually</code>
h2-&gt;SetMarkerColor(kGreen);
h2-&gt;Draw();
<code>  // Open the example file and get the tree</code>
TFile f("staff.root");
TTree *myTree = (TTree*)f.Get("T");
<code>  // the update is needed for the next draw command to work properly</code>
gPad-&gt;Update();
myTree-&gt;Draw("Cost:Age", "","same");
}
</programlisting>

<para>In this example, <code>h2-&gt;Draw</code> is only adding the object h2 to the pad's list of primitives. It does not paint the object on the screen. However, <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> when called with option "<code>same</code>" gets the current pad coordinates to build an intermediate histogram with the right limits. Since nothing has been painted in the pad yet, the pad limits have not been computed. Calling <code>pad-&gt;Update</code><code>()</code> forces the painting of the pad and allows <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> to compute the right limits for the intermediate histogram.</para>
</sect2>

<sect2>
<title>Setting the Range in TTree::Draw</title>
<para>There are two more optional parameters to the <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> method: one is the number of entries and the second one is the entry to start with. For example, this command draws 1000 entries starting with entry 100:</para>

<programlisting language="c++">myTree-&gt;Draw("Cost:Age", "","",1000,100);
</programlisting>

</sect2>

<sect2>
<title>TTree::Draw Examples</title>
<para>The examples below use the <code>Event.root</code> file generated by the <code>$ROOTSYS/test/Event</code> executable and the <code>Event</code>, <code>Track</code>, and <code>EventHeader</code> class definitions are in <code>$ROOTSYS/test/Event.h</code>. The commands have been tested on the split-levels 0, 1, and 9. Each command is numbered and referenced by the explanations immediately following the examples.</para>

<programlisting language="c++"><code>// Data members and methods</code>
<code>1   tree-&gt;Draw("fNtrack");</code>
<code>2   tree-&gt;Draw("event.GetNtrack()");</code>
<code>3   tree-&gt;Draw("GetNtrack()");</code>
<code>4   tree-&gt;Draw("fH.fXaxis.fXmax");</code>
<code>5   tree-&gt;Draw("fH.fXaxis.GetXmax()");</code>
<code>6   tree-&gt;Draw("fH.GetXaxis().fXmax");</code>
<code>7   tree-&gt;Draw("GetHistogram().GetXaxis().GetXmax()");</code>
<code>// Expressions in the selection paramter</code>
<code>8   tree-&gt;Draw("fTracks.fPx","fEvtHdr.fEvtNum%10 == 0");</code>
<code>9   tree-&gt;Draw("fPx","fEvtHdr.fEvtNum%10 == 0");</code>
<code>// Two dimensional arrays defined as: Float_t  fMatrix[4][4] in Event class</code>
<code>10  tree-&gt;Draw("fMatrix");</code>
<code>11  tree-&gt;Draw("fMatrix[ ][ ]");</code>
<code>12  tree-&gt;Draw("fMatrix[2][2]");</code>
<code>13  tree-&gt;Draw("fMatrix[ ][0]");</code>
<code>14  tree-&gt;Draw("fMatrix[1][ ]");</code>
<code>// using two arrays… Float_t  fVertex[3];  in Track class</code>
<code>15  tree-&gt;Draw("fMatrix - fVertex");</code>
<code>16  tree-&gt;Draw("fMatrix[2][1]  - fVertex[5][1]");</code>
<code>17  tree-&gt;Draw("fMatrix[ ][1]  - fVertex[5][1]");</code>
<code>18  tree-&gt;Draw("fMatrix[2][ ]  - fVertex[5][ ]");</code>
<code>19  tree-&gt;Draw("fMatrix[ ][2]  - fVertex[ ][1]");</code>
<code>20  tree-&gt;Draw("fMatrix[ ][2]  - fVertex[ ][ ]");</code>
<code>21  tree-&gt;Draw("fMatrix[ ][ ]  - fVertex[ ][ ]");</code>
<code>// variable length arrays</code>
<code>22  tree-&gt;Draw("fClosestDistance");</code>
<code>23  tree-&gt;Draw("fClosestDistance[fNvertex/2]");</code>
<code>// mathematical expressions</code>
<code>24  tree-&gt;Draw("sqrt(fPx*fPx + fPy*fPy + fPz*fPz))");</code>
<code>// external function call</code>
<code>25  tree-&gt;Draw("TMath::BreitWigner(fPx,3,2)");</code>
<code>// strings</code>
<code>26  tree-&gt;Draw("fEvtHdr.fEvtNum","fType=="type1" ");</code>
<code>27  tree-&gt;Draw("fEvtHdr.fEvtNum","strstr(fType,"1" ");</code>
<code>// Where fPoints is defined in the track class:</code>
<code>//        Int_t  fNpoint; </code>
<code>//        Int_t *fPoints; [fNpoint]</code>
<code>28  tree-&gt;Draw("fTracks.fPoints");</code>
<code>29  tree-&gt;Draw("fTracks.fPoints – fTracks.fPoints[][fAvgPoints]");</code>
<code>30  tree-&gt;Draw("fTracks.fPoints[2][]- fTracks.fPoints[][55]");</code>
<code>31  tree-&gt;Draw("fTracks.fPoints[][] - fTracks.fVertex[][]");</code>
<code>// selections</code>
<code>32  tree-&gt;Draw("fValid&amp;0x1","(fNvertex&gt;10) &amp;&amp; (fNseg&lt;=6000)");</code>
<code>33  tree-&gt;Draw("fPx","(fBx&gt;.4) || (fBy&lt;=-.4)");</code>
<code>34  tree-&gt;Draw("fPx","fBx*fBx*(fBx&gt;.4) + fBy*fBy*(fBy&lt;=-.4)");</code>
<code>35  tree-&gt;Draw("fVertex","fVertex&gt;10");</code>
<code>36  tree-&gt;Draw("fPx[600]");</code>
<code>37  tree-&gt;Draw("fPx[600]","fNtrack&gt;600");</code>
<code>// alphanumeric bin histogram</code>
<emphasis role="italic"><code>// where Nation is a char* indended to be used as a string</code></emphasis>
<code>38  tree-&gt;Draw("Nation");</code>
<emphasis role="italic"><code>// where MyByte is a char* intended to be used as a byte</code></emphasis>
<code>39  tree-&gt;Draw("MyByte + 0");</code>
<emphasis role="italic"><code>// where fTriggerBits is a data member of TTrack of type TBits</code></emphasis>
<code>40  tree-&gt;Draw("fTracks.fTriggerBits");</code>
<emphasis role="italic"><code>// u</code></emphasis>sing <emphasis role="italic"><code>alternate values</code></emphasis>
<code>41  tree-&gt;Draw("fMatrix-Alt$(fClosestDistance,0)");</code>
<emphasis role="italic"><code>// u</code></emphasis>sing <emphasis role="italic"><code>meta information about the formula</code></emphasis>
<code>42  tree-&gt;Draw("fMatrix:Iteration$")</code>
<code>43</code><code> T-&gt;Draw("fLastTrack.GetPx():fLastTrack.fPx");</code>
<code>44</code><code> T-&gt;Scan("((Track*)(fLastTrack@.GetObject())).GetPx()","","");</code>
<code>45</code><code> tree-&gt;Draw("This-&gt;GetReadEntry()");</code>
<code>46  tree-&gt;Draw("mybr.mystring");</code>
<code>47  tree-&gt;Draw("myTimeStamp");</code>
</programlisting>

<sect3>
<title>Explanations:</title>
<para>
<emphasis role="bold"><code>1. </code></emphasis>
<emphasis role="bold"><code>tree-&gt;Draw("fNtrack");</code></emphasis></para>
<para>It fills the histogram with the number of tracks for each entry. <code>fNtrack</code> is a member of event. </para>
<para>
<emphasis role="bold"><code>2.</code></emphasis>
<emphasis role="bold"><code> tree-&gt;Draw("event.GetNtrack()");</code></emphasis></para>
<para>Same as case 1, but use the method of event to get the number of tracks. When using a method, you can include parameters for the method as long as the parameters are literals.</para>
<para>
<emphasis role="bold"><code>3. tree-&gt;Draw("GetNtrack()");</code></emphasis></para>
<para>Same as case 2, the object of the method is not specified. The command uses the first instance of the <code>GetNtrack</code> method found in the objects stored in the tree. We recommend using this shortcut only if the method name is unique.</para>
<para>
<emphasis role="bold"><code>4. tree-&gt;Draw</code></emphasis>
<emphasis role="bold"><code>("fH.fXaxis.fXmax"); </code></emphasis></para>
<para>Draw the data member of a data member. In the tree, each entry has a histogram. This command draws the maximum value of the X-axis for each histogram.</para>
<para>
<emphasis role="bold"><code>5.</code></emphasis>
<emphasis role="bold"><code>tree-&gt;Draw("fH.fXaxis.GetXmax()");</code></emphasis></para>
<para>Same as case 4, but use the method of a data member.</para>
<para>
<emphasis role="bold"><code>6.tree-&gt;Draw("fH.GetXaxis().fXmax");</code></emphasis></para>
<para>The same as case 4: a data member of a data member retrieved by a method.</para>
<para>
<emphasis role="bold"><code>7. </code></emphasis>
<emphasis role="bold"><code>tree-&gt;Draw("GetHis</code></emphasis>
<emphasis role="bold"><code>togram().GetXaxis().GetXmax()");</code></emphasis></para>
<para>Same as case 4, but using methods.</para>
<para>
<emphasis role="bold"><code>8.tree-&gt;Draw("fTracks.fPx","fEvtHdr.fEvtNum%10 == 0");</code></emphasis></para>
<para>Use data members in the expression and in the selection parameter to plot <code>fPx</code> or all tracks in every 10th entry. Since <code>fTracks</code> is a <emphasis role="bold"><code>TClonesArray</code></emphasis> of <code>Tracks</code>, there will be d values of <code>fPx</code> for each entry.</para>
<para>
<emphasis role="bold"><code>9. tree-&gt;Draw("</code></emphasis>
<emphasis role="bold"><code>fPx</code></emphasis>
<emphasis role="bold"><code>","fEvtHdr.fEvtNum%10 == 0</code></emphasis>
<emphasis role="bold"><code>");</code></emphasis></para>
<para>Same as case 8, use the name of the data member directly.</para>
<para>
<emphasis role="bold"><code>10.tree-&gt;Draw("fMatrix</code></emphasis>
<emphasis role="bold"><code>"</code></emphasis>
<emphasis role="bold"><code>);</code></emphasis></para>
<para>When the index of the array is left out or when empty brackets are used <code>[]</code>, all values of the array are selected. Draw all values of <code>fMatrix</code> for each entry in the tree. If <code>fMatrix</code> is defined as: <code>Float_t fMatrix[4][4]</code>, all 16 values are used for each entry.</para>
<para>
<emphasis role="bold"><code>11. </code></emphasis>
<emphasis role="bold"><code>tree-&gt;Draw("fMatrix[ ][ ]");</code></emphasis></para>
<para>The same as case 10, all values of <code>fMatrix</code> are drawn for each entry.</para>
<para>
<emphasis role="bold"><code>12. tree-&gt;Draw("</code></emphasis>
<emphasis role="bold"><code>fMatrix[2][2]");</code></emphasis></para>
<para>The single element at <code>fMatrix[2][2]</code> is drawn for each entry.</para>
<para>
<emphasis role="bold"><code>13. tree-&gt;Draw("fMatrix[</code></emphasis>

<emphasis role="bold"><code>][0]");</code></emphasis></para>
<para>Four elements of <code>fMatrix</code> are used: <code>fMatrix[1][0]</code>, <code>fMatrix[2][0]</code>, <code>fMatrix[3][0]</code>, <code>fMatrix[4][0]</code>.</para>
<para>
<emphasis role="bold"><code>14. tree-&gt;Draw(</code></emphasis>
<emphasis role="bold"><code>"fMatrix[1][ ]");</code></emphasis></para>
<para>Four elements of <code>fMatrix</code> are used: <code>fMatrix[1][0]</code>, <code>fMatrix[1][2]</code>, <code>fMatrix[1][3]</code>, <code>fMatrix[1][4]</code>.</para>
<para>
<emphasis role="bold"><code>15. tree-&gt;Draw</code></emphasis>
<emphasis role="bold"><code>("fMatrix - fVertex</code></emphasis>
<emphasis role="bold"><code>"</code></emphasis>
<emphasis role="bold"><code>);</code></emphasis></para>
<para>With two arrays and unspecified element numbers, the number of selected values is the minimum of the first dimension times the minimum of the second dimension.  In this case <code>fVertex</code> is also a two dimensional array since it is a data member of the tracks array. If <code>fVertex</code> is defined in the track class as:
<code>Float_t *fVertex[3]</code>, it has <code>fNtracks</code> x 3 elements. <code>fMatrix</code> has 4 x 4 elements.  This case, draws 4 (the smaller of <code>fNtrack</code> and 4) times 3 (the smaller of 4 and 3), meaning 12 elements per entry. The selected values for each entry are:</para>
<para>
<code>fMatrix[0][0] – fVertex[0][0]</code></para>
<para>
<code>fMatrix[0][1] – fVertex[0][1]</code></para>
<para>
<code>fMatrix[0][2] – fVertex[0][2]</code></para>
<para>
<code>fMatrix[1][0] – fVertex[1][0]</code></para>
<para>
<code>fMatrix[1][1] – fVertex[1][1]</code></para>
<para>
<code>fMatrix[1][2] – fVertex[1][2]</code></para>
<para>
<code>fMatrix[2][0] – fVertex[2][0]</code></para>
<para>
<code>fMatrix[2][1] – fVertex[2][1]</code></para>
<para>
<code>fMatrix[2][2] – fVertex[2][2]</code></para>
<para>
<code>fMatrix[3][0] – fVertex[3][0]</code></para>
<para>
<code>fMatrix[3][1] – fVertex[3][1]</code></para>
<para>
<code>fMatrix[3][2] – fVertex[3][2]</code></para>
<para>
<emphasis role="bold"><code>16. tree-&gt;Draw</code></emphasis>
<emphasis role="bold"><code>("fMatrix[2][1] - fVertex[5][1]");</code></emphasis></para>
<para>This command selects one value per entry.</para>
<para>
<emphasis role="bold"><code>17. tree-&gt;Draw</code></emphasis>
<emphasis role="bold"><code>("fMatrix[ ][1] - fVertex[5][1]");</code></emphasis></para>
<para>The first dimension of the array is taken by the <code>fMatrix</code>. </para>
<para>
<code>fMatrix[0][1] - fVertex[5][1]</code></para>
<para>
<code>fMatrix[1][1] - fVertex[5][1]</code></para>
<para>
<code>fMatrix[2][1] - fVertex[5][1]</code></para>
<para>
<code>fMatrix[3][1] - fVertex[5][1]</code></para>
<para>
<emphasis role="bold"><code>18. tree-&gt;Draw</code></emphasis>
<emphasis role="bold"><code>("("fMatrix[2][ ] - fVertex[5][ ]");</code></emphasis></para>
<para>The first dimension minimum is 2, and the second dimension minimum is 3 (from <code>fVertex</code>). Three values are selected from each entry:</para>
<para>
<code>fMatrix[2][0] - fVertex[5][0]</code></para>
<para>
<code>fMatrix[2][1] - fVertex[5][1]</code></para>
<para>
<code>fMatrix[2][2] - fVertex[5][2]</code></para>
<para>
<emphasis role="bold"><code>19. tree-&gt;Draw</code></emphasis>
<emphasis role="bold"><code>("fMatrix[ ][2] - fVertex[ ][1]")</code></emphasis></para>
<para>This is similar to case 18. Four values are selected from each entry:</para>
<para>
<code>fMatrix[0][2] - fVertex[0][1]</code></para>
<para>
<code>fMatrix[1][2] - fVertex[1][1]</code></para>
<para>
<code>fMatrix[2][2] - fVertex[2][1]</code></para>
<para>
<code>fMatrix[3][2] - fVertex[3][1]</code></para>
<para>
<emphasis role="bold"><code>20. tree-&gt;Draw</code></emphasis>
<emphasis role="bold"><code>("fMatrix[ ][2] - fVertex[ ][ ]")</code></emphasis></para>
<para>This is similar to case 19. Twelve values are selected (4x3) from each entry:</para>
<para>
<code>fMatrix[0][2] - fVertex[0][0]</code></para>
<para>
<code>fMatrix[0][2] - fVertex[0][1]</code></para>
<para>
<code>fMatrix[0][2] - fVertex[0][2]</code></para>
<para>
<code>fMatrix[1][2] - fVertex[1][0]</code></para>
<para>
<code>fMatrix[1][2] - fVertex[1][1]</code></para>
<para>
<code>fMatrix[1][2] - fVertex[1][2]</code></para>
<para>
<code>fMatrix[2][2] - fVertex[2][0]</code></para>
<para>
<code>fMatrix[2][2] - fVertex[2][1]</code></para>
<para>
<code>fMatrix[2][2] - fVertex[2][2]</code></para>
<para>
<code>fMatrix[3][2] - fVertex[3][0]</code></para>
<para>
<code>fMatrix[3][2] - fVertex[3][1]</code></para>
<para>
<code>fMatrix[3][2] - fVertex[3][2]</code></para>
<para>
<emphasis role="bold"><code>21. tree-&gt;Draw</code></emphasis>
<emphasis role="bold"><code>("fMatrix[ ][ ] - fVertex[ ][ ]")</code></emphasis></para>
<para>This is the same as case 15. The first dimension minimum is 4 (from <code>fMatrix</code>), and the second dimension minimum is 3 (from <code>fVertex</code>). Twelve values are selected from each entry.</para>
<para>
<emphasis role="bold"><code>22. tree-&gt;Draw</code></emphasis>
<emphasis role="bold"><code>("fClosestDistance")</code></emphasis></para>
<para>This event data member <code>fClosestDistance</code> is a variable length array: </para>
<para>
<code>Float_t  *fClosestDistance;   //[fNvertex]</code></para>
<para>This command selects all elements, but the number per entry depends on the number of vertices of that entry.</para>
<para>
<emphasis role="bold"><code>23. tree-&gt;Draw</code></emphasis>
<emphasis role="bold"><code>("fClosestDistance[fNvertex/2]")</code></emphasis></para>
<para>With this command the element at <code>fNvertex/2</code> of the <code>fClosestDistance </code>array is selected. Only one per entry is selected.</para>
<para>
<emphasis role="bold"><code>24. tree-&gt;Draw</code></emphasis>
<emphasis role="bold"><code>("sqrt(fPx*fPx + fPy*fPy + fPz*fPz)")</code></emphasis></para>
<para>This command shows the use of a mathematical expression. It draws the square root of the sum of the product.</para>
<para>
<emphasis role="bold"><code>25. tree-&gt;Draw("TMath::BreitWigner(fPx,3,2)")</code></emphasis></para>
<para>The formula can contains call to a function that takes numerical arguments and returns a numerical value.  The function needs to be declared to the dictionary and need to be available from the global namespace.  In particular, global functions and public static member functions can be called.</para>
<para>
<emphasis role="bold"><code>26. tree-&gt;Draw("fEvtHdr.fEvtNum","fType=="type1" ")</code></emphasis></para>
<para>You can compare strings, using the symbols == and !=, in the first two parameters of the <code>Draw</code> command (<emphasis role="bold"><code>TTree</code></emphasis><code>Formula</code>).  In this case, the event number for ‘type1’ events is plotted.</para>
<para>
<emphasis role="bold"><code>27. tree-&gt;Draw("fEvtHdr.fEvtNum","strstr(fType,"1") ")</code></emphasis></para>
<para>To compare strings, you can also use <code>strstr</code>.  In this case, events having a '1' in <code>fType</code> are selected.</para>
<para>
<emphasis role="bold"><code>28. tree-&gt;Draw("fTracks.fPoints")</code></emphasis></para>
<para>If <code>fPoints</code> is a data member of the <code>Track</code> class declared as:</para>
<para>
<code>Int_t  fNpoint;</code></para>
<para>
<code>Int_t *fPoints; [fNpoint]</code></para>
<para>The size of the array <code>fPoints</code> varies with each track of each event.  This command draws all the value in the <code>fPoints</code> arrays.</para>
<para>
<emphasis role="bold"><code>29. tree-&gt;Draw("fTracks.fPoints - fTracks.fPoints[][fAvgPoints]");</code></emphasis></para>
<para><code>When fAvgPoints</code> is a data member of the <code>Event</code> class, this example selects:</para>
<para>
<code>fTracks[0].fPoints[0] - fTracks[0].fPoint[fAvgPoints]</code></para>
<para>
<code>fTracks[0].fPoints[1] - fTracks[0].fPoint[fAvgPoints]</code></para>
<para>
<code>fTracks[0].fPoints[2] - fTracks[0].fPoint[fAvgPoints]</code></para>
<para>
<code>fTracks[0].fPoints[3] - fTracks[0].fPoint[fAvgPoints]</code></para>
<para>
<code>fTracks[0].fPoints[4] - fTracks[0].fPoint[fAvgPoints]</code></para>
<para>
<code>…</code></para>
<para>
<code>fTracks[0].fPoints[max0]- fTracks[0].fPoint[fAvgPoints]</code></para>
<para>
<code>…</code></para>
<para>
<code>fTracks[1].fPoints[0] - fTracks[1].fPoint[fAvgPoints]</code></para>
<para>
<code>fTracks[1].fPoints[1] - fTracks[1].fPoint[fAvgPoints]</code></para>
<para>
<code>fTracks[1].fPoints[2] - fTracks[1].fPoint[fAvgPoints]</code></para>
<para>
<code>fTracks[1].fPoints[3] - fTracks[1].fPoint[fAvgPoints]</code></para>
<para>
<code>fTracks[1].fPoints[4] - fTracks[1].fPoint[fAvgPoints]</code></para>
<para>
<code>…</code></para>
<para>
<code>fTracks[1].fPoints[max1]- fTracks[1].fPoint[fAvgPoints]</code></para>
<para>
<code>…</code></para>
<para>
<code>fTracks[fNtrack-1].fPoints[0] - fTracks[fNtrack-1].fPoint[fAvgPoints]</code></para>
<para>
<code>fTracks[fNtrack-1].fPoints[1] - fTracks[fNtrack-1].fPoint[fAvgPoints]</code></para>
<para>
<code>fTracks[fNtrack-1].fPoints[2] - fTracks[fNtrack-1].fPoint[fAvgPoints]</code></para>
<para>
<code>fTracks[fNtrack-1].fPoints[3] - fTracks[fNtrack-1].fPoint[fAvgPoints]</code></para>
<para>
<code>fTracks[fNtrack-1].fPoints[4] - fTracks[fNtrack-1].fPoint[fAvgPoints]</code></para>
<para>
<code>…</code></para>
<para>
<code>fTracks[fNtrack-1].fPoints[maxn] - fTracks[fNtrack-1].fPoint[fAvgPoints]</code></para>
<para>Where<code> max0</code>, <code>max1</code>,  <code>… max n</code>, is the size of the<code> fPoints </code>array for the respective track<code>.</code></para>
<para>
<emphasis role="bold"><code>30. tree-&gt;Draw("fTracks.fPoints[2][]– fTracks.fPoints[][55]") </code></emphasis></para>
<para>For each event, this expression is selected:</para>
<para>
<code>fTracks[2].fPoints[0] - fTracks[0].fPoints[55]</code></para>
<para>
<code>fTracks[2].fPoints[1] - fTracks[1].fPoints[55]</code></para>
<para>
<code>fTracks[2].fPoints[2] - fTracks[2].fPoints[55]</code></para>
<para>
<code>fTracks[2].fPoints[3] - fTracks[3].fPoints[55]</code></para>
<para>
<code>  ...</code></para>
<para>
<code>fTracks[2].fPoints[max] - fTracks[max].fPoints[55]</code></para>
<para>where max is the minimum of <code>fNtrack</code> and <code>fTracks[2].fNpoint</code>.</para>
<para>
<emphasis role="bold"><code>31. tree-&gt;Draw("fTracks.fPoints[][] - fTracks.fVertex[][]")</code></emphasis></para>
<para>For each event and each track, this expression is selected. It is the difference between <code>fPoints</code> and of <code>fVertex</code>.  The number of elements used for each track is the minimum of <code>fNpoint</code> and 3 (the size of the <code>fVertex</code> array).</para>
<para>
<code>fTracks[0].fPoints[0] - fTracks[0].fVertex[0]</code></para>
<para>
<code>fTracks[0].fPoints[1] - fTracks[0].fVertex[1]</code></para>
<para>
<code>fTracks[0].fPoints[2] - fTracks[0].fVertex[2]</code></para>
<para>
<code>// with fTracks[1].fNpoint==7</code></para>
<para>
<code>fTracks[1].fPoints[0] - fTracks[1].fVertex[0]</code></para>
<para>
<code>fTracks[1].fPoints[1] - fTracks[1].fVertex[1]</code></para>
<para>
<code>fTracks[1].fPoints[2] - fTracks[1].fVertex[2]</code></para>
<para>
<code>// with fTracks[1].fNpoint==5</code></para>
<para>
<code>fTracks[2].fPoints[0] - fTracks[1].fVertex[0]</code></para>
<para>
<code>fTracks[2].fPoints[1] - fTracks[1].fVertex[1]</code></para>
<para>
<code>// with fTracks[2].fNpoint==2</code></para>
<para>
<code>fTracks[3].fPoints[0] - fTracks[3].fVertex[0]</code></para>
<para>
<code>// with fTracks[3].fNpoint==1</code></para>
<para>
<code>fTracks[4].fPoints[0] - fTracks[4].fVertex[0]</code></para>
<para>
<code>fTracks[4].fPoints[1] - fTracks[4].fVertex[1]</code></para>
<para>
<code>fTracks[4].fPoints[2] - fTracks[4].fVertex[2] </code></para>
<para>
<code>// with fTracks[4].fNpoint==3</code></para>
<para>
<emphasis role="bold"><code>32. tree-&gt;Draw("fValid&amp;0x1","(fNvertex&gt;10) &amp;&amp; (fNseg&lt;=6000)")</code></emphasis></para>
<para>You can use bit patterns (<code>&amp;,|,&lt;&lt;</code>) or Boolean operation.</para>
<para>
<emphasis role="bold"><code>33. tree-&gt;Draw("fPx","(fBx&gt;.4) || (fBy&lt;=-.4)");</code></emphasis></para>
<para>
<emphasis role="bold"><code>34. tree-&gt;Draw("fPx","fBx*fBx*(fBx&gt;.4) + fBy*fBy*(fBy&lt;=-.4)");</code></emphasis></para>
<para>The selection argument is used as a weight. The expression returns a multiplier and in case of a Boolean the multiplier is either 0 (for false) or 1 (for true). The first command draws <code>fPx</code> for the range between 0.4 and –0.4, the second command draws <code>fPx</code> for the same range, but adds a weight using the result of the second expression.</para>
<para>
<emphasis role="bold"><code>35. tree-&gt;Draw("fVertex","fVertex&gt;10")</code></emphasis></para>
<para>When using arrays in the selection and the expression, the selection is applied to each element of the array. </para>
<para>
<code>if (fVertex[0]&gt;10) fVertex[0]</code></para>
<para>
<code>if (fVertex[1]&gt;10) fVertex[1]</code></para>
<para>
<code>if (fVertex[2]&gt;10) fVertex[2]</code></para>
<para>
<emphasis role="bold"><code>36. tree-&gt;Draw("fPx[600]")</code></emphasis></para>
<para>
<emphasis role="bold"><code>37. tree-&gt;Draw("fPx[600]","fNtrack &gt; 600")</code></emphasis></para>
<para>When using a specific element for a variable length array the entries with fewer elements are ignored. Thus these two commands are equivalent.</para>
<para>
<emphasis role="bold"><code>38. tree-&gt;Draw("Nation")</code></emphasis></para>
<para><code>Nation</code> is a <code>char*</code> branch. When drawing a <code>char*</code> it will plot an alphanumeric histogram, of the different value of the string <code>Nation</code>. The axis will have the <code>Nation</code> values. See “Histograms”.</para>
<para>
<emphasis role="bold"><code>39. tree-&gt;Draw("MyChar +0")</code></emphasis></para>
<para>If you want to plot a char* variable as a byte rather than a string, you can use the syntax above. </para>
<para>
<emphasis role="bold"><code>40. tree-&gt;Draw("fTracks.fTriggerBits")</code></emphasis></para>
<para><code>fTriggerBits</code> is a data member of <emphasis role="bold"><code>TTrack</code></emphasis> of type <emphasis role="bold"><code>TBits</code></emphasis>. Objects of class <emphasis role="bold"><code>TBits</code></emphasis> can be drawn directly.  This command will create a 1D histogram from 0 to <code>nbits</code> which is filled for each non-null bit-number. </para>
<para>
<emphasis role="bold"><code>41. tree-&gt;Draw("fMatrix-Alt$(fClosestDistance,0)")</code></emphasis></para>
<para><code>Alt$(primary,alternate)</code> returns the value of "<code>primary</code>" if it is available for the current iteration; otherwise return the value of "<code>alternate</code>".  Assuming that <code>fClosestDistance</code> is a smaller array than <code>fMatrix</code>. This example will draw <code>fMatrix[i]+fClosestDistance[i]</code> for <code>i</code> less than the size of <code>fClosestDistance</code>, and will draw <code>fMatrix[i]+0</code> for the other value of <code>i</code>.</para>
<para>
<emphasis role="bold"><code>42. tree-&gt;Draw("fClosestDistance:Iteration$")</code></emphasis></para>
<para>This example draws a 2D plot with, for all entries, <code>fClosestDistance[i]:i</code> for each value of <code>i</code> between 0 and the size of <code>fClosestDistance</code>.  <code>Iterations$</code> is one of four special variables giving some indications of the state of the loops implied by the formula:</para>
<para><code>Entry$    :</code> return the current entry number (<emphasis role="bold"><code>TTree</code></emphasis><code>::GetReadEntry()</code>)</para>
<para><code>Entries$  :</code> return the total number of entries (<emphasis role="bold"><code>TTree</code></emphasis><code>::GetEntries()</code>)</para>
<para><code>Length$   :</code> return the total number of element of this formula for this entry</para>
<para><code>Iteration$:</code> return the current iteration over this formula for this entry (i.e. varies from 0 to <code>Length$</code>).</para>
<para>
<emphasis role="bold"><code>43. T-&gt;Draw("fLastTrack.GetPx():fLastTrack.fPx");</code></emphasis></para>
<para><emphasis role="bold"><code>TRef</code></emphasis> and <emphasis role="bold"><code>TRefArray</code></emphasis> are automatically deferenced and this shows the value of the <code>fPx</code> of the track referenced by <code>fLastTrack</code>. To access the <emphasis role="bold"><code>TRef</code></emphasis> object itself use the '<code>@</code>' notation (see next example). This auto dereferencing can be extended (via an implementation of <emphasis role="bold"><code>TVirtualRefProxy</code></emphasis>) to any reference type.</para>
<para>
<emphasis role="bold"><code>44. T-&gt;Scan("((Track*)(fLastTrack@.GetObject())).GetPx()","","");</code></emphasis></para>
<para>Will cast the return value of <code>GetObject()</code> (which happens to be <emphasis role="bold"><code>TObject*</code></emphasis> in this case) before requesting the <code>GetPx()</code> member functions.</para>
<para>
<emphasis role="bold"><code>45. tree-&gt;Draw("This-&gt;GetReadEntry()");</code></emphasis></para>
<para>You can refer to the tree (or chain) containing the data by using the string '<code>This</code>'.  You can also call any <emphasis role="bold"><code>TTree</code></emphasis> methods.  Next example will display the name of the first '<code>user info</code>' object:</para>
<para>
<code>tree-&gt;Draw("This-&gt;GetUserInfo()-&gt;At(0)-&gt;GetName()");</code></para>
<para>
<emphasis role="bold"><code>46.  tree-&gt;Draw("mybr.mystring");</code></emphasis></para>
<para><emphasis role="bold"><code>TString</code></emphasis> and <code>std::string</code> object are plotted directly. The example 45 draws the same results - i.e. an histogram whose labels are the string value of '<code>mystring</code>':</para>
<para>
<code>tree-&gt;Draw("mybr.mystring.c_str()");</code></para>
<para>or</para>
<para>
<code>tree-&gt;Draw("mybr.mytstring.Data()");</code></para>
<para>
<emphasis role="bold"><code>47.  tree-&gt;Draw("myTimeStamp");</code></emphasis></para>
<para>You can plot plot objects of any class which has either <code>AsDouble</code> or <code>AsString</code> (<code>AsDouble</code> has priority). For such a class (for example <emphasis role="bold"><code>TTimeStamp</code></emphasis>), the line 46 will plot the same as:</para>
<para>
<code>tree-&gt;Draw("myTimeStamp.AsDouble");</code></para>
<para><code>AsString</code> can be returning either a <code>char*</code>, or a <emphasis role="bold"><code>TString</code></emphasis> or an <code>std::string</code>.</para>
</sect3>
</sect2>

<sect2>
<title>Using TTree::Scan</title>
<para><emphasis role="bold"><code>TTree</code></emphasis><code>::Scan</code> can be used to print the content of the tree's entries optional passing a selection.</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>MyTree-&gt;Scan();</code></emphasis>
</programlisting>

<para>will print the first 8 variables of the tree. </para>

<programlisting language="c++">root[] <emphasis role="bold"><code>MyTree-&gt;Scan("*");</code></emphasis>
</programlisting>

<para>will print all the variable of the tree.</para>
<para>Specific variables of the tree can be explicit selected by list them in column separated list:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>MyTree-&gt;Scan("var1:var2:var3");</code></emphasis>
</programlisting>

<para>will print the values of <code>var1</code>, <code>var2</code> and <code>var3</code>. A selection can be applied in the second argument:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>MyTree-&gt;Scan("var1:var2:var3","var1==0");</code></emphasis>
</programlisting>

<para>will print the values of <code>var1</code>, <code>var2</code> and <code>var3</code> for the entries where var1 is exactly 0.</para>
<para><emphasis role="bold"><code>TTree</code></emphasis><code>::Scan</code> returns the number of entries passing the selection. By default 50 rows are shown before <emphasis role="bold"><code>TTree</code></emphasis><code>::Scan</code> pauses and ask you to press the Enter key to see the next 50 rows. You can change the default number of rows to be shown before &lt;CR&gt; via <code>mytree-&gt;SetScanfield(maxrows)</code> where maxrows is 50 by default. If maxrows is set to 0 all rows of the <emphasis role="bold"><code>Tree</code></emphasis> are shown. This option is interesting when dumping the contents of a Tree to an ascii file, eg from the command line:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>tree-&gt;SetScanField(0)</code></emphasis>;
root[] <emphasis role="bold"><code>tree-&gt;Scan("*"); &gt;tree.log</code></emphasis>
</programlisting>

<para>will create a file <code>tree.log</code>.</para>
<para>Arrays (within an entry) are printed in their linear forms. If several arrays with multiple dimensions are printed together, they will NOT be synchronized.  For example, with a tree containing <code>arr1[4][2] </code>and <code>arr2[2][3]</code>,</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>MyTree("arr1:arr2");</code></emphasis>
</programlisting>

<para>will results in a printing similar to:</para>

<programlisting language="c++">************************************************
*    Row   * Instance *      arr1 *      arr2 *
***********************************************
*        x *        0 * arr1[0][0]* arr2[0][0]*
*        x *        1 * arr1[0][1]* arr2[0][1]*
*        x *        2 * arr1[1][0]* arr2[0][2]*
*        x *        3 * arr1[1][1]* arr2[1][0]*
*        x *        4 * arr1[2][0]* arr2[1][1]*
*        x *        5 * arr1[2][1]* arr2[1][2]*
*        x *        6 * arr1[3][0]*           *
*        x *        7 * arr1[3][1]*           *
</programlisting>

<para>However, if there is a selection criterium which is an array, then all the formulas will be synchronized with the selection criterium  (see <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> for more information).</para>
<para>The third parameter of <emphasis role="bold"><code>TTree</code></emphasis><code>::Scan</code> can be use to specific the layout of the table:</para>
<itemizedlist>
<listitem><para><code>lenmax=dd</code> - where 'dd' is the maximum number of elements per array that should be printed. If 'dd' is 0, all elements are printed (this is the default).</para></listitem>
<listitem><para><code>colsize=ss</code> - where 'ss' will be used as the default size for all the column. If this options is not specified, the default column size is 9.</para></listitem>
<listitem><para><code>precision=pp</code> - where 'pp' will be used as the default 'precision' for the printing format.</para></listitem>
<listitem><para><code>col=xxx</code> - where '<code>xxx</code>' is colon (:) delimited list of printing format for each column if no format is specified for a column, the default is  used.</para></listitem>
</itemizedlist>
<para>For example:</para>

<programlisting language="c++">tree-&gt;Scan("a:b:c","","colsize=30 precision=3 col=::20.10");
</programlisting>

<para>will print 3 columns, the first 2 columns will be 30 characters long, the third columns will be 20 characters long. The printf format  for the columns (assuming they are numbers) will be respectively: <code>%30.3g</code> <code>%30.3g</code> <code>%20.10g</code>.</para>
</sect2>

<sect2>
<title>TEventList and TEntryList</title>
<para>The <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw </code>method can also be used to build a list of the entries. When the first argument is preceded by <code>"&gt;&gt;"</code> ROOT knows that this command is not intended to draw anything, but to save the entries in a list with the name given by the first argument. As a result, a <emphasis role="bold"><code>TEventList</code></emphasis> or a <emphasis role="bold"><code>TEntryList</code></emphasis> object is created in the current directory. For example, to create a <emphasis role="bold"><code>TEventList</code></emphasis> of all entries with more than 600 tracks, do:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>TFile *f = new TFile("E</code></emphasis><emphasis role="bold"><code>vent.root"</code></emphasis><emphasis role="bold"><code>)</code></emphasis>;
root[] <emphasis role="bold"><code>T-&gt;Draw("&gt;&gt; myList","fNtrack &gt; </code></emphasis><emphasis role="bold"><code>600")</code></emphasis><emphasis role="bold"><code>;</code></emphasis>
</programlisting>

<para>To create a <emphasis role="bold"><code>TEntryList</code></emphasis>, use the option "<code>entrylist</code>".</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>T-&gt;Draw("&gt;&gt;myList", "fNtrack&gt;600", "entrylist")</code></emphasis><emphasis role="bold"><code>;</code></emphasis>
</programlisting>

<para>This list contains the entry number of all entries with more than 600 tracks. To see the entry numbers use the <code>Print("all")</code> command.</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>myList-&gt;Print("all");</code></emphasis>
</programlisting>

<para>When using the "<code>&gt;&gt;</code>" whatever was in the list is overwritten. The list can be grown by using the "<code>&gt;&gt;+</code>" syntax. For example to add the entries, with exactly 600 tracks:</para>


<programlisting language="c++">root[] <emphasis role="bold"><code>T-&gt;Draw("&gt;&gt;+ myList","</code></emphasis><emphasis role="bold"><code>fNtrack == 600"</code></emphasis><emphasis role="bold"><code>, </code></emphasis><emphasis role="bold"><code>"entrylist"</code></emphasis><emphasis role="bold"><code>)</code></emphasis><emphasis role="bold"><code>;</code></emphasis>
</programlisting>

<para>If the <code>Draw</code> command generates duplicate entries, they are not added to the list.</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>T-&gt;Draw("&gt;&gt;+ myList"," fNtrack &gt; 610"</code></emphasis><emphasis role="bold"><code>, </code></emphasis><emphasis role="bold"><code>"entrylist"</code></emphasis><emphasis role="bold"><code>)</code></emphasis><emphasis role="bold"><code>;</code></emphasis>
</programlisting>

<para>This command does not add any new entries to the list because all entries with more than 610 tracks have already been found by the previous command for entries with more than 600 tracks. </para>

<sect3>
<title>Main Differences between TEventList and TEntryList</title>
<para>The functionality is essentialy the same: both are used to store entry numbers. <emphasis role="bold"><code>TEntryList</code></emphasis>, however, uses considerably less memory for storage, and is optimized for both very high and very low selectivity of cuts (see <emphasis role="bold"><code>TEntryListBlock</code></emphasis> class description for the details of internal storage). Unlike the <emphasis role="bold"><code>TEventList</code></emphasis>, <emphasis role="bold"><code>TEntryList</code></emphasis> makes a distinction between indices from a <emphasis role="bold"><code>TChain</code></emphasis> and from a <emphasis role="bold"><code>TTree</code></emphasis>. While a <emphasis role="bold"><code>TEntryList</code></emphasis> for a <emphasis role="bold"><code>TTree</code></emphasis> can be seen as just a list of numbers, a <emphasis role="bold"><code>TEntryList</code></emphasis> for a <emphasis role="bold"><code>TChain</code></emphasis> is a collection of <emphasis role="bold"><code>TEntryList</code></emphasis>(s) for the <emphasis role="bold"><code>TTree</code></emphasis>(s) that constitute this <emphasis role="bold"><code>TChain</code></emphasis>. Such "sub-lists" can be extracted by calling the function </para>

<programlisting language="c++">TEntryList::GetEntryList(const char *treename, const char *filename)
</programlisting>

<para>and then be used to construct a new <emphasis role="bold"><code>TEntryList</code></emphasis> for a new <emphasis role="bold"><code>TChain</code></emphasis>, or processed independently as normal <emphasis role="bold"><code>TEntryList</code></emphasis>(s) for <emphasis role="bold"><code>TTre</code></emphasis><emphasis role="bold"><code>e</code></emphasis>(s). This modularity makes <emphasis role="bold"><code>TEntryList</code></emphasis> much better suited for PROOF processing than the <emphasis role="bold"><code>TEventList</code></emphasis>.</para>
</sect3>

<sect3>
<title>Using an Event List</title>
<para>A <emphasis role="bold"><code>TEventList</code></emphasis> or a <emphasis role="bold"><code>TEntryList</code></emphasis> can be used to limit the <emphasis role="bold"><code>TTree</code></emphasis> to the events in the list. The methods <code>SetEventList</code> and <code>SetEntryList</code> tell the tree to use the list and hence limit all subsequent calls to <code>Draw</code>, <code>Scan</code>, <code>Process</code>, <code>Query</code>, <code>Principal</code> and <code>CopyTree</code> methods to the entries in the list. In general, it affects the <code>GetEntryNumber</code> method and all functions using it for looping over the tree entries. The <code>GetEntry</code> and <code>GetEntries</code> methods are not affected. Note, that in the <code>SetEventList</code> method, the <emphasis role="bold"><code>TEventList</code></emphasis> argument is internally transformed into a <emphasis role="bold"><code>TEntryList</code></emphasis>, and this operation, in case of a <emphasis role="bold"><code>TChain</code></emphasis>, requires loading of all the tree headers. In this example, we create a list with all entries with more than 600 tracks and then set it so that the tree will use this list. To reset the <emphasis role="bold"><code>TTree</code></emphasis> to use all events use <code>SetEventList(0)</code> or <code>SetEntryList(0)</code>.</para>
<para>1) Let’s look at an example. First, open the file and draw the <code>fNtrack</code>.</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>TFile *f = new TFile("Event.root")</code></emphasis><emphasis role="bold"><code>;</code></emphasis>
root[] <emphasis role="bold"><code>TTree *T = (TTree*)f-&gt;Get("T");</code></emphasis>
root[] <emphasis role="bold"><code>T-&gt;Draw("fNtrack</code></emphasis><emphasis role="bold"><code>")</code></emphasis><emphasis role="bold"><code>;</code></emphasis>
</programlisting>

<para>2) Now, put the entries with over 600 tracks into a <emphasis role="bold"><code>TE</code></emphasis><emphasis role="bold"><code>ntry</code></emphasis><emphasis role="bold"><code>List</code></emphasis> called <code>myList</code>. We get the list from the current directory and assign it to a variable list.</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>T-&gt;Draw("&gt;&gt;myList","</code></emphasis><emphasis role="bold"><code>fNtrack &gt; 600"</code></emphasis><emphasis role="bold"><code>,</code></emphasis><emphasis role="bold"><code>"entrylist"</code></emphasis><emphasis role="bold"><code>)</code></emphasis><emphasis role="bold"><code>;</code></emphasis>
root[]<emphasis role="bold"><code>TE</code></emphasis><emphasis role="bold"><code>ntry</code></emphasis><emphasis role="bold"><code>List</code></emphasis> <emphasis role="bold"><code>*list=(</code></emphasis><emphasis role="bold"><code>TE</code></emphasis><emphasis role="bold"><code>ntry</code></emphasis><emphasis role="bold"><code>List</code></emphasis><emphasis role="bold"><code>*)gDirectory</code></emphasis><emphasis role="bold"><code>-&gt;Get("myList")</code></emphasis><emphasis role="bold"><code>;</code></emphasis>
</programlisting>

<para>3) Instruct the tree <emphasis role="bold"><code>T</code></emphasis> to use the new list and draw it again. Note that this is exactly the same <code>Draw</code> command. The list limits the entries.</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>T-&gt;SetE</code></emphasis><emphasis role="bold"><code>ntry</code></emphasis><emphasis role="bold"><code>List(list)</code></emphasis><emphasis role="bold"><code>;</code></emphasis>
root[] <emphasis role="bold"><code>T-&gt;Draw("fNtrack</code></emphasis><emphasis role="bold"><code>")</code></emphasis><emphasis role="bold"><code>;</code></emphasis>
</programlisting>

<para>You should now see a canvas similar to this one. </para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/03000105.png" width="217.25pt" depth="170.7pt"/></imageobject></inlinemediaobject>
</para>
</sect3>

<sect3>
<title>Operations on TEntryLists</title>
<para>If you have entry lists that were created using different cuts, you can combine the lists to get a new list, with entries passing at least one of the cuts. Example:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>T-&gt;Draw("&gt;&gt;list1","fNtrack&gt;600","entrylist");</code></emphasis>
root[] <emphasis role="bold"><code>TEntryList *list1 = (TEntryList*)gDirectory-&gt;Get("list1");</code></emphasis>
root[] <emphasis role="bold"><code>T-&gt;Draw("&gt;&gt;list2","fNtrack&lt;</code></emphasis><emphasis role="bold"><code>59</code></emphasis><emphasis role="bold"><code>0","entrylist");</code></emphasis>
root[] <emphasis role="bold"><code>TEntryList *list2 = (TEntryList*)gDirectory-&gt;Get("list2");</code></emphasis>
root[] <emphasis role="bold"><code>list1-&gt;Add(list2);</code></emphasis>
</programlisting>

<para><code>list1</code> now contains entries with more than 600 or less than 590 tracks. Check this by calling:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>T-&gt;SetEntryList(list1)</code></emphasis>;
root[] <emphasis role="bold"><code>T-&gt;Draw("fNtrack")</code></emphasis>;
</programlisting>

<para>You can also subtract <emphasis role="bold"><code>TEntryList</code></emphasis> from each other, so that the first list contains only the entries, passing the selection of the first list and not present in the second list. </para>
<para>To add some individual entries, use <emphasis role="bold"><code>TEntryList</code></emphasis><code>::Enter()</code> function. To remove the entries you don't like, use <emphasis role="bold"><code>TEntryList</code></emphasis><code>::Remove()</code>. To see if the entry is in the list, use <emphasis role="bold"><code>TEntryList</code></emphasis><code>::Contains()</code>. Remember, that all operation in a <emphasis role="bold"><code>TEntryList</code></emphasis> for a <emphasis role="bold"><code>TChain</code></emphasis> are on the <emphasis role="bold"><code>TTree</code></emphasis> level. This is illustrated by the following example:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>TEntryList *</code></emphasis><emphasis role="bold"><code>list1 = new TEntryList("list1",</code></emphasis><emphasis role="bold"><code>"list1");</code></emphasis>
root[] <emphasis role="bold"><code>list1-&gt;SetTree("tree1",</code></emphasis><emphasis role="bold"><code>"file1")</code></emphasis>
root[] <emphasis role="bold"><code>list1-&gt;Enter(0);</code></emphasis>
root[] <emphasis role="bold"><code>list1-&gt;Enter(2);</code></emphasis>
root[] <emphasis role="bold"><code>TEntryList *list2 = new TEntryList("list2", "list2");</code></emphasis>
root[] <emphasis role="bold"><code>list2-&gt;SetTree("tree2", "file2");</code></emphasis>
root[] <emphasis role="bold"><code>list2-&gt;Enter(0);</code></emphasis>
root[] <emphasis role="bold"><code>list2-&gt;Enter(3);</code></emphasis>
root[] <emphasis role="bold"><code>list1-&gt;Add(list2);</code></emphasis>
root[] <emphasis role="bold"><code>list1-&gt;Print("all")</code></emphasis>
tree1 file1
0
2
tree2 file2
0
3
</programlisting>

<para>The result is a <emphasis role="bold"><code>TEntryList</code></emphasis> for a <emphasis role="bold"><code>TChain</code></emphasis> of <code>tree1</code> and <code>tree2</code>. If the second list was for the same <emphasis role="bold"><code>TTree</code></emphasis> in the same file as the first list, the result would be as follows:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>TEntryList *list2_2 = new TEntryList("list2_2", "list2_2");</code></emphasis>
root[] <emphasis role="bold"><code>list2_2-&gt;SetTree("tree2", "file2");</code></emphasis>
root[] <emphasis role="bold"><code>list2_2-&gt;Enter(1);</code></emphasis>
root[] <emphasis role="bold"><code>list2_2-&gt;Enter(2);</code></emphasis>
root[] <emphasis role="bold"><code>list2-&gt;Add(list2_2);</code></emphasis>
root[] <emphasis role="bold"><code>list2-&gt;Print("all")</code></emphasis>
tree2 file2
0
1
2
3
</programlisting>

</sect3>

<sect3>
<title>TEntryListFromFile</title>
<para>This is a special kind of <emphasis role="bold"><code>TEntryList</code></emphasis>, used only when processing <emphasis role="bold"><code>TChain</code></emphasis> objects (see the method <emphasis role="bold"><code>TChain</code></emphasis><code>::SetEntryListFile()</code>). It is used in the case, when the entry lists, corresponding to the trees of this chain, are stored in separate files. It allows to load the entry lists in memory one by one, keeping only the list for the currently processed tree loaded. </para>
<para>For more details on entry lists, see <emphasis role="bold"><code>TEntryList</code></emphasis>, <emphasis role="bold"><code>TEntryListBlock</code></emphasis> and <emphasis role="bold"><code>TEntryListFromFile</code></emphasis> class descriptions, functions <emphasis role="bold"><code>TChain</code></emphasis><code>::SetEntryList()</code>, <emphasis role="bold"><code>TChain</code></emphasis><code>::SetEntryListFile()</code>, and the macro  <code>$ROOTSYS/test/stressEntryList.C</code>.</para>
</sect3>
</sect2>

<sect2>
<title>Filling a Histogram</title>
<para>The <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> method can also be used to fill a specific histogram. The syntax is:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>TFile *f = new TFile("Event.root")</code></emphasis>
root[] <emphasis role="bold"><code>T-&gt;Draw("fNtrack &gt;&gt; myHisto")</code></emphasis>
root[] <emphasis role="bold"><code>myHisto-&gt;Print()</code></emphasis>
TH1.Print Name= myHisto, Entries= 100, Total sum= 100
</programlisting>

<para>As we can see, this created a <emphasis role="bold"><code>TH1</code></emphasis>, called <code>myHisto</code>. If you want to append more entries to the histogram, you can use this syntax:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>T-&gt;Draw("fNtrack &gt;&gt;+ myHisto")</code></emphasis>
</programlisting>

<para>If you do not create a histogram ahead of time, ROOT will create one at the time of the Draw command (as is the case above). If you would like to draw the variable into a specific histogram where you, for example, set the range and bin number, you can define the histogram ahead of time and use it in the Draw command. The histogram has to be in the same directory as the tree.</para>

<programlisting language="c++">root[] <emphasis role="bold">TH1 *h1 = new TH1("h1","h1",50,0.,150.);</emphasis>
root[] <emphasis role="bold">T-&gt;Draw("fNtrack&gt;&gt; h1");</emphasis>
</programlisting>

<para>When you project a <emphasis role="bold"><code>TTree</code></emphasis> into a histogram, the histogram inherits the <emphasis role="bold"><code>TTree</code></emphasis> attributes and not the current style attributes. This allows you to project two Trees with different attributes into the same picture. You can call the method <emphasis role="bold"><code>TTree</code></emphasis><code>::UseCurrentStyle</code> to change the histogram to use the current style <emphasis role="italic"><emphasis role="bold"><code>gStyle</code></emphasis></emphasis>. See “Graphics and the Graphical User Interface.</para>
<para>The binning of the newly created histogram can be specified in two ways. You can set a default in the <code>.rootrc</code> and/or you can add the binning information in the <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> command.</para>
<para>To set number of bins default for the 1-D, 2-D, 3-D histograms can be specified in the <code>.rootrc</code> file via the environment variables, e.g.:</para>

<programlisting language="c++"><emphasis role="bold"><code># default binnings</code></emphasis>   <code>Hist.Binning.1D.x: 100</code>

<code>Hist.Binning.2D.x: 40</code>
<code>Hist.Binning.2D.y: 40</code>
<code>Hist.Binning.2D.Prof: 100</code>

<code>Hist.Binning.3D.x: 20</code>
<code>Hist.Binning.3D.y: 20</code>
<code>Hist.Binning.3D.z: 20</code>
<code>Hist.Binning.3D.Profx: 100</code>
<code>Hist.Binning.3D.Profy: 100</code>
</programlisting>

<para>To set the number of bins for a specific histogram when using <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw,</code> add up to nine numbers following the histogram name. The numbers meaning is:</para>
<para>1 bins in x-direction</para>
<para>2 lower limit in x-direction</para>
<para>3upper limit in x-direction</para>
<para>4-6 same for y-direction</para>
<para>7-9 same for z-direction</para>
<para>When a bin number is specified, the value becomes the default. Any of the numbers can be skipped. For example:</para>

<programlisting language="c++"><code>tree.Draw("sqrt(x)&gt;&gt;hsqrt(500,10,20)";</code>
<emphasis role="italic"><code>// plot sqrt(x) between 10 and 20 using 500 bins</code></emphasis>
<code>tree.Draw("sqrt(x):sin(y)&gt;&gt;hsqrt(100,10,,50,.1,.5)";</code>
<emphasis role="italic"><code>// plot sqrt(x) against sin(y) 100 bins in x-direction;</code></emphasis>
<emphasis role="italic"><code>// lower limit on x-axis is 10; no upper limit</code></emphasis>
<emphasis role="italic"><code>// 50 bins in y-direction; lower limit on y-axis is .1; upper limit is .5 </code></emphasis>
</programlisting>

<para>When the name is followed by binning information, appending the histogram with a "+", will not reset <code>hsqrt</code>, but will continue to fill it.</para>

<programlisting language="c++"><code>tree.Draw("sqrt(x)&gt;&gt;+hsqrt","y&gt;0");</code>
</programlisting>

<para>This works for 1-D, 2-D and 3-D histograms.</para>

<sect3>
<title>Projecting a Histogram</title>
<para>If you would like to fill a histogram, but not draw it you can use the <emphasis role="bold"><code>TTree</code></emphasis><code>::Project()</code>         method.</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>T-&gt;Project("quietHisto","fNtrack")</code></emphasis>
</programlisting>

</sect3>

<sect3>
<title>Making a Profile Histogram</title>
<para>In case of a two dimensional expression, you can generate a <emphasis role="bold"><code>TProfile</code></emphasis> histogram instead of a two dimensional histogram by specifying the <code>'prof'</code> or '<code>profs'</code> option. The <code>prof</code> option is automatically selected when the output is redirected into a <emphasis role="bold"><code>TProfile</code></emphasis>. For example <code>y:x&gt;&gt;pf</code> where <code>pf </code>is an existing <emphasis role="bold"><code>TProfile</code></emphasis> histogram.</para>
</sect3>

<sect3>
<title>Tree Information</title>
<para>Once we have drawn a tree, we can get information about the tree. These are the methods used to get information from a drawn tree <emphasis role="bold"><code>TTree</code></emphasis>:</para>
<itemizedlist>
<listitem><para><code>GetSelectedRows</code>: Returns the number of entries accepted by the selection expression. In case where no selection was specified, it returns the number of entries processed. </para></listitem>
<listitem><para><code>GetV1</code>: Returns a pointer to the float array of the first variable.</para></listitem>
<listitem><para><code>GetV2</code>: Returns a pointer to the float array of second variable </para></listitem>
<listitem><para><code>GetV3</code>: Returns a pointer to the float array of third variable.</para></listitem>
<listitem><para><code>GetW</code>: Returns a pointer to the float array of Weights where the weight equals the result of the selection expression.</para></listitem>
</itemizedlist>
<para>To read the drawn values of <code>fNtrack</code> into an array, and loop through the entries follow the lines below. First, open the file and draw the <code>fNtrack</code> variable:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>TFile *f = new TFile("Event.root")</code></emphasis>
root[] <emphasis role="bold"><code>T-&gt;Draw("fNtrack")</code></emphasis>
</programlisting>

<para>Then declare a pointer to a float and use the GetV1 method to retrieve the first dimension of the tree. In this example we only drew one dimension (<code>fNtrack</code>) if we had drawn two, we could use GetV2 to get the second one.</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>Float_t *a</code></emphasis>
root[] <emphasis role="bold"><code>a = T-&gt;GetV1()</code></emphasis>
</programlisting>

<para>Loop through the first 10 entries and print the values of <code>fNtrack</code>:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>for (int i = 0; i &lt; 10; i++) </code></emphasis>
<code>root[]</code><emphasis role="bold"><code> cout &lt;&lt; a[i] &lt;&lt; " " &lt;&lt; endl    </code></emphasis><code>// need an endl to see the values</code>
594 597 606 595 604 610 604 602 603 596
</programlisting>

<para>By default, <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> creates these arrays with <code>fEstimate</code> words where <code>fEstimate</code> can be set via <emphasis role="bold"><code>TTree</code></emphasis><code>::SetEstimate</code>. If you have more entries than <code>fEstimate</code> only the first <code>fEstimate</code> selected entries will be stored in the arrays. The arrays are used as buffers. When <code>fEstimate</code> entries have been processed, ROOT scans the buffers to compute the minimum and maximum of each coordinate and creates the corresponding histograms. You can use these lines to read all entries into these arrays:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>Int_t nestimate = (Int_t)T-&gt;GetEntries();</code></emphasis>
 root[] <emphasis role="bold"><code>T-&gt;SetEstimate(nestimate);</code></emphasis>
</programlisting>

<para>Obviously, this will not work if the number of entries is very large. This technique is useful in several cases, for example if you want to draw a graph connecting all the <code>x</code>, <code>y(or z)</code> points. Note that you may have a tree (or chain) with 1 billion entries, but only a few may survive the cuts and will fit without problems in these arrays.</para>
</sect3>
</sect2>
</sect1>

<sect1>
<title>Using TTree::MakeClass</title>
<para>The <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> method is convenient and easy to use; however it falls short if you need to do some programming with the variable. </para>
<para>For example, for plotting the masses of all oppositely changed pairs of tracks, you would need to write a program that loops over all events, finds all pairs of tracks, and calculates the required quantities. We have shown how to retrieve the data arrays from the branches of the tree in the previous section, and you could just write that program from scratch. Since this is a very common task, ROOT provides a utility that generates a skeleton class designed to loop over the entries of the tree. </para>
<para>This is the <emphasis role="bold"><code>TTree</code></emphasis><code>::MakeClass</code> method. We will now go through the steps of using <code>MakeClass</code> with a simplified example. The methods used here obviously work for complex event loop calculations.</para>
<para>These are our assumptions: we would like to do selective plotting and loop through each entry of the tree and tracks. We chose a simple example: we want to plot <code>fPx</code> of the first 100 tracks of each entry. We have a ROOT tree with a branch for each data member in the "<code>Event</code>" object. To build this file and tree follow the instructions on how to build the examples in <code>$ROOTSYS/test</code>. Execute <code>Event</code> and instruct it to split the object with this command (from the UNIX command line).</para>

<programlisting language="c++">&gt; <emphasis role="bold"><code>$ROOTSYS/test/Event 400 1 2 1</code></emphasis>
</programlisting>

<para>This creates an <code>Event.root</code> file with 400 events, compressed, split, and filled. </para>
<para>See <code>$ROOTSYS/test/MainEvent.cxx</code> for more info.</para>
<para>The person who designed the tree makes a shared library available to you, which defines the classes needed. In this case, the classes are Event, <code>EventHeader</code>, and Track and they are defined in the shared library <code>libEvent.so</code>. The designer also gives you the <code>Event.h</code> file to see the definition of the classes. You can locate <code>Event.h</code> in <code>$ROOTSYS/test</code>, and if you have not yet built <code>libEvent.so</code>, please see the instructions of how to build it (typing make in $ROOTSYS/test is enough). If you have already built it, you can now use it again.</para>

<sect2>
<title>Creating a Class with MakeClass</title>
<para>First, we load the shared library and open <code>Event.root</code>.</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>.L libEvent.so </code></emphasis>
root[] <emphasis role="bold"><code>TFile</code></emphasis><emphasis role="bold"><code> *f = new TFile("Event.root");</code></emphasis>
root[] <emphasis role="bold"><code>f-&gt;ls(); </code></emphasis>
TFile**         Event.root      TTree benchmark ROOT file
TFile*         Event.root      TTree benchmark ROOT file
KEY: TH1F     htime;1 Real-Time to write versus time
KEY: TTree    T;1     An example of a ROOT tree
</programlisting>

<para>We can see there is a tree “<code>T</code>”, and just to verify that we are working with the correct one, we print the tree, which will show us the header and branches. </para>

<programlisting language="c++">root[] <emphasis role="bold"><code>T-&gt;Print();</code></emphasis>
</programlisting>

<para>From the output of print we can see that the tree has one branch for each data member of <code>Event</code>, <code>Track</code>, and <code>EventHeader</code>. Now we can use <emphasis role="bold"><code>TTree</code></emphasis><code>::MakeClass</code> on our tree “<code>T</code>”. <code>MakeClass</code> takes one parameter, a string containing the name of the class to be made. In the command below, the name of our class will be “<code>MyClass</code>”.</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>T-&gt;MakeClass</code></emphasis><emphasis role="bold"><code>("MyClass")</code></emphasis>
Files: MyClass.h and MyClass.C generated from Tree: T
</programlisting>

<para>CINT informs us that it has created two files. <code>MyClass.</code>h contains the class definition and <code>MyClass.C</code> contains the <code>MyClass::Loop()</code> method. <code>MyClass</code> has more methods than just <code>Loop()</code>. The other methods are a constructor, a destructor, <code>GetEntry()</code>, <code>LoadTree()</code>, <code>Notify()</code>, <code>Cut()</code> and <code>Show()</code>. The implementations of these methods are in the .h file. This division of methods was done intentionally. The .C file is kept as short as possible, and contains only code that is intended for you to customize. The .h file contains all the other methods. It is clear that you want to be as independent as possible of the header file (i.e. <code>MyClass.h</code>) generated by <code>MakeClass</code>. The solution is to implement a derived class, for example <code>MyRealClass</code> deriving from <code>MyClass</code> such that a change in your <code>Tree </code>or regeneration of <code>MyClass.h</code> does not force you to change <code>MyRealClass.h</code>. You can imagine deriving several classes from <code>MyClass.h</code>, each with a specific algorithm. To understand both files, let’s start with <code>MyClass.h</code> and the class declaration:</para>
</sect2>

<sect2>
<title>MyClass.h</title>

<programlisting language="c++"><code>class MyClass {</code>
public :
<code>//pointer to the analyzed TTree or TChain</code>
TTree          *fChain;
<code>   //current Tree number in a TChain</code>
Int_t           fCurrent;
<code>   //Declaration of leaves types</code>
UInt_t          fUniqueID;
UInt_t          fBits;
Char_t          fType[20];
Int_t           fNtrack;
Int_t           fNseg;
Int_t           fNvertex;
UInt_t          fFlag;
Float_t         fTemperature;
Int_t           fEvtHdr_fEvtNum;
<code>   //List of branches</code>
TBranch        *b_fUniqueID;
TBranch        *b_fBits;
TBranch        *b_fType;
TBranch        *b_fNtrack;
TBranch        *b_fNseg;
TBranch        *b_fNvertex;
TBranch        *b_fFlag;
TBranch        *b_fTemperature;
TBranch        *b_fEvtHdr_fEvtNum;
…
MyClass(TTree *tree=0);
~MyClass();
Int_t  Cut(Int_t entry);
Int_t  GetEntry(Int_t entry);
Int_t  LoadTree(Int_t entry);
void   Init(TTree *tree);
void   Loop();
Bool_t Notify();
void   Show(Int_t entry = -1);
};
</programlisting>

<para>We can see data members in the generated class. The first data member is <code>fChain</code>. Once this class is instantiated, <code>fChain</code> will point to the original tree or chain this class was made from. In our case, this is “T” in “<code>Event.root</code>”. If the class is instantiated with a tree as a parameter to the constructor, <code>fChain</code> will point to the tree named in the parameter. Next is <code>fCurrent</code>, which is also a pointer to the current tree/chain. Its role is only relevant when we have multiple trees chained together in a <emphasis role="bold"><code>TChain</code></emphasis>. The class definition shows us that this tree has one branch and one leaf per data member. The methods of <code>MyClass</code> are:</para>
<itemizedlist>
<listitem><para><code>MyClass(</code><emphasis role="bold"><code>TTree</code></emphasis><code> *tree=0) - t</code>his constructor has an optional tree for a parameter. If you pass a tree, <code>MyClass</code> will use it rather than the tree from which it was created.</para></listitem>
<listitem><para><code>void  Init(</code><emphasis role="bold"><code>TTree</code></emphasis><code> *tree) –</code> it is called by the constructor to initialize the tree for reading. It associates each branch with the corresponding leaf data member.</para></listitem>
<listitem><para><code>~MyClass() - </code>the destructor, nothing special.</para></listitem>
<listitem><para><code>Int_t GetEntry(Int_t entry) -</code> it loads the class with the entry specified. Once you have executed <code>GetEntry</code>, the leaf data members in <code>MyClass</code> are set to the values of the entry. For example, <code>GetEntry(12)</code> loads the 13th event into the event data member of <code>MyClass</code> (note that the first entry is 0).  <code>GetEntry</code> returns the number of bytes read from the file. In case the same entry is read twice, ROOT does not have to do any I/O. In this case <code>GetEntry</code> returns 1. It does not return 0, because many people assume a return of 0 means an error has occurred while reading.</para></listitem>
<listitem><para><code>Int_t LoadTree(Int_t entry)</code> and <code>void  Notify()</code> - these two methods are related to chains. <code>LoadTree</code> will load the tree containing the specified entry from a chain of trees. Notify is called by <code>LoadTree</code> to adjust the branch addresses.</para></listitem>
<listitem><para><code>void Loop()</code>         - it is the skeleton method that loops through each entry of the tree. This is interesting to us, because we will need to customize it for our analysis.</para></listitem>
</itemizedlist>
</sect2>

<sect2>
<title>MyClass.C</title>
<para><code>MyClass::Loop</code> consists of a for-loop calling <code>GetEntry</code> for each entry.  In the template, the numbers of bytes are added up, but it does nothing else. If we were to execute it now, there would be no output.</para>

<programlisting language="c++"><code>void MyClass::Loop()</code>         {
if (fChain == 0) return;

Int_t nentries = Int_t(fChain-&gt;GetEntries());
Int_t nbytes = 0, nb = 0;
for (Int_t jentry=0; jentry&lt;nentries;jentry++) {
Int_t ientry = LoadTree(jentry);
<code>// in case of a TChain</code>   <code>, ientry is the entry number in the current file</code>
nb = fChain-&gt;GetEntry(jentry);   nbytes += nb;
<emphasis role="italic"><code>      // if (Cut(ientry) &lt; 0) continue;</code></emphasis>
}
}
</programlisting>

<para>At the beginning of the file are instructions about reading selected branches. They are not reprinted here, but please read them from your own file</para>
</sect2>

<sect2>
<title>Modifying MyClass::Loop</title>
<para>Let us continue with the goal of going through the first 100 tracks of each entry and plot <code>Px</code>. To do this we change the Loop method.</para>

<programlisting language="c++">…
if (fChain == 0) return;
Int_t nentries = Int_t(fChain-&gt;GetEntries());
TH1F *myHisto  = new TH1F("myHisto","fPx", 100, -5,5);
TH1F *smallHisto = new TH1F("small","fPx", 100, -5,5);
…
</programlisting>

<para>In the for-loop, we need to add another for-loop to go over all the tracks.  In the outer for-loop, we get the entry and the number of tracks. In the inner for-loop, we fill the large histogram (<code>myHisto</code>) with all tracks and the small histogram (<code>smallHisto</code>) with the track if it is in the first 100. </para>

<programlisting language="c++">…
for (Int_t jentry=0; jentry&lt;nentries;jentry++) {
GetEntry(jentry);
for (Int_t j = 0; j &lt; 100; j++){
myHisto-&gt;Fill(fTracks_fPx[j]);
if (j &lt; 100){
smallHisto-&gt;Fill(fTracks_fPx[j]);
}
}
}
…
</programlisting>

<para>Outside of the for-loop, we draw both histograms on the same canvas.</para>

<programlisting language="c++">…
myHisto-&gt;Draw();
smallHisto-&gt;Draw("Same");
…
</programlisting>

<para>Save these changes to <code>MyClass.C</code> and start a fresh root session. We will now load <code>MyClass</code> and experiment with its methods.</para>
</sect2>

<sect2>
<title>Loading MyClass</title>
<para>The first step is to load the library and the class file. Then we can instantiate a <code>MyClass</code> object.</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>.L libEvent.so</code></emphasis>
root[] <emphasis role="bold"><code>.L MyClass.C</code></emphasis>
root[] <emphasis role="bold"><code>MyClass m</code></emphasis>
</programlisting>

<para>Now we can get a specific entry and populate the event leaf. In the code snipped below, we get entry 0, and print the number of tracks (594). Then we get entry 1 and print the number of tracks (597).</para>

<programlisting language="c++"><code>root[] </code><emphasis role="bold"><code>m.GetEntry(0)</code></emphasis>
<code>(int)57503</code>
<code>root[] </code><emphasis role="bold"><code>m.fNtrack()</code></emphasis>
<code>(Int_t)594</code>
<code>root[] </code><emphasis role="bold"><code>m.GetEntry(1)</code></emphasis>
<code>(int)48045</code>
<code>root[] </code><emphasis role="bold"><code>m.fNtrack()</code></emphasis>
<code>(Int_t)597</code>
</programlisting>

<para>Now we can call the <code>Loop</code> method, which will build and display the two histograms.</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>m.Loop() </code></emphasis>
</programlisting>

<para>You should now see a canvas that looks like this.</para>
<para> <inlinemediaobject><imageobject><imagedata fileref="pictures/03000106.png" width="254.5pt" depth="202.95pt"/></imageobject></inlinemediaobject> </para>
<para>To conclude the discussion on <code>MakeClass</code> let us lists the steps that got us here.</para>
<itemizedlist>
<listitem><para>Call <emphasis role="bold"><code>TTree</code></emphasis><code>::MakeClass</code>, which automatically creates a class to loop over the tree.</para></listitem>
<listitem><para>Modify the <code>MyClass::Loop()</code> method in <code>MyClass.C</code> to fit your task.</para></listitem>
<listitem><para>Load and instantiate <code>MyClass</code>, and run <code>MyClass::Loop()</code>.</para></listitem>
</itemizedlist>
</sect2>
</sect1>

<sect1>
<title>Using TTree::MakeSelector</title>
<para>With a <emphasis role="bold"><code>TTree</code></emphasis> we can make a selector and use it to process a limited set of entries. This is especially important in a parallel processing configuration where the analysis is distributed over several processors and we can specify which entries to send to each processor. The <emphasis role="bold"><code>TTree</code></emphasis><code>::Process</code> method is used to specify the selector and the entries. Before we can use <emphasis role="bold"><code>TTree</code></emphasis><code>::Process</code> we need to make a selector.  We can call the <emphasis role="bold"><code>TTree</code></emphasis><code>::MakeSelector</code> method. It creates two files similar to <emphasis role="bold"><code>TTree</code></emphasis><code>::MakeClass</code>. </para>
<para>In the resulting files is a class that is a descendent of <emphasis role="bold"><code>TSelector</code></emphasis> and implements the following methods:</para>
<itemizedlist>
<listitem><para><emphasis role="bold"><code>TSelector</code></emphasis><code>::Begin()</code>         <code>-</code> this method is called every time a loop over the tree starts. This is a convenient place to create your histograms.</para></listitem>
<listitem><para><emphasis role="bold"><code>TSelector</code></emphasis><code>::Notify()</code>         <code>-</code> it is called at the first entry of a new tree in a chain.</para></listitem>
<listitem><para><emphasis role="bold"><code>TSelector</code></emphasis><code>::Process()</code>         <code>-</code> it is called to process an event. It is the user's responsibility to read the corresponding entry in memory (may be just a partial read). Once the entry is in memory one can apply a selection and if the event is selected histograms can be filled. Processing stops when this function returns <code>kFALSE</code>. It combines the methods <emphasis role="bold"><code>TSelector</code></emphasis><code>::ProcessCut()</code> and <emphasis role="bold"><code>TSelector</code></emphasis><code>::ProcessFill()</code> in one, avoiding the necessity to maintain the state in the class to communicate between these two functions. It reduces the information that needs to be shared between them and promotes a more granular data access by reading branches as they are needed.</para></listitem>
<listitem><para><emphasis role="bold"><code>TSelector</code></emphasis><code>::Terminate() -</code> it is called at the end of a loop on a <emphasis role="bold"><code>TTree</code></emphasis>. This is a convenient place to draw and fit your histograms.         </para></listitem>
<listitem><para><emphasis role="bold"><code>TSelector</code></emphasis><code>::Version()</code>         <code>-</code> this function provides backward compatibility for old versions and support for the future upgrades.</para></listitem>
<listitem><para>The <emphasis role="bold"><code>TSelector</code></emphasis>, unlike the resulting class from <code>MakeClass</code>, separates the processing into a <code>ProcessCut()</code> and <code>ProcessFill()</code>, so we can limit reading of branches to the ones we need.</para></listitem>
<listitem><para>When a selector is used with a <emphasis role="bold"><code>TChain</code></emphasis> in methods         <code>Process()</code>, <code>ProcessFill()</code>, <code>ProcessCut()</code>, you must use the pointer to the current <emphasis role="bold"><code>TTree</code></emphasis> to call the method <code>GetEntry(entry)</code>. The parameter <code>entry</code> is always the local entry number in the current tree. Assuming that <code>fChain</code> is the pointer to the <emphasis role="bold"><code>TChain</code></emphasis> being processed, use</para></listitem>
</itemizedlist>
<programlisting language="c++">fChain-&gt;GetTree()-&gt;GetEntry(entry);
</programlisting>

<para>To create a selector call:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>T-&gt;MakeSelector("MySelector");</code></emphasis>
</programlisting>

<para>Where <code>T</code> is the <emphasis role="bold"><code>TTree</code></emphasis> and <code>MySelector</code> is the name of created class and the name of the <code>.h</code> and <code>.C</code> files. The resulting <emphasis role="bold"><code>TSelector</code></emphasis> is the argument to <emphasis role="bold"><code>TTree</code></emphasis><code>::Process</code>. The argument can be the file name or a pointer to the selector object. </para>

<programlisting language="c++">root[] <emphasis role="bold"><code>T-&gt;Process("MySelector.C","",1000,100);</code></emphasis>
</programlisting>

<para>This call will interpret the class defined in <code>MySelector.C</code> and process 1000 entries beginning with entry 100. The file name can be appended with a "+" or a "++" to use <code>ACLiC</code>.</para>

<programlisting language="c++">root[]<emphasis role="bold"><code> T-&gt;Process("MySelector.C++","",1000,100);</code></emphasis>
</programlisting>

<para>When appending a "++", the class will be compiled and dynamically loaded.</para>

<programlisting language="c++"><code>root[]</code><emphasis role="bold"><code> T-&gt;Process("MySelector.C+","",1000,100);</code></emphasis>
</programlisting>

<para>When appending a "+", the class will also be compiled and dynamically loaded. When it is called again, it recompiles only if the macro (<code>MySelector.C</code>) has changed since it was compiled last. If not, it loads the existing library. The next example shows how to create a selector with a pointer:</para>

<programlisting language="c++"><code>MySelector *selector = (MySelector *)TSelector::GetSelector(“MySelector.C+”);</code>
<code>T-&gt;Process(selector);</code>
</programlisting>

<para><code>Using this form, you can do things like:</code></para>

<programlisting language="c++"><code>selector-&gt;public_attribute1 = init_value;</code>
<code>for (int i=0; i&lt;limit; i++) {</code>
<code>T-&gt;Process(selector);</code>
<code>   selector-&gt;public_attribute1 = function(selector-&gt;public_attribute2);</code>
<code>}</code>
</programlisting>

<para><emphasis role="bold"><code>TTree</code></emphasis><code>::Process()</code> is aware of PROOF, ROOT parallel processing facility. If PROOF is setup, it divides the processing amongst the slave CPUs. </para>

<sect2>
<title>Performance Benchmarks</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/03000107.png" width="182.5pt" depth="250.75pt"/></imageobject></inlinemediaobject>
</para>
<para>The program <code>$ROOTSYS/test/bench.cxx</code> compares the I/O performance of STL vectors to the ROOT native <emphasis role="bold"><code>TClonesArray</code></emphasis><code>s</code> collection class. It creates trees with and without compression for the following cases: <code>vector&lt;THit&gt;</code>, <code>vector&lt;THit*&gt;</code>, <emphasis role="bold"><code>TClonesArray</code></emphasis><code>(</code><emphasis role="bold"><code>TObjHit</code></emphasis><code>)</code> <code>not split </code><emphasis role="bold"><code>TClonesArray</code></emphasis><code>(</code><emphasis role="bold"><code>TObjHit</code></emphasis><code>)</code> <code>split.</code></para>
<para><code>The next graphs show the two columns on the right which represent the split and non-split </code><emphasis role="bold"><code>TClonesArray</code></emphasis><code>, </code>are significantly lower than the vectors. The most significant difference is in reading a file without compression. </para>
<para>The file size with compression, write times with and without compression and the read times with and without compression all favor the <emphasis role="bold"><code>TClonesArray</code></emphasis>. </para>
</sect2>
</sect1>

<sect1>
<title>Impact of Compression on I/O</title>
<para>This benchmark illustrates the pros and cons of the compression option. We recommend using compression when the time spent in I/O is small compared to the total processing time. In this case, if the I/O operation is increased by a factor of 5 it is still a small percentage of the total time and it may very well save a factor of 10 on disk space. On the other hand if the time spend on I/O is large, compression may slow down the program's performance. The standard test program <code>$ROOTSYS/test/Event</code> was used in various configurations with 400 events. The data file contains a <emphasis role="bold"><code>TTree</code></emphasis>. The program was invoked with: </para>

<programlisting language="c++">Event 400 comp split
</programlisting>

<itemizedlist>
<listitem><para>comp = 0 means: no compression at all. </para></listitem>
<listitem><para>comp = 1 means: compress everything if split = 0. </para></listitem>
<listitem><para>comp = 1 means: compress only the tree branches with integers if split = 1. </para></listitem>
<listitem><para>comp = 2 means: compress everything if split=1. </para></listitem>
<listitem><para>split = 0 : the full event is serialized into one single buffer. </para></listitem>
<listitem><para>split = 1 : the event is split into branches. One branch for each data member of the Event class. The list of tracks (a <emphasis role="bold"><code>TClonesArray</code></emphasis>) has the data members of the Track class also split into individual buffers. </para></listitem>
</itemizedlist>
<para>These tests were run on Pentium III CPU with 650 MHz.</para>
<informaltable frame="all">
<tgroup cols="6">
<colspec colwidth="1345*" colname="column-1"/>
<colspec colwidth="791*" colname="column-2"/>
<colspec colwidth="1658*" colname="column-3"/>
<colspec colwidth="1661*" colname="column-4"/>
<colspec colwidth="1759*" colname="column-5"/>
<colspec colwidth="1809*" colname="column-6"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>Event Parameters</para>
</entry>
<entry rowsep="1" colsep="1">
<para>File Size </para>
</entry>
<entry rowsep="1" colsep="1">
<para>Total Time to Write (MB/sec)</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Effective Time to Write (MB/sec)</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Total Time to Read All (MB/sec)</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Total Time to Read Sample (MB/sec)</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>Comp = 0 </para>
<para>Split = 1</para>
</entry>
<entry rowsep="1" colsep="1">
<para>19.75 MB</para>
</entry>
<entry rowsep="1" colsep="1">
<para>6.84 s.(2.8 MB/s)</para>
</entry>
<entry rowsep="1" colsep="1">
<para>3.56 s.(5.4 MB/s)</para>
</entry>
<entry rowsep="1" colsep="1">
<para>0.79s.(24.2 MB/s)</para>
</entry>
<entry rowsep="1" colsep="1">
<para>0.79 s.(24.2 MB/s)</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>Comp = 1 </para>
<para>Split   = 1</para>
</entry>
<entry rowsep="1" colsep="1">
<para>17.73 MB</para>
</entry>
<entry rowsep="1" colsep="1">
<para>6.44 s.(3.0 MB/s)</para>
</entry>
<entry rowsep="1" colsep="1">
<para>4.02 s.(4.8 MB/s)</para>
</entry>
<entry rowsep="1" colsep="1">
<para>0.90 s.(21.3 MB/s)</para>
</entry>
<entry rowsep="1" colsep="1">
<para>0.90 s.(21.3 MB/s)</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>Comp = 2 </para>
<para>Split   = 1</para>
</entry>
<entry rowsep="1" colsep="1">
<para>13.78 MB</para>
</entry>
<entry rowsep="1" colsep="1">
<para>11.34s.(1.7 MB/s)</para>
</entry>
<entry rowsep="1" colsep="1">
<para>9.51 s.(2.0 MB/s)</para>
</entry>
<entry rowsep="1" colsep="1">
<para>2.17 s.(8.8 MB/s)</para>
</entry>
<entry rowsep="1" colsep="1">
<para>2.17 s.(8.8 MB/s)</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>The <emphasis role="bold">Total Time</emphasis> is the real time in seconds to run the program. <emphasis role="bold">Effective time</emphasis> is the real time minus the time spent in non I/O operations (essentially the random number generator). The program <code>Event</code> generates in average 600 tracks per event. Each track has 17 data members. The read benchmark runs in the interactive version of ROOT. The ‘Total Time to Read All’ is the real time reported by the execution of the script <code>&amp;ROOTSYS/test/eventa</code>. </para>
<para>We did not correct this time for the overhead coming from the interpreter itself. The <emphasis role="bold">Total time to read sample</emphasis> is the execution time of the script <code>$ROOTSYS/test/eventb</code>. This script loops on all events. For each event, the branch containing the number of tracks is read. In case the number of tracks is less than 585, the full event is read in memory. This test is obviously not possible in non-split mode. In non-split mode, the full event must be read in memory. The times reported in the table correspond to complete I/O operations necessary to deal with <emphasis role="bold">machine independent binary files</emphasis>. On <emphasis role="bold">Linux</emphasis>, this also includes byte-swapping operations. The ROOT file allows for direct access to any event in the file and direct access to any part of an event when split=1. </para>
<para>Note also that the uncompressed file generated with split=0 is 48.7 Mbytes and only 47.17 Mbytes for the option split=1. The difference in size is due to the object identification mechanism overhead when the event is written to a single buffer. This overhead does not exist in split mode because the branch buffers are optimized for homogeneous data types. You can run the test programs on your architecture. The program <code>Event</code> will report the write performance. You can measure the read performance by executing the scripts <code>eventa</code> and <code>eventb</code>. The performance depends not only of the processor type, but also of the disk devices (local, NFS, AFS, etc.). </para>
</sect1>

<sect1>
<title>Chains</title>
<para>A <emphasis role="bold"><code>TChain</code></emphasis> object is a list of ROOT files containing the same tree. As an example, assume we have three files called <code>file1.root, file2.root, file3.root</code>. Each file contains one tree called "<code>T</code>". We can create a chain with the following statements: </para>

<programlisting language="c++">TChain chain("T");   <code>// name of the tree is the argument</code>
chain.Add("file1.root");
chain.Add("file2.root");
chain.Add("file3.root");
</programlisting>

<para>The name of the <emphasis role="bold"><code>TChain</code></emphasis> will be the same as the name of the tree; in this case it will be <code>"T". Note that two </code>objects can have the same name as long as they are not histograms in the same directory, because there, the histogram names are used to build a hash table. The class <emphasis role="bold"><code>TChain</code></emphasis> is derived from the class <emphasis role="bold"><code>TTree</code></emphasis>. For example, to generate a histogram corresponding to the attribute "<code>x</code>" in tree "<code>T</code>" by processing sequentially the three files of this chain, we can use the <emphasis role="bold"><code>TChain</code></emphasis><code>::Draw</code> method. </para>

<programlisting language="c++"><code>chain.Draw("x");</code>
</programlisting>

<para>When using a <emphasis role="bold"><code>TChain</code></emphasis>, the branch address(es) must be set with:</para>

<programlisting language="c++"><code>chain.SetBranchAdress</code><code>(branchname,…)  </code><emphasis role="italic"><code>// use this for TChain</code></emphasis>
</programlisting>

<para>rather than:</para>

<programlisting language="c++"><code>branch-&gt;SetAddress</code><code>(…);</code><emphasis role="italic"><code>  // this will not work</code></emphasis>
</programlisting>

<para>The second form returns the pointer to the branch of the current <emphasis role="bold"><code>TTree</code></emphasis> in the chain, typically the first one. The information is lost when the next <emphasis role="bold"><code>TTree</code></emphasis> is loaded. The following statements illustrate how to set the address of the object to be read and how to loop on all events of all files of the chain.</para>

<programlisting language="c++">{
TChain chain("T");  <code>// create the chain with tree "T"</code>
chain.Add("file1.root");  <code>// add the files</code>
chain.Add("file2.root");
chain.Add("file3.root");
TH1F *hnseg = new TH1F("hnseg","Number of segments for selected tracks",
5000,0,5000);
<code>// create an object</code> <code>before setting the branch address</code>
Event *event = new Event();
<code>// Specify the address where to read the event object</code>
chain.SetBranchAddress("event", &amp;event);

<emphasis role="italic"><code>   // Start main loop on all events In case you want to read only a few </code></emphasis>
<emphasis role="italic"><code>   // branches, use TChain</code></emphasis><emphasis role="italic"><code>::SetBranchStatus to activate a branch.</code></emphasis>
Int_t nevent = chain.GetEntries();
for (Int_t i=0;i&lt;nevent;i++) {
<code>// read complete accepted event in memory</code>
chain.GetEvent(i);
<code>// Fill histogram with number of segments</code>
hnseg-&gt;Fill(event-&gt;GetNseg());
}
<code>   // Draw the histogram</code>
hnseg-&gt;Draw();
}
</programlisting>

<sect2>
<title>TChain::AddFriend</title>
<para><code>A </code><emphasis role="bold"><code>TChain</code></emphasis> has a list of friends similar to a tree (see <emphasis role="bold"><code>TTree</code></emphasis><code>::AddFriend)</code>. You can add a friend to a chain with the <emphasis role="bold"><code>TChain</code></emphasis><code>::AddFriend</code> method. With <emphasis role="bold"><code>TChain</code></emphasis><code>::GetListOfFriends</code> you can retrieve the list of friends. The next example has four chains each has 20 ROOT trees from 20 ROOT files.</para>

<programlisting language="c++"><code>TChain ch("t");    </code><emphasis role="italic"><code>// a chain with 20 trees from 20 files</code></emphasis>
<code>TChain ch1("t1");  </code>
<code>TChain ch2("t2");</code>
<code>TChain ch3("t3");</code>
</programlisting>

<para>Now we can add the friends to the first chain.</para>

<programlisting language="c++"><code>ch.AddFriend("t1")</code>
<code>ch.AddFriend("t2")</code>
<code>ch.AddFriend("t3")</code>
</programlisting>

<para>The parameter is the name of friend chain (the name of a chain is always the name of the tree from which it was created). The original chain has access to all variables in its friends. We can use the <emphasis role="bold"><code>TChain</code></emphasis><code>::Draw</code>         method as if the values in the friends were in the original chain. To specify the chain to use in the <code>Draw</code> method, use:</para>

<programlisting language="c++"><code>&lt;chainname&gt;.&lt;branchname&gt;.&lt;varname&gt;</code>
</programlisting>

<para>If the variable name is enough to identify uniquely the variable, you can leave out the chain and/or branch name. For example, this generates a 3-d scatter plot of variable "<code>var</code>" in the <emphasis role="bold"><code>TChain</code></emphasis><code> ch</code> versus variable <code>v1 in </code><emphasis role="bold"><code>TChain</code></emphasis><code> t1</code> versus variable <code>v2</code> in <emphasis role="bold"><code>TChain</code></emphasis><code> t2</code>.</para>

<programlisting language="c++"><code>ch.Draw("var:t1.v1:t2.v2");</code>
</programlisting>

<para>When a <emphasis role="bold"><code>TChain</code></emphasis><code>::Draw</code> is executed, an automatic call to <emphasis role="bold"><code>TTree</code></emphasis><code>::AddFriend </code>connects the trees in the chain. When a chain is deleted, its friend elements are also deleted. </para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/02000108.jpg" width="245.15pt" depth="127.85pt"/></imageobject></inlinemediaobject>
</para>
<para>The number of entries in the friend must be equal or greater to the number of entries of the original chain. If the friend has fewer entries a warning is given and the resulting histogram will have missing entries. For additional information see <emphasis role="bold"><code>TTree</code></emphasis><code>::AddFriends()</code>. A full example of a tree and friends is in Example #3 <code>($ROOTSYS/tutorials/tree/tree3.C</code>) in the Trees section above.</para>
</sect2>
</sect1>
</chapter>



