# The following CMake code does not work on Windows at the moment
if(NOT ROOT_root7_FOUND OR (MSVC AND NOT win_broken_tests))
  return()
endif()

# Generate common dictionary for custom class
ROOT_GENERATE_DICTIONARY(
  eventDict
  ${CMAKE_CURRENT_SOURCE_DIR}/ntuple_makeproject_header.h
  LINKDEF ${CMAKE_CURRENT_SOURCE_DIR}/ntuple_makeproject_header_LinkDef.h)

# MakeProject with TTree data
# Write the TTree with the custom class branch
ROOTTEST_GENERATE_EXECUTABLE(
  write_ttree
  write_ttree.cxx eventDict.cxx
  DEPENDS ${GENERATE_DICTIONARY_TEST}
  LIBRARIES Core RIO Tree
  FIXTURES_SETUP write_ttree_executable)
ROOTTEST_ADD_TEST(write_ttree
                  EXEC ./write_ttree
                  FIXTURES_REQUIRED write_ttree_executable
                  FIXTURES_SETUP written_ttree)

# Call MakeProject on the output file
ROOTTEST_GENERATE_EXECUTABLE(
  makeproject_ttree
  makeproject_ttree.cxx
  LIBRARIES Core RIO Tree
  FIXTURES_SETUP makeproject_ttree)
ROOTTEST_ADD_TEST(makeproject_ttree
                  EXEC ./makeproject_ttree
                  FIXTURES_REQUIRED "written_ttree;makeproject_ttree"
                  FIXTURES_SETUP makeproject_ttree_called)

# Read back the class instance thanks to the shared library generated by MakeProject.
# Make sure it corresponds to the data stored in the original custom class
ROOTTEST_GENERATE_EXECUTABLE(
  read_ttree
  read_ttree.cxx
  LIBRARIES ${ROOT_LIBRARIES} gtest gtest_main gmock gmock_main ttreestltest
  FIXTURES_REQUIRED makeproject_ttree_called
  FIXTURES_SETUP read_ttree_executable
)
target_include_directories(read_ttree PRIVATE ${CMAKE_CURRENT_BINARY_DIR} ${GTEST_INCLUDE_DIR})
target_link_directories(read_ttree PRIVATE ${CMAKE_CURRENT_BINARY_DIR}/libttreestltest)
# Need to also explicitly set the LD_LIBRARY_PATH (at least on MacOS), so that
# the generated library with the custom class can be loaded by the read test.
# Setting the value of ${ld_library_path} in the ENVIRONMENT argument of the
# ROOTTEST_ADD_TEST function will not work, because that function sets the same
# variable internally, thus overriding our choice. The simplest thing to do is
# to append our directory to the ${ROOTTEST_ENV_LIBRARYPATH} contents, which
# are automatically used by ROOTTEST_ADD_TEST
set(_roottest_env_librarypath ${ROOTTEST_ENV_LIBRARYPATH})
set(ROOTTEST_ENV_LIBRARYPATH "${ROOTTEST_ENV_LIBRARYPATH}:${CMAKE_CURRENT_BINARY_DIR}/libttreestltest")
ROOTTEST_ADD_TEST(read_ttree
                  EXEC ./read_ttree
                  FIXTURES_REQUIRED read_ttree_executable)
set(ROOTTEST_ENV_LIBRARYPATH ${_roottest_env_librarypath})

# MakeProject with RNTuple data
# Write the RNTuple with the custom class field
ROOTTEST_GENERATE_EXECUTABLE(
  write_rntuple
  write_rntuple.cxx eventDict.cxx
  LIBRARIES Core RIO ROOTNTuple
  FIXTURES_SETUP write_rntuple_executable)
ROOTTEST_ADD_TEST(write_rntuple
                  EXEC ./write_rntuple
                  FIXTURES_REQUIRED write_rntuple_executable
                  FIXTURES_SETUP written_rntuple)

# Call MakeProject on the output file
ROOTTEST_GENERATE_EXECUTABLE(
  makeproject_rntuple
  makeproject_rntuple.cxx
  LIBRARIES Core RIO ROOTNTuple
  FIXTURES_SETUP makeproject_rntuple)
ROOTTEST_ADD_TEST(makeproject_rntuple
                  EXEC ./makeproject_rntuple
                  FIXTURES_REQUIRED "written_rntuple;makeproject_rntuple"
                  FIXTURES_SETUP makeproject_rntuple_called)

# Read back the class instance thanks to the shared library generated by MakeProject.
# Make sure it corresponds to the data stored in the original custom class
ROOTTEST_GENERATE_EXECUTABLE(
  read_rntuple
  read_rntuple.cxx
  LIBRARIES ${ROOT_LIBRARIES} gtest gtest_main gmock gmock_main rntuplestltest ROOTNTuple
  FIXTURES_REQUIRED makeproject_rntuple_called
  FIXTURES_SETUP read_rntuple_executable
)
target_include_directories(read_rntuple PRIVATE ${CMAKE_CURRENT_BINARY_DIR} ${GTEST_INCLUDE_DIR})
target_link_directories(read_rntuple PRIVATE ${CMAKE_CURRENT_BINARY_DIR}/librntuplestltest)
# Need to also explicitly set the LD_LIBRARY_PATH (at least on MacOS), so that
# the generated library with the custom class can be loaded by the read test.
# Setting the value of ${ld_library_path} in the ENVIRONMENT argument of the
# ROOTTEST_ADD_TEST function will not work, because that function sets the same
# variable internally, thus overriding our choice. The simplest thing to do is
# to append our directory to the ${ROOTTEST_ENV_LIBRARYPATH} contents, which
# are automatically used by ROOTTEST_ADD_TEST
set(_roottest_env_librarypath ${ROOTTEST_ENV_LIBRARYPATH})
set(ROOTTEST_ENV_LIBRARYPATH "${ROOTTEST_ENV_LIBRARYPATH}:${CMAKE_CURRENT_BINARY_DIR}/librntuplestltest")
ROOTTEST_ADD_TEST(read_rntuple
                  EXEC ./read_rntuple
                  FIXTURES_REQUIRED read_rntuple_executable)
set(ROOTTEST_ENV_LIBRARYPATH ${_roottest_env_librarypath})

