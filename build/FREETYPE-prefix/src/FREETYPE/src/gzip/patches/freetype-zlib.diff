[zlib] Fix zlib sources for compilation with FreeType

We must ensure that they do not issue compiler errors or warnings when they
are compiled as part of `src/gzip/ftgzip.c`.

* src/gzip/adler32.c: Do not define unused functions when `Z_FREETYPE`
is set.

* src/gzip/gzguts.h (COPY): Rename to...
(COPY__): ... this since `COPY` and `COPY_` conflict with enum values,
which have the same name in `zlib.h`.

* src/gzip/inflate.c, src/gzip/adler32.c: Omit unused function
declarations when `Z_FREETYPE` is defined.

* src/gzip/zlib.h: Include `ftzconf.h` instead of `zconf.h` to avoid
conflicts with system-installed headers.
Omit unused function declarations when `Z_FREETYPE` is defined.

* src/gzip/zutil.h: Use `ft_memxxx` functions instead of `memxxx`.
Omit unused function declarations when `Z_FREETYPE` is defined.

* src/gzip/inflate.h, src/gzip/inftrees.h: Add header guard macros to
prevent compiler errors.

diff --git a/src/gzip/adler32.c b/src/gzip/adler32.c
index be5e8a247..aa032e1dd 100644
--- a/src/gzip/adler32.c
+++ b/src/gzip/adler32.c
@@ -7,7 +7,9 @@
 
 #include "zutil.h"
 
+#ifndef Z_FREETYPE
 local uLong adler32_combine_ OF((uLong adler1, uLong adler2, z_off64_t len2));
+#endif
 
 #define BASE 65521U     /* largest prime smaller than 65536 */
 #define NMAX 5552
@@ -139,6 +141,8 @@ uLong ZEXPORT adler32(
     return adler32_z(adler, buf, len);
 }
 
+#ifndef Z_FREETYPE
+
 /* ========================================================================= */
 local uLong adler32_combine_(
     uLong adler1,
@@ -184,3 +188,5 @@ uLong ZEXPORT adler32_combine64(
 {
     return adler32_combine_(adler1, adler2, len2);
 }
+
+#endif  /* !Z_FREETYPE */
diff --git a/src/gzip/gzguts.h b/src/gzip/gzguts.h
index 57faf3716..4f09a52a7 100644
--- a/src/gzip/gzguts.h
+++ b/src/gzip/gzguts.h
@@ -163,7 +163,7 @@
 
 /* values for gz_state how */
 #define LOOK 0      /* look for a gzip header */
-#define COPY 1      /* copy input directly */
+#define COPY__ 1    /* copy input directly */
 #define GZIP 2      /* decompress a gzip stream */
 
 /* internal gzip file state data structure */
diff --git a/src/gzip/inflate.c b/src/gzip/inflate.c
index 4375557b4..5bf5b815e 100644
--- a/src/gzip/inflate.c
+++ b/src/gzip/inflate.c
@@ -99,8 +99,10 @@ local int updatewindow OF((z_streamp strm, const unsigned char FAR *end,
 #ifdef BUILDFIXED
    void makefixed OF((void));
 #endif
+#ifndef Z_FREETYPE
 local unsigned syncsearch OF((unsigned FAR *have, const unsigned char FAR *buf,
                               unsigned len));
+#endif
 
 local int inflateStateCheck(
     z_streamp strm)
@@ -245,6 +247,8 @@ int ZEXPORT inflateInit_(
     return inflateInit2_(strm, DEF_WBITS, version, stream_size);
 }
 
+#ifndef Z_FREETYPE
+
 int ZEXPORT inflatePrime(
     z_streamp strm,
     int bits,
@@ -266,6 +270,8 @@ int ZEXPORT inflatePrime(
     return Z_OK;
 }
 
+#endif  /* !Z_FREETYPE */
+
 /*
    Return state with length and distance decoding tables and index sizes set to
    fixed code decoding.  Normally this returns fixed tables from inffixed.h.
@@ -1312,6 +1318,8 @@ int ZEXPORT inflateEnd(
     return Z_OK;
 }
 
+#ifndef Z_FREETYPE
+
 int ZEXPORT inflateGetDictionary(
     z_streamp strm,
     Bytef *dictionary,
@@ -1471,6 +1479,8 @@ int ZEXPORT inflateSync(
     return Z_OK;
 }
 
+#endif  /* !Z_FREETYPE */
+
 /*
    Returns true if inflate is currently at the end of a block generated by
    Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
@@ -1489,6 +1499,8 @@ int ZEXPORT inflateSyncPoint(
     return state->mode == STORED && state->bits == 0;
 }
 
+#ifndef Z_FREETYPE
+
 int ZEXPORT inflateCopy(
     z_streamp dest,
     z_streamp source)
@@ -1536,6 +1548,8 @@ int ZEXPORT inflateCopy(
     return Z_OK;
 }
 
+#endif  /* !Z_FREETYPE */
+
 int ZEXPORT inflateUndermine(
     z_streamp strm,
     int subvert)
@@ -1569,6 +1583,8 @@ int ZEXPORT inflateValidate(
     return Z_OK;
 }
 
+#ifndef Z_FREETYPE
+
 long ZEXPORT inflateMark(
     z_streamp strm)
 {
@@ -1590,3 +1606,5 @@ unsigned long ZEXPORT inflateCodesUsed(
     state = (struct inflate_state FAR *)strm->state;
     return (unsigned long)(state->next - state->codes);
 }
+
+#endif  /* !Z_FREETYPE */
diff --git a/src/gzip/inflate.h b/src/gzip/inflate.h
index f127b6b1f..c6f5a52e1 100644
--- a/src/gzip/inflate.h
+++ b/src/gzip/inflate.h
@@ -3,6 +3,9 @@
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
+#ifndef INFLATE_H
+#define INFLATE_H
+
 /* WARNING: this file should *not* be used by applications. It is
    part of the implementation of the compression library and is
    subject to change. Applications should only use zlib.h.
@@ -124,3 +127,5 @@ struct inflate_state {
     int back;                   /* bits back of last unprocessed length/lit */
     unsigned was;               /* initial length of match */
 };
+
+#endif  /* INFLATE_H */
diff --git a/src/gzip/inftrees.h b/src/gzip/inftrees.h
index baa53a0b1..c94eb78b5 100644
--- a/src/gzip/inftrees.h
+++ b/src/gzip/inftrees.h
@@ -3,6 +3,9 @@
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
+#ifndef INFTREES_H
+#define INFTREES_H
+
 /* WARNING: this file should *not* be used by applications. It is
    part of the implementation of the compression library and is
    subject to change. Applications should only use zlib.h.
@@ -60,3 +63,5 @@ typedef enum {
 int ZLIB_INTERNAL inflate_table OF((codetype type, unsigned short FAR *lens,
                              unsigned codes, code FAR * FAR *table,
                              unsigned FAR *bits, unsigned short FAR *work));
+
+#endif  /* INFTREES_H_ */
diff --git a/src/gzip/zlib.h b/src/gzip/zlib.h
index 4a98e38bf..d760140c2 100644
--- a/src/gzip/zlib.h
+++ b/src/gzip/zlib.h
@@ -31,7 +31,7 @@
 #ifndef ZLIB_H
 #define ZLIB_H
 
-#include "zconf.h"
+#include "ftzconf.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -211,6 +211,8 @@ typedef gz_header FAR *gz_headerp;
 
 #define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
 
+#ifndef Z_FREETYPE
+
 #define zlib_version zlibVersion()
 /* for compatibility with versions < 1.0.2 */
 
@@ -246,7 +248,6 @@ ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
    this will be done by deflate().
 */
 
-
 ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
 /*
     deflate compresses as much data as possible, and stops when the input
@@ -373,6 +374,7 @@ ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
    deallocated).
 */
 
+#endif  /* !Z_FREETYPE */
 
 /*
 ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
@@ -534,6 +536,8 @@ ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
     The following functions are needed only in some special applications.
 */
 
+#ifndef Z_FREETYPE
+
 /*
 ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
                                      int  level,
@@ -956,6 +960,8 @@ ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
    destination.
 */
 
+#endif  /* !Z_FREETYPE */
+
 ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
 /*
      This function is equivalent to inflateEnd followed by inflateInit,
@@ -980,6 +986,8 @@ ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,
    the windowBits parameter is invalid.
 */
 
+#ifndef Z_FREETYPE
+
 ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
                                      int bits,
                                      int value));
@@ -1069,6 +1077,8 @@ ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
    stream state was inconsistent.
 */
 
+#endif  /* !Z_FREETYPE */
+
 /*
 ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
                                         unsigned char FAR *window));
@@ -1095,6 +1105,8 @@ typedef unsigned (*in_func) OF((void FAR *,
                                 z_const unsigned char FAR * FAR *));
 typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));
 
+#ifndef Z_FREETYPE
+
 ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
                                     in_func in, void FAR *in_desc,
                                     out_func out, void FAR *out_desc));
@@ -1214,6 +1226,8 @@ ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
      27-31: 0 (reserved)
  */
 
+#endif  /* !Z_FREETYPE */
+
 #ifndef Z_SOLO
 
                         /* utility functions */
@@ -1742,6 +1756,8 @@ ZEXTERN uLong ZEXPORT crc32 OF((uLong crc, const Bytef *buf, uInt len));
      if (crc != original_crc) error();
 */
 
+#ifndef Z_FREETYPE
+
 ZEXTERN uLong ZEXPORT crc32_z OF((uLong crc, const Bytef *buf,
                                   z_size_t len));
 /*
@@ -1822,6 +1838,19 @@ ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
                            ZLIB_VERSION, (int)sizeof(z_stream))
 #endif
 
+#else  /* Z_FREETYPE */
+
+
+ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
+                                      const char *version, int stream_size));
+
+#  define inflateInit2(strm, windowBits) \
+          inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
+                        (int)sizeof(z_stream))
+
+#endif  /* Z_FREETYPE */
+
+
 #ifndef Z_SOLO
 
 /* gzgetc() macro and its supporting function and exposed data structure.  Note
@@ -1901,13 +1930,16 @@ ZEXTERN int ZEXPORT gzgetc_ OF((gzFile file));  /* backward compatibility */
 
 #else /* Z_SOLO */
 
+#ifndef Z_FREETYPE
    ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
    ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
    ZEXTERN uLong ZEXPORT crc32_combine_gen OF((z_off_t));
+#endif
 
 #endif /* !Z_SOLO */
 
 /* undocumented functions */
+#ifndef Z_FREETYPE
 ZEXTERN const char   * ZEXPORT zError           OF((int));
 ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));
 ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table    OF((void));
@@ -1927,6 +1959,7 @@ ZEXTERN int            ZEXPORTVA gzvprintf Z_ARG((gzFile file,
                                                   va_list va));
 #  endif
 #endif
+#endif  /* !Z_FREETYPE */
 
 #ifdef __cplusplus
 }
diff --git a/src/gzip/zutil.h b/src/gzip/zutil.h
index d9a20ae1b..14f0f1a85 100644
--- a/src/gzip/zutil.h
+++ b/src/gzip/zutil.h
@@ -188,6 +188,8 @@ extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
   #pragma warn -8066
 #endif
 
+#ifndef Z_FREETYPE
+
 /* provide prototypes for these when building zlib without LFS */
 #if !defined(_WIN32) && \
     (!defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0)
@@ -195,6 +197,8 @@ extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
 #endif
 
+#endif  /* !Z_FREETYPE */
+
         /* common defaults */
 
 #ifndef OS_CODE
@@ -226,9 +230,9 @@ extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
 #    define zmemcmp _fmemcmp
 #    define zmemzero(dest, len) _fmemset(dest, 0, len)
 #  else
-#    define zmemcpy memcpy
-#    define zmemcmp memcmp
-#    define zmemzero(dest, len) memset(dest, 0, len)
+#    define zmemcpy ft_memcpy
+#    define zmemcmp ft_memcmp
+#    define zmemzero(dest, len) ft_memset(dest, 0, len)
 #  endif
 #else
    void ZLIB_INTERNAL zmemcpy OF((Bytef* dest, const Bytef* source, uInt len));
