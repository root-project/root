<br/> 
<hr/> 
<a name="hist"></a> 
<h3>Histogram Libraries</h3>

<h4>TH2Poly</h4>
<ul>
<li>The values set by <tt>SetMaximum()</tt> and <tt>SetMinimum()</tt> were not
   taken into account by <tt>GetMaximum()</tt> and <tt>GetMinimum()</tt>.</li>
<li>The Palette and the statistics box were not pickable when TH2Poly was drawn
   with option COLZ.</li>
<li> TH2Poly was wrongly picked in the canvas area after a zoom along axis.
</li>
</ul>

<h4>TEfficiency</h4>
<ul>
<li>list holding the associated functions is created only on demand</li>
<li>default constructor creates two dummy histograms</li>
<li>can now be filled with weights (only Bayesian methods and the normal
approximation are supported) </li>
<li>update <tt>TEfficiency::SavePrimitive</tt> to store also the set bits</li>
</ul>

<h4>TGraphAsymmErrors</h4>
<ul>
<li>add option to <tt>TGraphAsymmErrors::Divide</tt> for interpreting the given
histograms as ratio of Poisson means<li>
</ul>

<h4>TPaletteAxis</h4>
<ul>
<li>In <tt>TPaletteAxis::Paint()</tt> now makes sure the min and max of the
   palette are not 0 when the histogram content is 0.
</li>
<li> on Ubuntu the following macro crashed. A char variable was too small.
<pre>
   { 
      TCanvas *tmp = new TCanvas(); 
      TH2F *h1 = new TH2F("h1","h1",40,0.,10.,40,1.e-2,1.e2); 
      h1->Fill(5,10); 
      h1->Draw("COLZ"); 
      tmp->SetLogz(); 
      h1->GetZaxis()->SetNdivisions(110,kFALSE); 
   } 
</pre>
</li>
</ul>

<h4>THistPainter</h4>
<ul>
<li>The option E0 forces the error bars drawing even if the data point are
outside the plot frame. This option did not clip the error bars correctly.
</li>
</ul>

<h4>TPainter3dAlgorithms</h4>
<ul>
<li>Protection against possible NaN added. The following macro produced wrong 
   plots.
<pre>
   {
      TCanvas * canvas = new TCanvas("glC","C",800,800);
      TH3D *h = new TH3D("h3","h3",150,0,20,150,-5,5,150,-5,5);
      ntuple->Draw("px:py+1:pz+4.7>>h3","","Q");
   }
</pre>
</li>
</ul>

<h4>TGraph</h4>
<ul>
   <li> <tt>TGraph::SavePrimitive()</tt> uses a greater precision to output the
X and Y vectors. The following macro generated a wrong output (tmp.C).
<pre>
   void testGraphPrec() {
      double offset=55.0;
      TCanvas* myC = new TCanvas("myC","myC",600,400);
      TGraph* gr=new TGraph();
      for(int i=0;i<1000;i++){
         double point_x = 3.0+((double) i)*1e-7;
         double point_y = offset+((double) i)*1e-8;
         gr->SetPoint(i,point_x,point_y);
      }
      gr->Draw("AP");
      myC->Print("tmp.C");
   }
</pre>
</li>
</ul>
