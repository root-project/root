## \file
## \ingroup tutorial_tree
## \notebook
##
## Save many histograms in different Tree branches.
##
## To run this example, do:
## ~~~{.py}
## IPython [1]: %run htest.py
## IPython [2]: htw()
## IPython [3]: htr1()
## IPython [4]: htr2()
## IPython [5]: htr3()
## ~~~
##
## \macro_image
## \macro_code
##
## \author Rene Brun
## \translator P. P.


import ROOT
import ctypes
from array import array


# standard library
from ROOT import std
from ROOT.std import (
                       make_shared,
                       unique_ptr,
                       )

# classes
from ROOT import (
                   TProfile,
                   TFile,
                   TTree,
                   TCanvas,
                   TH1F,
                   TH2F,
)

TGraph = ROOT.TGraph
TLatex = ROOT.TLatex

# maths
from ROOT import (
                   sin,
                   cos,
                   sqrt,
)

# types
from ROOT import (
                   Double_t,
                   Bool_t,
                   Float_t,
                   Int_t,
                   nullptr,
)
#
from ctypes import (
                     c_double,
                     c_float,
                     )

# utils
def to_c( ls ):
   return (c_double * len(ls) )( * ls )
def printf(string, *args):
   print( string % args, end="")
def sprintf(buffer, string, *args):
   buffer = string % args 
   return buffer

# constants
from ROOT import (
                   kBlue,
                   kRed,
                   kGreen,
)

# globals
from ROOT import (
                   gStyle,
                   gPad,
                   gRandom,
                   gBenchmark,
                   gROOT,
)



# void
def htw() :

   """
   Create a Tree with a few branches of type TH1F (histogram).
   25000 entries are filled in the Tree.
   For each entry, the copy of 3 histograms is written.
   In total, the data base will contain 75000 histograms.

   """

   #
   gBenchmark.Start("hsimple")


   #
   global f, T
   f = TFile ( "ht.root" , "recreate" )
   T = TTree ( "T"       , "test"     ) # auto # new

   #
   global hpx, hpxpy, hprof
   hpx    = TH1F("hpx", "This is the px distribution", 100, -4, 4) 
   hpxpy  = TH2F("hpxpy", "py vs px", 40, -4, 4, 40, -4, 4) 
   hprof  = TProfile("hprof", "Profile of pz versus px", 100, -4, 4, 0, 20) 


   #
   T.Branch ( "hpx"   , "TH1F"     , hpx   , 32000 , 0 )
   T.Branch ( "hpxpy" , "TH2F"     , hpxpy , 32000 , 0 )
   T.Branch ( "hprof" , "TProfile" , hprof , 32000 , 0 )


   #
   px = c_float()
   py = c_float()
   #
   #for (Int_t i = 0; i < 25000; i++) {
   #for i in range(0, 25000, 1): # error
   #for i in range(0, 250, 1): # ok
   for i in range(0, 2500, 1): # ok
      #
      # Status report.
      if (i % 1000 == 0)  :
         printf("at entry: %d\n", i)
         
      #
      gRandom.Rannor(px, py)
      #pz = px * px + py * py
      pz =  px.value **2  +  py.value **2

      #
      # Fill histograms.
      hpx.Fill   ( px.value           )
      hpxpy.Fill ( px.value, py.value )
      hprof.Fill ( px.value, pz       )

      #
      T.Fill()
      
   #
   T.Print()
   f.Write()

   #
   f.Close()

   #
   gBenchmark.Show("hsimple")
   

# void
def htr1() :

   """
   Read Tree generated by "htw" function and show histograms for 
   the specific entry "custom_entry=12" .

   It loads the data into new object pointers.
   And uses their methods to draw.

   """

   global f, T
   f = TFile("ht.root")  # auto # new
   T = f.Get("T")  # auto # (TTree *)

   #
   hpx    = TH1F()      # nullptr  *
   hpxpy  = TH2F()      # nullptr  *
   hprof  = TProfile()  # nullptr  *

   #
   T.SetBranchAddress ( "hpx"   , hpx   )
   T.SetBranchAddress ( "hpxpy" , hpxpy )
   T.SetBranchAddress ( "hprof" , hprof )

   # custom_entry = 12345
   custom_entry = 12
   #
   #T.GetEntry(12345)
   T.GetEntry( custom_entry )

   #
   global c1 
   c1 =  TCanvas("c1", "test", 10, 10, 600, 1000)  # auto # new
   c1.Divide(1, 3)
   #
   c1.cd(1)
   hpx.Draw()
   c1.Update()
   #
   c1.cd(2)
   hpxpy.Draw()
   c1.Update()
   #
   c1.cd(3)
   hprof.Draw()
   c1.Update()
   # Note :
   #        Remeber to update your canvas each time you draw a new object.
   #        Otherwise, memory leaks will occour.
   #        In .C version updating is unnecesary, but in pyroot is mandatory.

   #
   c1.Update()
   c1.Draw()

   #
   c1.Print("htr1.png")
   

   #
   f.Close()


# void
def htr2() :

   """
   A variant of "htr1" function.

   Read the Tree generated by "htw" function and 
   show histograms for entry "custom_entry=12345". As in "htr1".
   But no creation of pointer objects is used.
   Instead, we use directly the names in the 
   Tree to draw.
   So much simplier to draw.
   

   """

   #
   global f, T
   f =  TFile("ht.root")  # auto # new
   T = f.Get("T")  # auto # (TTree *)


   #
   global c1
   c1 =  TCanvas("c1", "test", 10, 10, 600, 1000)  # auto # new
   c1.Divide(1, 3)
   #
   custom_entry = 12
   #custom_entry = 12345
   #
   c1.cd(1)
   T.Draw("hpx.Draw()", "", "goff", 1, custom_entry)
   #
   c1.cd(2)
   T.Draw("hpxpy.Draw()", "", "goff", 1, custom_entry)
   #
   c1.cd(3)
   T.Draw("hprof.Draw()", "", "goff", 1, custom_entry)
   
   #
   c1.Update()
   c1.Draw()


   #
   c1.Print("htr2.png")
   
   #
   f.Close()

# void
def htr3() :

   """

   Read the Tree generated by "htw", 
   load all its histograms, and 
   plot the RMS(root mean square) of "hpx" versus 
   the Mean(statistical mean) of "hprof"
   for each of the 25.000 entries.

   """

   # 
   global f, T
   f =  TFile("ht.root")  # auto # new
   T = f.Get("T")  # auto # (TTree *)

   #
   global c1
   c1 =  TCanvas("c1", "test", 10, 10, 600, 400)  # auto # new

   #
   T.Draw("hpx.GetRMS():hprof.GetMean()")

   #
   c1.Draw()
   c1.Update()

   #
   c1.Print("htr3.png")

   #
   f.Close()
   

# void
def htest() :
   #
   # Write.
   htw()
   # Read by constructing an object.
   #htr1()
   # Read by specifing an argument.
   #htr2()
   # Read and Plot directly mean vs. root-mean-square
   htr3()
   

   # Note :
   #        Due to its implementation, "htr1" and "htr2" functions
   #        should return the same drawing.


if __name__ == "__main__":
   htest()
