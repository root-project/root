## \file
## \ingroup tutorial_tree
## \notebook -header -nodraw
##
##
## Example of an analysis class for the H1 data.
##
## This file uses 4 large data sets from the H1 collaboration at DESY Hamburg.
## One can access these data sets (277 MBytes) from the standard Root web site
## at: [https://root.cern.ch/files/h1/](https://root.cern.ch/files/h1/)
## The Physics plots below generated by this example cannot be produced when
## using smaller data sets.
##
## There are several ways to analyze data stored in a Root Tree. A brief 
## description of these methods is given below.
##
## - Using TTree.Draw: This is very convenient and efficient for small tasks.
##   A TTree.Draw call produces one histogram at a time; where the histogram
##   is automatically generated. The selection expression(filter of data or
##   cutoffs) may be specified in the script or, for interactive
##   exploration, in the command line. 
##
## - Using the TTreeViewer: This is a graphical interface to TTree.Draw
##   with the same functionality. It can be invoked by calling it with
##   a TTree-object argument. TTreeViewer( myTreeObject ) will launch 
##   a GUI interface where you could adjust parameters and view results 
##   in real-time.
## 
## - Using the code generated by TTree.MakeClass method: In this case,
##   one creates an instance of the analysis class. Such instances (if 
##   more than one is created) have overall control of the main event loop.
##   This helps at generating an unlimited
##   number of histograms--thousands without significant issues-- for 
##   whatever analysis one is intended to make. This is because, each instance--
##   along with its own analysis represented in a histogram--
##   can iterate over the main loop, making a loop of loops of histograms.
##   
##
## - Using the code generated by TTree.MakeSelector: Similar to the code that 
##   generates TTree.MakeClass, the user can do complex analysis with this.
##   However, they cannot control the main event loop. Such a loop is controlled
##   only by the TTree.Process called by the user. This solution is illustrated
##   in the current code. The advantage of this method is that it can be run
##   in a parallel environment using PROOF (the Parallel ROOt Facility).
##
## A chain of 4 files (originally converted from ntuples of Physics Analysis
## Workstation, or PAW ntuples ) is used to
## illustrate the various ways to loop over Root data sets.
## Furthermore, wach data set contains a Root Tree named "h42".
## 
## The class definition in h1analysis.h has been generated automatically
## by the Root utility TTree.MakeSelector using one of the files with the
## following statement:
##
## ~~~{.py}
##        h42.MakeSelector("h1analysis")
## ~~~
##
## This produces two files: h1analysis.h and h1analysis.C (skeleton of this file)
## The h1analysis class is derived from the Root class TSelector.
##
## The following member functions are called by the TTree.Process method.
## - **Begin()**: Called every time a loop over the tree starts.
##                A convenient place to create your histograms.
## - **Notify()**: This function is called only at the first entry of
##                 a new Tree in a chain.
## - **Process()**: Called to analyze each entry.
##
## - **Terminate()**: Called at the end of a loop on a TTree.
##                    A convenient place to draw/fit your histograms.
##
##
## To use this file, try the following sessions.
##
## ~~~{.py}
##  IPython > gROOT.Time() ## will show RT & CPU time per command
## ~~~
##
##
## ### Case A: Create a TChain with the four H1-data files.
##
## The chain can be created by executing the short macro h1chain.C below:
##
## ~~~{.py}
##  chain = TChain("h42")
##  chain.Add("$H1/dstarmb.root")  ##   21330730 bytes  21920 events
##  chain.Add("$H1/dstarp1a.root") ##   71464503 bytes  73243 events
##  chain.Add("$H1/dstarp1b.root") ##   83827959 bytes  85597 events
##  chain.Add("$H1/dstarp2.root")  ##  100675234 bytes 103053 events
##  ## where $H1 is a system symbol pointing to the H1 data directory.
## ~~~
##
## ### Case B: Loop over all events.
##
## ~~~{.py}
##  IPython > chain.Process( "h1analysis.C" )
## ~~~
##
## ### Case C: Same as B, but in addition it fills the entry list 
## ###         with selected entries.
##
## The entry list is saved to a file "elist.root" by the Terminate function.
## To see the list of selected events, you can do `elist.Print("all")`.
## The selection function has selected 7525 events out of the 283813 events
## in the chain of files. (2.65 per cent)
##
## ~~~{.py}
##  IPython > chain.Process( "h1analysis.C", "fillList" )
## ~~~
##
## ### Case D: Process only entries in the entry list
##
## The entry list is read from the file elist.root generated in Step C.
##
## ~~~{.py}
##  IPython > chain.Process( "h1analysis.C", "useList" )
## ~~~
##
## ### Case E: The above Steps have been executed via the interpreter.
##             You can repeat the Steps B, C and D using them in
##             a python script.
##              
##
## ### Case F: Using the Just-In-Time(JIT) Compilation.
##             Create the chain as in A, then execute
##
## for one time compilation:
## ~~~{.py}
##  IPython > chain.Process("h1analysis.C+","useList")
## ~~~
## or
## for recompiling every time it is run: 
## ~~~{.cpp}
##  IPython > chain.Process("h1analysis.C++","useList")
## ~~~
##
## The same analysis can be run on PROOF. First, for a quick try start a PROOF-Lite
## session previously:
##
## ~~~{.py}
##  IPython > p = TProof.Open("") # -> TProof
## ~~~
##
## second, create (if not already done) the chain by executing the 'h1chain.py' script
## mentioned above, and third, tell ROOT to use PROOF to process the chain:
##
## ~~~{.py}
##  Python > chain.SetProof()
## ~~~
##
##
## You can then repeat Step B above. Step C can also be executed in PROOF.
## However, Step D cannot be executed in PROOF since it runs in a local session
## (i.e. it just passes the option 'useList'). To use the entry list in PROOF 
## first you will have to load the session first, as shown below.
##
##
## ### Case G: First, load the list from the file.
##
## ~~~{.py}
##  Python > f = TFile("elist.root") # TFile                            
##  Python > elist = f.Get("elist")  # TEntryList 
## ~~~
##
##             Then, set it on the chain:
##
## ~~~{.py}
##  IPython > chain.SetEntryList(elist)
## ~~~
##
##             Thus, you can call the `.Process` method as in Step B. Of course, 
##             this (Step B) works also for local session.
##
##
##
## \macro_code
##
## \author Rene Brun
## \translator P. P.



from array import array
import ctypes

import ROOT

import h1analysis_h
from h1analysis_h import h1analysis


# standard library
from ROOT import std
from ROOT.std import (
                       make_shared,
                       unique_ptr,
                       )


# classes
from ROOT import (
                   Info,
                   Error,
                   addressof,
                   TBranch,
                   TCanvas,
                   TF1,
                   TH2,
                   TLine,
                   TMath,
                   TPaveStats,
                   TStyle,
                   TTree,
                   TCanvas,
                   TH1F,
                   TH2F,
                   TGraph,
                   TLatex,
                   TString,
)

# maths
from ROOT import (
                   sin,
                   cos,
                   sqrt,
)

# TMath
from ROOT.TMath import (
                         Exp,
                         Power,
                         Abs,
)

# types
from ROOT import (
                   Double_t,
                   Bool_t,
                   Float_t,
                   Int_t,
                   nullptr,
)
#
from ctypes import (
                     c_double,
                     c_longlong,
)
Long64_t = c_longlong

# utils
def to_c( ls ):
   return (c_double * len(ls) )( * ls )
def printf(string, *args):
   print( string % args, end="")
def sprintf(buffer, string, *args):
   buffer = string % args 
   return buffer

# constants
from ROOT import (
                   kBlue,
                   kRed,
                   kGreen,
)

# globals
from ROOT import (
                   gDirectory,
                   gStyle,
                   gPad,
                   gRandom,
                   gBenchmark,
                   gROOT,
)




#variables
dxbin = (0.17 - 0.13) / 40. # Bin-width
sigma = 0.0012


# Double_t
def fdm5( xx : Double_t, par : Double_t) :
   x = xx[0] # Double_t

   if (x <= 0.13957) : return 0
      
   xp3 = (x - par[3]) * (x - par[3]) # Double_t
   res = dxbin * \
         (  par[0] * 
            Power( x - 0.13957, par[1] ) \
            + \
            par[2] / 2.5066 / par[4] * \
            Exp( -xp3 / 2 / par[4] / par[4] ) \
            ) # Double_t

   return res
   

# Double_t
def fdm2(xx : Double_t, par : Double_t) :

   x = xx[0] # Double_t

   if (x <= 0.13957) : return 0
      
   xp3 = (x - 0.1454) * (x - 0.1454) # Double_t
   res = dxbin * \
         (   par[0] * Power(x - 0.13957, 0.25)
             +
             par[1] / 2.5066 / sigma *
             Exp(-xp3 / 2 / sigma / sigma)
             ) # Double_t

   return res
   


# void
def h1analysis__Begin( self,  tree : TTree ) :

   """
   This function is called before starting the main event loop.
    -It performs some cleanup.
    -It creates histograms.
    -It sets some initialization for the entry list.
   """
   
   # This is needed when re-processing the object.
   self.Reset()
   
   #
   # Print the option specified in the `Process` method.
   option = TString( self.GetOption() ) # TString         
   #
   Info("Begin.", 
        "Starting 'h1analysis' with process option: %s" % (
           str( option.Data() ),
           )
        )
   

   # Process those cases which have an entry list.
   if (self.fChain) :
      self.fChain.SetEntryList(nullptr)
      
   #
   #delete gDirectory.GetList().FindObject("elist")
   gDirectory.GetList().FindObject("elist")
   


   # # #
   # Case A: when one creates/fills the entry list.
   if (option.Contains( "fillList" )) :
      fillList = True                          
      elist    =  TEntryList("elist", "H1 selection from Cut") # new
      # Add to the input list for processing in PROOF, if needed
      if (fInput) :
         
         fInput.Add( TNamed("fillList", "")) # new TNamed
         # We send a clone to avoid double deletes when importing the result
         fInput.Add(elist)
         # This is needed to avoid warnings from output-to-members mapping
         elist = nullptr                       
         
      Info("Begin", "creating an entry-list")
      


   # # #
   # Case B: 
   # When one uses the entry list generated in a previous call.
   #
   if (option.Contains( "useList" )) :
      #
      useList = True                          
      #
      if (fInput) :
         # In PROOF option "useList" is processed in SlaveBegin and we do not need
         # to do anything here.
         pass
      #   
      else :
         f = TFile("elist.root")           
         elist = f.Get("elist") # (TEntryList *)
         if (elist) :
            elist.SetDirectory(nullptr) 
            # Otherwise, the file destructor will delete "elist".
      
   

# void
def h1analysis__SlaveBegin( self, tree : TTree) :

   """
   This function is called before starting the event loop.
    -It performs some cleanup.
    -It creates histograms.
    -It sets some initialisation for the entry list.
   """
   
   # Initialize the Tree branch addresses.
   self.Init(tree)
   
   # Print the option specified in the `.Process` method.
   option = TString( self.GetOption() ) # TString         
   Info( "SlaveBegin", 
         "starting h1analysis with process option: %s (tree: %s)" % \
            ( option.Data(), hex( addressof( tree ) ) ),
         )

   #   
   # Create histograms.
   hdmd =  TH1F("hdmd", "dm_d", 40, 0.13, 0.17) # new
   h2   =  TH2F("h2", "ptD0 vs dm_d", 30, 0.135, 0.165, 30, -3, 6) # new
   #
   # Save histograms.
   # DOING: 
   #        self.fOutput = self.GetOutputList()
   #self.fOutput.Add(hdmd)
   #self.fOutput.Add(h2)

   
   #
   # The entry list stuff. 
   # Re-parse option because on "PROOF" only "SlaveBegin" is called.
   if (option.Contains( "fillList" )) :

      fillList = True                          

      # Get the list into "fOutput".
      if (fInput) :

         elist = fInput.FindObject("elist") # (TEntryList *)
         #
         # Cloning the selector helps prevent issues related to 
         # memory management when it is destroyed.
         if ( elist ) :
            elist = elist.Clone() # (TEntryList *)

         # 
         if (elist) :
            fOutput.Add(elist)
         else :
            fillList = False                         
            
         
      
   # Notify.
   if (self.fillList) :
      Info("SlaveBegin", "creating an entry-list")
      

   # Check and Get option "useList".
   if (option.Contains( "useList" )) :
      useList = True                          
      
   

# Bool_t
def h1analysis__Process( self, entry : Long64_t) :

   """
   This is a selection function to select D* and D0.
   Furthermore, "entry" is the entry number in the current Tree.
   """

   # For better readability we load the self.variables as variables:
   # f = self.f___
   fProcessed = self.fProcessed
   #fStatus = self.fStatus
   fillList = self.fillList
   elist = self.elist
   useList = self.useList
   b_md0_d = self.b_md0_d
   md0_d = self.md0_d
   b_dm_d = self.b_dm_d
   b_rpd0_t = self.b_rpd0_t
   b_ptd0_d = self.b_ptd0_d
   b_njets = self.b_njets
   b_ipis = self.b_ipis
   b_nlhpi = self.b_nlhpi
   b_nlhk = self.b_nlhk
   b_rend = self.b_rend
   b_rstart = self.b_rstart
   ik = self.ik
   ipi = self.ipi
   b_ik = self.b_ik
   b_ipi = self.b_ipi
   b_ntracks = self.b_ntracks
   b_nhitrp = self.b_nhitrp
   b_etads_d = self.b_etads_d
   b_ptds_d = self.b_ptds_d
   b_md0_d = self.b_md0_d
   
   self.fProcessed += 1

   #
   # If one entry list is given in the input, the selection has 
   # already been done: the one and only entry.
   if ( not useList ) :
      #
      # Read only the necessary branches to select entries.
      # Return False as soon as a bad entry is detected.
      # To read the complete event, previously call:
      #    `fChain.GetTree().GetEntry(entry)`
      

      #
      print(">>> ", type(entry), entry)
      b_md0_d.GetEntry(entry)
      if (Abs(md0_d - 1.8646) >= 0.04) :
         return False

      #
      b_ptds_d.GetEntry(entry)
      if (ptds_d <= 2.5) :
         return False

      #
      b_etads_d.GetEntry(entry)
      if (Abs(etads_d) >= 1.5) :
         return False


      #
      # Get relevant number of entries.
      b_ik.GetEntry(entry)
      b_ipi.GetEntry(entry)
      b_ntracks.GetEntry(entry)
      b_nhitrp.GetEntry(entry)
      #
      # Note: The original name "ik" was used in the f77 (fortran-77) 
      # version. Such convention starts at 1.
      #
      ik -= 1  # for b_ik
      ipi -= 1 # for b_ipi
      #
      #
      if (nhitrp[ik] * nhitrp[ipi] <= 1) :
         return False
         
      
      #
      b_rend.GetEntry(entry)
      b_rstart.GetEntry(entry)
      #
      if (rend[ik] - rstart[ik] <= 22) :
         return False
      # #   
      if (rend[ipi] - rstart[ipi] <= 22) :
         return False

         
      #
      b_nlhk.GetEntry(entry)
      #
      if (nlhk[ik] <= 0.1) :
         return False

         
      #
      b_nlhpi.GetEntry(entry)
      #
      if (nlhpi[ipi] <= 0.1) :
         return False
         

      #
      b_ipis.GetEntry(entry)
      #
      ipis -= 1
      #
      if (nlhpi[ipis] <= 0.1) :
         return False
         

      #
      b_njets.GetEntry(entry)
      #
      if (njets < 1) :
         return False
         

      
   #
   # Fill the entry list "elist" if the "fillList" option was set True.
   if (fillList) :
      elist.Enter(entry)
      
   
   # To read the complete event, call fChain.GetTree().GetEntry(entry) before.
   # Note that the read branches are not processed in the cut process.
   b_dm_d.GetEntry(entry)   # read branch holding for dm_d
   b_rpd0_t.GetEntry(entry) # read branch holding for rpd0_t
   b_ptd0_d.GetEntry(entry) # read branch holding for ptd0_d
   
   # Fill the histograms (in 1-dim and 2-dim).
   hdmd.Fill(dm_d)
   h2.Fill(dm_d, rpd0_t / 0.029979 * 1.8646 / ptd0_d)
   
   # Count the number of selected events.
   fStatus += 1
   
   return True
   

# void
def h1analysis__SlaveTerminate( self, ) :
   # nothing to be done
   pass
   

# void
def h1analysis__Terminate( self, ) :

   """
   This function is called at the end of the main event loop.
   """
   
   fOutput = self.GetOutputList()
   hdmd = fOutput.FindObject("hdmd") # dynamic_cast<TH1F *>
   h2   = fOutput.FindObject("h2")   # dynamic_cast<TH2F *>
   
   if (hdmd == nullptr or h2 == nullptr) :
      Error("Terminate", 
            "hdmd = %s , h2 = %s" % (                       
               hex( addressof( hdmd ) ) , hex( addressof( h2 ) ),
               ),
            )
      return
      
   
   #
   # Create and Style the canvas for the "h1analysis"-fit.
   #
   gStyle.SetOptFit()
   #
   c1 = TCanvas("c1", "h1analysis analysis", 10, 10, 800, 600) # TCanvas
   c1.SetBottomMargin(0.15)
   #
   hdmd.GetXaxis().SetTitle("m_{K#pi#pi} - m_{K#pi}[GeV/c^{2}]")
   hdmd.GetXaxis().SetTitleOffset(1.4)
   
   #
   if (gROOT.GetListOfFunctions().FindObject( "f5" )) :
      #delete gROOT.GetFunction("f5")
      gROOT.GetFunction("f5")
   #
   # Fit the histogram "hdmd" with a function "f5" using the log-likelihood option.
   #
   f5 = TF1("f5", fdm5, 0.139, 0.17, 5) # TF1
   f5.SetParameters(1000000, .25, 2000, .1454, .001)
   #
   # "lr" stands for Log-likelihood-ratio and Range options.
   hdmd.Fit("f5", "lr")

   """
   Other options for `.Fit` method.

    "l": Log
        Indicates that the fit should be performed in logarithmic scale.

    "r": Log-likelihood ratio
        Used in combination with "l" as "lr" to specify that the 
        fitting should use the log-likelihood ratio.

    "q": Quiet
        Suppresses output messages during the fitting process.

    "e": Errors
        Indicates that the fit should take into account the errors in 
        the data points.

    "b": Binned
        Indicates that the fit should be performed on binned data.

    "w": Weights
        Indicates that weights should be used for the fit.

    "m": Minos
        Indicates that the MINOS algorithm should be used to calculate 
        errors on parameters.

    "c": Constrain
        Indicates that parameters should be constrained during the fit.
  
   More detailed technical information at:
   TH1
   https://root.cern/doc/master/classTH1.html
   TH1.Fit
   https://root.cern/doc/master/classTH1.html#a63eb028df86bc86c8e20c989eb23fb2a
   
   """
   
   # Create and Style the canvas for \tau_D0.
   gStyle.SetOptFit(0)
   gStyle.SetOptStat(1100)
   #
   c2 = TCanvas("c2", "tauD0", 100, 100, 800, 600) # TCanvas
   #
   c2.SetGrid()
   c2.SetBottomMargin(0.15)
   
   #
   if (gROOT.GetListOfFunctions().FindObject( "f2" )) :
      #delete gROOT.GetFunction("f2")
      gROOT.GetFunction("f2")
   #
   # Project some slices of a 2-d histogram "h2" along with X; then, fit each slice
   # with a function "f2", and make a histogram using each one of its
   # fit parameters (of "f2") .
   #
   # Note that the generated histograms are added into the list of objects
   # in the current directory.
   #
   f2 = TF1("f2", fdm2, 0.139, 0.17, 2) # TF1
   f2.SetParameters(10000, 10)
   # 
   # "qln" stands for Quiet, Logarithmic, and New histogram options.
   h2.FitSlicesX(f2, 0, -1, 1, "qln")
   #
   h2_1 = gDirectory.Get("h2_1") # (TH1D *)
   #
   h2_1.GetXaxis().SetTitle("#tau[ps]")
   h2_1.SetMarkerStyle(21)
   h2_1.Draw()
   #
   #c2.Update()
   # 
   line = TLine( 0, 0, 0, c2.GetUymax() ) # TLine
   line.Draw()
   #
   c2.Update()
   """
   More available options for the `.FitSlicesX` method are listed below.

    "q": Quiet mode. Suppresses the output of fit results to the console.
    "l": Logarithmic fitting. Fits the slices on a logarithmic scale.
    "r": Range specification. Allows you to specify a range for the fit.
    "n": Store the fit results in a new histogram.

   You can combine this options as needed.
   """

   
   #
   # Get the number of entries of the first histogram (to cross check when running
   # with the entry lists)
   psdmd = hdmd.GetListOfFunctions().FindObject("stats") # (TPaveStats *)
   #
   psdmd.SetOptStat(1110)
   #
   c1.Modified()
   


   #
   # Save the entry list into a ".root" file if one entry was produced.
   #
   if (fillList) :

      #   
      if ( not elist ) :
         elist = fOutput.FindObject("elist") # dynamic_cast<TEntryList *>
         
      #   
      if (elist) :

         Printf("Entry list 'elist' created:")
         elist.Print()
         #
         efile = TFile("elist.root", "recreate")
         elist.Write()
      # #    
      else :
         Error("Terminate", "entry list requested but not found in output")
         
      
   #
   # Notify the amount of processed events
   if ( not fInput ) :
      Info( "Terminate", "processed %lld events" % fProcessed )
      
   

# # #
# Loading methods into h1analysis class.
h1analysis = h1analysis_h.h1analysis
h1analysis.Begin            = h1analysis__Begin             
h1analysis.SlaveBegin       = h1analysis__SlaveBegin        
h1analysis.Process          = h1analysis__Process           
h1analysis.SlaveTerminate   = h1analysis__SlaveTerminate    
h1analysis.Terminate        = h1analysis__Terminate         

if __name__ == "__main__":

   # test
   #h1analysis__Begin()
   #h1analysis__SlaveBegin()
   #h1analysis__Process()
   #h1analysis__SlaveTerminate()
   #h1analysis__Terminate()

   my_tree  = TTree()
   my_entry = 0 #Long64_t(0)
   #my_entry = 11021231231321312330 #Long64_t(0)
   my_entry = 2**32   #Long64_t(0)
   #my_entry = 2**64 - 1 # error   #Long64_t(0)
   #my_entry = ctypes.c_longlong(1231231230).value
   #
   myh1analysis = h1analysis()
   #
   myh1analysis.Begin          ( my_tree  )
   myh1analysis.SlaveBegin     ( my_tree  )
   myh1analysis.Process        ( my_entry )
   myh1analysis.SlaveTerminate (          )
   myh1analysis.Terminate      (          )

   pass
