<br/> 
<hr/> 
<a name="io"></a> 
<h3>I/O</h3>
<ul>
<li>Add support for the Chirp filesystem.  To configure and build, chirp 3.2.2 must be installed.</li>
<li>When a <tt>TFile</tt> object is deleted, make sure that CINT also 'removes' any global variables that might point to it.</li>
<li>Fix support for the automatic addition to the current directory (for <tt>TTree</tt> and <tt>TH1</tt> for example) in <tt>TKey::Read(TObject*).</tt></li>
<li>In <tt>TKey</tt>, properly handle error in the I/O routines.</li>
<li>Explicitly check the validity of the zipped buffer before calling <tt>R__unzip</tt>, this allow for better error recovery.</li>
<li>When double checking whether a checksum difference is sustantial, ignore the std namespace.   Use <tt>CompareContent</tt> also in the case of where 
the class is versioned but the 'current' streamerInfo has not yet been built.</li>
<li>Prevent the I/O engine from mistakenly applying schema evolution to the <tt>TObject::fBits.</tt></li>
<li>Make sure that when a streamer info of a base class is used to stream memberwise that is always not-optimized. If the StreamerInfo on file 
has the same version as the StreamerInfo in memory but the one on file need to be 'not optimized' while the one in memory is not yet built, make 
sure it will not be optimized.</li>
<li>Fix the reading of empty collection of object when reading without the library.</li>
<li>If the sequence of actions for streaming member-wise is not created correctly (i.e. where <tt>fReadMemberWise</tt> was null previously),
we know explicitly issue a Fatal error:
<pre style="border:gray 1px solid;padding:0.5em 2em;background:#ffe">
Fatal in &lt;ReadSequence&gt;: The sequence of actions to read AliESDVertex:7 member-wise was not initialized.
aborting
</pre></li>
<li>Add new optional parameter maxbuf to <tt>TXMLEngine::ParseFile()</tt> allowing the specification of the XML file size to be parsed. This fixes issue <a href=https://savannah.cern.ch/bugs/?78864>#78864</a>.</li>
<li><h4>MakeProject</h4>
  <ul>
  <li>Add support for the case when the requested project/files in path that in not under the current directory</li>
  <li>Generate the code/dictonary only for pair type that do not already have a dictionary</li>
  </ul>
</li>
</ul>

<h4>Asynchronous Prefetching</h4>
<ul>
<li>The prefetching mechanism uses two new classes (<tt>TFilePrefetch.h</tt> and <tt>TFPBlock.h</tt>) to prefetch in advance a block of entries. There is a second thread which takes care of actually transferring the blocks and making them available to the main requesting thread. Therefore, the time spent by the main thread waiting for the data before processing considerably decreases. Besides the prefetching mechanisms there is also a local caching option which can be enabled by the user. Both capabilities are disabled by default and must be explicitly enabled by the user. 
</li>

<li>In order to enable the prefetching the user must set the environment variable <tt>TFile.AsyncPrefetching</tt> as follows: <tt>gEnv->SetValue("TFile.AsyncPrefetching", 1)</tt>. Only when the prefetching is enabled can the user set the local cache directory in which the file transferred will be saved. For subsequent reads of the same file the system will use the local copy of the file from cache. To set up a local cache directory, the client can use the following commands:
</li>
<pre style="border:gray 1px solid;padding:0.5em 2em;background:#ffe">
  TString cachedir="file:/tmp/xcache/";
  // or using xrootd on port 2000  
  // TString cachedir="root://localhost:2000//tmp/xrdcache1/";
  gEnv->SetValue("Cache.Directory", cachedir.Data());
</pre>

<li>The <tt>TFilePrefetch</tt> class is responsible with actually reading and storing the requests received from the main thread. It also creates the working thread which will transfer all the information. Apart from managing the block requests, it also deals with caching the blocks on the local machine and retrieving them when necessary. 
</li>

<li>The <tt>TFPBlock</tt> class represents the encapsulation of a block request. It contains the chunks to be prefetched and also serves as a container for the information read.</li>

<li>In order to accommodate the new prefetching mechanism the following files have suffered considerable modifications: <tt>TFileCacheRead.cxx/.h</tt>, <tt>TTreeCache.cxx/.h</tt> and to a less extent <tt>TXNetFile.cxx</tt>, <tt>TFile.h</tt>. Basically in <tt>TFileCacheRead</tt> we've added the logic for dealing with the second buffer that is prefetched. In <tt>TTreeCache</tt> during prefetching the method FillBuffer is called after each read so that once the main thread starts reading from the beginning of the last available buffer, the second thread starts prefetching the next block.
</li>
</ul>


