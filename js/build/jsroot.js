// https://root.cern/js/ v7.3.1
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.JSROOT = global.JSROOT || {}));
})(this, (function (exports) { 'use strict';

/** @summary version id
  * @desc For the JSROOT release the string in format 'major.minor.patch' like '7.0.0' */
let version_id = '7.3.1';

/** @summary version date
  * @desc Release date in format day/month/year like '14/04/2022' */
let version_date = '28/03/2023';

/** @summary version id and date
  * @desc Produced by concatenation of {@link version_id} and {@link version_date}
  * Like '7.0.0 14/04/2022' */
let version = version_id + ' ' + version_date;

/** @summary Location of JSROOT scripts
  * @desc Automatically detected and used to load other scripts or modules */
exports.source_dir = '';

let nodejs = !!((typeof process == 'object') && isObject(process.versions) && process.versions.node && process.versions.v8);

/** @summary internal data
  * @private */
let internals = {
   id_counter: 1          ///< unique id contner, starts from 1
};

//openuicfg // DO NOT DELETE, used to configure openui5 usage like internals.openui5src = 'nojsroot';

const src = (typeof document === 'undefined' && typeof location === 'undefined' ? undefined : typeof document === 'undefined' ? location.href : (document.currentScript && document.currentScript.src || new URL('jsroot.js', document.baseURI).href));if (src && isStr(src)) {
   const pos = src.indexOf('modules/core.mjs');
   if (pos >= 0) {
      exports.source_dir = src.slice(0, pos);
      console.log(`Set jsroot source_dir to ${exports.source_dir}, ${version}`);
   } else {
      console.log(`jsroot bundle, ${version}`);
      internals.ignore_v6 = true;
   }
}

let batch_mode = nodejs;

/** @summary Indicates if running in batch mode */
function isBatchMode() { return batch_mode; }

/** @summary Set batch mode */
function setBatchMode(on) { batch_mode = !!on; }

/** @summary Indicates if running inside Node.js */
function isNodeJs() { return nodejs; }

/** @summary atob function in all environments */
const atob_func = isNodeJs() ? str => Buffer.from(str,'base64').toString('latin1') : globalThis?.atob;

/** @summary btoa function in all environments */
const btoa_func = isNodeJs() ? str => Buffer.from(str,'latin1').toString('base64') : globalThis?.btoa;

let browser$1 = { isFirefox: true, isSafari: false, isChrome: false, isWin: false, touches: false };

if ((typeof document !== 'undefined') && (typeof window !== 'undefined') && (typeof navigator !== 'undefined')) {
   browser$1.isFirefox = (navigator.userAgent.indexOf('Firefox') >= 0) || (typeof InstallTrigger !== 'undefined');
   browser$1.isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
   browser$1.isChrome = !!window.chrome;
   browser$1.isChromeHeadless = navigator.userAgent.indexOf('HeadlessChrome') >= 0;
   browser$1.chromeVersion = (browser$1.isChrome || browser$1.isChromeHeadless) ? parseInt(navigator.userAgent.match(/Chrom(?:e|ium)\/([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)/)[1]) : 0;
   browser$1.isWin = navigator.userAgent.indexOf('Windows') >= 0;
   browser$1.touches = ('ontouchend' in document); // identify if touch events are supported
}

/** @summary Check if prototype string match to array (typed on untyped)
  * @return {Number} 0 - not array, 1 - regular array, 2 - typed array
  * @private */
function isArrayProto(proto) {
    if ((proto.length < 14) || (proto.indexOf('[object ') != 0)) return 0;
    let p = proto.indexOf('Array]');
    if ((p < 0) || (p != proto.length - 6)) return 0;
    // plain array has only '[object Array]', typed array type name inside
    return proto.length == 14 ? 1 : 2;
}

/** @desc Specialized JSROOT constants, used in {@link settings}
  * @namespace */
let constants$1 = {
   /** @summary Kind of 3D rendering, used for {@link settings.Render3D}
     * @namespace */
   Render3D: {
      /** @summary Default 3D rendering, normally WebGL, if not supported - SVG */
      Default: 0,
      /** @summary Use normal WebGL rendering and place as interactive Canvas element on HTML page */
      WebGL: 1,
      /** @summary Use WebGL rendering, but convert into svg image, not interactive */
      WebGLImage: 2,
      /** @summary Use SVG rendering, slow, inprecise and not interactive, nor recommendet */
      SVG: 3,
      fromString(s) {
         if ((s === 'webgl') || (s == 'gl')) return this.WebGL;
         if (s === 'img') return this.WebGLImage;
         if (s === 'svg') return this.SVG;
         return this.Default;
      }
   },
   /** @summary Way to embed 3D into SVG, used for {@link settings.Embed3D}
     * @namespace */
   Embed3D: {
      /** @summary Do not embed 3D drawing, use complete space */
      NoEmbed: -1,
      /** @summary Default embeding mode - on Firefox and latest Chrome is real ```Embed```, on all other ```Overlay``` */
      Default: 0,
      /** @summary WebGL canvas not inserted into SVG, but just overlayed The only way how earlier Chrome browser can be used */
      Overlay: 1,
      /** @summary Really embed WebGL Canvas into SVG */
      Embed: 2,
      /** @summary Embeding, but when SVG rendering or SVG image converion is used */
      EmbedSVG: 3,
      /** @summary Convert string values into number  */
      fromString(s) {
         if (s === 'embed') return this.Embed;
         if (s === 'overlay') return this.Overlay;
         return this.Default;
      }
   },
   /** @summary How to use latex in text drawing, used for {@link settings.Latex}
     * @namespace */
   Latex: {
      /** @summary do not use Latex at all for text drawing */
      Off: 0,
      /** @summary convert only known latex symbols */
      Symbols: 1,
      /** @summary normal latex processing with svg */
      Normal: 2,
      /** @summary use MathJax for complex cases, otherwise simple SVG text */
      MathJax: 3,
      /** @summary always use MathJax for text rendering */
      AlwaysMathJax: 4,
      /** @summary Convert string values into number */
      fromString(s) {
         if (!s || !isStr(s))
            return this.Normal;
         switch(s){
            case 'off': return this.Off;
            case 'symbols': return this.Symbols;
            case 'normal':
            case 'latex':
            case 'exp':
            case 'experimental': return this.Normal;
            case 'MathJax':
            case 'mathjax':
            case 'math': return this.MathJax;
            case 'AlwaysMathJax':
            case 'alwaysmath':
            case 'alwaysmathjax': return this.AlwaysMathJax;
         }
         let code = parseInt(s);
         return (Number.isInteger(code) && (code >= this.Off) && (code <= this.AlwaysMathJax)) ? code : this.Normal;
      }
   }
};

/** @desc Global JSROOT settings
  * @namespace */
let settings = {
   /** @summary Render of 3D drawing methods, see {@link constants.Render3D} for possible values */
   Render3D: constants$1.Render3D.Default,
   /** @summary 3D drawing methods in batch mode, see {@link constants.Render3D} for possible values */
   Render3DBatch: constants$1.Render3D.Default,
   /** @summary Way to embed 3D drawing in SVG, see {@link constants.Embed3D} for possible values */
   Embed3D: constants$1.Embed3D.Default,
   /** @summary Enable or disable tooltips, default on */
   Tooltip: true,
   /** @summary Time in msec for appearance of tooltips, 0 - no animation */
   TooltipAnimation: 500,
   /** @summary Enables context menu usage */
   ContextMenu: true,
   /** @summary Global zooming flag, enable/disable any kind of interactive zooming */
   Zooming: true,
   /** @summary Zooming with the mouse events */
   ZoomMouse: true,
   /** @summary Zooming with mouse wheel */
   ZoomWheel: true,
   /** @summary Zooming on touch devices */
   ZoomTouch: true,
   /** @summary Enables move and resize of elements like statbox, title, pave, colz  */
   MoveResize: true,
   /** @summary Configures keybord key press handling
     * @desc Can be disabled to prevent keys heandling in complex HTML layouts
     * @default true */
   HandleKeys: true,
   /** @summary enables drag and drop functionality */
   DragAndDrop: true,
   /** @summary Interactive dragging of TGraph points */
   DragGraphs: true,
   /** @summary Show progress box */
   ProgressBox: true,
   /** @summary Show additional tool buttons on the canvas, false - disabled, true - enabled, 'popup' - only toggle button */
   ToolBar: 'popup',
   /** @summary Position of toolbar 'left' left-bottom corner on canvas, 'right' - right-bottom corner on canvas, opposite on sub-pads */
   ToolBarSide: 'left',
   /** @summary display tool bar vertical (default false) */
   ToolBarVert: false,
   /** @summary if drawing inside particular div can be enlarged on full window */
   CanEnlarge: true,
   /** @summary if frame position can be adjusted to let show axis or colz labels */
   CanAdjustFrame: false,
   /** @summary calculation of text size consumes time and can be skipped to improve performance (but with side effects on text adjustments) */
   ApproxTextSize: false,
   /** @summary Histogram drawing optimization: 0 - disabled, 1 - only for large (>5000 1d bins, >50 2d bins) histograms, 2 - always */
   OptimizeDraw: 1,
   /** @summary Automatically create stats box, default on */
   AutoStat: true,
   /** @summary Default frame position in NFC */
   FrameNDC: { fX1NDC: 0.07, fY1NDC: 0.12, fX2NDC: 0.95, fY2NDC: 0.88 },
   /** @summary size of pad, where many features will be deactivated like text draw or zooming  */
   SmallPad: { width: 150, height: 100 },
   /** @summary Default color palette id  */
   Palette: 57,
   /** @summary Configures Latex usage, see {@link constants.Latex} for possible values */
   Latex: constants$1.Latex.Normal,
   /** @summary Grads per segment in TGeo spherical shapes like tube */
   GeoGradPerSegm: 6,
   /** @summary Enables faces compression after creation of composite shape  */
   GeoCompressComp: true,
   /** @summary if true, ignore all kind of URL options in the browser URL */
   IgnoreUrlOptions: false,
   /** @summary how many items shown on one level of hierarchy */
   HierarchyLimit: 250,
   /** @summary custom format for all X values, when not specified {@link gStyle.fStatFormat} is used */
   XValuesFormat: undefined,
   /** @summary custom format for all Y values, when not specified {@link gStyle.fStatFormat} is used */
   YValuesFormat: undefined,
   /** @summary custom format for all Z values, when not specified {@link gStyle.fStatFormat} is used */
   ZValuesFormat: undefined,
   /** @summary Let detect and solve problem when browser returns wrong content-length parameter
     * @desc See [jsroot#189]{@link https://github.com/root-project/jsroot/issues/189} for more info
     * Can be enabled by adding 'wrong_http_response' parameter to URL when using JSROOT UI
     * @default false */
   HandleWrongHttpResponse: false,
   /** @summary Tweak browser caching with stamp URL parameter
     * @desc When specified, extra URL parameter like ```?stamp=unique_value``` append to each files loaded
     * In such case browser will be forced to load file content disregards of server cache settings
     * @default true */
   UseStamp: true,
   /** @summary Maximal number of bytes ranges in http 'Range' header
     * @desc Some http server has limitations for number of bytes rannges therefore let change maximal number via setting
     * @default 200 */
   MaxRanges: 200,
   /** @summary Skip streamer infos from the GUI */
   SkipStreamerInfos: false,
   /** @summary Show only last cycle for objects in TFile */
   OnlyLastCycle: false,
   /** @summary Configures dark mode for the GUI */
   DarkMode: false,
   /** @summary Prefer to use saved points in TF1/TF2, avoids eval() and Function() when possible */
   PreferSavedPoints: false
};


if (nodejs)
   Object.assign(settings, { ToolBar: false, Tooltip: 0, ContextMenu: false, Zooming: false, MoveResize: false, DragAndDrop: false, ProgressBox: false });


/** @namespace
  * @summary Insiance of TStyle object like in ROOT
  * @desc Includes default draw styles, can be changed after loading of JSRoot.core.js
  * or can be load from the file providing style=itemname in the URL
  * See [TStyle docu]{@link https://root.cern/doc/master/classTStyle.html} 'Private attributes' section for more detailed info about each value */
let gStyle = {
   fName: 'Modern',
   /** @summary Default log x scale */
   fOptLogx: 0,
   /** @summary Default log y scale */
   fOptLogy: 0,
   /** @summary Default log z scale */
   fOptLogz: 0,
   fOptDate: 0,
   fOptFile: 0,
   fDateX: 0.01,
   fDateY: 0.01,
   /** @summary Draw histogram title */
   fOptTitle: 1,
   /** @summary Canvas fill color */
   fCanvasColor: 0,
   /** @summary Pad fill color */
   fPadColor: 0,
   fPadBottomMargin: 0.1,
   fPadTopMargin: 0.1,
   fPadLeftMargin: 0.1,
   fPadRightMargin: 0.1,
   /** @summary TPad.fGridx default value */
   fPadGridX: false,
   /** @summary TPad.fGridy default value */
   fPadGridY: false,
   fPadTickX: 0,
   fPadTickY: 0,
   /** @summary fill color for stat box */
   fStatColor: 0,
   /** @summary fill style for stat box */
   fStatStyle: 1000,
   /** @summary text color in stat box */
   fStatTextColor: 1,
   /** @summary text size in stat box */
   fStatFontSize: 0,
   /** @summary stat text font */
   fStatFont: 42,
   /** @summary Stat border size */
   fStatBorderSize: 1,
   /** @summary Printing format for stats */
   fStatFormat: '6.4g',
   fStatX: 0.98,
   fStatY: 0.935,
   fStatW: 0.2,
   fStatH: 0.16,
   fTitleAlign: 23,
   fTitleColor: 0,
   fTitleTextColor: 1,
   fTitleBorderSize: 0,
   fTitleFont: 42,
   fTitleFontSize: 0.05,
   fTitleStyle: 0,
   /** @summary X position of top left corner of title box */
   fTitleX: 0.5,
   /** @summary Y position of top left corner of title box  */
   fTitleY: 0.995,
   /** @summary Width of title box */
   fTitleW: 0,
   /** @summary Height of title box */
   fTitleH: 0,
   /** @summary Printing format for fit parameters */
   fFitFormat: '5.4g',
   fOptStat: 1111,
   fOptFit: 0,
   fNumberContours: 20,
   fGridColor: 0,
   fGridStyle: 3,
   fGridWidth: 1,
   fFrameFillColor: 0,
   fFrameFillStyle: 1001,
   fFrameLineColor: 1,
   fFrameLineWidth: 1,
   fFrameLineStyle: 1,
   fFrameBorderSize: 1,
   fFrameBorderMode: 0,
   /** @summary size in pixels of end error for E1 draw options */
   fEndErrorSize: 2,
   /** @summary X size of the error marks for the histogram drawings */
   fErrorX: 0.5,
   /** @summary when true, BAR and LEGO drawing using base = 0  */
   fHistMinimumZero: false,
   /** @summary Margin between histogram's top and pad's top */
   fHistTopMargin: 0.05,
   fHistFillColor: 0,
   fHistFillStyle: 1001,
   fHistLineColor: 602,
   fHistLineStyle: 1,
   fHistLineWidth: 1,
   /** @summary format for bin content */
   fPaintTextFormat: 'g',
   /** @summary default time offset, UTC time at 01/01/95   */
   fTimeOffset: 788918400,
   fLegendBorderSize: 1,
   fLegendFont: 42,
   fLegendTextSize: 0,
   fLegendFillColor: 0,
   fHatchesLineWidth: 1,
   fHatchesSpacing: 1
};

/** @summary Method returns current document in use
  * @private */
function getDocument() {
   if (nodejs)
      return internals.nodejs_document;
   if (typeof document !== 'undefined')
      return document;
   if (typeof window == 'object')
      return window.document;
   return undefined;
}

/** @summary Inject javascript code
  * @desc Replacement for eval
  * @return {Promise} when code is injected
  * @private */
async function injectCode(code) {
   if (nodejs) {
      let name, fs;
      return Promise.resolve().then(function () { return _rollup_plugin_ignore_empty_module_placeholder$1; }).then(tmp => {
         name = tmp.tmpNameSync() + '.js';
         return Promise.resolve().then(function () { return _rollup_plugin_ignore_empty_module_placeholder$1; });
      }).then(_fs => {
         fs = _fs;
         fs.writeFileSync(name, code);
         return import(/* webpackIgnore: true */ 'file://' + name);
      }).finally(() => fs.unlinkSync(name));
   }

   if (typeof document !== 'undefined') {
      // check if code already loaded - to avoid duplication
      let scripts = document.getElementsByTagName('script');
      for (let n = 0; n < scripts.length; ++n)
         if (scripts[n].innerHTML == code)
            return true;

      let promise = code.indexOf('JSROOT.require') >= 0 ? _ensureJSROOT() : Promise.resolve(true);

      return promise.then(() => {
         return new Promise(resolve => {
            let element = document.createElement('script');
            element.setAttribute('type', 'text/javascript');
            element.innerHTML = code;
            document.head.appendChild(element);
            setTimeout(() => resolve(true), 10); // while onload event not fired, just postpone resolve
         });
      });
   }

   return false;
}

/** @summary Load script or CSS file into the browser
  * @param {String} url - script or css file URL (or array, in this case they all loaded secuentially)
  * @return {Promise} */
async function loadScript(url) {
   if (!url)
      return true;

   if (isStr(url) && (url.indexOf(';') >= 0))
      url = url.split(';');

   if (!isStr(url)) {
      let scripts = url, loadNext = () => {
         if (!scripts.length) return true;
         return loadScript(scripts.shift()).then(loadNext, loadNext);
      };
      return loadNext();
   }

   if (url.indexOf('$$$') === 0) {
      url = url.slice(3);
      if ((url.indexOf('style/') == 0) && (url.indexOf('.css') < 0))
         url += '.css';
      url = exports.source_dir + url;
   }

   let element, isstyle = url.indexOf('.css') > 0;

   if (nodejs) {
      if (isstyle)
         return null;
      if ((url.indexOf('http:') == 0) || (url.indexOf('https:') == 0))
         return httpRequest(url, 'text').then(code => injectCode(code));

      return import(/* webpackIgnore: true */ url);
   }

   const match_url = src => {
      if (src == url) return true;
      let indx = src.indexOf(url);
      return (indx > 0) && (indx + url.length == src.length) && (src[indx-1] == '/');
   };

   if (isstyle) {
      let styles = document.getElementsByTagName('link');
      for (let n = 0; n < styles.length; ++n) {
         if (!styles[n].href || (styles[n].type !== 'text/css') || (styles[n].rel !== 'stylesheet')) continue;
         if (match_url(styles[n].href))
            return true;
      }

   } else {
      let scripts = document.getElementsByTagName('script');
      for (let n = 0; n < scripts.length; ++n)
         if (match_url(scripts[n].src))
            return true;
   }

   if (isstyle) {
      element = document.createElement('link');
      element.setAttribute('rel', 'stylesheet');
      element.setAttribute('type', 'text/css');
      element.setAttribute('href', url);
   } else {
      element = document.createElement('script');
      element.setAttribute('type', 'text/javascript');
      element.setAttribute('src', url);
   }

   return new Promise((resolveFunc, rejectFunc) => {
      element.onload = () => resolveFunc(true);
      element.onerror = () => { element.remove(); rejectFunc(Error(`Fail to load ${url}`)); };
      document.head.appendChild(element);
   });
}

/** @summary Generate mask for given bit
  * @param {number} n bit number
  * @return {Number} produced mask
  * @private */
function BIT(n) { return 1 << n; }

/** @summary Make deep clone of the object, including all sub-objects
  * @return {object} cloned object
  * @private */
function clone(src, map, nofunc) {
   if (!src) return null;

   if (!map) {
      map = { obj: [], clones: [], nofunc: nofunc };
   } else {
      const i = map.obj.indexOf(src);
      if (i >= 0) return map.clones[i];
   }

   let arr_kind = isArrayProto(Object.prototype.toString.apply(src));

   // process normal array
   if (arr_kind == 1) {
      let tgt = [];
      map.obj.push(src);
      map.clones.push(tgt);
      for (let i = 0; i < src.length; ++i)
         if (isObject(src[i]))
            tgt.push(clone(src[i], map));
         else
            tgt.push(src[i]);

      return tgt;
   }

   // process typed array
   if (arr_kind == 2) {
      let tgt = [];
      map.obj.push(src);
      map.clones.push(tgt);
      for (let i = 0; i < src.length; ++i)
         tgt.push(src[i]);

      return tgt;
   }

   let tgt = {};
   map.obj.push(src);
   map.clones.push(tgt);

   for (let k in src) {
      if (isObject(src[k]))
         tgt[k] = clone(src[k], map);
      else if (!map.nofunc || !isFunc(src[k]))
         tgt[k] = src[k];
   }

   return tgt;
}

// used very often - keep shortcut
const extend$1 = Object.assign;

/** @summary Adds specific methods to the object.
  * @desc JSROOT implements some basic methods for different ROOT classes.
  * @param {object} obj - object where methods are assigned
  * @param {string} [typename] - optional typename, if not specified, obj._typename will be used
  * @private */
function addMethods(obj, typename) {
   extend$1(obj, getMethods(typename || obj._typename, obj));
}

/** @summary Should be used to parse JSON string produced with TBufferJSON class
  * @desc Replace all references inside object like { "$ref": "1" }
  * @param {object|string} json  object where references will be replaced
  * @return {object} parsed object */
function parse(json) {

   if (!json) return null;

   let obj = isStr(json) ? JSON.parse(json) : json,
       map = [], newfmt = undefined;

   const unref_value = value => {
      if ((value === null) || (value === undefined)) return;

      if (isStr(value)) {
         if (newfmt || (value.length < 6) || (value.indexOf('$ref:') !== 0)) return;
         let ref = parseInt(value.slice(5));
         if (!Number.isInteger(ref) || (ref < 0) || (ref >= map.length)) return;
         newfmt = false;
         return map[ref];
      }

      if (typeof value !== 'object') return;

      let proto = Object.prototype.toString.apply(value);

      // scan array - it can contain other objects
      if (isArrayProto(proto) > 0) {
          for (let i = 0; i < value.length; ++i) {
             let res = unref_value(value[i]);
             if (res !== undefined) value[i] = res;
          }
          return;
      }

      let ks = Object.keys(value), len = ks.length;

      if ((newfmt !== false) && (len === 1) && (ks[0] === '$ref')) {
         const ref = parseInt(value['$ref']);
         if (!Number.isInteger(ref) || (ref < 0) || (ref >= map.length)) return;
         newfmt = true;
         return map[ref];
      }

      if ((newfmt !== false) && (len > 1) && (ks[0] === '$arr') && (ks[1] === 'len')) {
         // this is ROOT-coded array
         let arr;
         switch (value.$arr) {
            case 'Int8': arr = new Int8Array(value.len); break;
            case 'Uint8': arr = new Uint8Array(value.len); break;
            case 'Int16': arr = new Int16Array(value.len); break;
            case 'Uint16': arr = new Uint16Array(value.len); break;
            case 'Int32': arr = new Int32Array(value.len); break;
            case 'Uint32': arr = new Uint32Array(value.len); break;
            case 'Float32': arr = new Float32Array(value.len); break;
            case 'Int64':
            case 'Uint64':
            case 'Float64': arr = new Float64Array(value.len); break;
            default: arr = new Array(value.len);
         }

         arr.fill((value.$arr === 'Bool') ? false : 0);

         if (value.b !== undefined) {
            // base64 coding

            let buf = atob_func(value.b);

            if (arr.buffer) {
               let dv = new DataView(arr.buffer, value.o || 0),
                   len = Math.min(buf.length, dv.byteLength);
               for (let k = 0; k < len; ++k)
                  dv.setUint8(k, buf.charCodeAt(k));
            } else {
               throw new Error('base64 coding supported only for native arrays with binary data');
            }
         } else {
            // compressed coding
            let nkey = 2, p = 0;
            while (nkey < len) {
               if (ks[nkey][0] == 'p') p = value[ks[nkey++]]; // position
               if (ks[nkey][0] !== 'v') throw new Error(`Unexpected member ${ks[nkey]} in array decoding`);
               let v = value[ks[nkey++]]; // value
               if (typeof v === 'object') {
                  for (let k = 0; k < v.length; ++k) arr[p++] = v[k];
               } else {
                  arr[p++] = v;
                  if ((nkey < len) && (ks[nkey][0] == 'n')) {
                     let cnt = value[ks[nkey++]]; // counter
                     while (--cnt) arr[p++] = v;
                  }
               }
            }
         }

         return arr;
      }

      if ((newfmt !== false) && (len === 3) && (ks[0] === '$pair') && (ks[1] === 'first') && (ks[2] === 'second')) {
         newfmt = true;
         let f1 = unref_value(value.first),
             s1 = unref_value(value.second);
         if (f1 !== undefined) value.first = f1;
         if (s1 !== undefined) value.second = s1;
         value._typename = value['$pair'];
         delete value['$pair'];
         return; // pair object is not counted in the objects map
      }

     // prevent endless loop
     if (map.indexOf(value) >= 0) return;

      // add object to object map
      map.push(value);

      // add methods to all objects, where _typename is specified
      if (value._typename) addMethods(value);

      for (let k = 0; k < len; ++k) {
         const i = ks[k],
              res = unref_value(value[i]);
         if (res !== undefined) value[i] = res;
      }
   };

   unref_value(obj);

   return obj;
}

/** @summary Parse response from multi.json request
  * @desc Method should be used to parse JSON code, produced by multi.json request of THttpServer
  * @param {string} json string to parse
  * @return {Array} array of parsed elements */
function parseMulti(json) {
   if (!json) return null;
   let arr = JSON.parse(json);
   if (arr && arr.length)
      for (let i = 0; i < arr.length; ++i)
         arr[i] = parse(arr[i]);
   return arr;
}

/** @summary Method converts JavaScript object into ROOT-like JSON
  * @desc Produced JSON can be used in parse() again
  * When performed properly, JSON can be used in [TBufferJSON::fromJSON()]{@link https://root.cern/doc/master/classTBufferJSON.html#a2ecf0daacdad801e60b8093a404c897d} method to read data back with C++
  * @param {object} obj - JavaScript object to convert
  * @param {number} [spacing] - optional line spacing in JSON
  * @return {string} produced JSON code */
function toJSON(obj, spacing) {
   if (!isObject(obj)) return '';

   let map = []; // map of stored objects

   const copy_value = value => {
      if (isFunc(value)) return undefined;

      if ((value === undefined) || (value === null) || !isObject(value)) return value;

      // typed array need to be converted into normal array, otherwise looks strange
      if (isArrayProto(Object.prototype.toString.apply(value)) > 0) {
         let arr = new Array(value.length);
         for (let i = 0; i < value.length; ++i)
            arr[i] = copy_value(value[i]);
         return arr;
      }

      // this is how reference is code
      let refid = map.indexOf(value);
      if (refid >= 0) return { $ref: refid };

      let ks = Object.keys(value), len = ks.length, tgt = {};

      if ((len == 3) && (ks[0] === '$pair') && (ks[1] === 'first') && (ks[2] === 'second')) {
         // special handling of pair objects which does not included into objects map
         tgt.$pair = value.$pair;
         tgt.first = copy_value(value.first);
         tgt.second = copy_value(value.second);
         return tgt;
      }

      map.push(value);

      for (let k = 0; k < len; ++k) {
         let name = ks[k];
         if (name && (name[0] != '$'))
            tgt[name] = copy_value(value[name]);
      }

      return tgt;
   };

   let tgt = copy_value(obj);

   return JSON.stringify(tgt, null, spacing);
}

/** @summary decodes URL options after '?' mark
  * @desc Following options supported ?opt1&opt2=3
  * @param {string} [url] URL string with options, document.URL will be used when not specified
  * @return {Object} with ```.has(opt)``` and ```.get(opt,dflt)``` methods
  * @example
  * let d = decodeUrl('any?opt1&op2=3');
  * console.log(`Has opt1 ${d.has('opt1')}`);     // true
  * console.log(`Get opt1 ${d.get('opt1')}`);     // ''
  * console.log(`Get opt2 ${d.get('opt2')}`);     // '3'
  * console.log(`Get opt3 ${d.get('opt3','-')}`); // '-' */
function decodeUrl(url) {
   let res = {
      opts: {},
      has(opt) { return this.opts[opt] !== undefined; },
      get(opt,dflt) { let v = this.opts[opt]; return v !== undefined ? v : dflt; }
   };

   if (!url || !isStr(url)) {
      if (settings.IgnoreUrlOptions || (typeof document === 'undefined')) return res;
      url = document.URL;
   }
   res.url = url;

   let p1 = url.indexOf('?');
   if (p1 < 0) return res;
   url = decodeURI(url.slice(p1+1));

   while (url) {

      // try to correctly handle quotes in the URL
      let pos = 0, nq = 0, eq = -1, firstq = -1;
      while ((pos < url.length) && ((nq !== 0) || ((url[pos] !== '&') && (url[pos] !== '#')))) {
         switch (url[pos]) {
            case "'": if (nq >= 0) nq = (nq+1)%2; if (firstq < 0) firstq = pos; break;
            case '"': if (nq <= 0) nq = (nq-1)%2; if (firstq < 0) firstq = pos; break;
            case '=': if ((firstq < 0) && (eq < 0)) eq = pos; break;
         }
         pos++;
      }

      if ((eq < 0) && (firstq < 0)) {
         res.opts[url.slice(0,pos)] = '';
      } if (eq > 0) {
         let val = url.slice(eq+1, pos);
         if (((val[0] === "'") || (val[0] === '"')) && (val[0] === val[val.length-1])) val = val.slice(1, val.length-1);
         res.opts[url.slice(0,eq)] = val;
      }

      if ((pos >= url.length) || (url[pos] == '#')) break;

      url = url.slice(pos+1);
   }

   return res;
}

/** @summary Find function with given name
  * @private */
function findFunction(name) {
   if (isFunc(name)) return name;
   if (!isStr(name)) return null;
   let names = name.split('.'), elem = globalThis;

   for (let n = 0; elem && (n < names.length); ++n)
      elem = elem[names[n]];

   return isFunc(elem) ? elem : null;
}


/** @summary Assign methods to request
  * @private */
function setRequestMethods(xhr, url, kind, user_accept_callback, user_reject_callback) {
   xhr.http_callback = isFunc(user_accept_callback) ? user_accept_callback.bind(xhr) : function() {};
   xhr.error_callback = isFunc(user_reject_callback) ? user_reject_callback.bind(xhr) : function(err) { console.warn(err.message); this.http_callback(null); }.bind(xhr);

   if (!kind) kind = 'buf';

   let method = 'GET', is_async = true, p = kind.indexOf(';sync');
   if (p > 0) { kind = kind.slice(0,p); is_async = false; }
   switch (kind) {
      case 'head': method = 'HEAD'; break;
      case 'posttext': method = 'POST'; kind = 'text'; break;
      case 'postbuf':  method = 'POST'; kind = 'buf'; break;
      case 'post':
      case 'multi': method = 'POST'; break;
   }

   xhr.kind = kind;

   if (settings.HandleWrongHttpResponse && (method == 'GET') && isFunc(xhr.addEventListener))
      xhr.addEventListener('progress', function(oEvent) {
         if (oEvent.lengthComputable && this.expected_size && (oEvent.loaded > this.expected_size)) {
            this.did_abort = true;
            this.abort();
            this.error_callback(Error(`Server sends more bytes ${oEvent.loaded} than expected ${this.expected_size}. Abort I/O operation`), 598);
         }
      }.bind(xhr));

   xhr.onreadystatechange = function() {

      if (this.did_abort) return;

      if ((this.readyState === 2) && this.expected_size) {
         let len = parseInt(this.getResponseHeader('Content-Length'));
         if (Number.isInteger(len) && (len > this.expected_size) && !settings.HandleWrongHttpResponse) {
            this.did_abort = true;
            this.abort();
            return this.error_callback(Error(`Server response size ${len} larger than expected ${this.expected_size}. Abort I/O operation`), 599);
         }
      }

      if (this.readyState != 4) return;

      if ((this.status != 200) && (this.status != 206) && !browser$1.qt5 &&
          // in these special cases browsers not always set status
          !((this.status == 0) && ((url.indexOf('file://') == 0) || (url.indexOf('blob:') == 0)))) {
            return this.error_callback(Error(`Fail to load url ${url}`), this.status);
      }

      if (this.nodejs_checkzip && (this.getResponseHeader('content-encoding') == 'gzip'))
         // special handling of gzipped JSON objects in Node.js
         return Promise.resolve().then(function () { return _rollup_plugin_ignore_empty_module_placeholder$1; }).then(handle => {
             let res = handle.unzipSync(Buffer.from(this.response)),
                 obj = JSON.parse(res); // zlib returns Buffer, use JSON to parse it
            return this.http_callback(parse(obj));
         });

      switch(this.kind) {
         case 'xml': return this.http_callback(this.responseXML);
         case 'text': return this.http_callback(this.responseText);
         case 'object': return this.http_callback(parse(this.responseText));
         case 'multi': return this.http_callback(parseMulti(this.responseText));
         case 'head': return this.http_callback(this);
      }

      // if no response type is supported, return as text (most probably, will fail)
      if (this.responseType === undefined)
         return this.http_callback(this.responseText);

      if ((this.kind == 'bin') && ('byteLength' in this.response)) {
         // if string representation in requested - provide it

         let filecontent = '', u8Arr = new Uint8Array(this.response);
         for (let i = 0; i < u8Arr.length; ++i)
            filecontent += String.fromCharCode(u8Arr[i]);

         return this.http_callback(filecontent);
      }

      this.http_callback(this.response);
   };

   xhr.open(method, url, is_async);

   if ((kind == 'bin') || (kind == 'buf'))
      xhr.responseType = 'arraybuffer';

   if (nodejs && (method == 'GET') && (kind === 'object') && (url.indexOf('.json.gz') > 0)) {
      xhr.nodejs_checkzip = true;
      xhr.responseType = 'arraybuffer';
   }

   return xhr;
}

/** @summary Method to create http request, without promise can be used only in browser environment
  * @private */
function createHttpRequest(url, kind, user_accept_callback, user_reject_callback, use_promise) {
   if (isNodeJs()) {
      if (!use_promise)
         throw Error('Not allowed to create http requests in node without promise');
      return Promise.resolve().then(function () { return _rollup_plugin_ignore_empty_module_placeholder$1; }).then(h => {
         let xhr = new h.default();
         setRequestMethods(xhr, url, kind, user_accept_callback, user_reject_callback);
         return xhr;
      });
   }

   let xhr = new XMLHttpRequest();
   setRequestMethods(xhr, url, kind, user_accept_callback, user_reject_callback);
   return use_promise ? Promise.resolve(xhr) : xhr;
}

/** @summary Submit asynchronoues http request
  * @desc Following requests kind can be specified:
  *    - 'bin' - abstract binary data, result as string
  *    - 'buf' - abstract binary data, result as ArrayBuffer (default)
  *    - 'text' - returns req.responseText
  *    - 'object' - returns parse(req.responseText)
  *    - 'multi' - returns correctly parsed multi.json request
  *    - 'xml' - returns req.responseXML
  *    - 'head' - returns request itself, uses 'HEAD' request method
  *    - 'post' - creates post request, submits req.send(post_data)
  *    - 'postbuf' - creates post request, expectes binary data as response
  * @param {string} url - URL for the request
  * @param {string} kind - kind of requested data
  * @param {string} [post_data] - data submitted with post kind of request
  * @return {Promise} Promise for requested data, result type depends from the kind
  * @example
  * httpRequest('https://root.cern/js/files/thstack.json.gz', 'object')
  *       .then(obj => console.log(`Get object of type ${obj._typename}`))
  *       .catch(err => console.error(err.message)); */
async function httpRequest(url, kind, post_data) {
   return new Promise((accept, reject) => {
      createHttpRequest(url, kind, accept, reject, true).then(xhr => xhr.send(post_data || null));
   });
}

const clTObject = 'TObject', clTNamed = 'TNamed',
      clTString = 'TString', clTObjString = 'TObjString',
      clTList = 'TList', clTHashList = 'THashList', clTMap = 'TMap', clTObjArray = 'TObjArray', clTClonesArray = 'TClonesArray',
      clTAttLine = 'TAttLine', clTAttFill = 'TAttFill', clTAttMarker = 'TAttMarker', clTAttText = 'TAttText',
      clTHStack = 'THStack', clTGraph = 'TGraph', clTMultiGraph = 'TMultiGraph', clTCutG = 'TCutG',
      clTGraphPolargram = 'TGraphPolargram', clTGraphTime = 'TGraphTime',
      clTPave = 'TPave', clTPaveText = 'TPaveText', clTPaveStats = 'TPaveStats',
      clTLegend = 'TLegend', clTLegendEntry = 'TLegendEntry', clTPaletteAxis = 'TPaletteAxis',
      clTText = 'TText', clTLatex = 'TLatex', clTMathText = 'TMathText',
      clTColor = 'TColor', clTLine = 'TLine', clTBox = 'TBox', clTPolyLine = 'TPolyLine',
      clTPolyLine3D = 'TPolyLine3D', clTPolyMarker3D = 'TPolyMarker3D',
      clTAttPad = 'TAttPad', clTPad = 'TPad', clTCanvas = 'TCanvas', clTAttCanvas = 'TAttCanvas',
      clTGaxis = 'TGaxis', clTAttAxis = 'TAttAxis', clTAxis = 'TAxis', clTStyle = 'TStyle',
      clTH1 = 'TH1', clTH2 = 'TH2', clTH3 = 'TH3', clTF1 = 'TF1', clTF2 = 'TF2', clTProfile = 'TProfile', clTProfile2D = 'TProfile2D',
      clTGeoVolume = 'TGeoVolume', clTGeoNode = 'TGeoNode', clTGeoNodeMatrix = 'TGeoNodeMatrix',
      kNoZoom = -1111;


/** @summary Create some ROOT classes
  * @desc Supported classes: `TObject`, `TNamed`, `TList`, `TAxis`, `TLine`, `TText`, `TLatex`, `TPad`, `TCanvas`
  * @param {string} typename - ROOT class name
  * @example
  * import { create } from 'path_to_jsroot/modules/core.mjs';
  * let obj = create('TNamed');
  * obj.fName = 'name';
  * obj.fTitle = 'title'; */
function create$1(typename, target) {
   let obj = target || {};

   switch (typename) {
      case clTObject:
          extend$1(obj, { fUniqueID: 0, fBits: 0 });
          break;
      case clTNamed:
         extend$1(obj, { fUniqueID: 0, fBits: 0, fName: '', fTitle: '' });
         break;
      case clTList:
      case clTHashList:
         extend$1(obj, { name: typename, arr: [], opt: [] });
         break;
      case clTAttAxis:
         extend$1(obj, { fNdivisions: 510, fAxisColor: 1,
                       fLabelColor: 1, fLabelFont: 42, fLabelOffset: 0.005, fLabelSize: 0.035, fTickLength: 0.03,
                       fTitleOffset: 1, fTitleSize: 0.035, fTitleColor: 1, fTitleFont: 42 });
         break;
      case clTAxis:
         create$1(clTNamed, obj);
         create$1(clTAttAxis, obj);
         extend$1(obj, { fNbins: 1, fXmin: 0, fXmax: 1, fXbins : [], fFirst: 0, fLast: 0,
                       fBits2: 0, fTimeDisplay: false, fTimeFormat: '', fLabels: null, fModLabs: null });
         break;
      case clTAttLine:
         extend$1(obj, { fLineColor: 1, fLineStyle: 1, fLineWidth: 1 });
         break;
      case clTAttFill:
         extend$1(obj, { fFillColor: 0, fFillStyle: 0 });
         break;
      case clTAttMarker:
         extend$1(obj, { fMarkerColor: 1, fMarkerStyle: 1, fMarkerSize: 1. });
         break;
      case clTLine:
         create$1(clTObject, obj);
         create$1(clTAttLine, obj);
         extend$1(obj, { fX1: 0, fX2: 1, fY1: 0, fY2: 1 });
         break;
      case clTBox:
         create$1(clTObject, obj);
         create$1(clTAttLine, obj);
         create$1(clTAttFill, obj);
         extend$1(obj, { fX1: 0, fX2: 1, fY1: 0, fY2: 1 });
         break;
      case clTPave:
         create$1(clTBox, obj);
         extend$1(obj, { fX1NDC : 0., fY1NDC: 0, fX2NDC: 1, fY2NDC: 1,
                       fBorderSize: 0, fInit: 1, fShadowColor: 1,
                       fCornerRadius: 0, fOption: 'brNDC', fName: 'title' });
         break;
      case clTAttText:
         extend$1(obj, { fTextAngle: 0, fTextSize: 0, fTextAlign: 22, fTextColor: 1, fTextFont: 42});
         break;
      case clTPaveText:
         create$1(clTPave, obj);
         create$1(clTAttText, obj);
         extend$1(obj, { fLabel: '', fLongest: 27, fMargin: 0.05, fLines: create$1(clTList) });
         break;
      case clTPaveStats:
         create$1(clTPaveText, obj);
         extend$1(obj, { fFillColor: gStyle.fStatColor, fFillStyle: gStyle.fStatStyle,
                       fTextFont: gStyle.fStatFont, fTextSize: gStyle.fStatFontSize, fTextColor: gStyle.fStatTextColor,
                       fBorderSize: gStyle.fStatBorderSize,
                       fOptFit: 0, fOptStat: 0, fFitFormat: '', fStatFormat: '', fParent: null });
         break;
      case clTLegend:
         create$1(clTPave, obj);
         create$1(clTAttText, obj);
         extend$1(obj, { fColumnSeparation: 0, fEntrySeparation: 0.1, fMargin: 0.25, fNColumns: 1, fPrimitives: create$1(clTList),
                       fBorderSize: gStyle.fLegendBorderSize, fTextFont: gStyle.fLegendFont, fTextSize: gStyle.fLegendTextSize, fFillColor: gStyle.fLegendFillColor });
         break;
      case clTPaletteAxis:
         create$1(clTPave, obj);
         extend$1(obj, { fAxis: create$1(clTGaxis), fH: null, fName: clTPave });
         break;
      case clTLegendEntry:
         create$1(clTObject, obj);
         create$1(clTAttText, obj);
         create$1(clTAttLine, obj);
         create$1(clTAttFill, obj);
         create$1(clTAttMarker, obj);
         extend$1(obj, { fLabel: '', fObject: null, fOption: '' });
         break;
      case clTText:
         create$1(clTNamed, obj);
         create$1(clTAttText, obj);
         extend$1(obj, { fLimitFactorSize: 3, fOriginSize: 0.04 });
         break;
      case clTLatex:
         create$1(clTText, obj);
         create$1(clTAttLine, obj);
         extend$1(obj, { fX: 0, fY: 0 });
         break;
      case clTObjString:
         create$1(clTObject, obj);
         extend$1(obj, { fString: '' });
         break;
      case clTH1:
         create$1(clTNamed, obj);
         create$1(clTAttLine, obj);
         create$1(clTAttFill, obj);
         create$1(clTAttMarker, obj);
         extend$1(obj, { fBits: 8, fNcells: 0,
                       fXaxis: create$1(clTAxis), fYaxis: create$1(clTAxis), fZaxis: create$1(clTAxis),
                       fFillColor: gStyle.fHistFillColor, fFillStyle: gStyle.fHistFillStyle,
                       fLineColor: gStyle.fHistLineColor, fLineStyle: gStyle.fHistLineStyle, fLineWidth: gStyle.fHistLineWidth,
                       fBarOffset: 0, fBarWidth: 1000, fEntries: 0.,
                       fTsumw: 0., fTsumw2: 0., fTsumwx: 0., fTsumwx2: 0.,
                       fMaximum: kNoZoom, fMinimum: kNoZoom, fNormFactor: 0., fContour: [],
                       fSumw2: [], fOption: '', fFunctions: create$1(clTList),
                       fBufferSize: 0, fBuffer: [], fBinStatErrOpt: 0, fStatOverflows: 2 });
         break;
      case 'TH1I':
      case 'TH1L64':
      case 'TH1F':
      case 'TH1D':
      case 'TH1S':
      case 'TH1C':
         create$1(clTH1, obj);
         obj.fArray = [];
         break;
      case clTH2:
         create$1(clTH1, obj);
         extend$1(obj, { fScalefactor: 1., fTsumwy: 0.,  fTsumwy2: 0, fTsumwxy: 0 });
         break;
      case 'TH2I':
      case 'TH2L64':
      case 'TH2F':
      case 'TH2D':
      case 'TH2S':
      case 'TH2C':
         create$1(clTH2, obj);
         obj.fArray = [];
         break;
      case clTH3:
         create$1(clTH1, obj);
         extend$1(obj, { fTsumwy: 0.,  fTsumwy2: 0, fTsumwz: 0.,  fTsumwz2: 0, fTsumwxy: 0, fTsumwxz: 0, fTsumwyz: 0 });
         break;
      case 'TH3I':
      case 'TH3L64':
      case 'TH3F':
      case 'TH3D':
      case 'TH3S':
      case 'TH3C':
         create$1(clTH3, obj);
         obj.fArray = [];
         break;
      case clTHStack:
         create$1(clTNamed, obj);
         extend$1(obj, { fHists: create$1(clTList), fHistogram: null, fMaximum: kNoZoom, fMinimum: kNoZoom });
         break;
      case clTGraph:
         create$1(clTNamed, obj);
         create$1(clTAttLine, obj);
         create$1(clTAttFill, obj);
         create$1(clTAttMarker, obj);
         extend$1(obj, { fFunctions: create$1(clTList), fHistogram: null,
                       fMaxSize: 0, fMaximum: kNoZoom, fMinimum: kNoZoom, fNpoints: 0, fX: [], fY: [] });
         break;
      case 'TGraphAsymmErrors':
         create$1(clTGraph, obj);
         extend$1(obj, { fEXlow: [], fEXhigh: [], fEYlow: [], fEYhigh: []});
         break;
      case clTMultiGraph:
         create$1(clTNamed, obj);
         extend$1(obj, { fFunctions: create$1(clTList), fGraphs: create$1(clTList),
                       fHistogram: null, fMaximum: kNoZoom, fMinimum: kNoZoom });
         break;
      case clTGraphPolargram:
         create$1(clTNamed, obj);
         create$1(clTAttText, obj);
         create$1(clTAttLine, obj);
         extend$1(obj, { fRadian: true, fDegree: false, fGrad: false, fPolarLabelColor: 1, fRadialLabelColor: 1,
                       fAxisAngle: 0, fPolarOffset: 0.04, fPolarTextSize: 0.04, fRadialOffset: 0.025, fRadialTextSize: 0.035,
                       fRwrmin: 0, fRwrmax: 1, fRwtmin: 0, fRwtmax: 2*Math.PI, fTickpolarSize: 0.02,
                       fPolarLabelFont: 62, fRadialLabelFont: 62, fCutRadial: 0, fNdivRad: 508, fNdivPol: 508 });
         break;
      case clTPolyLine:
         create$1(clTObject, obj);
         create$1(clTAttLine, obj);
         create$1(clTAttFill, obj);
         extend$1(obj, { fLastPoint: -1, fN: 0, fOption: '', fX: null, fY: null });
         break;
      case clTGaxis:
         create$1(clTLine, obj);
         create$1(clTAttText, obj);
         extend$1(obj, { fChopt: '', fFunctionName: '', fGridLength: 0,
                       fLabelColor: 1, fLabelFont: 42, fLabelOffset: 0.005, fLabelSize: 0.035,
                       fName: '', fNdiv: 12, fTickSize: 0.02, fTimeFormat: '',
                       fTitle: '', fTitleOffset: 1, fTitleSize: 0.035,
                       fWmax: 100, fWmin: 0 });
         break;
      case clTAttPad:
         extend$1(obj, { fLeftMargin: gStyle.fPadLeftMargin,
                       fRightMargin: gStyle.fPadRightMargin,
                       fBottomMargin: gStyle.fPadBottomMargin,
                       fTopMargin: gStyle.fPadTopMargin,
                       fXfile: 2, fYfile: 2, fAfile: 1, fXstat: 0.99, fYstat: 0.99, fAstat: 2,
                       fFrameFillColor: gStyle.fFrameFillColor,
                       fFrameFillStyle: gStyle.fFrameFillStyle,
                       fFrameLineColor: gStyle.fFrameLineColor,
                       fFrameLineWidth: gStyle.fFrameLineWidth,
                       fFrameLineStyle: gStyle.fFrameLineStyle,
                       fFrameBorderSize: gStyle.fFrameBorderSize,
                       fFrameBorderMode: gStyle.fFrameBorderMode });
         break;
      case clTPad:
         create$1(clTObject, obj);
         create$1(clTAttLine, obj);
         create$1(clTAttFill, obj);
         create$1(clTAttPad, obj);
         extend$1(obj, { fFillColor: gStyle.fPadColor, fFillStyle: 1001,
                       fX1: 0, fY1: 0, fX2: 1, fY2: 1, fXtoAbsPixelk: 1, fXtoPixelk: 1,
                       fXtoPixel: 1, fYtoAbsPixelk: 1, fYtoPixelk: 1, fYtoPixel: 1,
                       fUtoAbsPixelk: 1, fUtoPixelk: 1, fUtoPixel: 1, fVtoAbsPixelk: 1,
                       fVtoPixelk: 1, fVtoPixel: 1, fAbsPixeltoXk: 1, fPixeltoXk: 1,
                       fPixeltoX: 1, fAbsPixeltoYk: 1, fPixeltoYk: 1, fPixeltoY: 1,
                       fXlowNDC: 0, fYlowNDC: 0, fXUpNDC: 0, fYUpNDC: 0, fWNDC: 1, fHNDC: 1,
                       fAbsXlowNDC: 0, fAbsYlowNDC: 0, fAbsWNDC: 1, fAbsHNDC: 1,
                       fUxmin: 0, fUymin: 0, fUxmax: 0, fUymax: 0, fTheta: 30, fPhi: 30, fAspectRatio: 0,
                       fNumber: 0, fLogx: gStyle.fOptLogx, fLogy: gStyle.fOptLogy, fLogz: gStyle.fOptLogz,
                       fTickx: gStyle.fPadTickX, fTicky: gStyle.fPadTickY,
                       fPadPaint: 0, fCrosshair: 0, fCrosshairPos: 0, fBorderSize: 2,
                       fBorderMode: 0, fModified: false,
                       fGridx: gStyle.fPadGridX, fGridy: gStyle.fPadGridY,
                       fAbsCoord: false, fEditable: true, fFixedAspectRatio: false,
                       fPrimitives: create$1(clTList), fExecs: null,
                       fName: 'pad', fTitle: 'canvas' });

         break;
      case clTAttCanvas:
         extend$1(obj, { fXBetween: 2, fYBetween: 2, fTitleFromTop: 1.2,
                       fXdate: 0.2, fYdate: 0.3, fAdate: 1 });
         break;
      case clTCanvas:
         create$1(clTPad, obj);
         extend$1(obj, { fFillColor: gStyle.fCanvasColor, fFillStyle: 1001,
                       fNumPaletteColor: 0, fNextPaletteColor: 0, fDISPLAY: '$DISPLAY',
                       fDoubleBuffer: 0, fRetained: true, fXsizeUser: 0,
                       fYsizeUser: 0, fXsizeReal: 20, fYsizeReal: 10,
                       fWindowTopX: 0, fWindowTopY: 0, fWindowWidth: 0, fWindowHeight: 0,
                       fCw: 500, fCh: 300, fCatt: create$1(clTAttCanvas),
                       kMoveOpaque: true, kResizeOpaque: true, fHighLightColor: 5,
                       fBatch: true, kShowEventStatus: false, kAutoExec: true, kMenuBar: true });
         break;
      case clTGeoVolume:
         create$1(clTNamed, obj);
         create$1(clTAttLine, obj);
         create$1(clTAttFill, obj);
         extend$1(obj, { fGeoAtt: 0, fFinder: null, fMedium: null, fNodes: null, fNtotal: 0, fNumber: 0, fRefCount: 0, fShape: null, fVoxels: null });
         break;
      case clTGeoNode:
         create$1(clTNamed, obj);
         extend$1(obj, { fGeoAtt: 0, fMother: null, fNovlp: 0, fNumber: 0, fOverlaps: null, fVolume: null });
         break;
      case clTGeoNodeMatrix:
         create$1(clTGeoNode, obj);
         extend$1(obj, { fMatrix: null });
         break;
      case 'TGeoTrack':
         create$1(clTObject, obj);
         create$1(clTAttLine, obj);
         create$1(clTAttMarker, obj);
         extend$1(obj, { fGeoAtt: 0, fNpoints: 0, fPoints: [] });
         break;
      case clTPolyLine3D:
         create$1(clTObject, obj);
         create$1(clTAttLine, obj);
         extend$1(obj, { fLastPoint: -1, fN: 0, fOption: '', fP: [] });
         break;
      case clTPolyMarker3D:
         create$1(clTObject, obj);
         create$1(clTAttMarker, obj);
         extend$1(obj, { fLastPoint: -1, fN: 0, fName: '', fOption: '', fP: [] });
         break;
   }

   obj._typename = typename;
   addMethods(obj, typename);
   return obj;
}

/** @summary Create histogram object of specified type
  * @param {string} typename - histogram typename like 'TH1I' or 'TH2F'
  * @param {number} nbinsx - number of bins on X-axis
  * @param {number} [nbinsy] - number of bins on Y-axis (for 2D/3D histograms)
  * @param {number} [nbinsz] - number of bins on Z-axis (for 3D histograms)
  * @return {Object} created histogram object
  * @example
  * let h1 = createHistogram('TH1I', 20);
  * h1.fName = 'Hist1';
  * h1.fTitle = 'Histogram title';
  * h1.fXaxis.fTitle = 'xaxis';
  * h1.fYaxis.fTitle = 'yaxis';
  * h1.fXaxis.fLabelSize = 0.02; */
function createHistogram(typename, nbinsx, nbinsy, nbinsz) {
   let histo = create$1(typename);
   if (!histo.fXaxis || !histo.fYaxis || !histo.fZaxis) return null;
   histo.fName = 'hist'; histo.fTitle = 'title';
   if (nbinsx) extend$1(histo.fXaxis, { fNbins: nbinsx, fXmin: 0, fXmax: nbinsx });
   if (nbinsy) extend$1(histo.fYaxis, { fNbins: nbinsy, fXmin: 0, fXmax: nbinsy });
   if (nbinsz) extend$1(histo.fZaxis, { fNbins: nbinsz, fXmin: 0, fXmax: nbinsz });
   switch (parseInt(typename[2])) {
      case 1: if (nbinsx) histo.fNcells = nbinsx+2; break;
      case 2: if (nbinsx && nbinsy) histo.fNcells = (nbinsx+2) * (nbinsy+2); break;
      case 3: if (nbinsx && nbinsy && nbinsz) histo.fNcells = (nbinsx+2) * (nbinsy+2) * (nbinsz+2); break;
   }
   if (histo.fNcells > 0) {
      switch (typename[3]) {
         case 'C': histo.fArray = new Int8Array(histo.fNcells); break;
         case 'S': histo.fArray = new Int16Array(histo.fNcells); break;
         case 'I': histo.fArray = new Int32Array(histo.fNcells); break;
         case 'F': histo.fArray = new Float32Array(histo.fNcells); break;
         case 'L':
         case 'D': histo.fArray = new Float64Array(histo.fNcells); break;
         default: histo.fArray = new Array(histo.fNcells);
      }
      histo.fArray.fill(0);
   }
   return histo;
}

/** @summary Creates TPolyLine object
  * @param {number} npoints - number of points
  * @param {boolean} [use_int32] - use Int32Array type for points, default is Float32Array */
function createTPolyLine(npoints, use_int32) {
   let poly = create$1(clTPolyLine);
   if (npoints) {
      poly.fN = npoints;
      if (use_int32) {
         poly.fX = new Int32Array(npoints);
         poly.fY = new Int32Array(npoints);
      } else {
         poly.fX = new Float32Array(npoints);
         poly.fY = new Float32Array(npoints);
      }
   }
   return poly;
}

/** @summary Creates TGraph object
  * @param {number} npoints - number of points in TGraph
  * @param {array} [xpts] - array with X coordinates
  * @param {array} [ypts] - array with Y coordinates */
function createTGraph(npoints, xpts, ypts) {
   let graph = extend$1(create$1(clTGraph), { fBits: 0x408, fName: 'graph', fTitle: 'title' });

   if (npoints > 0) {
      graph.fMaxSize = graph.fNpoints = npoints;

      const usex = isObject(xpts) && (xpts.length === npoints);
      const usey = isObject(ypts) && (ypts.length === npoints);

      for (let i = 0; i < npoints; ++i) {
         graph.fX.push(usex ? xpts[i] : i/npoints);
         graph.fY.push(usey ? ypts[i] : i/npoints);
      }
   }

   return graph;
}

/** @summary Creates THStack object
  * @desc As arguments one could specify any number of histograms objects
  * @example
  * let nbinsx = 20;
  * let h1 = createHistogram('TH1F', nbinsx);
  * let h2 = createHistogram('TH1F', nbinsx);
  * let h3 = createHistogram('TH1F', nbinsx);
  * let stack = createTHStack(h1, h2, h3); */
function createTHStack() {
   let stack = create$1(clTHStack);
   for (let i = 0; i < arguments.length; ++i)
      stack.fHists.Add(arguments[i], '');
   return stack;
}

/** @summary Creates TMultiGraph object
  * @desc As arguments one could specify any number of TGraph objects
  * @example
  * let gr1 = createTGraph(100);
  * let gr2 = createTGraph(100);
  * let gr3 = createTGraph(100);
  * let mgr = createTMultiGraph(gr1, gr2, gr3); */
function createTMultiGraph() {
   let mgraph = create$1(clTMultiGraph);
   for (let i = 0; i < arguments.length; ++i)
       mgraph.fGraphs.Add(arguments[i], '');
   return mgraph;
}

/** @summary variable used to keep methods for known classes
  * @private */
const methodsCache = {};

/** @summary Returns methods for given typename
  * @private */
function getMethods(typename, obj) {

   let m = methodsCache[typename],
       has_methods = (m !== undefined);

   if (!has_methods) m = {};

   // Due to binary I/O such TObject methods may not be set for derived classes
   // Therefore when methods requested for given object, check also that basic methods are there
   if ((typename == clTObject) || (typename == clTNamed) || (obj && (obj.fBits !== undefined)))
      if (typeof m.TestBit === 'undefined') {
         m.TestBit = function (f) { return (this.fBits & f) != 0; };
         m.InvertBit = function (f) { this.fBits = this.fBits ^ (f & 0xffffff); };
      }

   if (has_methods) return m;

   if ((typename === clTList) || (typename === clTHashList)) {
      m.Clear = function() {
         this.arr = [];
         this.opt = [];
      };
      m.Add = function(obj,opt) {
         this.arr.push(obj);
         this.opt.push(isStr(opt) ? opt : '');
      };
      m.AddFirst = function(obj,opt) {
         this.arr.unshift(obj);
         this.opt.unshift(isStr(opt) ? opt : '');
      };
      m.RemoveAt = function(indx) {
         this.arr.splice(indx, 1);
         this.opt.splice(indx, 1);
      };
   }

   if ((typename === clTPaveText) || (typename === clTPaveStats)) {
      m.AddText = function(txt) {
         let line = create$1(clTLatex);
         line.fTitle = txt;
         line.fTextAlign = this.fTextAlign;
         this.fLines.Add(line);
      };
      m.Clear = function() {
         this.fLines.Clear();
      };
   }

   if ((typename.indexOf(clTF1) == 0) || (typename === clTF2)) {
      m.addFormula = function(obj) {
         if (!obj) return;
         if (this.formulas === undefined) this.formulas = [];
         this.formulas.push(obj);
      };

      m.GetParName = function(n) {
         if (this.fParams && this.fParams.fParNames) return this.fParams.fParNames[n];
         if (this.fFormula && this.fFormula.fParams) {
            for (let k=0;k<this.fFormula.fParams.length;++k)
               if(this.fFormula.fParams[k].second == n)
                  return this.fFormula.fParams[k].first;
         }
         if (this.fNames && this.fNames[n]) return this.fNames[n];
         return 'p'+n;
      };
      m.GetParValue = function(n) {
         if (this.fParams && this.fParams.fParameters) return this.fParams.fParameters[n];
         if (this.fFormula && this.fFormula.fClingParameters) return this.fFormula.fClingParameters[n];
         if (this.fParams) return this.fParams[n];
         return undefined;
      };
      m.GetParError = function(n) {
         return this.fParErrors ? this.fParErrors[n] : undefined;
      };
      m.GetNumPars = function() {
         return this.fNpar;
      };
   }

   if (((typename.indexOf(clTGraph) == 0) || (typename == clTCutG)) && (typename != clTGraphPolargram) && (typename != clTGraphTime)) {
      // check if point inside figure specified by the TGraph
      m.IsInside = function(xp,yp) {
         let i = 0, j = this.fNpoints - 1, x = this.fX, y = this.fY, oddNodes = false;

         for (; i < this.fNpoints; ++i) {
            if ((y[i]<yp && y[j]>=yp) || (y[j]<yp && y[i]>=yp)) {
               if (x[i]+(yp-y[i])/(y[j]-y[i])*(x[j]-x[i])<xp) {
                  oddNodes = !oddNodes;
               }
            }
            j=i;
         }

         return oddNodes;
      };
   }

   if (typename.indexOf(clTH1) == 0 || typename.indexOf(clTH2) == 0 || typename.indexOf(clTH3) == 0) {
      m.getBinError = function(bin) {
         //   -*-*-*-*-*Return value of error associated to bin number bin*-*-*-*-*
         //    if the sum of squares of weights has been defined (via Sumw2),
         //    this function returns the sqrt(sum of w2).
         //    otherwise it returns the sqrt(contents) for this bin.
         if (bin >= this.fNcells) bin = this.fNcells - 1;
         if (bin < 0) bin = 0;
         if (bin < this.fSumw2.length)
            return Math.sqrt(this.fSumw2[bin]);
         return Math.sqrt(Math.abs(this.fArray[bin]));
      };
      m.setBinContent = function(bin, content) {
         // Set bin content - only trivial case, without expansion
         this.fEntries++;
         this.fTsumw = 0;
         if ((bin >= 0) && (bin<this.fArray.length))
            this.fArray[bin] = content;
      };
   }

   if (typename.indexOf(clTH1) == 0) {
      m.getBin = function(x) { return x; };
      m.getBinContent = function(bin) { return this.fArray[bin]; };
      m.Fill = function(x, weight) {
         let axis = this.fXaxis,
             bin = 1 + Math.floor((x - axis.fXmin) / (axis.fXmax - axis.fXmin) * axis.fNbins);
         if (bin < 0) bin = 0; else
         if (bin > axis.fNbins + 1) bin = axis.fNbins + 1;
         this.fArray[bin] += (weight === undefined) ? 1 : weight;
         this.fEntries++;
      };
   }

   if (typename.indexOf(clTH2) == 0) {
      m.getBin = function(x, y) { return (x + (this.fXaxis.fNbins+2) * y); };
      m.getBinContent = function(x, y) { return this.fArray[this.getBin(x, y)]; };
      m.Fill = function(x, y, weight) {
         let axis1 = this.fXaxis, axis2 = this.fYaxis,
             bin1 = 1 + Math.floor((x - axis1.fXmin) / (axis1.fXmax - axis1.fXmin) * axis1.fNbins),
             bin2 = 1 + Math.floor((y - axis2.fXmin) / (axis2.fXmax - axis2.fXmin) * axis2.fNbins);
         if (bin1 < 0) bin1 = 0; else
         if (bin1 > axis1.fNbins + 1) bin1 = axis1.fNbins + 1;
         if (bin2 < 0) bin2 = 0; else
         if (bin2 > axis2.fNbins + 1) bin2 = axis2.fNbins + 1;
         this.fArray[bin1 + (axis1.fNbins+2)*bin2] += (weight === undefined) ? 1 : weight;
         this.fEntries++;
      };
   }

   if (typename.indexOf(clTH3) == 0) {
      m.getBin = function(x, y, z) { return (x + (this.fXaxis.fNbins+2) * (y + (this.fYaxis.fNbins+2) * z)); };
      m.getBinContent = function(x, y, z) { return this.fArray[this.getBin(x, y, z)]; };
      m.Fill = function(x, y, z, weight) {
         let axis1 = this.fXaxis, axis2 = this.fYaxis, axis3 = this.fZaxis,
             bin1 = 1 + Math.floor((x - axis1.fXmin) / (axis1.fXmax - axis1.fXmin) * axis1.fNbins),
             bin2 = 1 + Math.floor((y - axis2.fXmin) / (axis2.fXmax - axis2.fXmin) * axis2.fNbins),
             bin3 = 1 + Math.floor((z - axis3.fXmin) / (axis3.fXmax - axis3.fXmin) * axis3.fNbins);
         if (bin1 < 0) bin1 = 0; else
         if (bin1 > axis1.fNbins + 1) bin1 = axis1.fNbins + 1;
         if (bin2 < 0) bin2 = 0; else
         if (bin2 > axis2.fNbins + 1) bin2 = axis2.fNbins + 1;
         if (bin3 < 0) bin3 = 0; else
         if (bin3 > axis3.fNbins + 1) bin3 = axis3.fNbins + 1;
         this.fArray[bin1 + (axis1.fNbins+2)* (bin2+(axis2.fNbins+2)*bin3)] += (weight === undefined) ? 1 : weight;
         this.fEntries++;
      };
   }

   if (typename.indexOf(clTProfile) == 0) {
      if (typename.indexOf(clTProfile2D) == 0) {
         m.getBin = function(x, y) { return (x + (this.fXaxis.fNbins+2) * y); };
         m.getBinContent = function(x, y) {
            let bin = this.getBin(x, y);
            if (bin < 0 || bin >= this.fNcells) return 0;
            if (this.fBinEntries[bin] < 1e-300) return 0;
            if (!this.fArray) return 0;
            return this.fArray[bin]/this.fBinEntries[bin];
         };
         m.getBinEntries = function(x, y) {
            let bin = this.getBin(x, y);
            if (bin < 0 || bin >= this.fNcells) return 0;
            return this.fBinEntries[bin];
         };
      } else {
         m.getBin = function(x) { return x; };
         m.getBinContent = function(bin) {
            if (bin < 0 || bin >= this.fNcells) return 0;
            if (this.fBinEntries[bin] < 1e-300) return 0;
            if (!this.fArray) return 0;
            return this.fArray[bin]/this.fBinEntries[bin];
         };
      }
      m.getBinEffectiveEntries = function(bin) {
         if (bin < 0 || bin >= this.fNcells) return 0;
         let sumOfWeights = this.fBinEntries[bin];
         if ( !this.fBinSumw2 || this.fBinSumw2.length != this.fNcells) {
            // this can happen  when reading an old file
            return sumOfWeights;
         }
         let sumOfWeightsSquare = this.fBinSumw2[bin];
         return (sumOfWeightsSquare > 0) ? sumOfWeights * sumOfWeights / sumOfWeightsSquare : 0;
      };
      m.getBinError = function(bin) {
         if (bin < 0 || bin >= this.fNcells) return 0;
         let cont = this.fArray[bin],               // sum of bin w *y
             sum  = this.fBinEntries[bin],          // sum of bin weights
             err2 = this.fSumw2[bin],               // sum of bin w * y^2
             neff = this.getBinEffectiveEntries(bin);  // (sum of w)^2 / (sum of w^2)
         if (sum < 1e-300) return 0;                  // for empty bins
         const EErrorType = { kERRORMEAN: 0, kERRORSPREAD: 1, kERRORSPREADI: 2, kERRORSPREADG: 3 };
         // case the values y are gaussian distributed y +/- sigma and w = 1/sigma^2
         if (this.fErrorMode === EErrorType.kERRORSPREADG)
            return 1.0/Math.sqrt(sum);
         // compute variance in y (eprim2) and standard deviation in y (eprim)
         let contsum = cont/sum, eprim = Math.sqrt(Math.abs(err2/sum - contsum**2));
         if (this.fErrorMode === EErrorType.kERRORSPREADI) {
            if (eprim != 0) return eprim/Math.sqrt(neff);
            // in case content y is an integer (so each my has an error +/- 1/sqrt(12)
            // when the std(y) is zero
            return 1.0/Math.sqrt(12*neff);
         }
         // if approximate compute the sums (of w, wy and wy2) using all the bins
         //  when the variance in y is zero
         // case option 'S' return standard deviation in y
         if (this.fErrorMode === EErrorType.kERRORSPREAD) return eprim;
         // default case : fErrorMode = kERRORMEAN
         // return standard error on the mean of y
         return eprim/Math.sqrt(neff);
      };
   }

   if (typename == clTAxis) {
      m.GetBinLowEdge = function(bin) {
         if (this.fNbins <= 0) return 0;
         if ((this.fXbins.length > 0) && (bin > 0) && (bin <= this.fNbins)) return this.fXbins[bin-1];
         return this.fXmin + (bin-1) * (this.fXmax - this.fXmin) / this.fNbins;
      };
      m.GetBinCenter = function(bin) {
         if (this.fNbins <= 0) return 0;
         if ((this.fXbins.length > 0) && (bin > 0) && (bin < this.fNbins)) return (this.fXbins[bin-1] + this.fXbins[bin])/2;
         return this.fXmin + (bin-0.5) * (this.fXmax - this.fXmin) / this.fNbins;
      };
   }

   if (typename.indexOf('ROOT::Math::LorentzVector') === 0) {
      m.Px = m.X = function() { return this.fCoordinates.Px(); };
      m.Py = m.Y = function() { return this.fCoordinates.Py(); };
      m.Pz = m.Z = function() { return this.fCoordinates.Pz(); };
      m.E = m.T = function() { return this.fCoordinates.E(); };
      m.M2 = function() { return this.fCoordinates.M2(); };
      m.M = function() { return this.fCoordinates.M(); };
      m.R = m.P = function() { return this.fCoordinates.R(); };
      m.P2 = function() { return this.P() * this.P(); };
      m.Pt = m.pt = function() { return Math.sqrt(this.P2()); };
      m.Phi = m.phi = function() { return Math.atan2(this.fCoordinates.Py(), this.fCoordinates.Px()); };
      m.Eta = m.eta = function() { return Math.atanh(this.Pz()/this.P()); };
   }

   if (typename.indexOf('ROOT::Math::PxPyPzE4D') === 0) {
      m.Px = m.X = function() { return this.fX; };
      m.Py = m.Y = function() { return this.fY; };
      m.Pz = m.Z = function() { return this.fZ; };
      m.E = m.T = function() { return this.fT; };
      m.P2 = function() { return this.fX**2 + this.fY**2 + this.fZ**2; };
      m.R = m.P = function() { return Math.sqrt(this.P2()); };
      m.Mag2 = m.M2 = function() { return this.fT**2 - this.fX**2 - this.fY**2 - this.fZ**2; };
      m.Mag = m.M = function() { return (this.M2() >= 0) ? Math.sqrt(this.M2()) : -Math.sqrt(-this.M2()); };
      m.Perp2 = m.Pt2 = function() { return this.fX**2 + this.fY**2; };
      m.Pt = m.pt = function() { return Math.sqrt(this.P2()); };
      m.Phi = m.phi = function() { return Math.atan2(this.fY, this.fX); };
      m.Eta = m.eta = function() { return Math.atanh(this.Pz/this.P()); };
   }

   methodsCache[typename] = m;
   return m;
}

/** @summary Add methods for specified type.
  * @desc Will be automatically applied when decoding JSON string
  * @private */
function registerMethods(typename, m) {
   methodsCache[typename] = m;
}

/** @summary Returns true if object represents basic ROOT collections
  * @desc Checks if type is TList or TObjArray or TClonesArray or TMap or THashList
  * @param {object} lst - object to check
  * @param {string} [typename] - or just typename to check
  * @private */
function isRootCollection(lst, typename) {
   if (isObject(lst)) {
      if ((lst.$kind === clTList) || (lst.$kind === clTObjArray)) return true;
      if (!typename) typename = lst._typename;
   }
   if (!typename) return false;
   return (typename === clTList) || (typename === clTHashList) || (typename === clTMap) ||
          (typename === clTObjArray) || (typename === clTClonesArray);
}

/** @summary Check if argument is a not-null Object
  * @private */
function isObject(arg) { return arg && typeof arg === 'object'; }

/** @summary Check if argument is a Function
  * @private */
function isFunc(arg) { return typeof arg === 'function'; }

/** @summary Check if argument is a atring
  * @private */
function isStr(arg) { return typeof arg === 'string'; }

/** @summary Check if object is a Promise
  * @private */
function isPromise(obj) { return isObject(obj) && isFunc(obj.then); }

/** @summary Provide promise in any case
  * @private */
function getPromise(obj) { return isPromise(obj) ? obj : Promise.resolve(obj); }

/** @summary Ensure global JSROOT and v6 support methods
  * @private */
async function _ensureJSROOT() {
   let pr = globalThis.JSROOT ? Promise.resolve(true) : loadScript(exports.source_dir + 'scripts/JSRoot.core.js');

   return pr.then(() => {
      if (globalThis.JSROOT?._complete_loading)
         return globalThis.JSROOT._complete_loading();
   }).then(() => globalThis.JSROOT);
}

var core = /*#__PURE__*/Object.freeze({
__proto__: null,
version_id: version_id,
version_date: version_date,
version: version,
get source_dir () { return exports.source_dir; },
isNodeJs: isNodeJs,
isBatchMode: isBatchMode,
setBatchMode: setBatchMode,
browser: browser$1,
internals: internals,
constants: constants$1,
settings: settings,
gStyle: gStyle,
atob_func: atob_func,
btoa_func: btoa_func,
clTObject: clTObject,
clTNamed: clTNamed,
clTString: clTString,
clTObjString: clTObjString,
clTList: clTList,
clTHashList: clTHashList,
clTMap: clTMap,
clTObjArray: clTObjArray,
clTClonesArray: clTClonesArray,
clTAttLine: clTAttLine,
clTAttFill: clTAttFill,
clTAttMarker: clTAttMarker,
clTAttText: clTAttText,
clTPave: clTPave,
clTPaveText: clTPaveText,
clTPaveStats: clTPaveStats,
clTLegend: clTLegend,
clTLegendEntry: clTLegendEntry,
clTPaletteAxis: clTPaletteAxis,
clTText: clTText,
clTLatex: clTLatex,
clTMathText: clTMathText,
clTMultiGraph: clTMultiGraph,
clTColor: clTColor,
clTLine: clTLine,
clTBox: clTBox,
clTPolyLine: clTPolyLine,
clTPad: clTPad,
clTCanvas: clTCanvas,
clTAttCanvas: clTAttCanvas,
clTGaxis: clTGaxis,
clTAxis: clTAxis,
clTStyle: clTStyle,
clTH1: clTH1,
clTH2: clTH2,
clTH3: clTH3,
clTF1: clTF1,
clTF2: clTF2,
clTProfile: clTProfile,
clTProfile2D: clTProfile2D,
clTGraph: clTGraph,
clTGraphPolargram: clTGraphPolargram,
clTGraphTime: clTGraphTime,
clTCutG: clTCutG,
clTPolyLine3D: clTPolyLine3D,
clTPolyMarker3D: clTPolyMarker3D,
clTGeoVolume: clTGeoVolume,
clTGeoNode: clTGeoNode,
clTGeoNodeMatrix: clTGeoNodeMatrix,
kNoZoom: kNoZoom,
isArrayProto: isArrayProto,
getDocument: getDocument,
BIT: BIT,
clone: clone,
addMethods: addMethods,
parse: parse,
parseMulti: parseMulti,
toJSON: toJSON,
decodeUrl: decodeUrl,
findFunction: findFunction,
createHttpRequest: createHttpRequest,
httpRequest: httpRequest,
loadScript: loadScript,
injectCode: injectCode,
create: create$1,
createHistogram: createHistogram,
createTPolyLine: createTPolyLine,
createTGraph: createTGraph,
createTHStack: createTHStack,
createTMultiGraph: createTMultiGraph,
getMethods: getMethods,
registerMethods: registerMethods,
isRootCollection: isRootCollection,
isObject: isObject,
isFunc: isFunc,
isStr: isStr,
isPromise: isPromise,
getPromise: getPromise,
_ensureJSROOT: _ensureJSROOT
});

// https://d3js.org v7.6.1 Copyright 2010-2021 Mike Bostock

function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color$2() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
    reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
    reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
    reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
    reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
    reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color$2, color$1, {
  copy(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHex8() {
  return this.rgb().formatHex8();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color$1(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color$2)) o = color$1(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color$2, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}

function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}

function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}

function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}

function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}

function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color$2)) o = color$1(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color$2, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));

function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}

function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

const radians = Math.PI / 180;
const degrees$1 = 180 / Math.PI;

// https://observablehq.com/@mbostock/lab-and-rgb
const K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0$1 = 4 / 29,
    t1$1 = 6 / 29,
    t2 = 3 * t1$1 * t1$1,
    t3 = t1$1 * t1$1 * t1$1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

define(Lab, lab, extend(Color$2, {
  brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0$1;
}

function lab2xyz(t) {
  return t > t1$1 ? t * t * t : t2 * (t - t0$1);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees$1;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

define(Hcl, hcl, extend(Color$2, {
  brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * degrees$1 - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Cubehelix, cubehelix, extend(Color$2, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

var abs$1 = Math.abs;
var cos$1 = Math.cos;
var sin$1 = Math.sin;
var pi$2 = Math.PI;
var halfPi$1 = pi$2 / 2;
var tau$2 = pi$2 * 2;
var max$2 = Math.max;
var epsilon$2 = 1e-12;

function range$1(i, j) {
  return Array.from({length: j - i}, (_, k) => i + k);
}

function compareValue(compare) {
  return function(a, b) {
    return compare(
      a.source.value + a.target.value,
      b.source.value + b.target.value
    );
  };
}

function chord() {
  return chord$1(false, false);
}

function chord$1(directed, transpose) {
  var padAngle = 0,
      sortGroups = null,
      sortSubgroups = null,
      sortChords = null;

  function chord(matrix) {
    var n = matrix.length,
        groupSums = new Array(n),
        groupIndex = range$1(0, n),
        chords = new Array(n * n),
        groups = new Array(n),
        k = 0, dx;

    matrix = Float64Array.from({length: n * n}, transpose
        ? (_, i) => matrix[i % n][i / n | 0]
        : (_, i) => matrix[i / n | 0][i % n]);

    // Compute the scaling factor from value to angle in [0, 2pi].
    for (let i = 0; i < n; ++i) {
      let x = 0;
      for (let j = 0; j < n; ++j) x += matrix[i * n + j] + directed * matrix[j * n + i];
      k += groupSums[i] = x;
    }
    k = max$2(0, tau$2 - padAngle * n) / k;
    dx = k ? padAngle : tau$2 / n;

    // Compute the angles for each group and constituent chord.
    {
      let x = 0;
      if (sortGroups) groupIndex.sort((a, b) => sortGroups(groupSums[a], groupSums[b]));
      for (const i of groupIndex) {
        const x0 = x;
        if (directed) {
          const subgroupIndex = range$1(~n + 1, n).filter(j => j < 0 ? matrix[~j * n + i] : matrix[i * n + j]);
          if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(a < 0 ? -matrix[~a * n + i] : matrix[i * n + a], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]));
          for (const j of subgroupIndex) {
            if (j < 0) {
              const chord = chords[~j * n + i] || (chords[~j * n + i] = {source: null, target: null});
              chord.target = {index: i, startAngle: x, endAngle: x += matrix[~j * n + i] * k, value: matrix[~j * n + i]};
            } else {
              const chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});
              chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
            }
          }
          groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};
        } else {
          const subgroupIndex = range$1(0, n).filter(j => matrix[i * n + j] || matrix[j * n + i]);
          if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(matrix[i * n + a], matrix[i * n + b]));
          for (const j of subgroupIndex) {
            let chord;
            if (i < j) {
              chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});
              chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
            } else {
              chord = chords[j * n + i] || (chords[j * n + i] = {source: null, target: null});
              chord.target = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
              if (i === j) chord.source = chord.target;
            }
            if (chord.source && chord.target && chord.source.value < chord.target.value) {
              const source = chord.source;
              chord.source = chord.target;
              chord.target = source;
            }
          }
          groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};
        }
        x += dx;
      }
    }

    // Remove empty chords.
    chords = Object.values(chords);
    chords.groups = groups;
    return sortChords ? chords.sort(sortChords) : chords;
  }

  chord.padAngle = function(_) {
    return arguments.length ? (padAngle = max$2(0, _), chord) : padAngle;
  };

  chord.sortGroups = function(_) {
    return arguments.length ? (sortGroups = _, chord) : sortGroups;
  };

  chord.sortSubgroups = function(_) {
    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
  };

  chord.sortChords = function(_) {
    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
  };

  return chord;
}

const pi$1 = Math.PI,
    tau$1 = 2 * pi$1,
    epsilon$1 = 1e-6,
    tauEpsilon = tau$1 - epsilon$1;

function Path$1() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path$1;
}

Path$1.prototype = path.prototype = {
  constructor: Path$1,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon$1));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi$1 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon$1) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau$1 + tau$1;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon$1) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi$1)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

var slice = Array.prototype.slice;

function constant$4(x) {
  return function() {
    return x;
  };
}

function defaultSource(d) {
  return d.source;
}

function defaultTarget(d) {
  return d.target;
}

function defaultRadius(d) {
  return d.radius;
}

function defaultStartAngle(d) {
  return d.startAngle;
}

function defaultEndAngle(d) {
  return d.endAngle;
}

function defaultPadAngle() {
  return 0;
}

function ribbon(headRadius) {
  var source = defaultSource,
      target = defaultTarget,
      sourceRadius = defaultRadius,
      targetRadius = defaultRadius,
      startAngle = defaultStartAngle,
      endAngle = defaultEndAngle,
      padAngle = defaultPadAngle,
      context = null;

  function ribbon() {
    var buffer,
        s = source.apply(this, arguments),
        t = target.apply(this, arguments),
        ap = padAngle.apply(this, arguments) / 2,
        argv = slice.call(arguments),
        sr = +sourceRadius.apply(this, (argv[0] = s, argv)),
        sa0 = startAngle.apply(this, argv) - halfPi$1,
        sa1 = endAngle.apply(this, argv) - halfPi$1,
        tr = +targetRadius.apply(this, (argv[0] = t, argv)),
        ta0 = startAngle.apply(this, argv) - halfPi$1,
        ta1 = endAngle.apply(this, argv) - halfPi$1;

    if (!context) context = buffer = path();

    if (ap > epsilon$2) {
      if (abs$1(sa1 - sa0) > ap * 2 + epsilon$2) sa1 > sa0 ? (sa0 += ap, sa1 -= ap) : (sa0 -= ap, sa1 += ap);
      else sa0 = sa1 = (sa0 + sa1) / 2;
      if (abs$1(ta1 - ta0) > ap * 2 + epsilon$2) ta1 > ta0 ? (ta0 += ap, ta1 -= ap) : (ta0 -= ap, ta1 += ap);
      else ta0 = ta1 = (ta0 + ta1) / 2;
    }

    context.moveTo(sr * cos$1(sa0), sr * sin$1(sa0));
    context.arc(0, 0, sr, sa0, sa1);
    if (sa0 !== ta0 || sa1 !== ta1) {
      if (headRadius) {
        var hr = +headRadius.apply(this, arguments), tr2 = tr - hr, ta2 = (ta0 + ta1) / 2;
        context.quadraticCurveTo(0, 0, tr2 * cos$1(ta0), tr2 * sin$1(ta0));
        context.lineTo(tr * cos$1(ta2), tr * sin$1(ta2));
        context.lineTo(tr2 * cos$1(ta1), tr2 * sin$1(ta1));
      } else {
        context.quadraticCurveTo(0, 0, tr * cos$1(ta0), tr * sin$1(ta0));
        context.arc(0, 0, tr, ta0, ta1);
      }
    }
    context.quadraticCurveTo(0, 0, sr * cos$1(sa0), sr * sin$1(sa0));
    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  if (headRadius) ribbon.headRadius = function(_) {
    return arguments.length ? (headRadius = typeof _ === "function" ? _ : constant$4(+_), ribbon) : headRadius;
  };

  ribbon.radius = function(_) {
    return arguments.length ? (sourceRadius = targetRadius = typeof _ === "function" ? _ : constant$4(+_), ribbon) : sourceRadius;
  };

  ribbon.sourceRadius = function(_) {
    return arguments.length ? (sourceRadius = typeof _ === "function" ? _ : constant$4(+_), ribbon) : sourceRadius;
  };

  ribbon.targetRadius = function(_) {
    return arguments.length ? (targetRadius = typeof _ === "function" ? _ : constant$4(+_), ribbon) : targetRadius;
  };

  ribbon.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$4(+_), ribbon) : startAngle;
  };

  ribbon.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$4(+_), ribbon) : endAngle;
  };

  ribbon.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$4(+_), ribbon) : padAngle;
  };

  ribbon.source = function(_) {
    return arguments.length ? (source = _, ribbon) : source;
  };

  ribbon.target = function(_) {
    return arguments.length ? (target = _, ribbon) : target;
  };

  ribbon.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
  };

  return ribbon;
}

function ribbon$1() {
  return ribbon();
}

var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames$1(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames$1(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get$1(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set$1(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

var xhtml = "http://www.w3.org/1999/xhtml";

var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
}

function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

function creator(name) {
  var fullname = namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}

function none() {}

function selector(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

function selection_select(select) {
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection$1(subgroups, this._parents);
}

// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we don’t ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}

function empty() {
  return [];
}

function selectorAll(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}

function selection_selectAll(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection$1(subgroups, parents);
}

function matcher(selector) {
  return function() {
    return this.matches(selector);
  };
}

function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

var find = Array.prototype.find;

function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}

function childFirst() {
  return this.firstElementChild;
}

function selection_selectChild(match) {
  return this.select(match == null ? childFirst
      : childFind(typeof match === "function" ? match : childMatcher(match)));
}

var filter = Array.prototype.filter;

function children() {
  return Array.from(this.children);
}

function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}

function selection_selectChildren(match) {
  return this.selectAll(match == null ? children
      : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

function selection_filter(match) {
  if (typeof match !== "function") match = matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection$1(subgroups, this._parents);
}

function sparse(update) {
  return new Array(update.length);
}

function selection_enter() {
  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

function constant$3(x) {
  return function() {
    return x;
  };
}

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = new Map,
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
      exit[i] = node;
    }
  }
}

function datum(node) {
  return node.__data__;
}

function selection_data(value, key) {
  if (!arguments.length) return Array.from(this, datum);

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant$3(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection$1(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isn’t worried about “live” collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// don’t; we’d rather avoid a gratuitous copy.)
function arraylike(data) {
  return typeof data === "object" && "length" in data
    ? data // Array, TypedArray, NodeList, array-like
    : Array.from(data); // Map, Set, iterable, string, or anything else
}

function selection_exit() {
  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
}

function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

function selection_merge(context) {
  var selection = context.selection ? context.selection() : context;

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection$1(merges, this._parents);
}

function selection_order() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}

function selection_sort(compare) {
  if (!compare) compare = ascending$1;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection$1(sortgroups, this._parents).order();
}

function ascending$1(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

function selection_nodes() {
  return Array.from(this);
}

function selection_node() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}

function selection_size() {
  let size = 0;
  for (const node of this) ++size; // eslint-disable-line no-unused-vars
  return size;
}

function selection_empty() {
  return !this.node();
}

function selection_each(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}

function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant$1(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS$1(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction$1(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS$1(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

function selection_attr(name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS$1 : attrRemove$1) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)
      : (fullname.local ? attrConstantNS$1 : attrConstant$1)))(fullname, value));
}

function defaultView(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}

function styleRemove$1(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant$1(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction$1(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

function selection_style(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove$1 : typeof value === "function"
            ? styleFunction$1
            : styleConstant$1)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}

function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

function selection_property(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

function selection_classed(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}

function textRemove() {
  this.textContent = "";
}

function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction$1(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

function selection_text(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction$1
          : textConstant$1)(value))
      : this.node().textContent;
}

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

function selection_html(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

function selection_raise() {
  return this.each(raise);
}

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

function selection_lower() {
  return this.each(lower);
}

function selection_append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}

function constantNull() {
  return null;
}

function selection_insert(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

function selection_remove() {
  return this.each(remove);
}

function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

function selection_datum(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}

function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

function selection_on(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}

function dispatchEvent(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

function selection_dispatch(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}

function* selection_iterator() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}

var root$1 = [null];

function Selection$1(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection$1([[document.documentElement]], root$1);
}

function selection_selection() {
  return this;
}

Selection$1.prototype = selection.prototype = {
  constructor: Selection$1,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};

function select(selector) {
  return typeof selector === "string"
      ? new Selection$1([[document.querySelector(selector)]], [document.documentElement])
      : new Selection$1([[selector]], root$1);
}

var nextId = 0;

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

function sourceEvent(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}

function pointer(event, node) {
  event = sourceEvent(event);
  if (node === undefined) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}

function pointers(events, node) {
  if (events.target) { // i.e., instanceof Event, not TouchList or iterable
    events = sourceEvent(events);
    if (node === undefined) node = events.currentTarget;
    events = events.touches || [events];
  }
  return Array.from(events, event => pointer(event, node));
}

// These are typically used in conjunction with noevent to ensure that we can
// preventDefault on the event.
const nonpassive = {passive: false};
const nonpassivecapture = {capture: true, passive: false};

function nopropagation(event) {
  event.stopImmediatePropagation();
}

function noevent(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

function nodrag(view) {
  var root = view.document.documentElement,
      selection = select(view).on("dragstart.drag", noevent, nonpassivecapture);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", noevent, nonpassivecapture);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = select(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", noevent, nonpassivecapture);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

var constant$2 = x => () => x;

function DragEvent(type, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x, y, dx, dy,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    subject: {value: subject, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    identifier: {value: identifier, enumerable: true, configurable: true},
    active: {value: active, enumerable: true, configurable: true},
    x: {value: x, enumerable: true, configurable: true},
    y: {value: y, enumerable: true, configurable: true},
    dx: {value: dx, enumerable: true, configurable: true},
    dy: {value: dy, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// Ignore right-click, since that should open the context menu.
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(event, d) {
  return d == null ? {x: event.x, y: event.y} : d;
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function drag() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = dispatch("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved, nonpassive)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned(event, d) {
    if (touchending || !filter.call(this, event, d)) return;
    var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
    if (!gesture) return;
    select(event.view)
      .on("mousemove.drag", mousemoved, nonpassivecapture)
      .on("mouseup.drag", mouseupped, nonpassivecapture);
    nodrag(event.view);
    nopropagation(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }

  function mousemoved(event) {
    noevent(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }

  function mouseupped(event) {
    select(event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(event.view, mousemoving);
    noevent(event);
    gestures.mouse("end", event);
  }

  function touchstarted(event, d) {
    if (!filter.call(this, event, d)) return;
    var touches = event.changedTouches,
        c = container.call(this, event, d),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
        nopropagation(event);
        gesture("start", event, touches[i]);
      }
    }
  }

  function touchmoved(event) {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent(event);
        gesture("drag", event, touches[i]);
      }
    }
  }

  function touchended(event) {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation(event);
        gesture("end", event, touches[i]);
      }
    }
  }

  function beforestart(that, container, event, d, identifier, touch) {
    var dispatch = listeners.copy(),
        p = pointer(touch || event, container), dx, dy,
        s;

    if ((s = subject.call(that, new DragEvent("beforestart", {
        sourceEvent: event,
        target: drag,
        identifier,
        active,
        x: p[0],
        y: p[1],
        dx: 0,
        dy: 0,
        dispatch
      }), d)) == null) return;

    dx = s.x - p[0] || 0;
    dy = s.y - p[1] || 0;

    return function gesture(type, event, touch) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[identifier] = gesture, n = active++; break;
        case "end": delete gestures[identifier], --active; // falls through
        case "drag": p = pointer(touch || event, container), n = active; break;
      }
      dispatch.call(
        type,
        that,
        new DragEvent(type, {
          sourceEvent: event,
          subject: s,
          target: drag,
          identifier,
          active: n,
          x: p[0] + dx,
          y: p[1] + dy,
          dx: p[0] - p0[0],
          dy: p[1] - p0[1],
          dispatch
        }),
        d
      );
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant$2(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant$2(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant$2(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$2(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
}

function ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function descending(a, b) {
  return a == null || b == null ? NaN
    : b < a ? -1
    : b > a ? 1
    : b >= a ? 0
    : NaN;
}

function bisector(f) {
  let compare1, compare2, delta;

  // If an accessor is specified, promote it to a comparator. In this case we
  // can test whether the search value is (self-) comparable. We can’t do this
  // for a comparator (except for specific, known comparators) because we can’t
  // tell if the comparator is symmetric, and an asymmetric comparator can’t be
  // used to test whether a single value is comparable.
  if (f.length !== 2) {
    compare1 = ascending;
    compare2 = (d, x) => ascending(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === ascending || f === descending ? f : zero$1;
    compare2 = f;
    delta = f;
  }

  function left(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function right(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function center(a, x, lo = 0, hi = a.length) {
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {left, center, right};
}

function zero$1() {
  return 0;
}

function number$2(x) {
  return x === null ? NaN : +x;
}

const ascendingBisect = bisector(ascending);
const bisectRight = ascendingBisect.right;
bisector(number$2).center;
var bisect = bisectRight;

var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function ticks(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    let r0 = Math.round(start / step), r1 = Math.round(stop / step);
    if (r0 * step < start) ++r0;
    if (r1 * step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);
    while (++i < n) ticks[i] = (r0 + i) * step;
  } else {
    step = -step;
    let r0 = Math.round(start * step), r1 = Math.round(stop * step);
    if (r0 / step < start) ++r0;
    if (r1 / step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);
    while (++i < n) ticks[i] = (r0 + i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

var constant$1 = x => () => x;

function linear$1(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function gamma$1(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant$1(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear$1(a, d) : constant$1(isNaN(a) ? b : a);
}

var interpolateRgb = (function rgbGamma(y) {
  var color = gamma$1(y);

  function rgb$1(start, end) {
    var r = color((start = rgb(start)).r, (end = rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb$1.gamma = rgbGamma;

  return rgb$1;
})(1);

function numberArray(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = interpolate$1(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}

function date$1(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

function interpolateNumber(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

function object(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = interpolate$1(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

function interpolateString(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: interpolateNumber(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}

function interpolate$1(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant$1(b)
      : (t === "number" ? interpolateNumber
      : t === "string" ? ((c = color$1(b)) ? (b = c, interpolateRgb) : interpolateString)
      : b instanceof color$1 ? interpolateRgb
      : b instanceof Date ? date$1
      : isNumberArray(b) ? numberArray
      : Array.isArray(b) ? genericArray
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
      : interpolateNumber)(a, b);
}

function interpolateRound(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}

var degrees = 180 / Math.PI;

var identity$3 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity$3 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return identity$3;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity$3;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

function constants(x) {
  return function() {
    return x;
  };
}

function number$1(x) {
  return +x;
}

var unit = [0, 1];

function identity$2(x) {
  return x;
}

function normalize$1(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constants(isNaN(b) ? NaN : 0.5);
}

function clamper(a, b) {
  var t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize$1(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize$1(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize$1(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = bisect(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy$1(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function transformer$2() {
  var domain = unit,
      range = unit,
      interpolate = interpolate$1,
      transform,
      untransform,
      unknown,
      clamp = identity$2,
      piecewise,
      output,
      input;

  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== identity$2) clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate = interpolateRound, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity$2, rescale()) : clamp !== identity$2;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous() {
  return transformer$2()(identity$2, identity$2);
}

function formatDecimal(x) {
  return Math.abs(x = Math.round(x)) >= 1e21
      ? x.toLocaleString("en").replace(/,/g, "")
      : x.toString(10);
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

function exponent(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}

function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};

// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

var prefixExponent;

function formatPrefixAuto(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

function formatRounded(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

var formatTypes = {
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": formatDecimal,
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => formatRounded(x * 100, p),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
};

function identity$1(x) {
  return x;
}

var map$1 = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","\xB5","m","","k","M","G","T","P","E","Z","Y"];

function formatLocale$1(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? identity$1 : formatGroup(map$1.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? identity$1 : formatNumerals(map$1.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "\u2212" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = formatTrim(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

var locale$1;
var format;
var formatPrefix;

defaultLocale$1({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale$1(definition) {
  locale$1 = formatLocale$1(definition);
  format = locale$1.format;
  formatPrefix = locale$1.formatPrefix;
  return locale$1;
}

function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}

function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}

function precisionRound(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
}

function tickFormat(start, stop, count, specifier) {
  var step = tickStep(start, stop, count),
      precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop, count);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = continuous();

  scale.copy = function() {
    return copy$1(scale, linear());
  };

  initRange.apply(scale, arguments);

  return linearish(scale);
}

function nice(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

function transformLog(x) {
  return Math.log(x);
}

function transformExp(x) {
  return Math.exp(x);
}

function transformLogn(x) {
  return -Math.log(-x);
}

function transformExpn(x) {
  return -Math.exp(-x);
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : x => Math.pow(base, x);
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), x => Math.log(x) / base);
}

function reflect(f) {
  return (x, k) => -f(-x, k);
}

function loggish(transform) {
  const scale = transform(transformLog, transformExp);
  const domain = scale.domain;
  let base = 10;
  let logs;
  let pows;

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = count => {
    const d = domain();
    let u = d[0];
    let v = d[d.length - 1];
    const r = v < u;

    if (r) ([u, v] = [v, u]);

    let i = logs(u);
    let j = logs(v);
    let k;
    let t;
    const n = count == null ? 10 : +count;
    let z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0) for (; i <= j; ++i) {
        for (k = 1; k < base; ++k) {
          t = i < 0 ? k / pows(-i) : k * pows(i);
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i <= j; ++i) {
        for (k = base - 1; k >= 1; --k) {
          t = i > 0 ? k / pows(-i) : k * pows(i);
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      if (z.length * 2 < n) z = ticks(u, v, n);
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }
    return r ? z.reverse() : z;
  };

  scale.tickFormat = (count, specifier) => {
    if (count == null) count = 10;
    if (specifier == null) specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
      specifier = format(specifier);
    }
    if (count === Infinity) return specifier;
    const k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return d => {
      let i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = () => {
    return domain(nice(domain(), {
      floor: x => pows(Math.floor(logs(x))),
      ceil: x => pows(Math.ceil(logs(x)))
    }));
  };

  return scale;
}

function log() {
  const scale = loggish(transformer$2()).domain([1, 10]);
  scale.copy = () => copy$1(scale, log()).base(scale.base());
  initRange.apply(scale, arguments);
  return scale;
}

function transformSymlog(c) {
  return function(x) {
    return Math.sign(x) * Math.log1p(Math.abs(x / c));
  };
}

function transformSymexp(c) {
  return function(x) {
    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
  };
}

function symlogish(transform) {
  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

  scale.constant = function(_) {
    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
  };

  return linearish(scale);
}

function symlog() {
  var scale = symlogish(transformer$2());

  scale.copy = function() {
    return copy$1(scale, symlog()).constant(scale.constant());
  };

  return initRange.apply(scale, arguments);
}

var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
  }

  interval.floor = function(date) {
    return floori(date = new Date(+date)), date;
  };

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

var millisecond$1 = millisecond;
millisecond.range;

const durationSecond = 1000;
const durationMinute = durationSecond * 60;
const durationHour = durationMinute * 60;
const durationDay = durationHour * 24;
const durationWeek = durationDay * 7;
const durationMonth = durationDay * 30;
const durationYear = durationDay * 365;

var second = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds());
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});

var utcSecond = second;
second.range;

var minute = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getMinutes();
});

var timeMinute = minute;
minute.range;

var hour = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getHours();
});

var timeHour = hour;
hour.range;

var day = newInterval(
  date => date.setHours(0, 0, 0, 0),
  (date, step) => date.setDate(date.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
  date => date.getDate() - 1
);

var timeDay = day;
day.range;

function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

sunday.range;
monday.range;
tuesday.range;
wednesday.range;
thursday.range;
friday.range;
saturday.range;

var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

var timeMonth = month;
month.range;

var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

var timeYear = year;
year.range;

var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});
utcMinute.range;

var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getUTCHours();
});
utcHour.range;

var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});

var utcDay$1 = utcDay;
utcDay.range;

function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

utcSunday.range;
utcMonday.range;
utcTuesday.range;
utcWednesday.range;
utcThursday.range;
utcFriday.range;
utcSaturday.range;

var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});
utcMonth.range;

var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

var utcYear$1 = utcYear;
utcYear.range;

function ticker(year, month, week, day, hour, minute) {

  const tickIntervals = [
    [utcSecond,  1,      durationSecond],
    [utcSecond,  5,  5 * durationSecond],
    [utcSecond, 15, 15 * durationSecond],
    [utcSecond, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function ticks(start, stop, count) {
    const reverse = stop < start;
    if (reverse) [start, stop] = [stop, start];
    const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
    const ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop
    return reverse ? ticks.reverse() : ticks;
  }

  function tickInterval(start, stop, count) {
    const target = Math.abs(stop - start) / count;
    const i = bisector(([,, step]) => step).right(tickIntervals, target);
    if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));
    if (i === 0) return millisecond$1.every(Math.max(tickStep(start, stop, count), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step);
  }

  return [ticks, tickInterval];
}
const [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, sunday, timeDay, timeHour, timeMinute);

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newDate(y, m, d) {
  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, undefined, 1),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

      // If this is utcParse, never use the local timezone.
      if (Z && !("Z" in d)) d.Z = 0;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // If the month was not specified, inherit from the quarter.
      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay$1.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? monday.ceil(week) : monday(week);
          week = timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return localDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + timeDay.count(timeYear(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(sunday.count(timeYear(d) - 1, d), p, 2);
}

function dISO(d) {
  var day = d.getDay();
  return (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
}

function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(thursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(monday.count(timeYear(d) - 1, d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay$1.count(utcYear$1(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear$1(d) - 1, d), p, 2);
}

function UTCdISO(d) {
  var day = d.getUTCDay();
  return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
}

function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(utcThursday.count(utcYear$1(d), d) + (utcYear$1(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear$1(d) - 1, d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

var locale;
var timeFormat;
var utcFormat;
var utcParse;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  timeFormat = locale.format;
  locale.parse;
  utcFormat = locale.utcFormat;
  utcParse = locale.utcParse;
  return locale;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

Date.prototype.toISOString
    ? formatIsoNative
    : utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

+new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : utcParse(isoSpecifier);

function date(t) {
  return new Date(t);
}

function number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
  var scale = continuous(),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
  };

  scale.ticks = function(interval) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval) {
    var d = domain();
    if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
    return interval ? domain(nice(d, interval)) : scale;
  };

  scale.copy = function() {
    return copy$1(scale, calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
  };

  return scale;
}

function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, sunday, timeDay, timeHour, timeMinute, utcSecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
}

function constant(x) {
  return function constant() {
    return x;
  };
}

const abs = Math.abs;
const atan2 = Math.atan2;
const cos = Math.cos;
const max = Math.max;
const min = Math.min;
const sin = Math.sin;
const sqrt = Math.sqrt;

const epsilon = 1e-12;
const pi = Math.PI;
const halfPi = pi / 2;
const tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}

function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < epsilon) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

function arc() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = constant(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi,
        a1 = endAngle.apply(this, arguments) - halfPi,
        da = abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)),
            p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * cos(a01),
          y01 = r1 * sin(a01),
          x10 = r0 * cos(a10),
          y10 = r0 * sin(a10);

      // Apply rounded corners?
      if (rc > epsilon) {
        var x11 = r1 * cos(a11),
            y11 = r1 * sin(a11),
            x00 = r0 * cos(a00),
            y00 = r0 * sin(a00),
            oc;

        // Restrict the corner radius according to the sector angle.
        if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
          var ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min(rc, (r0 - lc) / (kc - 1));
          rc1 = min(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > epsilon)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a) * r, sin(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}

var frame = 0, // is an animation frame pending?
    timeout$1 = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now$1() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now$1() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now$1(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout$1) timeout$1 = clearTimeout(timeout$1);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

function timeout(callback, delay, time) {
  var t = new Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(elapsed => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

var emptyOn = dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

function schedule(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get$2(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get$2(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get$2(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = timer(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return timeout(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    timeout(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}

function interrupt(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}

function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}

function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

function transition_tween(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = get$2(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = set(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return get$2(node, id).value[name];
  };
}

function interpolate(a, b) {
  var c;
  return (typeof b === "number" ? interpolateNumber
      : b instanceof color$1 ? interpolateRgb
      : (c = color$1(b)) ? (b = c, interpolateRgb)
      : interpolateString)(a, b);
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function transition_attr(name, value) {
  var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}

function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

function delayFunction(id, value) {
  return function() {
    init(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    init(this, id).delay = value;
  };
}

function transition_delay(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : get$2(this.node(), id).delay;
}

function durationFunction(id, value) {
  return function() {
    set(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    set(this, id).duration = value;
  };
}

function transition_duration(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : get$2(this.node(), id).duration;
}

function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    set(this, id).ease = value;
  };
}

function transition_ease(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : get$2(this.node(), id).ease;
}

function easeVarying(id, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error;
    set(this, id).ease = v;
  };
}

function transition_easeVarying(value) {
  if (typeof value !== "function") throw new Error;
  return this.each(easeVarying(this._id, value));
}

function transition_filter(match) {
  if (typeof match !== "function") match = matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Transition(subgroups, this._parents, this._name, this._id);
}

function transition_merge(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Transition(merges, this._parents, this._name, this._id);
}

function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? init : set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

function transition_on(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? get$2(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}

function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}

function transition_select(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id, i, subgroup, get$2(node, id));
      }
    }
  }

  return new Transition(subgroups, this._parents, name, id);
}

function transition_selectAll(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = get$2(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            schedule(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new Transition(subgroups, parents, name, id);
}

var Selection = selection.prototype.constructor;

function transition_selection() {
  return new Selection(this._groups, this._parents);
}

function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = styleValue(this, name),
        string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = styleValue(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = set(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

function transition_style(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
}

function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

function transition_text(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(tweenValue(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
}

function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
}

function transition_transition() {
  var name = this._name,
      id0 = this._id,
      id1 = newId();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = get$2(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new Transition(groups, this._parents, name, id1);
}

function transition_end() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = set(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });

    // The selection was empty, resolve end immediately
    if (size === 0) resolve();
  });
}

var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function newId() {
  return ++id;
}

var selection_prototype = selection.prototype;

Transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  easeVarying: transition_easeVarying,
  end: transition_end,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id} not found`);
    }
  }
  return timing;
}

function selection_transition(name) {
  var id,
      timing;

  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = now$1(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new Transition(groups, this._parents, name, id);
}

selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;

/** @summary Returns visible rect of element
  * @param {object} elem - d3.select object with element
  * @param {string} [kind] - which size method is used
  * @desc kind = 'bbox' use getBBox, works only with SVG
  * kind = 'full' - full size of element, using getBoundingClientRect function
  * kind = 'nopadding' - excludes padding area
  * With node.js can use 'width' and 'height' attributes when provided in element
  * @private */
function getElementRect(elem, sizearg) {
   if (isNodeJs() && (sizearg != 'bbox'))
      return { x: 0, y: 0, width: parseInt(elem.attr('width')), height: parseInt(elem.attr('height')) };

   const styleValue = name => {
      let value = elem.style(name);
      if (!value || !isStr(value)) return 0;
      value = parseFloat(value.replace('px', ''));
      return !Number.isFinite(value) ? 0 : Math.round(value);
   };

   let rect = elem.node().getBoundingClientRect();
   if ((sizearg == 'bbox') && (parseFloat(rect.width) > 0))
      rect = elem.node().getBBox();

   let res = { x: 0, y: 0, width: parseInt(rect.width), height: parseInt(rect.height) };
   if (rect.left !== undefined) {
      res.x = parseInt(rect.left);
      res.y = parseInt(rect.top);
   } else if (rect.x !== undefined) {
      res.x = parseInt(rect.x);
      res.y = parseInt(rect.y);
   }

   if ((sizearg === undefined) || (sizearg == 'nopadding')) {
      // this is size exclude padding area
      res.width -= styleValue('padding-left') + styleValue('padding-right');
      res.height -= styleValue('padding-top') + styleValue('padding-bottom');
   }

   return res;
}


/** @summary Calculate absolute position of provided element in canvas
  * @private */
function getAbsPosInCanvas(sel, pos) {
   while (pos && !sel.empty() && !sel.classed('root_canvas')) {
      let cl = sel.attr('class');
      if (cl && ((cl.indexOf('root_frame') >= 0) || (cl.indexOf('__root_pad_') >= 0))) {
         pos.x += sel.property('draw_x') || 0;
         pos.y += sel.property('draw_y') || 0;
      }
      sel = select(sel.node().parentNode);
   }
   return pos;
}


/** @summary Converts numeric value to string according to specified format.
  * @param {number} value - value to convert
  * @param {string} [fmt='6.4g'] - format can be like 5.4g or 4.2e or 6.4f
  * @param {boolean} [ret_fmt] - when true returns array with value and actual format like ['0.1','6.4f']
  * @return {string|Array} - converted value or array with value and actual format
  * @private */
function floatToString(value, fmt, ret_fmt) {
   if (!fmt) fmt = '6.4g';

   fmt = fmt.trim();
   let len = fmt.length;
   if (len < 2)
      return ret_fmt ? [value.toFixed(4), '6.4f'] : value.toFixed(4);
   let last = fmt[len-1];
   fmt = fmt.slice(0,len-1);
   let isexp, prec = fmt.indexOf('.');
   prec = (prec < 0) ? 4 : parseInt(fmt.slice(prec+1));
   if (!Number.isInteger(prec) || (prec <= 0)) prec = 4;

   let significance = false;
   if ((last == 'e') || (last == 'E')) { isexp = true; } else
   if (last == 'Q') { isexp = true; significance = true; } else
   if ((last == 'f') || (last == 'F')) { isexp = false; } else
   if (last == 'W') { isexp = false; significance = true; } else
   if ((last == 'g') || (last == 'G')) {
      let se = floatToString(value, fmt+'Q', true),
          sg = floatToString(value, fmt+'W', true);

      if (se[0].length < sg[0].length) sg = se;
      return ret_fmt ? sg : sg[0];
   } else {
      isexp = false;
      prec = 4;
   }

   if (isexp) {
      // for exponential representation only one significant digit befor point
      if (significance) prec--;
      if (prec < 0) prec = 0;

      let se = value.toExponential(prec);

      return ret_fmt ? [se, '5.'+prec+'e'] : se;
   }

   let sg = value.toFixed(prec);

   if (significance) {

      // when using fixed representation, one could get 0.0
      if (value && (Number(sg) === 0.) && (prec > 0)) {
         prec = 20; sg = value.toFixed(prec);
      }

      let l = 0;
      while ((l<sg.length) && (sg[l] == '0' || sg[l] == '-' || sg[l] == '.')) l++;

      let diff = sg.length - l - prec;
      if (sg.indexOf('.')>l) diff--;

      if (diff != 0) {
         prec -= diff;
         if (prec < 0)
            prec = 0;
         else if (prec > 20)
            prec = 20;
         sg = value.toFixed(prec);
      }
   }

   return ret_fmt ? [sg, '5.'+prec+'f'] : sg;
}


/** @summary Draw options interpreter
  * @private */
class DrawOptions {

   constructor(opt) {
      this.opt = isStr(opt) ? opt.toUpperCase().trim() : '';
      this.part = '';
   }

   /** @summary Returns true if remaining options are empty or contain only seperators symbols. */
   empty() {
      if (this.opt.length === 0) return true;
      return this.opt.replace(/[ ;_,]/g, '').length == 0;
   }

   /** @summary Returns remaining part of the draw options. */
   remain() { return this.opt; }

   /** @summary Checks if given option exists */
   check(name, postpart) {
      let pos = this.opt.indexOf(name);
      if (pos < 0) return false;
      this.opt = this.opt.slice(0, pos) + this.opt.slice(pos + name.length);
      this.part = '';
      if (!postpart) return true;

      let pos2 = pos;
      while ((pos2 < this.opt.length) && (this.opt[pos2] !== ' ') && (this.opt[pos2] !== ',') && (this.opt[pos2] !== ';')) pos2++;
      if (pos2 > pos) {
         this.part = this.opt.slice(pos, pos2);
         this.opt = this.opt.slice(0, pos) + this.opt.slice(pos2);
      }
      return true;
   }

   /** @summary Returns remaining part of found option as integer. */
   partAsInt(offset, dflt) {
      let val = this.part.replace(/^\D+/g, '');
      val = val ? parseInt(val, 10) : Number.NaN;
      return !Number.isInteger(val) ? (dflt || 0) : val + (offset || 0);
   }

   /** @summary Returns remaining part of found option as float. */
   partAsFloat(offset, dflt) {
      let val = this.part.replace(/^\D+/g, '');
      val = val ? parseFloat(val) : Number.NaN;
      return !Number.isFinite(val) ? (dflt || 0) : val + (offset || 0);
   }
} // class DrawOptions


/** @summary Simple random generator with controlled seed
  * @private */
class TRandom {
   constructor(i) {
      if (i !== undefined) this.seed(i);
   }
   /** @summary Seed simple random generator */
   seed(i) {
      i = Math.abs(i);
      if (i > 1e8)
         i = Math.abs(1e8 * Math.sin(i));
      else if (i < 1)
         i *= 1e8;
      this.m_w = Math.round(i);
      this.m_z = 987654321;
   }
   /** @summary Produce random value between 0 and 1 */
   random() {
      if (this.m_z === undefined) return Math.random();
      this.m_z = (36969 * (this.m_z & 65535) + (this.m_z >> 16)) & 0xffffffff;
      this.m_w = (18000 * (this.m_w & 65535) + (this.m_w >> 16)) & 0xffffffff;
      let result = ((this.m_z << 16) + this.m_w) & 0xffffffff;
      result /= 4294967296;
      return result + 0.5;
   }
} // class TRandom


/** @summary Function used to provide svg:path for the smoothed curves.
  * @desc reuse code from d3.js. Used in TH1, TF1 and TGraph painters
  * @param {string} kind  should contain 'bezier' or 'line'.
  * If first symbol 'L', then it used to continue drawing
  * @private */
function buildSvgPath(kind, bins, height, ndig) {

   const smooth = kind.indexOf('bezier') >= 0;

   if (ndig === undefined) ndig = smooth ? 2 : 0;
   if (height === undefined) height = 0;

   const jsroot_d3_svg_lineSlope = (p0, p1) => (p1.gry - p0.gry) / (p1.grx - p0.grx),
         jsroot_d3_svg_lineFiniteDifferences = points => {
      let i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = jsroot_d3_svg_lineSlope(p0, p1);
      while (++i < j) {
         p0 = p1; p1 = points[i + 1];
         m[i] = (d + (d = jsroot_d3_svg_lineSlope(p0, p1))) / 2;
      }
      m[i] = d;
      return m;
   }, jsroot_d3_svg_lineMonotoneTangents = points => {
      let d, a, b, s, m = jsroot_d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
      while (++i < j) {
         d = jsroot_d3_svg_lineSlope(points[i], points[i + 1]);
         if (Math.abs(d) < 1e-6) {
            m[i] = m[i + 1] = 0;
         } else {
            a = m[i] / d;
            b = m[i + 1] / d;
            s = a * a + b * b;
            if (s > 9) {
               s = d * 3 / Math.sqrt(s);
               m[i] = s * a;
               m[i + 1] = s * b;
            }
         }
      }
      i = -1;
      while (++i <= j) {
         s = (points[Math.min(j, i + 1)].grx - points[Math.max(0, i - 1)].grx) / (6 * (1 + m[i] * m[i]));
         points[i].dgrx = s || 0;
         points[i].dgry = m[i] * s || 0;
      }
   };

   let res = { path: '', close: '' }, bin = bins[0], maxy = Math.max(bin.gry, height + 5),
      currx = Math.round(bin.grx), curry = Math.round(bin.gry), dx, dy, npnts = bins.length;

   const conv = val => {
      let vvv = Math.round(val);
      if ((ndig == 0) || (vvv === val)) return vvv.toString();
      let str = val.toFixed(ndig);
      while ((str[str.length - 1] == '0') && (str.lastIndexOf('.') < str.length - 1))
         str = str.slice(0, str.length - 1);
      if (str[str.length - 1] == '.')
         str = str.slice(0, str.length - 1);
      if (str == '-0') str = '0';
      return str;
   };

   res.path = ((kind[0] == 'L') ? 'L' : 'M') + conv(bin.grx) + ',' + conv(bin.gry);

   // just calculate all deltas, can be used to build exclusion
   if (smooth || kind.indexOf('calc') >= 0)
      jsroot_d3_svg_lineMonotoneTangents(bins);

   if (smooth) {
      // build smoothed curve
      res.path += `C${conv(bin.grx+bin.dgrx)},${conv(bin.gry+bin.dgry)},`;
      for (let n = 1; n < npnts; ++n) {
         let prev = bin;
         bin = bins[n];
         if (n > 1) res.path += 'S';
         res.path += `${conv(bin.grx - bin.dgrx)},${conv(bin.gry - bin.dgry)},${conv(bin.grx)},${conv(bin.gry)}`;
         maxy = Math.max(maxy, prev.gry);
      }
   } else if (npnts < 10000) {
      // build simple curve

      let acc_x = 0, acc_y = 0;

      const flush = () => {
         if (acc_x) { res.path += 'h' + acc_x; acc_x = 0; }
         if (acc_y) { res.path += 'v' + acc_y; acc_y = 0; }
      };

      for (let n = 1; n < npnts; ++n) {
         bin = bins[n];
         dx = Math.round(bin.grx) - currx;
         dy = Math.round(bin.gry) - curry;
         if (dx && dy) {
            flush();
            res.path += `l${dx},${dy}`;
         } else if (!dx && dy) {
            if ((acc_y === 0) || ((dy < 0) !== (acc_y < 0))) flush();
            acc_y += dy;
         } else if (dx && !dy) {
            if ((acc_x === 0) || ((dx < 0) !== (acc_x < 0))) flush();
            acc_x += dx;
         }
         currx += dx; curry += dy;
         maxy = Math.max(maxy, curry);
      }

      flush();

   } else {
      // build line with trying optimize many vertical moves
      let lastx, lasty, cminy = curry, cmaxy = curry, prevy = curry;
      for (let n = 1; n < npnts; ++n) {
         bin = bins[n];
         lastx = Math.round(bin.grx);
         lasty = Math.round(bin.gry);
         maxy = Math.max(maxy, lasty);
         dx = lastx - currx;
         if (dx === 0) {
            // if X not change, just remember amplitude and
            cminy = Math.min(cminy, lasty);
            cmaxy = Math.max(cmaxy, lasty);
            prevy = lasty;
            continue;
         }

         if (cminy !== cmaxy) {
            if (cminy != curry) res.path += 'v' + (cminy - curry);
            res.path += 'v' + (cmaxy - cminy);
            if (cmaxy != prevy) res.path += 'v' + (prevy - cmaxy);
            curry = prevy;
         }
         dy = lasty - curry;
         if (dy)
            res.path += `l${dx},${dy}`;
         else
            res.path += 'h' + dx;
         currx = lastx; curry = lasty;
         prevy = cminy = cmaxy = lasty;
      }

      if (cminy != cmaxy) {
         if (cminy != curry) res.path += 'v' + (cminy - curry);
         res.path += 'v' + (cmaxy - cminy);
         if (cmaxy != prevy) res.path += 'v' + (prevy - cmaxy);
      }
   }

   if (height > 0)
      res.close = `L${conv(bin.grx)},${conv(maxy)}h${conv(bins[0].grx - bin.grx)}Z`;

   return res;
}

/** @summary Compress SVG code, produced from drawing
  * @desc removes extra info or empty elements
  * @private */
function compressSVG(svg) {

   svg = svg.replace(/url\(\&quot\;\#(\w+)\&quot\;\)/g, 'url(#$1)')        // decode all URL
            .replace(/ class=\"\w*\"/g, '')                                // remove all classes
            .replace(/ pad=\"\w*\"/g, '')                                  // remove all pad ids
            .replace(/ title=\"\"/g, '')                                   // remove all empty titles
            .replace(/<g objname=\"\w*\" objtype=\"\w*\"/g, '<g')          // remove object ids
            .replace(/<g transform=\"translate\(\d+\,\d+\)\"><\/g>/g, '')  // remove all empty groups with transform
            .replace(/<g><\/g>/g, '');                                     // remove all empty groups

   // remove all empty frame svgs, typically appears in 3D drawings, maybe should be improved in frame painter itself
   svg = svg.replace(/<svg x=\"0\" y=\"0\" overflow=\"hidden\" width=\"\d+\" height=\"\d+\" viewBox=\"0 0 \d+ \d+\"><\/svg>/g, '');

   if (svg.indexOf('xlink:href') < 0)
      svg = svg.replace(/ xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\"/g, '');

   return svg;
}


/**
 * @summary Base painter class
 *
 */

class BasePainter {

   /** @summary constructor
     * @param {object|string} [dom] - dom element or id of dom element */
   constructor(dom) {
      this.divid = null; // either id of DOM element or element itself
      if (dom) this.setDom(dom);
   }

   /** @summary Assign painter to specified DOM element
     * @param {string|object} elem - element ID or DOM Element
     * @desc Normally DOM element should be already assigned in constructor
     * @protected */
   setDom(elem) {
      if (elem !== undefined) {
         this.divid = elem;
         delete this._selected_main;
      }
   }

   /** @summary Returns assigned dom element */
   getDom() {
      return this.divid;
   }

   /** @summary Selects main HTML element assigned for drawing
     * @desc if main element was layouted, returns main element inside layout
     * @param {string} [is_direct] - if 'origin' specified, returns original element even if actual drawing moved to some other place
     * @return {object} d3.select object for main element for drawing */
   selectDom(is_direct) {

      if (!this.divid) return select(null);

      let res = this._selected_main;
      if (!res) {
         if (isStr(this.divid)) {
            let id = this.divid;
            if (id[0] != '#') id = '#' + id;
            res = select(id);
            if (!res.empty()) this.divid = res.node();
         } else {
            res = select(this.divid);
         }
         this._selected_main = res;
      }

      if (!res || res.empty() || (is_direct === 'origin')) return res;

      let use_enlarge = res.property('use_enlarge'),
          layout = res.property('layout') || 'simple',
          layout_selector = (layout == 'simple') ? '' : res.property('layout_selector');

      if (layout_selector) res = res.select(layout_selector);

      // one could redirect here
      if (!is_direct && !res.empty() && use_enlarge) res = select('#jsroot_enlarge_div');

      return res;
   }

   /** @summary Access/change top painter
     * @private */
   _accessTopPainter(on) {
      let chld = this.selectDom().node()?.firstChild;
      if (!chld) return null;
      if (on === true) {
         chld.painter = this;
      } else if (on === false)
         delete chld.painter;
      return chld.painter;
   }

   /** @summary Set painter, stored in first child element
     * @desc Only make sense after first drawing is completed and any child element add to configured DOM
     * @protected */
   setTopPainter() {
      this._accessTopPainter(true);
   }

   /** @summary Return top painter set for the selected dom element
     * @protected */
   getTopPainter() {
      return this._accessTopPainter();
   }

   /** @summary Clear reference on top painter
     * @protected */
   clearTopPainter() {
      this._accessTopPainter(false);
   }

   /** @summary Generic method to cleanup painter
     * @desc Removes all visible elements and all internal data */
   cleanup(keep_origin) {
      this.clearTopPainter();
      let origin = this.selectDom('origin');
      if (!origin.empty() && !keep_origin) origin.html('');
      this.divid = null;
      delete this._selected_main;

      if (isFunc(this._hpainter?.removePainter))
         this._hpainter.removePainter(this);

      delete this._hitemname;
      delete this._hdrawopt;
      delete this._hpainter;
   }

   /** @summary Checks if draw elements were resized and drawing should be updated
     * @return {boolean} true if resize was detected
     * @protected
     * @abstract */
   checkResize(/* arg */) {}

   /** @summary Function checks if geometry of main div was changed.
     * @desc take into account enlarge state, used only in PadPainter class
     * @return size of area when main div is drawn
     * @private */
   testMainResize(check_level, new_size, height_factor) {

      let enlarge = this.enlargeMain('state'),
          main_origin = this.selectDom('origin'),
          main = this.selectDom(),
          lmt = 5; // minimal size

      if (enlarge !== 'on') {
         if (new_size && new_size.width && new_size.height)
            main_origin.style('width', new_size.width + 'px')
               .style('height', new_size.height + 'px');
      }

      let rect_origin = getElementRect(main_origin, true),
          can_resize = main_origin.attr('can_resize'),
          do_resize = false;

      if (can_resize == 'height')
         if (height_factor && Math.abs(rect_origin.width * height_factor - rect_origin.height) > 0.1 * rect_origin.width) do_resize = true;

      if (((rect_origin.height <= lmt) || (rect_origin.width <= lmt)) &&
         can_resize && can_resize !== 'false') do_resize = true;

      if (do_resize && (enlarge !== 'on')) {
         // if zero size and can_resize attribute set, change container size

         if (rect_origin.width > lmt) {
            height_factor = height_factor || 0.66;
            main_origin.style('height', Math.round(rect_origin.width * height_factor) + 'px');
         } else if (can_resize !== 'height') {
            main_origin.style('width', '200px').style('height', '100px');
         }
      }

      let rect = getElementRect(main),
          old_h = main.property('_jsroot_height'),
          old_w = main.property('_jsroot_width');

      rect.changed = false;

      if (old_h && old_w && (old_h > 0) && (old_w > 0)) {
         if ((old_h !== rect.height) || (old_w !== rect.width))
            rect.changed = (check_level > 1) || (rect.width / old_w < 0.9) || (rect.width / old_w > 1.1) ||
                           (rect.height / old_h < 0.9) || (rect.height / old_h > 1.1);
      } else {
         rect.changed = true;
      }

      if (rect.changed)
         main.property('_jsroot_height', rect.height).property('_jsroot_width', rect.width);

      // after change enlarge state always mark main element as resized
      if (main_origin.property('did_enlarge')) {
         rect.changed = true;
         main_origin.property('did_enlarge', false);
      }

      return rect;
   }

   /** @summary Try enlarge main drawing element to full HTML page.
     * @param {string|boolean} action  - defines that should be done
     * @desc Possible values for action parameter:
     *    - true - try to enlarge
     *    - false - revert enlarge state
     *    - 'toggle' - toggle enlarge state
     *    - 'state' - only returns current enlarge state
     *    - 'verify' - check if element can be enlarged
     * if action not specified, just return possibility to enlarge main div
     * @protected */
   enlargeMain(action, skip_warning) {

      let main = this.selectDom(true),
          origin = this.selectDom('origin');

      if (main.empty() || !settings.CanEnlarge || (origin.property('can_enlarge') === false)) return false;

      if ((action === undefined) || (action === 'verify')) return true;

      let state = origin.property('use_enlarge') ? 'on' : 'off';

      if (action === 'state') return state;

      if (action === 'toggle') action = (state === 'off');

      let enlarge = select('#jsroot_enlarge_div');

      if ((action === true) && (state !== 'on')) {
         if (!enlarge.empty()) return false;

         enlarge = select(document.body)
            .append('div')
            .attr('id', 'jsroot_enlarge_div')
            .attr('style', 'position: fixed; margin: 0px; border: 0px; padding: 0px; left: 1px; right: 1px; top: 1px; bottom: 1px; background: white; opacity: 0.95; z-index: 100; overflow: hidden;');

         let rect1 = getElementRect(main),
             rect2 = getElementRect(enlarge);

         // if new enlarge area not big enough, do not do it
         if ((rect2.width <= rect1.width) || (rect2.height <= rect1.height))
            if (rect2.width * rect2.height < rect1.width * rect1.height) {
               if (!skip_warning)
                  console.log(`Enlarged area ${rect2.width} x ${rect2.height} smaller then original drawing ${rect1.width} x ${rect1.height}`);
               enlarge.remove();
               return false;
            }

         while (main.node().childNodes.length > 0)
            enlarge.node().appendChild(main.node().firstChild);

         origin.property('use_enlarge', true);
         origin.property('did_enlarge', true);
         return true;
      }
      if ((action === false) && (state !== 'off')) {

         while (enlarge.node() && enlarge.node().childNodes.length > 0)
            main.node().appendChild(enlarge.node().firstChild);

         enlarge.remove();
         origin.property('use_enlarge', false);
         origin.property('did_enlarge', true);
         return true;
      }

      return false;
   }

   /** @summary Set item name, associated with the painter
     * @desc Used by {@link HierarchyPainter}
     * @private */
   setItemName(name, opt, hpainter) {
      if (isStr(name))
         this._hitemname = name;
      else
         delete this._hitemname;
      // only upate draw option, never delete.
      if (isStr(opt))
         this._hdrawopt = opt;

      this._hpainter = hpainter;
   }

   /** @summary Returns assigned item name
     * @desc Used with {@link HierarchyPainter} to identify drawn item name */
   getItemName() { return this._hitemname ?? null; }

   /** @summary Returns assigned item draw option
     * @desc Used with {@link HierarchyPainter} to identify drawn item option */
   getItemDrawOpt() { return this._hdrawopt ?? ''; }

} // class BasePainter

/** @summary Load and initialize JSDOM from nodes
  * @return {Promise} with d3 selection for d3_body
   * @private */
async function _loadJSDOM() {
   return Promise.resolve().then(function () { return _rollup_plugin_ignore_empty_module_placeholder$1; }).then(handle => {

      if (!internals.nodejs_window) {
         internals.nodejs_window = (new handle.JSDOM('<!DOCTYPE html>hello')).window;
         internals.nodejs_document = internals.nodejs_window.document; // used with three.js
         internals.nodejs_body = select(internals.nodejs_document).select('body'); //get d3 handle for body
      }

      return { JSDOM: handle.JSDOM, doc: internals.nodejs_document, body: internals.nodejs_body };
   });
}

const root_fonts = ['Arial', 'iTimes New Roman',
      'bTimes New Roman', 'biTimes New Roman', 'Arial',
      'oArial', 'bArial', 'boArial', 'Courier New',
      'oCourier New', 'bCourier New', 'boCourier New',
      'Symbol', 'Times New Roman', 'Wingdings', 'iSymbol',
      'Verdana', 'iVerdana', 'bVerdana', 'biVerdana'];


// taken from symbols.html, counted only for letters and digits
const root_fonts_aver_width = [0.5778,0.5314,
      0.5809, 0.5540, 0.5778,
      0.5783,0.6034,0.6030,0.6003,
      0.6004,0.6003,0.6005,
      0.5521,0.5521,0.5664,0.5314,
      0.5664,0.5495,0.5748,0.5578];

/**
 * @summary Helper class for font handling
 * @private
 */

class FontHandler {

   /** @summary constructor */
   constructor(fontIndex, size, scale, name, style, weight) {
      this.name = 'Arial';
      this.style = null;
      this.weight = null;

      if (scale && (size < 1)) {
         size *= scale;
         this.scaled = true;
      }

      this.size = Math.round(size || 11);
      this.scale = scale;

      if (fontIndex !== null) {

         let indx = Math.floor(fontIndex / 10),
             fontName = root_fonts[indx] || 'Arial';

         while (fontName) {
            if (fontName[0] === 'b')
               this.weight = 'bold';
            else if (fontName[0] === 'i')
               this.style = 'italic';
            else if (fontName[0] === 'o')
               this.style = 'oblique';
            else
               break;
            fontName = fontName.slice(1);
         }

         this.name = fontName;
         this.aver_width = root_fonts_aver_width[indx] || 0.55;
      } else {
         this.name = name;
         this.style = style || null;
         this.weight = weight || null;
         this.aver_width = this.weight ? 0.58 : 0.55;
      }

      if ((this.name == 'Symbol') || (this.name == 'Wingdings')) {
         this.isSymbol = this.name;
         this.name = "Times New Roman";
      } else {
         this.isSymbol = '';
      }

      this.func = this.setFont.bind(this);
   }

   /** @summary Assigns font-related attributes */
   setFont(selection, arg) {
      selection.attr("font-family", this.name);
      if (arg != 'without-size')
         selection.attr("font-size", this.size)
                  .attr("xml:space", "preserve");
      selection.attr("font-weight", this.weight || null);
      selection.attr("font-style", this.style || null);
   }

   /** @summary Set font size (optional) */
   setSize(size) { this.size = Math.round(size); }

   /** @summary Set text color (optional) */
   setColor(color) { this.color = color; }

   /** @summary Set text align (optional) */
   setAlign(align) { this.align = align; }

   /** @summary Set text angle (optional) */
   setAngle(angle) { this.angle = angle; }

   /** @summary Allign angle to step raster, add optional offset */
   roundAngle(step, offset) {
      this.angle = parseInt(this.angle || 0);
      if (!Number.isInteger(this.angle)) this.angle = 0;
      this.angle = Math.round(this.angle/step) * step + (offset || 0);
      if (this.angle < 0)
         this.angle += 360;
      else if (this.angle >= 360)
         this.angle -= 360;
   }

   /** @summary Clears all font-related attributes */
   clearFont(selection) {
      selection.attr("font-family", null)
               .attr("font-size", null)
               .attr("xml:space", null)
               .attr("font-weight", null)
               .attr("font-style", null);
   }

   /** @summary Returns true in case of monospace font
     * @private */
   isMonospace() {
      let n = this.name.toLowerCase();
      return (n.indexOf("courier") == 0) || (n == "monospace") || (n == "monaco");
   }

   /** @summary Return full font declaration which can be set as font property like "12pt Arial bold"
     * @private */
   getFontHtml() {
      let res = Math.round(this.size) + "pt " + this.name;
      if (this.weight) res += " " + this.weight;
      if (this.style) res += " " + this.style;
      return res;
   }

   /** @summary Returns font name */
   getFontName() {
      return this.isSymbol || this.name || 'none';
   }

} // class FontHandler

const symbols_map = {
   // greek letters
   '#alpha': '\u03B1',
   '#beta': '\u03B2',
   '#chi': '\u03C7',
   '#delta': '\u03B4',
   '#digamma': '\u03DD',
   '#varepsilon': '\u03B5',
   '#phi': '\u03C6',
   '#gamma': '\u03B3',
   '#eta': '\u03B7',
   '#iota': '\u03B9',
   '#varphi': '\u03C6',
   '#kappa': '\u03BA',
   '#koppa': '\u03DF',
   '#sampi': '\u03E1',
   '#lambda': '\u03BB',
   '#mu': '\u03BC',
   '#nu': '\u03BD',
   '#omicron': '\u03BF',
   '#pi': '\u03C0',
   '#theta': '\u03B8',
   '#rho': '\u03C1',
   '#sigma': '\u03C3',
   '#stigma': '\u03DB',
   '#san': '\u03FB',
   '#sho': '\u03F8',
   '#tau': '\u03C4',
   '#upsilon': '\u03C5',
   '#varomega': '\u03D6',
   '#varcoppa': '\u03D9',
   '#omega': '\u03C9',
   '#xi': '\u03BE',
   '#psi': '\u03C8',
   '#zeta': '\u03B6',
   '#Alpha': '\u0391',
   '#Beta': '\u0392',
   '#Chi': '\u03A7',
   '#Delta': '\u0394',
   '#Digamma': '\u03DC',
   '#Epsilon': '\u0395',
   '#Phi': '\u03A6',
   '#Gamma': '\u0393',
   '#Eta': '\u0397',
   '#Iota': '\u0399',
   '#vartheta': '\u03D1',
   '#Kappa': '\u039A',
   '#Koppa': '\u03DE',
   '#varKoppa': '\u03D8',
   '#Sampi': '\u03E0',
   '#Lambda': '\u039B',
   '#Mu': '\u039C',
   '#Nu': '\u039D',
   '#Omicron': '\u039F',
   '#Pi': '\u03A0',
   '#Theta': '\u0398',
   '#Rho': '\u03A1',
   '#Sigma': '\u03A3',
   '#Stigma': '\u03DA',
   '#San': '\u03FA',
   '#Sho': '\u03F7',
   '#Tau': '\u03A4',
   '#Upsilon': '\u03A5',
   '#varsigma': '\u03C2',
   '#Omega': '\u03A9',
   '#Xi': '\u039E',
   '#Psi': '\u03A8',
   '#Zeta': '\u0396',
   '#varUpsilon': '\u03D2',
   '#epsilon': '\u03B5',
   '#P': '\u00B6',

   // only required for MathJax to provide correct replacement
   '#sqrt': '\u221A',
   '#bar': '',
   '#overline': '',
   '#underline': '',
   '#strike': '',

   // from TLatex tables #2 & #3
   '#leq': '\u2264',
   '#/': '\u2044',
   '#infty': '\u221E',
   '#voidb': '\u0192',
   '#club': '\u2663',
   '#diamond': '\u2666',
   '#heart': '\u2665',
   '#spade': '\u2660',
   '#leftrightarrow': '\u2194',
   '#leftarrow': '\u2190',
   '#uparrow': '\u2191',
   '#rightarrow': '\u2192',
   '#downarrow': '\u2193',
   '#circ': '\u02C6', // ^
   '#pm': '\xB1',
   '#doublequote': '\u2033',
   '#geq': '\u2265',
   '#times': '\xD7',
   '#propto': '\u221D',
   '#partial': '\u2202',
   '#bullet': '\u2022',
   '#divide': '\xF7',
   '#neq': '\u2260',
   '#equiv': '\u2261',
   '#approx': '\u2248', // should be \u2245 ?
   '#3dots': '\u2026',
   '#cbar': '\x7C',
   '#topbar': '\xAF',
   '#downleftarrow': '\u21B5',
   '#aleph': '\u2135',
   '#Jgothic': '\u2111',
   '#Rgothic': '\u211C',
   '#voidn': '\u2118',
   '#otimes': '\u2297',
   '#oplus': '\u2295',
   '#oslash': '\u2205',
   '#cap': '\u2229',
   '#cup': '\u222A',
   '#supseteq': '\u2287',
   '#supset': '\u2283',
   '#notsubset': '\u2284',
   '#subseteq': '\u2286',
   '#subset': '\u2282',
   '#int': '\u222B',
   '#in': '\u2208',
   '#notin': '\u2209',
   '#angle': '\u2220',
   '#nabla': '\u2207',
   '#oright': '\xAE',
   '#ocopyright': '\xA9',
   '#trademark': '\u2122',
   '#prod': '\u220F',
   '#surd': '\u221A',
   '#upoint': '\u02D9',
   '#corner': '\xAC',
   '#wedge': '\u2227',
   '#vee': '\u2228',
   '#Leftrightarrow': '\u21D4',
   '#Leftarrow': '\u21D0',
   '#Uparrow': '\u21D1',
   '#Rightarrow': '\u21D2',
   '#Downarrow': '\u21D3',
   '#LT': '\x3C',
   '#void1': '\xAE',
   '#copyright': '\xA9',
   '#void3': '\u2122',
   '#sum': '\u2211',
   '#arctop': '\u239B',
   '#lbar': '\u23B8',
   '#arcbottom': '\u239D',
   '#void8': '',
   '#bottombar': '\u230A',
   '#arcbar': '\u23A7',
   '#ltbar': '\u23A8',
   '#AA': '\u212B',
   '#aa': '\u00E5',
   '#void06': '',
   '#GT': '\x3E',
   '#forall': '\u2200',
   '#exists': '\u2203',
   '#vec': '',
   '#dot': '\u22C5',
   '#hat': '\xB7',
   '#ddot': '',
   '#acute': '',
   '#grave': '',
   '#check': '\u2713',
   '#tilde': '\u02DC',
   '#slash': '\u2044',
   '#hbar': '\u0127',
   '#box': '\u25FD',
   '#Box': '\u2610',
   '#parallel': '\u2225',
   '#perp': '\u22A5',
   '#odot': '\u2299',
   '#left': '',
   '#right': '',
   '{}': ''
};

/** @summary Create a single regex to detect any symbol to replace
  * @private */
const symbolsRegexCache = new RegExp('(' + Object.keys(symbols_map).join('|').replace(/\\\{/g, '{').replace(/\\\}/g, '}') + ')', 'g');

/** @summary Simple replacement of latex letters
  * @private */
const translateLaTeX = (str, more) => {
   while ((str.length > 2) && (str[0] == '{') && (str[str.length - 1] == '}'))
      str = str.slice(1, str.length - 1);

   return str.replace(symbolsRegexCache, ch => symbols_map[ch]).replace(/\{\}/g, '');
};

// array with relative width of base symbols from range 32..126
const base_symbols_width = [453,535,661,973,955,1448,1242,324,593,596,778,1011,431,570,468,492,947,885,947,947,947,947,947,947,947,947,511,495,980,1010,987,893,1624,1185,1147,1193,1216,1080,1028,1270,1274,531,910,1177,1004,1521,1252,1276,1111,1276,1164,1056,1073,1215,1159,1596,1150,1124,1065,540,591,540,837,874,572,929,972,879,973,901,569,967,973,453,458,903,453,1477,973,970,972,976,638,846,548,973,870,1285,884,864,835,656,430,656,1069];

const extra_symbols_width = {945:1002,946:996,967:917,948:953,949:834,966:1149,947:847,951:989,953:516,954:951,955:913,956:1003,957:862,959:967,960:1070,952:954,961:973,963:1017,964:797,965:944,982:1354,969:1359,958:803,968:1232,950:825,913:1194,914:1153,935:1162,916:1178,917:1086,934:1358,915:1016,919:1275,921:539,977:995,922:1189,923:1170,924:1523,925:1253,927:1281,928:1281,920:1285,929:1102,931:1041,932:1069,933:1135,962:848,937:1279,926:1092,936:1334,918:1067,978:1154,8730:986,8804:940,8260:476,8734:1453,402:811,9827:1170,9830:931,9829:1067,9824:965,8596:1768,8592:1761,8593:895,8594:1761,8595:895,710:695,177:955,8243:680,8805:947,215:995,8733:1124,8706:916,8226:626,247:977,8800:969,8801:1031,8776:976,8230:1552,175:883,8629:1454,8501:1095,8465:1002,8476:1490,8472:1493,8855:1417,8853:1417,8709:1205,8745:1276,8746:1404,8839:1426,8835:1426,8836:1426,8838:1426,8834:1426,8747:480,8712:1426,8713:1426,8736:1608,8711:1551,174:1339,169:1339,8482:1469,8719:1364,729:522,172:1033,8743:1383,8744:1383,8660:1768,8656:1496,8657:1447,8658:1496,8659:1447,8721:1182,9115:882,9144:1000,9117:882,8970:749,9127:1322,9128:1322,8491:1150,229:929,8704:1397,8707:1170,8901:524,183:519,10003:1477,732:692,295:984,9725:1780,9744:1581,8741:737,8869:1390,8857:1421};

/** @ummary Calculate approximate labels width
  * @private */
function approximateLabelWidth(label, font, fsize) {
   let len = label.length,
       symbol_width = (fsize || font.size) * font.aver_width;
   if (font.isMonospace())
      return len * symbol_width;

   let sum = 0;
   for (let i = 0; i < len; ++i) {
      let code = label.charCodeAt(i);
      if ((code >= 32) && (code<127))
         sum += base_symbols_width[code-32];
      else
         sum += extra_symbols_width[code] || 1000;
   }

   return sum/1000*symbol_width;
}

/** @summary array defines features supported by latex parser, used by both old and new parsers
  * @private */
const latex_features = [
   { name: '#it{' }, // italic
   { name: '#bf{' }, // bold
   { name: '#underline{', deco: 'underline' }, // underline
   { name: '#overline{', deco: 'overline' }, // overline
   { name: '#strike{', deco: 'line-through' }, // line through
   { name: '#kern[', arg: 'float' }, // horizontal shift
   { name: '#lower[', arg: 'float' },  // vertical shift
   { name: '#scale[', arg: 'float' },  // font scale
   { name: '#color[', arg: 'int' },   // font color
   { name: '#font[', arg: 'int' },    // font face
   { name: '_{', low_up: 'low' },  // subscript
   { name: '^{', low_up: 'up' },   // superscript
   { name: '#bar{', deco: 'overline' /* accent: '\u02C9' */ }, // '\u0305'
   { name: '#hat{', accent: '\u02C6', hasw: true }, // '\u0302'
   { name: '#check{', accent: '\u02C7', hasw: true }, // '\u030C'
   { name: '#acute{', accent: '\u02CA' }, // '\u0301'
   { name: '#grave{', accent: '\u02CB' }, // '\u0300'
   { name: '#dot{', accent: '\u02D9' }, // '\u0307'
   { name: '#ddot{', accent: '\u02BA', hasw: true }, // '\u0308'
   { name: '#tilde{', accent: '\u02DC', hasw: true }, // '\u0303'
   { name: '#slash{', accent: '\u2215' }, // '\u0337'
   { name: '#vec{', accent: '\u02ED', hasw: true }, // '\u0350' arrowhead
   { name: '#frac{', twolines: 'line' },
   { name: '#splitline{', twolines: true },
   { name: '#sqrt[', arg: 'int', sqrt: true }, // root with arbitrary power
   { name: '#sqrt{', sqrt: true },             // square root
   { name: '#sum', special: '\u2211', w: 0.8, h: 0.9 },
   { name: '#int', special: '\u222B', w: 0.3, h: 1.0 },
   { name: '#left[', right: '#right]', braces: '[]' },
   { name: '#left(', right: '#right)', braces: '()' },
   { name: '#left{', right: '#right}', braces: '{}' },
   { name: '#left|', right: '#right|', braces: '||' },
   { name: '#[]{', braces: '[]' },
   { name: '#(){', braces: '()' },
   { name: '#{}{', braces: '{}' },
   { name: '#||{', braces: '||' }
];

// taken from: https://sites.math.washington.edu/~marshall/cxseminar/symbol.htm, starts from 33
const symbolsMap = [0,8704,0,8707,0,0,8717,0,0,8727,0,0,8722,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8773,913,914,935,916,917,934,915,919,921,977,922,923,924,925,927,928,920,929,931,932,933,962,937,926,936,918,0,8756,0,8869,0,0,945,946,967,948,949,966,947,951,953,981,954,955,956,957,959,960,952,961,963,964,965,982,969,958,968,950,0,402,0,8764,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,978,8242,8804,8260,8734,0,9827,9830,9829,9824,8596,8592,8593,8594,8595,0,0,8243,8805,0,8733,8706,8729,0,8800,8801,8776,8230,0,0,8629,8501,8465,8476,8472,8855,8853,8709,8745,8746,8835,8839,8836,8834,8838,8712,8713,8736,8711,0,0,8482,8719,8730,8901,0,8743,8744,8660,8656,8657,8658,8659,9674,9001,0,0,8482,8721,0,0,0,0,0,0,0,0,0,0,8364,9002,8747,8992,0,8993];

// taken from http://www.alanwood.net/demos/wingdings.html, starts from 33
const wingdingsMap = [128393,9986,9985,128083,128365,128366,128367,128383,9990,128386,128387,128234,128235,128236,128237,128193,128194,128196,128463,128464,128452,8987,128430,128432,128434,128435,128436,128427,128428,9991,9997,128398,9996,128076,128077,128078,9756,9758,9757,9759,128400,9786,128528,9785,128163,9760,127987,127985,9992,9788,128167,10052,128326,10014,128328,10016,10017,9770,9775,2384,9784,9800,9801,9802,9803,9804,9805,9806,9807,9808,9809,9810,9811,128624,128629,9679,128318,9632,9633,128912,10065,10066,11047,10731,9670,10070,11045,8999,11193,8984,127989,127990,128630,128631,0,9450,9312,9313,9314,9315,9316,9317,9318,9319,9320,9321,9471,10102,10103,10104,10105,10106,10107,10108,10109,10110,10111,128610,128608,128609,128611,128606,128604,128605,128607,183,8226,9642,9898,128902,128904,9673,9678,128319,9642,9723,128962,10022,9733,10038,10036,10041,10037,11216,8982,10209,8977,11217,10026,10032,128336,128337,128338,128339,128340,128341,128342,128343,128344,128345,128346,128347,11184,11185,11186,11187,11188,11189,11190,11191,128618,128619,128597,128596,128599,128598,128592,128593,128594,128595,9003,8998,11160,11162,11161,11163,11144,11146,11145,11147,129128,129130,129129,129131,129132,129133,129135,129134,129144,129146,129145,129147,129148,129149,129151,129150,8678,8680,8679,8681,11012,8691,11008,11009,11011,11010,129196,129197,128502,10004,128503,128505];

function replaceSymbols(s, kind) {
   let res = '', m = kind == 'Wingdings' ? wingdingsMap : symbolsMap;
   for (let k = 0; k < s.length; ++k) {
      let code = s.charCodeAt(k),
          new_code = (code > 32) ? m[code-33] : 0;
      res += String.fromCodePoint(new_code || code);
   }
   return res;
}

/** @summary Just add plain text to the SVG text elements
  * @private */
function producePlainText(painter, txt_node, arg) {
   arg.plain = true;
   if (arg.simple_latex)
      arg.text = translateLaTeX(arg.text); // replace latex symbols
   if (arg.font && arg.font.isSymbol)
      txt_node.text(replaceSymbols(arg.text, arg.font.isSymbol));
   else
      txt_node.text(arg.text);
}

/** @summary Check if plain text
  * @private */
function isPlainText(txt) {
   return !txt || ((txt.indexOf('#') < 0) && (txt.indexOf('{') < 0));
}

/** @ummary translate TLatex and draw inside provided g element
  * @desc use <text> together with normal <path> elements
  * @private */
function parseLatex(node, arg, label, curr) {

   let nelements = 0;

   const currG = () => { if (!curr.g) curr.g = node.append('svg:g'); return curr.g; };

   const shiftX = dx => { curr.x += Math.round(dx); };

   const extendPosition = (x1, y1, x2, y2) => {
      if (!curr.rect) {
         curr.rect = { x1: x1, y1: y1, x2: x2, y2: y2 };
      } else {
         curr.rect.x1 = Math.min(curr.rect.x1, x1);
         curr.rect.y1 = Math.min(curr.rect.y1, y1);
         curr.rect.x2 = Math.max(curr.rect.x2, x2);
         curr.rect.y2 = Math.max(curr.rect.y2, y2);
      }

      curr.rect.width = curr.rect.x2 - curr.rect.x1;
      curr.rect.height = curr.rect.y2 - curr.rect.y1;

      if (!curr.parent)
         arg.text_rect = curr.rect;
   };

   /** Position pos.g node which directly attached to curr.g and uses curr.g coordinates */
   const positionGNode = (pos, x, y, inside_gg) => {
      x = Math.round(x);
      y = Math.round(y);
      if (y)
         pos.g.attr('transform',`translate(${x},${y})`);
      else if (x)
         pos.g.attr('transform',`translate(${x})`);

      pos.rect.x1 += x;
      pos.rect.x2 += x;
      pos.rect.y1 += y;
      pos.rect.y2 += y;

      if (inside_gg)
         extendPosition(curr.x + pos.rect.x1, curr.y + pos.rect.y1, curr.x + pos.rect.x2, curr.y + pos.rect.y2);
      else
         extendPosition(pos.rect.x1, pos.rect.y1, pos.rect.x2, pos.rect.y2);
   };

   /** Create special sub-container for elements like sqrt or braces  */
   const createGG = () => {
      let gg = currG();

      // this is indicator that gg element will be the only one, one can use directly main container
      if ((nelements == 1) && !label && !curr.x && !curr.y) {
         return gg;
      }

      gg = gg.append('svg:g');

      if (curr.y)
         gg.attr('transform',`translate(${curr.x},${curr.y})`);
      else if (curr.x)
         gg.attr('transform',`translate(${curr.x})`);
      return gg;
   };

   const extractSubLabel = (check_first, lbrace, rbrace) => {
      let pos = 0, n = 1, err = false, extra_braces = false;
      if (!lbrace) lbrace = '{';
      if (!rbrace) rbrace = '}';

      const match = br => (pos + br.length <= label.length) && (label.slice(pos, pos+br.length) == br);

      if (check_first) {
         if(!match(lbrace))
            err = true;
         else
            label = label.slice(lbrace.length);
      }

      while (!err && (n != 0) && (pos < label.length)) {
         if (match(lbrace)) {
            n++;
            pos += lbrace.length;
         } else if (match(rbrace)) {
            n--;
            pos += rbrace.length;
            if ((n == 0) && (typeof check_first == 'string') && match(check_first+lbrace)) {
               // handle special case like a^{b}^{2} should mean a^{b^{2}}
               n++;
               pos += lbrace.length + check_first.length;
               check_first = true;
               extra_braces = true;
            }
         } else pos++;
      }
      if ((n != 0) || err) {
         console.log(`mismatch with open ${lbrace} and closing ${rbrace} in ${label}`);
         return -1;
      }

      let sublabel = label.slice(0, pos - rbrace.length);

      if (extra_braces) sublabel = lbrace + sublabel + rbrace;

      label = label.slice(pos);

      return sublabel;
   };

   const createPath = (gg, dofill) => {
      return gg.append('svg:path')
               .style('stroke', dofill ? 'none' : (curr.color || arg.color))
               .style('stroke-width', dofill ? null : Math.max(1, Math.round(curr.fsize*(curr.font.weight ? 0.1 : 0.07))))
               .style('fill', dofill ? (curr.color || arg.color) : 'none');
   };

   const createSubPos = fscale => {
      return { lvl: curr.lvl + 1, x: 0, y: 0, fsize: curr.fsize*(fscale || 1), color: curr.color, font: curr.font, parent: curr, painter: curr.painter };
   };

   while (label) {

      let best = label.length, found = null;

      for (let n = 0; n < latex_features.length; ++n) {
         let pos = label.indexOf(latex_features[n].name);
         if ((pos >= 0) && (pos < best)) { best = pos; found = latex_features[n]; }
      }

      if (best > 0) {

         let alone = (best == label.length) && (nelements == 0) && !found;

         nelements++;

         let s = translateLaTeX(label.slice(0, best));
         if (s || alone) {
            // if single text element created, place it directly in the node
            let g = curr.g || (alone ? node : currG()),
                elem = g.append('svg:text');

            if (alone && !curr.g) curr.g = elem;

            // apply font attributes only once, inherited by all other elements
            if (curr.ufont)
               curr.font.setFont(curr.g /*, 'without-size' */);

            if (curr.bold !== undefined)
               curr.g.attr('font-weight', curr.bold ? 'bold' : 'normal');

            if (curr.italic !== undefined)
               curr.g.attr('font-style', curr.italic ? 'italic' : 'normal');

            // set fill color directly to element
            elem.attr('fill', curr.color || arg.color || null);

            // set font size directly to element to avoid complex control
            if (curr.fisze !== curr.font.size)
               elem.attr('font-size', Math.round(curr.fsize));

            if (curr.font && curr.font.isSymbol)
               elem.text(replaceSymbols(s, curr.font.isSymbol));
            else
               elem.text(s);

            let rect = !isNodeJs() && !settings.ApproxTextSize && !arg.fast ? getElementRect(elem, 'nopadding') :
                          { height: curr.fsize * 1.2, width: approximateLabelWidth(s, curr.font, curr.fsize) };

            if (curr.x) elem.attr('x', curr.x);
            if (curr.y) elem.attr('y', curr.y);

            // values used for superscript
            curr.last_y1 = curr.y - rect.height*0.8;
            curr.last_y2 = curr.y + rect.height*0.2;

            extendPosition(curr.x, curr.last_y1, curr.x + rect.width, curr.last_y2);

            if (!alone) {
               shiftX(rect.width);
            } else if (curr.deco) {
               elem.attr('text-decoration', curr.deco);
               delete curr.deco; // inform that decoration was applied
            }
         }
      }

      if (!found) return true;

      // remove preceeding block and tag itself
      label = label.slice(best + found.name.length);

      nelements++;

      if (found.accent) {
         let sublabel = extractSubLabel();
         if (sublabel === -1) return false;

         let gg = createGG(),
             subpos = createSubPos();

         parseLatex(gg, arg, sublabel, subpos);

         let minw = curr.fsize*0.6, xpos = 0,
             w = subpos.rect.width,
             y1 = Math.round(subpos.rect.y1),
             dy2 = Math.round(curr.fsize*0.1), dy = dy2*2,
             dot = `a${dy2},${dy2},0,0,1,${dy},0a${dy2},${dy2},0,0,1,${-dy},0z`;

         // shift symbol when it is too small
         if (found.hasw && (w < minw)) {
            w = minw;
            xpos = (minw - subpos.rect.width) / 2;
         }

         let w5 = Math.round(w*0.5), w3 = Math.round(w*0.3), w2 = w5-w3, w8 = w5+w3;
         w = w5*2;

         positionGNode(subpos, xpos, 0, true);

         switch(found.name) {
            case '#check{': createPath(gg).attr('d',`M${w2},${y1-dy}L${w5},${y1}L${w8},${y1-dy}`); break;
            case '#acute{': createPath(gg).attr('d',`M${w5},${y1}l${dy},${-dy}`); break;
            case '#grave{': createPath(gg).attr('d',`M${w5},${y1}l${-dy},${-dy}`); break;
            case '#dot{': createPath(gg, true).attr('d',`M${w5-dy2},${y1}${dot}`); break;
            case '#ddot{': createPath(gg, true).attr('d',`M${w5-3*dy2},${y1}${dot} M${w5+dy2},${y1}${dot}`); break;
            case '#tilde{': createPath(gg).attr('d',`M${w2},${y1} a${w3},${dy},0,0,1,${w3},0 a${w3},${dy},0,0,0,${w3},0`); break;
            case '#slash{': createPath(gg).attr('d',`M${w},${y1}L0,${Math.round(subpos.rect.y2)}`); break;
            case '#vec{': createPath(gg).attr('d',`M${w2},${y1}H${w8}M${w8-dy},${y1-dy}l${dy},${dy}l${-dy},${dy}`); break;
            default: createPath(gg).attr('d',`M${w2},${y1}L${w5},${y1-dy}L${w8},${y1}`); // #hat{
         }

         shiftX(subpos.rect.width);

         continue;
      }

      if (found.twolines) {

         curr.twolines = true;

         let line1 = extractSubLabel(), line2 = extractSubLabel(true);
         if ((line1 === -1) || (line2 === -1)) return false;

         let gg = createGG(),
             fscale = (curr.parent && curr.parent.twolines) ? 0.7 : 1,
             subpos1 = createSubPos(fscale);

         parseLatex(gg, arg, line1, subpos1);

         let path = (found.twolines == 'line') ? createPath(gg) : null,
             subpos2 = createSubPos(fscale);

         parseLatex(gg, arg, line2, subpos2);

         let w = Math.max(subpos1.rect.width, subpos2.rect.width),
             dw = subpos1.rect.width - subpos2.rect.width,
             dy = -curr.fsize*0.35; // approximate position of middle line

         positionGNode(subpos1, (dw < 0 ? -dw/2 : 0), dy - subpos1.rect.y2, true);

         positionGNode(subpos2, (dw > 0 ? dw/2 : 0), dy - subpos2.rect.y1, true);

         if (path) path.attr('d', `M0,${Math.round(dy)}h${Math.round(w - curr.fsize*0.1)}`);

         shiftX(w);

         delete curr.twolines;

         continue;
      }

      const extractLowUp = name => {
         let res = {};
         if (name) {
            res[name] = extractSubLabel();
            if (res[name] === -1) return false;
         }

         while (label) {
            if (label[0] == '_') {
               label = label.slice(1);
               res.low = !res.low ? extractSubLabel('_') : -1;
               if (res.low === -1) {
                  console.log(`error with ${found.name} low limit`);
                  return false;
               }
            } else if (label[0] == '^') {
               label = label.slice(1);
               res.up = !res.up ? extractSubLabel('^') : -1;
               if (res.up === -1) {
                  console.log(`error with ${found.name} upper limit ` + label);
                  return false;
               }
            } else break;
         }
         return res;
      };

      if (found.low_up) {
         const subs = extractLowUp(found.low_up);
         if (!subs) return false;

         let pos_up, pos_low,
             x = curr.x, y1 = -curr.fsize, y2 = 0.25*curr.fsize, w1 = 0, w2 = 0;

         if (subs.up) {
            pos_up = createSubPos(0.6);
            parseLatex(currG(), arg, subs.up, pos_up);
         }

         if (subs.low) {
            pos_low = createSubPos(0.6);
            parseLatex(currG(), arg, subs.low, pos_low);
         }

         if ((curr.last_y1 !== undefined) && (curr.last_y2 !== undefined)) {
            y1 = curr.last_y1; y2 = curr.last_y2;
         }

         if (pos_up) {
            positionGNode(pos_up, x, y1 - pos_up.rect.y1 - curr.fsize*0.1);
            w1 = pos_up.rect.width;
         }

         if (pos_low) {
            positionGNode(pos_low, x, y2 - pos_low.rect.y2 + curr.fsize*0.1);
            w2 = pos_low.rect.width;
         }

         shiftX(Math.max(w1,w2));

         continue;
      }

      if (found.special) {
         // this is sum and integral, now make fix height, later can adjust to right-content size

         let subs = extractLowUp() || {},
             gg = createGG(), path = createPath(gg),
             h = Math.round(curr.fsize*1.7), w = Math.round(curr.fsize), r = Math.round(h*0.1), x_up, x_low;

         if (found.name == '#sum') {
            x_up = x_low = w/2;
            path.attr('d',`M${w},${Math.round(-0.75*h)}h${-w}l${Math.round(0.4*w)},${Math.round(0.3*h)}l${Math.round(-0.4*w)},${Math.round(0.7*h)}h${w}`);
         } else {
            x_up = 3*r; x_low = r;
            path.attr('d',`M0,${Math.round(0.25*h-r)}a${r},${r},0,0,0,${2*r},0v${2*r-h}a${r},${r},0,1,1,${2*r},0`);
            // path.attr('transform','skewX(-3)'); could use skewX for italic-like style
         }

         extendPosition(curr.x, curr.y - 0.6*h, curr.x + w, curr.y + 0.4*h);

         if (subs.low) {
            let subpos1 = createSubPos(0.6);
            parseLatex(gg, arg, subs.low, subpos1);
            positionGNode(subpos1, (x_low - subpos1.rect.width/2), 0.25*h - subpos1.rect.y1, true);
         }

         if (subs.up) {
            let subpos2 = createSubPos(0.6);
            parseLatex(gg, arg, subs.up, subpos2);
            positionGNode(subpos2, (x_up - subpos2.rect.width/2), -0.75*h - subpos2.rect.y2, true);
         }

         shiftX(w);

         continue;
      }

      if (found.braces) {
         let rbrace = found.right, lbrace = rbrace ? found.name : '{',
             sublabel = extractSubLabel(false, lbrace, rbrace),
             gg = createGG(),
             subpos = createSubPos(),
             path1 = createPath(gg);

         parseLatex(gg, arg, sublabel, subpos);

         let path2 = createPath(gg),
             w = Math.max(2, Math.round(curr.fsize*0.2)),
             r = subpos.rect, dy = Math.round(r.y2 - r.y1),
             r_y1 = Math.round(r.y1), r_width = Math.round(r.width);

         switch (found.braces) {
            case '||':
               path1.attr('d',`M${w},${r_y1}v${dy}`);
               path2.attr('d',`M${3*w+r_width},${r_y1}v${dy}`);
               break;
            case '[]':
               path1.attr('d',`M${2*w},${r_y1}h${-w}v${dy}h${w}`);
               path2.attr('d',`M${2*w+r_width},${r_y1}h${w}v${dy}h${-w}`);
               break;
            case '{}':
               path1.attr('d',`M${2*w},${r_y1} a${w},${w},0,0,0,${-w},${w} v${dy/2-2*w} a${w},${w},0,0,1,${-w},${w} a${w},${w},0,0,1,${w},${w} v${dy/2-2*w} a${w},${w},0,0,0,${w},${w}`);
               path2.attr('d',`M${2*w+r_width},${r_y1} a${w},${w},0,0,1,${w},${w} v${dy/2-2*w} a${w},${w},0,0,0,${w},${w} a${w},${w},0,0,0,${-w},${w} v${dy/2-2*w} a${w},${w},0,0,1,${-w},${w}`);
               break;
            default: // ()
               path1.attr('d',`M${w},${r_y1}a${4*dy},${4*dy},0,0,0,0,${dy}`);
               path2.attr('d',`M${3*w+r_width},${r_y1}a${4*dy},${4*dy},0,0,1,0,${dy}`);
         }

         positionGNode(subpos, 2*w, 0, true);

         extendPosition(curr.x, curr.y + r.y1, curr.x + 4*w + r.width, curr.y + r.y2);

         shiftX(4*w + r.width);

         // values used for superscript
         curr.last_y1 = r.y1;
         curr.last_y2 = r.y2;

         continue;
      }

      if (found.deco) {
         let sublabel = extractSubLabel(),
             gg = createGG(),
             subpos = createSubPos();

         subpos.deco = found.deco;

         parseLatex(gg, arg, sublabel, subpos);

         let r = subpos.rect;

         if (subpos.deco) {
            let path = createPath(gg), r_width = Math.round(r.width);
            switch(subpos.deco) {
               case 'underline': path.attr('d',`M0,${Math.round(r.y2)}h${r_width}`); break;
               case 'overline': path.attr('d',`M0,${Math.round(r.y1)}h${r_width}`); break;
               case 'line-through': path.attr('d',`M0,${Math.round(0.45*r.y1+0.55*r.y2)}h${r_width}`); break;
            }
         }

         positionGNode(subpos, 0, 0, true);

         shiftX(r.width);

         continue;
      }

      if (found.name == '#bf{' || found.name == '#it{') {
         let sublabel = extractSubLabel();
         if (sublabel === -1) return false;

         let subpos = createSubPos();

         if (found.name == '#bf{')
            subpos.bold = !subpos.bold;
         else
            subpos.italic = !subpos.italic;

         parseLatex(currG(), arg, sublabel, subpos);

         positionGNode(subpos, curr.x, curr.y);

         shiftX(subpos.rect.width);

         continue;
      }

      let foundarg = 0;

      if (found.arg) {
         let pos = label.indexOf(']{');
         if (pos < 0) { console.log('missing argument for ', found.name); return false; }
         foundarg = label.slice(0, pos);
         if (found.arg == 'int') {
            foundarg = parseInt(foundarg);
            if (!Number.isInteger(foundarg)) { console.log('wrong int argument', label.slice(0, pos)); return false; }
         } else if (found.arg == 'float') {
            foundarg = parseFloat(foundarg);
            if (!Number.isFinite(foundarg)) { console.log('wrong float argument', label.slice(0, pos)); return false; }
         }
         label = label.slice(pos + 2);
      }

      if ((found.name == '#kern[') || (found.name == '#lower[')) {
         let sublabel = extractSubLabel();
         if (sublabel === -1) return false;

         let subpos = createSubPos();

         parseLatex(currG(), arg, sublabel, subpos);

         let shiftx = 0, shifty = 0;
         if (found.name == 'kern[') shiftx = foundarg; else shifty = foundarg;

         positionGNode(subpos, curr.x + shiftx * subpos.rect.width, curr.y + shifty * subpos.rect.height);

         shiftX(subpos.rect.width * (shiftx > 0 ? 1 + foundarg : 1));

         continue;
      }

      if ((found.name == '#color[') || (found.name == '#scale[') || (found.name == '#font[')) {

         let sublabel = extractSubLabel();
         if (sublabel === -1) return false;

         let subpos = createSubPos();

         if (found.name == '#color[')
            subpos.color = curr.painter.getColor(foundarg);
         else if (found.name == '#font[') {
            subpos.font = new FontHandler(foundarg);
            subpos.ufont = true; // mark that custom font is applied
         } else
            subpos.fsize *= foundarg;

         parseLatex(currG(), arg, sublabel, subpos);

         positionGNode(subpos, curr.x, curr.y);

         shiftX(subpos.rect.width);

         continue;
      }

     if (found.sqrt) {
         let sublabel = extractSubLabel();
         if (sublabel === -1) return false;

         let gg = createGG(), subpos0, subpos = createSubPos();

         if (found.arg) {
            subpos0 = createSubPos(0.7);
            parseLatex(gg, arg, foundarg.toString(), subpos0);
         }

         // placeholder for the sqrt sign
         let path = createPath(gg);

         parseLatex(gg, arg, sublabel, subpos);

         let r = subpos.rect,
             h = Math.round(r.height),
             h1 = Math.round(r.height*0.1),
             w = Math.round(r.width), midy = Math.round((r.y1 + r.y2)/2),
             f2 = Math.round(curr.fsize*0.2), r_y2 = Math.round(r.y2);

         if (subpos0)
            positionGNode(subpos0, 0, midy - subpos0.fsize*0.3, true);

         path.attr('d', `M0,${midy}h${h1}l${h1},${r_y2-midy-f2}l${h1},${-h+f2}h${Math.round(h*0.2+w)}v${h1}`);

         positionGNode(subpos, h*0.4, 0, true);

         extendPosition(curr.x, curr.y + r.y1-curr.fsize*0.1, curr.x + w + h*0.6, curr.y + r.y2);

         shiftX(w + h*0.6);

         continue;
     }

   }

   return true;
}

/** @ummary translate TLatex and draw inside provided g element
  * @desc use <text> together with normal <path> elements
  * @private */
function produceLatex(painter, node, arg) {

   let pos = { lvl: 0, g: node, x: 0, y: 0, dx: 0, dy: -0.1, fsize: arg.font_size, font: arg.font, parent: null, painter };

   return parseLatex(node, arg, arg.text, pos);
}

let _mj_loading;

/** @summary Load MathJax functionality,
  * @desc one need not only to load script but wait for initialization
  * @private */
async function loadMathjax() {
   let loading = (_mj_loading !== undefined);

   if (!loading && (typeof globalThis.MathJax != 'undefined'))
      return globalThis.MathJax;

   if (!loading) _mj_loading = [];

   let promise = new Promise(resolve => { _mj_loading ? _mj_loading.push(resolve) : resolve(globalThis.MathJax); });

   if (loading) return promise;

   let svg_config = {
       scale: 1,                      // global scaling factor for all expressions
       minScale: .5,                  // smallest scaling factor to use
       mtextInheritFont: false,       // true to make mtext elements use surrounding font
       merrorInheritFont: true,       // true to make merror text use surrounding font
       mathmlSpacing: false,          // true for MathML spacing rules, false for TeX rules
       skipAttributes: {},            // RFDa and other attributes NOT to copy to the output
       exFactor: .5,                  // default size of ex in em units
       displayAlign: 'center',        // default for indentalign when set to 'auto'
       displayIndent: '0',            // default for indentshift when set to 'auto'
       fontCache: 'local',            // or 'global' or 'none'
       localID: null,                 // ID to use for local font cache (for single equation processing)
       internalSpeechTitles: true,    // insert <title> tags with speech content
       titleID: 0                     // initial id number to use for aria-labeledby titles
   };

   if (!isNodeJs()) {
      window.MathJax = {
         options: {
            enableMenu: false
         },
         loader: {
            load: ['[tex]/color', '[tex]/upgreek', '[tex]/mathtools', '[tex]/physics']
         },
         tex: {
            packages: {'[+]': ['color', 'upgreek', 'mathtools', 'physics']}
         },
         svg: svg_config,
         startup: {
            ready() {
               MathJax.startup.defaultReady();
               let arr = _mj_loading;
               _mj_loading = undefined;
               arr.forEach(func => func(globalThis.MathJax));
            }
         }
      };

      return loadScript(exports.source_dir + '../mathjax/3.2.0/es5/tex-svg.js')
               .catch(() => loadScript('https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-svg.js'))
               .then(() => promise);
   }

   let myJSDOM;

   return _loadJSDOM().then(handle => { myJSDOM = handle.JSDOM; return Promise.resolve().then(function () { return _rollup_plugin_ignore_empty_module_placeholder$1; }); }).then(mj => {

      // return Promise with mathjax loading
      mj.init({
         loader: {
            load: ['input/tex', 'output/svg', '[tex]/color', '[tex]/upgreek', '[tex]/mathtools', '[tex]/physics']
          },
          tex: {
             packages: {'[+]': ['color', 'upgreek', 'mathtools', 'physics']}
          },
          svg: svg_config,
          config: {
             JSDOM: myJSDOM
          },
          startup: {
             typeset: false,
             ready() {
                MathJax.startup.registerConstructor('jsdomAdaptor', () => {
                   return new MathJax._.adaptors.HTMLAdaptor.HTMLAdaptor(new MathJax.config.config.JSDOM().window);
                });
                MathJax.startup.useAdaptor('jsdomAdaptor', true);
                MathJax.startup.defaultReady();
                let arr = _mj_loading;
                _mj_loading = undefined;
                arr.forEach(func => func(MathJax));
             }
          }
      });

      return promise;
   });

}

const math_symbols_map = {
      '#LT': '\\langle',
      '#GT': '\\rangle',
      '#club': '\\clubsuit',
      '#spade': '\\spadesuit',
      '#heart': '\\heartsuit',
      '#diamond': '\\diamondsuit',
      '#voidn': '\\wp',
      '#voidb': 'f',
      '#copyright': '(c)',
      '#ocopyright': '(c)',
      '#trademark': 'TM',
      '#void3': 'TM',
      '#oright': 'R',
      '#void1': 'R',
      '#3dots': '\\ldots',
      '#lbar': '\\mid',
      '#void8': '\\mid',
      '#divide': '\\div',
      '#Jgothic': '\\Im',
      '#Rgothic': '\\Re',
      '#doublequote': '"',
      '#plus': '+',
      '#minus': '-',
      '#\/': '/',
      '#upoint': '.',
      '#aa': '\\mathring{a}',
      '#AA': '\\mathring{A}',
      '#omicron': 'o',
      '#Alpha': 'A',
      '#Beta': 'B',
      '#Epsilon': 'E',
      '#Zeta': 'Z',
      '#Eta': 'H',
      '#Iota': 'I',
      '#Kappa': 'K',
      '#Mu': 'M',
      '#Nu': 'N',
      '#Omicron': 'O',
      '#Rho': 'P',
      '#Tau': 'T',
      '#Chi': 'X',
      '#varomega': '\\varpi',
      '#corner': '?',
      '#ltbar': '?',
      '#bottombar': '?',
      '#notsubset': '?',
      '#arcbottom': '?',
      '#cbar': '?',
      '#arctop': '?',
      '#topbar': '?',
      '#arcbar': '?',
      '#downleftarrow': '?',
      '#splitline': '\\genfrac{}{}{0pt}{}',
      '#it': '\\textit',
      '#bf': '\\textbf',
      '#frac': '\\frac',
      '#left{': '\\lbrace',
      '#right}': '\\rbrace',
      '#left\\[': '\\lbrack',
      '#right\\]': '\\rbrack',
      '#\\[\\]{': '\\lbrack',
      ' } ': '\\rbrack',
      '#\\[': '\\lbrack',
      '#\\]': '\\rbrack',
      '#{': '\\lbrace',
      '#}': '\\rbrace',
      ' ': '\\;'
 };

 const mathjax_remap = {
   'upDelta': 'Updelta',
   'upGamma': 'Upgamma',
   'upLambda': 'Uplambda',
   'upOmega': 'Upomega',
   'upPhi': 'Upphi',
   'upPi': 'Uppi',
   'upPsi': 'Uppsi',
   'upSigma': 'Upsigma',
   'upTheta': 'Uptheta',
   'upUpsilon': 'Upupsilon',
   'upXi': 'Upxi',
   'notcong': 'ncong',
   'notgeq': 'ngeq',
   'notgr': 'ngtr',
   'notless': 'nless',
   'notleq': 'nleq',
   'notsucc': 'nsucc',
   'notprec': 'nprec',
   'notsubseteq': 'nsubseteq',
   'notsupseteq': 'nsupseteq',
   'openclubsuit': 'clubsuit',
   'openspadesuit': 'spadesuit',
   'dasharrow': 'dashrightarrow',
   'comp': 'circ',
   'iiintop': 'iiint',
   'iintop': 'iint',
   'ointop': 'oint'
 };

 const mathjax_unicode = {
   'Digamma': 0x3DC,
   'upDigamma': 0x3DC,
   'digamma': 0x3DD,
   'updigamma': 0x3DD,
   'Koppa': 0x3DE,
   'koppa': 0x3DF,
   'upkoppa': 0x3DF,
   'upKoppa': 0x3DE,
   'VarKoppa': 0x3D8,
   'upVarKoppa': 0x3D8,
   'varkoppa': 0x3D9,
   'upvarkoppa': 0x3D9,
   'varkappa': 0x3BA, // not found archaic kappa - use normal
   'upvarkappa': 0x3BA,
   'varbeta': 0x3D0, // not found archaic beta - use normal
   'upvarbeta': 0x3D0,
   'Sampi': 0x3E0,
   'upSampi': 0x3E0,
   'sampi': 0x3E1,
   'upsampi': 0x3E1,
   'Stigma': 0x3DA,
   'upStigma': 0x3DA,
   'stigma': 0x3DB,
   'upstigma': 0x3DB,
   'San': 0x3FA,
   'upSan': 0x3FA,
   'san': 0x3FB,
   'upsan': 0x3FB,
   'Sho': 0x3F7,
   'upSho': 0x3F7,
   'sho': 0x3F8,
   'upsho': 0x3F8,
   'P': 0xB6,
   'aa': 0xB0,
   'bulletdashcirc': 0x22B7,
   'circdashbullet': 0x22B6,
   'downuparrows': 0x21F5,
   'updownarrows': 0x21C5,
   'dashdownarrow': 0x21E3,
   'dashuparrow': 0x21E1,
   'complement': 0x2201,
   'dbar': 0x18C,
   'ddddot': 0x22EF,
   'dddot': 0x22EF,
   'ddots': 0x22F1,
   'defineequal': 0x225D,
   'defineeq': 0x225D,
   'downdownharpoons': 0x2965,
   'downupharpoons': 0x296F,
   'updownharpoons': 0x296E,
   'upupharpoons': 0x2963,
   'hateq': 0x2259,
   'ldbrack': 0x27E6,
   'rdbrack': 0x27E7,
   'leadsfrom': 0x219C,
   'leftsquigarrow': 0x21DC,
   'lightning': 0x2607,
   'napprox': 0x2249,
   'nasymp': 0x226D,
   'nequiv': 0x2262,
   'nsimeq': 0x2244,
   'nsubseteq': 0x2288,
   'nsubset': 0x2284,
   'notapprox': 0x2249,
   'notasymp': 0x226D,
   'notequiv': 0x2262,
   'notni': 0x220C,
   'notsimeq': 0x2244,
   'notsubseteq': 0x2288,
   'notsubset': 0x2284,
   'notsupseteq': 0x2289,
   'notsupset': 0x2285,
   'nsupset': 0x2285,
   'setdif': 0x2216,
   'simarrow': 0x2972,
   't': 0x2040,
   'u': 0x2C7,
   'v': 0x2C7,
   'undercurvearrowright': 0x293B,
   'updbar': 0x18C,
   'wwbar': 0x2015,
   'awointop': 0x2232,
   'awoint': 0x2233,
   'barintop': 0x2A1C,
   'barint': 0x2A1B,
   'cwintop': 0x2231, // no opposite direction, use same
   'cwint': 0x2231,
   'cwointop': 0x2233,
   'cwoint': 0x2232,
   'oiiintop': 0x2230,
   'oiiint': 0x2230,
   'oiintop': 0x222F,
   'oiint': 0x222F,
   'slashintop': 0x2A0F,
   'slashint': 0x2A0F
 };

const mathjax_asis = ['"', "'", '`', '=', '~'];

/** @summary Function translates ROOT TLatex into MathJax format
  * @private */
function translateMath(str, kind, color, painter) {

   if (kind != 2) {
      for (let x in math_symbols_map)
         str = str.replace(new RegExp(x, 'g'), math_symbols_map[x]);

      for (let x in symbols_map)
         if (x.length > 2)
            str = str.replace(new RegExp(x, 'g'), '\\' + x.slice(1));

      // replace all #color[]{} occurances
      let clean = '', first = true;
      while (str) {
         let p = str.indexOf('#color[');
         if ((p < 0) && first) { clean = str; break; }
         first = false;
         if (p != 0) {
            let norm = (p < 0) ? str : str.slice(0, p);
            clean += norm;
            if (p < 0) break;
         }

         str = str.slice(p + 7);
         p = str.indexOf(']{');
         if (p <= 0) break;
         let colindx = parseInt(str.slice(0, p));
         if (!Number.isInteger(colindx)) break;
         let col = painter.getColor(colindx), cnt = 1;
         str = str.slice(p + 2);
         p = -1;
         while (cnt && (++p < str.length)) {
            if (str[p] == '{') cnt++; else if (str[p] == '}') cnt--;
         }
         if (cnt != 0) break;

         let part = str.slice(0, p);
         str = str.slice(p + 1);
         if (part)
            clean += `\\color{${col}}{${part}}`;
      }

      str = clean;
   } else {
      if (str == '\\^') str = '\\unicode{0x5E}';
      if (str == '\\vec') str = '\\unicode{0x2192}';
      str = str.replace(/\\\./g, '\\unicode{0x2E}').replace(/\\\^/g, '\\hat');
      for (let x in mathjax_unicode)
         str = str.replace(new RegExp(`\\\\\\b${x}\\b`, 'g'), `\\unicode{0x${mathjax_unicode[x].toString(16)}}`);
      for(let x in mathjax_asis)
         str = str.replace(new RegExp(`(\\\\${mathjax_asis[x]})`, 'g'), `\\unicode{0x${mathjax_asis[x].charCodeAt(0).toString(16)}}`);
      for (let x in mathjax_remap)
         str = str.replace(new RegExp(`\\\\\\b${x}\\b`, 'g'), `\\${mathjax_remap[x]}`);
   }

   if (!isStr(color)) return str;

   // MathJax SVG converter use colors in normal form
   //if (color.indexOf('rgb(') >= 0)
   //   color = color.replace(/rgb/g, '[RGB]')
   //                .replace(/\(/g, '{')
   //                .replace(/\)/g, '}');
   return `\\color{${color}}{${str}}`;
}

/** @summary Workaround to fix size attributes in MathJax SVG
  * @private */
function repairMathJaxSvgSize(painter, mj_node, svg, arg) {
   let transform = value => {
      if (!value || !isStr(value) || (value.length < 3)) return null;
      let p = value.indexOf('ex');
      if ((p < 0) || (p !== value.length - 2)) return null;
      value = parseFloat(value.slice(0, p));
      return Number.isFinite(value) ? value * arg.font.size * 0.5 : null;
   };

   let width = transform(svg.getAttribute('width')),
       height = transform(svg.getAttribute('height')),
       valign = svg.getAttribute('style');

   if (valign && (valign.length > 18) && valign.indexOf('vertical-align:') == 0) {
      let p = valign.indexOf('ex;');
      valign = ((p > 0) && (p == valign.length - 3)) ? transform(valign.slice(16, valign.length - 1)) : null;
   } else {
      valign = null;
   }

   width = (!width || (width <= 0.5)) ? 1 : Math.round(width);
   height = (!height || (height <= 0.5)) ? 1 : Math.round(height);

   svg.setAttribute('width', width);
   svg.setAttribute('height', height);
   svg.removeAttribute('style');

   if (!isNodeJs()) {
      let box = getElementRect(mj_node, 'bbox');
      width = 1.05 * box.width; height = 1.05 * box.height;
   }

   arg.valign = valign;

   if (arg.scale)
      painter.scaleTextDrawing(Math.max(width / arg.width, height / arg.height), arg.draw_g);
}

/** @summary Apply attributes to mathjax drawing
  * @private */
function applyAttributesToMathJax(painter, mj_node, svg, arg, font_size, svg_factor) {
   let mw = parseInt(svg.attr('width')),
       mh = parseInt(svg.attr('height'));

   if (Number.isInteger(mh) && Number.isInteger(mw)) {
      if (svg_factor > 0.) {
         mw = mw / svg_factor;
         mh = mh / svg_factor;
         svg.attr('width', Math.round(mw)).attr('height', Math.round(mh));
      }
   } else {
      let box = getElementRect(mj_node, 'bbox'); // sizes before rotation
      mw = box.width || mw || 100;
      mh = box.height || mh || 10;
   }

   if ((svg_factor > 0.) && arg.valign) arg.valign = arg.valign / svg_factor;

   if (arg.valign === null) arg.valign = (font_size - mh) / 2;

   let sign = { x: 1, y: 1 }, nx = 'x', ny = 'y';
   if (arg.rotate == 180) {
      sign.x = sign.y = -1;
   } else if ((arg.rotate == 270) || (arg.rotate == 90)) {
      sign.x = (arg.rotate == 270) ? -1 : 1;
      sign.y = -sign.x;
      nx = 'y'; ny = 'x'; // replace names to which align applied
   }

   if (arg.align[0] == 'middle')
      arg[nx] += sign.x * (arg.width - mw) / 2;
   else if (arg.align[0] == 'end')
      arg[nx] += sign.x * (arg.width - mw);

   if (arg.align[1] == 'middle')
      arg[ny] += sign.y * (arg.height - mh) / 2;
   else if (arg.align[1] == 'bottom')
      arg[ny] += sign.y * (arg.height - mh);
   else if (arg.align[1] == 'bottom-base')
      arg[ny] += sign.y * (arg.height - mh - arg.valign);

   let trans = `translate(${arg.x},${arg.y})`;
   if (arg.rotate) trans += ` rotate(${arg.rotate})`;

   mj_node.attr('transform', trans).attr('visibility', null);
}

/** @summary Produce text with MathJax
  * @private */
async function produceMathjax(painter, mj_node, arg) {
   let mtext = translateMath(arg.text, arg.latex, arg.color, painter),
       options = { em: arg.font.size, ex: arg.font.size/2, family: arg.font.name, scale: 1, containerWidth: -1, lineWidth: 100000 };

   return loadMathjax()
          .then(() => MathJax.tex2svgPromise(mtext, options))
          .then(elem => {
              // when adding element to new node, it will be removed from original parent
              let svg = elem.querySelector('svg');

              mj_node.append(() => svg);

              repairMathJaxSvgSize(painter, mj_node, svg, arg);

              arg.applyAttributesToMathJax = applyAttributesToMathJax;
              return true;
           });
}

/** @summary Just typeset HTML node with MathJax
  * @private */
async function typesetMathjax(node) {
   return loadMathjax().then(() => MathJax.typesetPromise(node ? [node] : undefined));
}

/** @summary Covert value between 0 and 1 into hex, used for colors coding
  * @private */
function toHex(num,scale) {
   let s = Math.round(num*(scale || 255)).toString(16);
   return s.length == 1 ? '0'+s : s;
}

/** @summary list of global root colors
  * @private */
let gbl_colors_list = [];

/** @summary Generates all root colors, used also in jstests to reset colors
  * @private */
function createRootColors() {
   let colorMap = ['white', 'black', 'red', 'green', 'blue', 'yellow', 'magenta', 'cyan', '#59d454', '#5954d9', 'white'];
   colorMap[110] = 'white';

   const moreCol = [
      { n: 11, s: 'c1b7ad4d4d4d6666668080809a9a9ab3b3b3cdcdcde6e6e6f3f3f3cdc8accdc8acc3c0a9bbb6a4b3a697b8a49cae9a8d9c8f83886657b1cfc885c3a48aa9a1839f8daebdc87b8f9a768a926983976e7b857d9ad280809caca6c0d4cf88dfbb88bd9f83c89a7dc08378cf5f61ac8f94a6787b946971d45a549300ff7b00ff6300ff4b00ff3300ff1b00ff0300ff0014ff002cff0044ff005cff0074ff008cff00a4ff00bcff00d4ff00ecff00fffd00ffe500ffcd00ffb500ff9d00ff8500ff6d00ff5500ff3d00ff2600ff0e0aff0022ff003aff0052ff006aff0082ff009aff00b1ff00c9ff00e1ff00f9ff00ffef00ffd700ffbf00ffa700ff8f00ff7700ff6000ff4800ff3000ff1800ff0000' },
      { n: 201, s: '5c5c5c7b7b7bb8b8b8d7d7d78a0f0fb81414ec4848f176760f8a0f14b81448ec4876f1760f0f8a1414b84848ec7676f18a8a0fb8b814ecec48f1f1768a0f8ab814b8ec48ecf176f10f8a8a14b8b848ecec76f1f1' },
      { n: 390, s: 'ffffcdffff9acdcd9affff66cdcd669a9a66ffff33cdcd339a9a33666633ffff00cdcd009a9a00666600333300' },
      { n: 406, s: 'cdffcd9aff9a9acd9a66ff6666cd66669a6633ff3333cd33339a3333663300ff0000cd00009a00006600003300' },
      { n: 422, s: 'cdffff9affff9acdcd66ffff66cdcd669a9a33ffff33cdcd339a9a33666600ffff00cdcd009a9a006666003333' },
      { n: 590, s: 'cdcdff9a9aff9a9acd6666ff6666cd66669a3333ff3333cd33339a3333660000ff0000cd00009a000066000033' },
      { n: 606, s: 'ffcdffff9affcd9acdff66ffcd66cd9a669aff33ffcd33cd9a339a663366ff00ffcd00cd9a009a660066330033' },
      { n: 622, s: 'ffcdcdff9a9acd9a9aff6666cd66669a6666ff3333cd33339a3333663333ff0000cd00009a0000660000330000' },
      { n: 791, s: 'ffcd9acd9a669a66339a6600cd9a33ffcd66ff9a00ffcd33cd9a00ffcd00ff9a33cd66006633009a3300cd6633ff9a66ff6600ff6633cd3300ff33009aff3366cd00336600339a0066cd339aff6666ff0066ff3333cd0033ff00cdff9a9acd66669a33669a009acd33cdff669aff00cdff339acd00cdff009affcd66cd9a339a66009a6633cd9a66ffcd00ff6633ffcd00cd9a00ffcd33ff9a00cd66006633009a3333cd6666ff9a00ff9a33ff6600cd3300ff339acdff669acd33669a00339a3366cd669aff0066ff3366ff0033cd0033ff339aff0066cd00336600669a339acd66cdff009aff33cdff009acd00cdffcd9aff9a66cd66339a66009a9a33cdcd66ff9a00ffcd33ff9a00cdcd00ff9a33ff6600cd33006633009a6633cd9a66ff6600ff6633ff3300cd3300ffff339acd00666600339a0033cd3366ff669aff0066ff3366cd0033ff0033ff9acdcd669a9a33669a0066cd339aff66cdff009acd009aff33cdff009a' },
      { n: 920, s: 'cdcdcd9a9a9a666666333333' }];

   moreCol.forEach(entry => {
      let s = entry.s;
      for (let n = 0; n < s.length; n += 6) {
         let num = entry.n + n / 6;
         colorMap[num] = '#' + s.slice(n,n+6);
      }
   });

   gbl_colors_list = colorMap;
}

/** @summary Get list of colors
  * @private */
function getRootColors() {
   return gbl_colors_list;
}

/** @summary Produces rgb code for TColor object
  * @private */
function getRGBfromTColor(col) {
   if (col?._typename != clTColor) return null;

   let rgb = '#' + toHex(col.fRed) + toHex(col.fGreen) + toHex(col.fBlue);
   if ((col.fAlpha !== undefined) && (col.fAlpha !== 1.))
      rgb += toHex(col.fAlpha);

   switch (rgb) {
      case '#ffffff': return 'white';
      case '#000000': return 'black';
      case '#ff0000': return 'red';
      case '#00ff00': return 'green';
      case '#0000ff': return 'blue';
      case '#ffff00': return 'yellow';
      case '#ff00ff': return 'magenta';
      case '#00ffff': return 'cyan';
   }
   return rgb;
}


/** @summary Add new colors from object array
  * @private */
function extendRootColors(jsarr, objarr) {
   if (!jsarr) {
      jsarr = [];
      for (let n = 0; n < gbl_colors_list.length; ++n)
         jsarr[n] = gbl_colors_list[n];
   }

   if (!objarr) return jsarr;

   let rgb_array = objarr;
   if (objarr._typename && objarr.arr) {
      rgb_array = [];
      for (let n = 0; n < objarr.arr.length; ++n) {
         let col = objarr.arr[n];
         if (col?._typename != clTColor) continue;

         if ((col.fNumber >= 0) && (col.fNumber <= 10000))
            rgb_array[col.fNumber] = getRGBfromTColor(col);
      }
   }

   for (let n = 0; n < rgb_array.length; ++n)
      if (rgb_array[n] && (jsarr[n] != rgb_array[n]))
         jsarr[n] = rgb_array[n];

   return jsarr;
}

/** @ummary Set global list of colors.
  * @desc Either TObjArray of TColor instances or just plain array with rgb() code.
  * List of colors typically stored together with TCanvas primitives
  * @private */
function adoptRootColors(objarr) {
   extendRootColors(gbl_colors_list, objarr);
}

/** @summary Return ROOT color by index
  * @desc Color numbering corresponds typical ROOT colors
  * @return {String} with RGB color code or existing color name like 'cyan'
  * @private */
function getColor(indx) {
   return gbl_colors_list[indx];
}

/** @summary Search for specified color in the list of colors
  * @return Color index or -1 if fails
  * @private */
function findColor(name) {
   if (!name) return -1;
   for (let indx = 0; indx < gbl_colors_list.length; ++indx)
      if (gbl_colors_list[indx] == name)
         return indx;
   return -1;
}

/** @summary Add new color
  * @param {string} rgb - color name or just string with rgb value
  * @param {array} [lst] - optional colors list, to which add colors
  * @return {number} index of new color
  * @private */
function addColor(rgb, lst) {
   if (!lst) lst = gbl_colors_list;
   let indx = lst.indexOf(rgb);
   if (indx >= 0) return indx;
   lst.push(rgb);
   return lst.length-1;
}

/**
 * @summary Color palette handle
 *
 * @private
 */

class ColorPalette {

   /** @summary constructor */
   constructor(arr) {
      this.palette = arr;
   }

   /** @summary Returns color index which correspond to contour index of provided length */
   calcColorIndex(i, len) {
      let plen = this.palette.length, theColor = Math.floor((i + 0.99) * plen / (len - 1));
      return (theColor > plen - 1) ? plen - 1 : theColor;
    }

   /** @summary Returns color with provided index */
   getColor(indx) { return this.palette[indx]; }

   /** @summary Returns number of colors in the palette */
   getLength() { return this.palette.length; }

   /** @summary Calculate color for given i and len */
   calcColor(i, len) { return this.getColor(this.calcColorIndex(i, len)); }

} // class ColorPalette

createRootColors();

const root_markers = [
      0, 1, 2, 3, 4,           //  0..4
      5, 106, 107, 104, 1,     //  5..9
      1, 1, 1, 1, 1,           // 10..14
      1, 1, 1, 1, 1,           // 15..19
      104, 125, 126, 132, 4,   // 20..24
      25, 26, 27, 28, 130,     // 25..29
      30, 3, 32, 127, 128,     // 30..34
      35, 36, 37, 38, 137,     // 35..39
      40, 140, 42, 142, 44,    // 40..44
      144, 46, 146, 148, 149]; // 45..49


/**
  * @summary Handle for marker attributes
  * @private
  */

class TAttMarkerHandler {

   /** @summary constructor
     * @param {object} args - attributes, see {@link TAttMarkerHandler#setArgs} for details */
   constructor(args) {
      this.x0 = this.y0 = 0;
      this.color = 'black';
      this.style = 1;
      this.size = 8;
      this.scale = 1;
      this.stroke = true;
      this.fill = true;
      this.marker = '';
      this.ndig = 0;
      this.used = true;
      this.changed = false;
      this.func = this.apply.bind(this);
      this.setArgs(args);
      this.changed = false;
   }

   /** @summary Set marker attributes.
     * @param {object} args - arguments can be
     * @param {object} args.attr - instance of TAttrMarker (or derived class) or
     * @param {string} args.color - color in HTML form like grb(1,4,5) or 'green'
     * @param {number} args.style - marker style
     * @param {number} args.size - marker size
     * @param {number} [args.refsize] - when specified and marker size < 1, marker size will be calculated relative to that size */
   setArgs(args) {
      if (isObject(args) && (typeof args.fMarkerStyle == 'number')) args = { attr: args };

      if (args.attr) {
         if (args.color === undefined)
            args.color = args.painter ? args.painter.getColor(args.attr.fMarkerColor) : getColor(args.attr.fMarkerColor);
         if (!args.style || (args.style < 0)) args.style = args.attr.fMarkerStyle;
         if (!args.size) args.size = args.attr.fMarkerSize;
      }

      this.color = args.color;
      this.style = args.style;
      this.size = args.size;
      this.refsize = args.refsize;

      this._configure();
   }

   /** @summary Reset position, used for optimization of drawing of multiple markers
    * @private */
   resetPos() { this.lastx = this.lasty = null; }

   /** @summary Create marker path for given position.
     * @desc When drawing many elementary points, created path may depend from previously produced markers.
     * @param {number} x - first coordinate
     * @param {number} y - second coordinate
     * @return {string} path string */
   create(x, y) {
      if (!this.optimized)
         return `M${(x + this.x0).toFixed(this.ndig)},${(y + this.y0).toFixed(this.ndig)}${this.marker}`;

      // use optimized handling with relative position
      let xx = Math.round(x), yy = Math.round(y), mv = `M${xx},${yy}`;
      if (this.lastx !== null) {
         if ((xx == this.lastx) && (yy == this.lasty)) {
            mv = ''; // pathological case, but let exclude it
         } else {
            let m2 = `m${xx-this.lastx},${yy - this.lasty}`;
            if (m2.length < mv.length) mv = m2;
         }
      }
      this.lastx = xx + 1; this.lasty = yy;
      return mv + 'h1';
   }

   /** @summary Returns full size of marker */
   getFullSize() { return this.scale * this.size; }

   /** @summary Returns approximate length of produced marker string */
   getMarkerLength() { return this.marker ? this.marker.length : 10; }

   /** @summary Change marker attributes.
    *  @param {string} color - marker color
    *  @param {number} style - marker style
    *  @param {number} size - marker size */
   change(color, style, size) {
      this.changed = true;

      if (color !== undefined) this.color = color;
      if ((style !== undefined) && (style >= 0)) this.style = style;
      if (size !== undefined) this.size = size;

      this._configure();
   }

   /** @summary Prepare object to create marker
     * @private */
    _configure() {

      this.x0 = this.y0 = 0;

      if ((this.style === 1) || (this.style === 777)) {
         this.fill = false;
         this.marker = 'h1';
         this.size = 1;
         this.optimized = true;
         this.resetPos();
         return true;
      }

      this.optimized = false;

      let marker_kind = root_markers[this.style] ?? 104,
          shape = marker_kind % 100;

      this.fill = (marker_kind >= 100);

      this.scale = this.refsize || 8; // v7 defines refsize as 1 or pad height

      let size = this.getFullSize();

      this.ndig = (size > 7) ? 0 : ((size > 2) ? 1 : 2);
      if (shape == 30) this.ndig++; // increase precision for star
      let s1 = size.toFixed(this.ndig),
          s2 = (size/2).toFixed(this.ndig),
          s3 = (size/3).toFixed(this.ndig),
          s4 = (size/4).toFixed(this.ndig),
          s8 = (size/8).toFixed(this.ndig),
          s38 = (size*3/8).toFixed(this.ndig);

      switch (shape) {
         case 1: // dot
            this.marker = 'h1';
            break;
         case 2: // plus
            this.y0 = -size / 2;
            this.marker = `v${s1}m-${s2},-${s2}h${s1}`;
            break;
         case 3: // asterisk
            this.x0 = this.y0 = -size / 2;
            this.marker = `l${s1},${s1}m0,-${s1}l-${s1},${s1}m0,-${s2}h${s1}m-${s2},-${s2}v${s1}`;
            break;
         case 4: // circle
            this.x0 = -parseFloat(s2);
            s1 = (parseFloat(s2) * 2).toFixed(this.ndig);
            this.marker = `a${s2},${s2},0,1,0,${s1},0a${s2},${s2},0,1,0,-${s1},0z`;
            break;
         case 5: // mult
            this.x0 = this.y0 = -size / 2;
            this.marker = `l${s1},${s1}m0,-${s1}l-${s1},${s1}`;
            break;
         case 6: // small dot
            this.x0 = -1;
            this.marker = 'a1,1,0,1,0,2,0a1,1,0,1,0,-2,0z';
            break;
         case 7: // medium dot
            this.x0 = -1.5;
            this.marker = 'a1.5,1.5,0,1,0,3,0a1.5,1.5,0,1,0,-3,0z';
            break;
         case 25: // square
            this.x0 = this.y0 = -size / 2;
            this.marker = `v${s1}h${s1}v-${s1}z`;
            break;
         case 26: // triangle-up
            this.y0 = -size / 2;
            this.marker = `l-${s2},${s1}h${s1}z`;
            break;
         case 27: // diamand
            this.y0 = -size / 2;
            this.marker = `l${s3},${s2}l-${s3},${s2}l-${s3},-${s2}z`;
            break;
         case 28: // cross
            this.x0 = this.y0 = size / 6;
            this.marker = `h${s3}v-${s3}h-${s3}v-${s3}h-${s3}v${s3}h-${s3}v${s3}h${s3}v${s3}h${s3}z`;
            break;
         case 30: // star
            this.y0 = -size / 2;
            let s56 = (size*5/6).toFixed(this.ndig), s58 = (size*5/8).toFixed(this.ndig);
            this.marker = `l${s3},${s1}l-${s56},-${s58}h${s1}l-${s56},${s58}z`;
            break;
         case 32: // triangle-down
            this.y0 = size / 2;
            this.marker = `l-${s2},-${s1}h${s1}z`;
            break;
         case 35:
            this.x0 = -size / 2;
            this.marker = `l${s2},${s2}l${s2},-${s2}l-${s2},-${s2}zh${s1}m-${s2},-${s2}v${s1}`;
            break;
         case 36:
            this.x0 = this.y0 = -size / 2;
            this.marker = `h${s1}v${s1}h-${s1}zl${s1},${s1}m0,-${s1}l-${s1},${s1}`;
            break;
         case 37:
            this.x0 = -size/2;
            this.marker = `h${s1}l-${s4},-${s2}l-${s2},${s1}h${s2}l-${s2},-${s1}z`;
            break;
         case 38:
            this.x0 = -size/4; this.y0 = -size/2;
            this.marker = `h${s2}l${s4},${s4}v${s2}l-${s4},${s4}h-${s2}l-${s4},-${s4}v-${s2}zm${s4},0v${s1}m-${s2},-${s2}h${s1}`;
            break;
         case 40:
            this.x0 = -size/4; this.y0 = -size/2;
            this.marker = `l${s2},${s1}l${s4},-${s4}l-${s1},-${s2}zm${s2},0l-${s2},${s1}l-${s4},-${s4}l${s1},-${s2}z`;
            break;
         case 42:
            this.y0 = -size/2;
            this.marker = `l${s8},${s38}l${s38},${s8}l-${s38},${s8}l-${s8},${s38}l-${s8},-${s38}l-${s38},-${s8}l${s38},-${s8}z`;
            break;
         case 44:
            this.x0 = -size/4; this.y0 = -size/2;
            this.marker = `h${s2}l-${s8},${s38}l${s38},-${s8}v${s2}l-${s38},-${s8}l${s8},${s38}h-${s2}l${s8},-${s38}l-${s38},${s8}v-${s2}l${s38},${s8}z`;
            break;
         case 46:
            this.x0 = -size/4; this.y0 = -size/2;
            this.marker = `l${s4},${s4}l${s4},-${s4}l${s4},${s4}l-${s4},${s4}l${s4},${s4}l-${s4},${s4}l-${s4},-${s4}l-${s4},${s4}l-${s4},-${s4}l${s4},-${s4}l-${s4},-${s4}z`;
            break;
         case 48:
            this.x0 = -size/4; this.y0 = -size/2;
            this.marker = `l${s4},${s4}l-${s4},${s4}l-${s4},-${s4}zm${s2},0l${s4},${s4}l-${s4},${s4}l-${s4},-${s4}zm0,${s2}l${s4},${s4}l-${s4},${s4}l-${s4},-${s4}zm-${s2},0l${s4},${s4}l-${s4},${s4}l-${s4},-${s4}z`;
            break;
         case 49:
            this.x0 = -size/6; this.y0 = -size/2;
            this.marker = `h${s3}v${s3}h-${s3}zm${s3},${s3}h${s3}v${s3}h-${s3}zm-${s3},${s3}h${s3}v${s3}h-${s3}zm-${s3},-${s3}h${s3}v${s3}h-${s3}z`;
            break;
         default: // diamand
            this.y0 = -size / 2;
            this.marker = `l${s3},${s2}l-${s3},${s2}l-${s3},-${s2}z`;
            break;
      }

      return true;
   }

   /** @summary get stroke color */
   getStrokeColor() { return this.stroke ? this.color : 'none'; }

   /** @summary get fill color */
   getFillColor() { return this.fill ? this.color : 'none'; }

   /** @summary returns true if marker attributes will produce empty (invisible) output */
   empty() { return (this.color === 'none') || (!this.fill && !this.stroke); }

   /** @summary Apply marker styles to created element */
   apply(selection) {
      selection.style('stroke', this.stroke ? this.color : 'none')
               .style('fill', this.fill ? this.color : 'none');
   }

   /** @summary Method used when color or pattern were changed with OpenUi5 widgets.
     * @private */
   verifyDirectChange(/* painter */) {
      this.change(this.color, parseInt(this.style), parseFloat(this.size));
   }

   /** @summary Create sample with marker in given SVG element
     * @param {selection} svg - SVG element
     * @param {number} width - width of sample SVG
     * @param {number} height - height of sample SVG
     * @private */
   createSample(svg, width, height, plain) {
      if (plain) svg = select(svg);
      this.resetPos();
      svg.append('path')
         .attr('d', this.create(width / 2, height / 2))
         .call(this.func);
   }

} // class TAttMarkerHandler

/**
  * @summary Handle for fill attributes
  * @private
  */

class TAttFillHandler {

   /** @summary constructor
     * @param {object} args - arguments see {@link TAttFillHandler#setArgs} for more info
     * @param {number} [args.kind = 2] - 1 means object drawing where combination fillcolor == 0 and fillstyle == 1001 means no filling,  2 means all other objects where such combination is white-color filling */
   constructor(args) {
      this.color = 'none';
      this.colorindx = 0;
      this.pattern = 0;
      this.used = true;
      this.kind = args.kind || 2;
      this.changed = false;
      this.func = this.apply.bind(this);
      this.setArgs(args);
      this.changed = false; // unset change property that
   }

   /** @summary Set fill style as arguments
     * @param {object} args - different arguments to set fill attributes
     * @param {object} [args.attr] - TAttFill object
     * @param {number} [args.color] - color id
     * @param {number} [args.pattern] - filll pattern id
     * @param {object} [args.svg] - SVG element to store newly created patterns
     * @param {string} [args.color_as_svg] - color in SVG format */
   setArgs(args) {
      if (isObject(args.attr)) {
         if ((args.pattern === undefined) && (args.attr.fFillStyle !== undefined)) args.pattern = args.attr.fFillStyle;
         if ((args.color === undefined) && (args.attr.fFillColor !== undefined)) args.color = args.attr.fFillColor;
      }

      let was_changed = this.changed; // preserve changed state
      this.change(args.color, args.pattern, args.svg, args.color_as_svg, args.painter);
      this.changed = was_changed;
   }

   /** @summary Apply fill style to selection */
   apply(selection) {
      this.used = true;

      selection.style('fill', this.getFillColor());

      if ('opacity' in this)
         selection.style('opacity', this.opacity);

      if ('antialias' in this)
         selection.style('antialias', this.antialias);
   }

   /** @summary Returns fill color (or pattern url) */
   getFillColor() { return this.pattern_url || this.color; }

   /** @summary Returns fill color without pattern url.
     * @desc If empty, alternative color will be provided
     * @param {string} [altern] - alternative color which returned when fill color not exists
     * @private */
   getFillColorAlt(altern) { return this.color && (this.color != 'none') ? this.color : altern; }

   /** @summary Returns true if color not specified or fill style not specified */
   empty() {
      let fill = this.getFillColor();
      return !fill || (fill == 'none');
   }

   /** @summary Returns true if fill attributes has real color */
   hasColor() {
      return this.color && (this.color != 'none');
   }

   /** @summary Set solid fill color as fill pattern
     * @param {string} col - solid color */
   setSolidColor(col) {
      delete this.pattern_url;
      this.color = col;
      this.pattern = 1001;
   }

   /** @summary Set fill color opacity */
   setOpacity(o) {
      this.opacity = o;
   }

   /** @summary Check if solid fill is used, also color can be checked
     * @param {string} [solid_color] - when specified, checks if fill color matches */
   isSolid(solid_color) {
      if (this.pattern !== 1001) return false;
      return !solid_color || (solid_color == this.color);
   }

   /** @summary Method used when color or pattern were changed with OpenUi5 widgets
     * @private */
   verifyDirectChange(painter) {
      if (isStr(this.pattern))
         this.pattern = parseInt(this.pattern);
      if (!Number.isInteger(this.pattern))
         this.pattern = 0;

      this.change(this.color, this.pattern, painter ? painter.getCanvSvg() : null, true, painter);
   }

   /** @summary Method to change fill attributes.
     * @param {number} color - color index
     * @param {number} pattern - pattern index
     * @param {selection} svg - top canvas element for pattern storages
     * @param {string} [color_as_svg] - when color is string, interpret as normal SVG color
     * @param {object} [painter] - when specified, used to extract color by index */
   change(color, pattern, svg, color_as_svg, painter) {
      delete this.pattern_url;
      this.changed = true;

      if ((color !== undefined) && Number.isInteger(parseInt(color)) && !color_as_svg)
         this.colorindx = parseInt(color);

      if ((pattern !== undefined) && Number.isInteger(parseInt(pattern))) {
         this.pattern = parseInt(pattern);
         delete this.opacity;
         delete this.antialias;
      }

      if ((this.pattern == 1000) && (this.colorindx === 0)) {
         this.pattern_url = 'white';
         return true;
      }

      if (this.pattern == 1000)
         this.pattern = 1001;

      if (this.pattern < 1001) {
         this.pattern_url = 'none';
         return true;
      }

      if (this.isSolid() && (this.colorindx === 0) && (this.kind === 1) && !color_as_svg) {
         this.pattern_url = 'none';
         return true;
      }

      let indx = this.colorindx;

      if (color_as_svg) {
         this.color = color;
         if (color != 'none') indx = color$1(color).hex().slice(1); // fictional index produced from color code
      } else {
         this.color = painter ? painter.getColor(indx) : getColor(indx);
      }

      if (!isStr(this.color)) this.color = 'none';

      if (this.isSolid()) return true;

      if ((this.pattern >= 4000) && (this.pattern <= 4100)) {
         // special transparent colors (use for subpads)
         this.opacity = (this.pattern - 4000) / 100;
         return true;
      }

      if (!svg || svg.empty() || (this.pattern < 3000) || (this.color == 'none')) return false;

      let id = `pat_${this.pattern}_${indx}`,
         defs = svg.select('.canvas_defs');

      if (defs.empty())
         defs = svg.insert('svg:defs', ':first-child').attr('class', 'canvas_defs');

      this.pattern_url = `url(#${id})`;
      this.antialias = false;

      if (!defs.select('.' + id).empty())
         return true;

      let lines = '', lfill = null, fills = '', fills2 = '', w = 2, h = 2;

      switch (this.pattern) {
         case 3001: w = h = 2; fills = 'M0,0h1v1h-1zM1,1h1v1h-1z'; break;
         case 3002: w = 4; h = 2; fills = 'M1,0h1v1h-1zM3,1h1v1h-1z'; break;
         case 3003: w = h = 4; fills = 'M2,1h1v1h-1zM0,3h1v1h-1z'; break;
         case 3004: w = h = 8; lines = 'M8,0L0,8'; break;
         case 3005: w = h = 8; lines = 'M0,0L8,8'; break;
         case 3006: w = h = 4; lines = 'M1,0v4'; break;
         case 3007: w = h = 4; lines = 'M0,1h4'; break;
         case 3008:
            w = h = 10;
            fills = 'M0,3v-3h3ZM7,0h3v3ZM0,7v3h3ZM7,10h3v-3ZM5,2l3,3l-3,3l-3,-3Z';
            lines = 'M0,3l5,5M3,10l5,-5M10,7l-5,-5M7,0l-5,5';
            break;
         case 3009: w = 12; h = 12; lines = 'M0,0A6,6,0,0,0,12,0M6,6A6,6,0,0,0,12,12M6,6A6,6,0,0,1,0,12'; lfill = 'none'; break;
         case 3010: w = h = 10; lines = 'M0,2h10M0,7h10M2,0v2M7,2v5M2,7v3'; break; // bricks
         case 3011: w = 9; h = 18; lines = 'M5,0v8M2,1l6,6M8,1l-6,6M9,9v8M6,10l3,3l-3,3M0,9v8M3,10l-3,3l3,3'; lfill = 'none'; break;
         case 3012: w = 10; h = 20; lines = 'M5,1A4,4,0,0,0,5,9A4,4,0,0,0,5,1M0,11A4,4,0,0,1,0,19M10,11A4,4,0,0,0,10,19'; lfill = 'none'; break;
         case 3013: w = h = 7; lines = 'M0,0L7,7M7,0L0,7'; lfill = 'none'; break;
         case 3014: w = h = 16; lines = 'M0,0h16v16h-16v-16M0,12h16M12,0v16M4,0v8M4,4h8M0,8h8M8,4v8'; lfill = 'none'; break;
         case 3015: w = 6; h = 12; lines = 'M2,1A2,2,0,0,0,2,5A2,2,0,0,0,2,1M0,7A2,2,0,0,1,0,11M6,7A2,2,0,0,0,6,11'; lfill = 'none'; break;
         case 3016: w = 12; h = 7; lines = 'M0,1A3,2,0,0,1,3,3A3,2,0,0,0,9,3A3,2,0,0,1,12,1'; lfill = 'none'; break;
         case 3017: w = h = 4; lines = 'M3,1l-2,2'; break;
         case 3018: w = h = 4; lines = 'M1,1l2,2'; break;
         case 3019:
            w = h = 12;
            lines = 'M1,6A5,5,0,0,0,11,6A5,5,0,0,0,1,6h-1h1A5,5,0,0,1,6,11v1v-1A5,5,0,0,1,11,6h1h-1A5,5,0,0,1,6,1v-1v1A5,5,0,0,1,1,6';
            lfill = 'none';
            break;
         case 3020: w = 7; h = 12; lines = 'M1,0A2,3,0,0,0,3,3A2,3,0,0,1,3,9A2,3,0,0,0,1,12'; lfill = 'none'; break;
         case 3021: w = h = 8; lines = 'M8,2h-2v4h-4v2M2,0v2h-2'; lfill = 'none'; break; // left stairs
         case 3022: w = h = 8; lines = 'M0,2h2v4h4v2M6,0v2h2'; lfill = 'none'; break; // right stairs
         case 3023: w = h = 8; fills = 'M4,0h4v4zM8,4v4h-4z'; fills2 = 'M4,0L0,4L4,8L8,4Z'; break;
         case 3024: w = h = 16; fills = 'M0,8v8h2v-8zM8,0v8h2v-8M4,14v2h12v-2z'; fills2 = 'M0,2h8v6h4v-6h4v12h-12v-6h-4z'; break;
         case 3025: w = h = 18; fills = 'M5,13v-8h8ZM18,0v18h-18l5,-5h8v-8Z'; break;
         default:
            if ((this.pattern > 3025) && (this.pattern < 3100)) {
               // same as 3002, see TGX11.cxx, line 2234
               w = 4; h = 2; fills = 'M1,0h1v1h-1zM3,1h1v1h-1z'; break;
            }

            let code = this.pattern % 1000,
                k = code % 10,
                j = ((code - k) % 100) / 10,
                i = (code - j * 10 - k) / 100;
            if (!i) break;

            let hatches_spacing = Math.round(Math.max(0.5, gStyle.fHatchesSpacing)*2) * 6,
                sz = i * hatches_spacing, pos, step, x1, x2, y1, y2, max;  // axis distance between lines

            w = h = 6 * sz; // we use at least 6 steps

            const produce = (dy, swap) => {
               pos = []; step = sz; y1 = 0; max = h;

               // reduce step for smaller angles to keep normal distance approx same
               if (Math.abs(dy) < 3)
                  step = Math.round(sz / 12 * 9);
               if (dy == 0) {
                  step = Math.round(sz / 12 * 8);
                  y1 = step / 2;
               } else if (dy > 0) {
                  max -= step;
               } else {
                  y1 = step;
               }

               while (y1 <= max) {
                  y2 = y1 + dy * step;
                  if (y2 < 0) {
                     x2 = Math.round(y1 / (y1 - y2) * w);
                     pos.push(0, y1, x2, 0);
                     pos.push(w, h - y1, w - x2, h);
                  } else if (y2 > h) {
                     x2 = Math.round((h - y1) / (y2 - y1) * w);
                     pos.push(0, y1, x2, h);
                     pos.push(w, h - y1, w - x2, 0);
                  } else {
                     pos.push(0, y1, w, y2);
                  }
                  y1 += step;
               }
               for (let k = 0; k < pos.length; k += 4) {
                  if (swap) { x1 = pos[k+1]; y1 = pos[k]; x2 = pos[k+3]; y2 = pos[k+2]; }
                       else { x1 = pos[k]; y1 = pos[k+1]; x2 = pos[k+2]; y2 = pos[k+3]; }
                   lines += `M${x1},${y1}`;
                   if (y2 == y1)
                      lines += `h${x2-x1}`;
                   else if (x2 == x1)
                      lines += `v${y2-y1}`;
                   else
                      lines += `L${x2},${y2}`;
               }
            };

            switch (j) {
               case 0: produce(0); break;
               case 1: produce(1); break;
               case 2: produce(2); break;
               case 3: produce(3); break;
               case 4: produce(6); break;
               case 6: produce(3, true); break;
               case 7: produce(2, true); break;
               case 8: produce(1, true); break;
               case 9: produce(0, true); break;
            }

            switch (k) {
               case 0: if (j) produce(0); break;
               case 1: produce(-1); break;
               case 2: produce(-2); break;
               case 3: produce(-3); break;
               case 4: produce(-6); break;
               case 6: produce(-3, true); break;
               case 7: produce(-2, true); break;
               case 8: produce(-1, true); break;
               case 9: if (j != 9) produce(0, true); break;
            }

            break;
      }

      if (!fills && !lines) return false;

      let patt = defs.append('svg:pattern')
                     .attr('id', id).attr('class', id).attr('patternUnits', 'userSpaceOnUse')
                     .attr('width', w).attr('height', h);

      if (fills2) {
         let col = rgb(this.color);
         col.r = Math.round((col.r + 255) / 2); col.g = Math.round((col.g + 255) / 2); col.b = Math.round((col.b + 255) / 2);
         patt.append('svg:path').attr('d', fills2).style('fill', col);
      }
      if (fills) patt.append('svg:path').attr('d', fills).style('fill', this.color);
      if (lines) patt.append('svg:path').attr('d', lines).style('stroke', this.color).style('stroke-width', gStyle.fHatchesLineWidth).style('fill', lfill);

      return true;
   }

   /** @summary Create sample of fill pattern inside SVG
     * @private */
   createSample(svg, width, height, plain) {
      // we need to create extra handle to change
      if (plain) svg = select(svg);

      const sample = new TAttFillHandler({ svg, pattern: this.pattern, color: this.color, color_as_svg: true });

      svg.append('path')
         .attr('d', `M0,0h${width}v${height}h${-width}z`)
         .call(sample.func);
   }

   /** @summary Save fill attributes to style
     * @private */
   saveToStyle(name_color, name_pattern) {
      if (name_color) {
         let indx = this.colorindx ?? findColor(this.color);
         if (indx >= 0) gStyle[name_color] = indx;
      }
      if (name_pattern)
         gStyle[name_pattern] = this.pattern;
   }

} // class TAttFillHandler

const root_line_styles = [
      '', '', '3,3', '1,2',
      '3,4,1,4', '5,3,1,3', '5,3,1,3,1,3,1,3', '5,5',
      '5,3,1,3,1,3', '20,5', '20,10,1,10', '1,3'];

/**
  * @summary Handle for line attributes
  * @private
  */

class TAttLineHandler {

   /** @summary constructor
     * @param {object} attr - attributes, see {@link TAttLineHandler#setArgs} */
   constructor(args) {
      this.func = this.apply.bind(this);
      this.used = true;
      if (args._typename && (args.fLineStyle !== undefined)) args = { attr: args };
      this.setArgs(args);
   }

   /** @summary Set line attributes.
     * @param {object} args - specify attributes by different ways
     * @param {object} args.attr - TAttLine object with appropriate data members or
     * @param {string} args.color - color in html like rgb(255,0,0) or 'red' or '#ff0000'
     * @param {number} args.style - line style number
     * @param {number} args.width - line width */
   setArgs(args) {
      if (args.attr) {
         this.color_index = args.attr.fLineColor;
         args.color = args.color0 || (args.painter ? args.painter.getColor(this.color_index) : getColor(this.color_index));
         if (args.width === undefined) args.width = args.attr.fLineWidth;
         if (args.style === undefined) args.style = args.attr.fLineStyle;
      } else if (isStr(args.color)) {
         if ((args.color !== 'none') && !args.width) args.width = 1;
      } else if (typeof args.color == 'number') {
         this.color_index = args.color;
         args.color = args.painter ? args.painter.getColor(args.color) : getColor(args.color);
      }

      if (args.width === undefined)
         args.width = (args.color && args.color != 'none') ? 1 : 0;

      this.color = (args.width === 0) ? 'none' : args.color;
      this.width = args.width;
      this.style = args.style;
      this.pattern = args.pattern || root_line_styles[this.style] || null;

      if (args.can_excl) {
         this.excl_side = this.excl_width = 0;
         if (Math.abs(this.width) > 99) {
            // exclusion graph
            this.excl_side = (this.width < 0) ? -1 : 1;
            this.excl_width = Math.floor(this.width / 100) * 5;
            this.width = Math.abs(this.width % 100); // line width
         }
      }

      // if custom color number used, use lightgrey color to show lines
      if (!this.color && (this.width > 0))
         this.color = 'lightgrey';
   }

   /** @summary Change exclusion attributes */
   changeExcl(side, width) {
      if (width !== undefined)
         this.excl_width = width;
      if (side !== undefined) {
         this.excl_side = side;
         if ((this.excl_width === 0) && (this.excl_side !== 0)) this.excl_width = 20;
      }
      this.changed = true;
   }

   /** @summary returns true if line attribute is empty and will not be applied. */
   empty() { return this.color == 'none'; }

   /** @summary set border parameters, used for rect drawing */
   setBorder(rx, ry) {
      this.rx = rx;
      this.ry = ry;
      this.func = this.applyBorder.bind(this);
   }

   /** @summary Applies line attribute to selection.
     * @param {object} selection - d3.js selection */
   apply(selection) {
      this.used = true;
      if (this.empty())
         selection.style('stroke', null)
                  .style('stroke-width', null)
                  .style('stroke-dasharray', null);
      else
         selection.style('stroke', this.color)
                  .style('stroke-width', this.width)
                  .style('stroke-dasharray', this.pattern);
   }

   /** @summary Applies line and border attribute to selection.
     * @param {object} selection - d3.js selection */
   applyBorder(selection) {
      this.used = true;
      if (this.empty())
         selection.style('stroke', null)
                  .style('stroke-width', null)
                  .style('stroke-dasharray', null)
                  .attr('rx', null).attr('ry', null);
      else
         selection.style('stroke', this.color)
                  .style('stroke-width', this.width)
                  .style('stroke-dasharray', this.pattern)
                  .attr('rx', this.rx || null).attr('ry', this.ry || null);
   }

   /** @summary Change line attributes */
   change(color, width, style) {
      if (color !== undefined) {
         if (this.color !== color)
            delete this.color_index;
         this.color = color;
      }
      if (width !== undefined)
         this.width = width;
      if (style !== undefined) {
         this.style = style;
         this.pattern = root_line_styles[this.style] || null;
      }
      this.changed = true;
   }

   /** @summary Method used when color or pattern were changed with OpenUi5 widgets.
     * @private */
   verifyDirectChange(/* painter */) {
      this.change(this.color, parseInt(this.width), parseInt(this.style));
   }

   /** @summary Create sample element inside primitive SVG - used in context menu */
   createSample(svg, width, height, plain) {
      if (plain) svg = select(svg);
      svg.append('path')
         .attr('d', `M0,${height/2}h${width}`)
         .call(this.func);
   }

   /** @summary Save attributes values to gStyle */
   saveToStyle(name_color, name_width, name_style) {
      if (name_color) {
         let indx = (this.color_index !== undefined) ? this.color_index : findColor(this.color);
         if (indx >= 0)
            gStyle[name_color] = indx;
      }
      if (name_width)
         gStyle[name_width] = this.width;
      if (name_style)
         gStyle[name_style] = this.style;
   }

} // class TAttLineHandler

/** @summary Get svg string for specified line style
  * @private */
function getSvgLineStyle(indx) {
   if ((indx < 0) || (indx >= root_line_styles.length)) indx = 11;
   return root_line_styles[indx];
}

/**
 * @summary Painter class for ROOT objects
 *
 */

class ObjectPainter extends BasePainter {

   /** @summary constructor
     * @param {object|string} dom - dom element or identifier
     * @param {object} obj - object to draw
     * @param {string} [opt] - object draw options */
   constructor(dom, obj, opt) {
      super(dom);
      // this.draw_g = undefined; // container for all drawn objects
      // this._main_painter = undefined;  // main painter in the correspondent pad
      this.pad_name = dom ? this.selectCurrentPad() : ''; // name of pad where object is drawn
      this.assignObject(obj);
      if (isStr(opt))
         this.options = { original: opt };
   }

   /** @summary Assign object to the painter
     * @protected */
   assignObject(obj) {
      if (isObject(obj))
         this.draw_object = obj;
      else
         delete this.draw_object;
   }

   /** @summary Assigns pad name where element will be drawn
     * @desc Should happend before first draw of element is performed, only for special use case
     * @param {string} [pad_name] - on which subpad element should be draw, if not specified - use current
     * @protected */
   setPadName(pad_name) {
      this.pad_name = isStr(pad_name) ? pad_name : this.selectCurrentPad();
   }

   /** @summary Returns pad name where object is drawn */
   getPadName() {
      return this.pad_name || '';
   }

   /** @summary Assign snapid to the painter
    * @desc Identifier used to communicate with server side and identifies object on the server
    * @private */
   assignSnapId(id) { this.snapid = id; }

   /** @summary Generic method to cleanup painter.
     * @desc Remove object drawing and (in case of main painter) also main HTML components
     * @protected */
   cleanup() {

      this.removeG();

      let keep_origin = true;

      if (this.isMainPainter()) {
         let pp = this.getPadPainter();
         if (!pp || (pp.normal_canvas === false))
            keep_origin = false;
      }

      // cleanup all existing references
      delete this.pad_name;
      delete this._main_painter;
      this.draw_object = null;
      delete this.snapid;

      // remove attributes objects (if any)
      delete this.fillatt;
      delete this.lineatt;
      delete this.markeratt;
      delete this.bins;
      delete this.root_colors;
      delete this.options;
      delete this.options_store;

      // remove extra fields from v7 painters
      delete this.rstyle;
      delete this.csstype;

      super.cleanup(keep_origin);
   }

   /** @summary Returns drawn object */
   getObject() { return this.draw_object; }

   /** @summary Returns drawn object class name */
   getClassName() { return this.getObject()?._typename || ''; }

   /** @summary Checks if drawn object matches with provided typename
     * @param {string|object} arg - typename (or object with _typename member)
     * @protected */
   matchObjectType(arg) {
      if (!arg || !this.draw_object) return false;
      if (isStr(arg)) return this.draw_object._typename === arg;
      if (arg._typename) return this.draw_object._typename === arg._typename;
      return this.draw_object._typename.match(arg);
   }

   /** @summary Change item name
     * @desc When available, used for svg:title proprty
     * @private */
   setItemName(name, opt, hpainter) {
      super.setItemName(name, opt, hpainter);
      if (this.no_default_title || !name) return;
      let can = this.getCanvSvg();
      if (!can.empty()) can.select('title').text(name);
                   else this.selectDom().attr('title', name);
      let cp = this.getCanvPainter();
      if (cp && ((cp === this) || (this.isMainPainter() && (cp === this.getPadPainter()))))
         cp.drawItemNameOnCanvas(name);
   }

   /** @summary Store actual this.options together with original string
     * @private */
   storeDrawOpt(original) {
      if (!this.options) return;
      if (!original) original = '';
      let pp = original.indexOf(';;');
      if (pp >= 0) original = original.slice(0, pp);
      this.options.original = original;
      this.options_store = Object.assign({}, this.options);
   }

   /** @summary Return actual draw options as string
     * @desc if options are not modified - returns original string which was specified for object draw */
   getDrawOpt() {
      if (!this.options) return '';

      if (isFunc(this.options.asString)) {
         let changed = false, pp = this.getPadPainter();
         if (!this.options_store || pp?._interactively_changed) {
            changed  = true;
         } else {
            for (let k in this.options)
               if (this.options[k] !== this.options_store[k])
                  changed = true;
         }
         if (changed)
            return this.options.asString(this.isMainPainter(), pp?.getRootPad());
      }

      return this.options.original || ''; // nothing better, return original draw option
   }

   /** @summary Returns array with supported draw options as configured in draw.mjs
     * @desc works via pad painter and only when module was loaded */
   getSupportedDrawOptions() {
      let pp = this.getPadPainter(),
          obj = this.getObject();

      if (!obj?._typename || !pp?.getObjectDrawSettings)
         return [];

      let sett = pp.getObjectDrawSettings('ROOT.' + obj._typename, 'nosame');
      return sett?.opts;
   }

   /** @summary Central place to update objects drawing
     * @param {object} obj - new version of object, values will be updated in original object
     * @param {string} [opt] - when specified, new draw options
     * @return {boolean|Promise} for object redraw
     * @desc Two actions typically done by redraw - update object content via {@link ObjectPainter#updateObject} and
      * then redraw correspondent pad via {@link ObjectPainter#redrawPad}. If possible one should redefine
      * only updateObject function and keep this function unchanged. But for some special painters this function is the
      * only way to control how object can be update while requested from the server
      * @protected */
   redrawObject(obj, opt) {
      if (!this.updateObject(obj,opt)) return false;
      let current = document.body.style.cursor;
      document.body.style.cursor = 'wait';
      let res = this.redrawPad();
      document.body.style.cursor = current;
      return res || true;
   }

   /** @summary Generic method to update object content.
     * @desc Default implementation just copies first-level members to current object
     * @param {object} obj - object with new data
     * @param {string} [opt] - option which will be used for redrawing
     * @protected */
   updateObject(obj /*, opt */) {
      if (!this.matchObjectType(obj)) return false;
      Object.assign(this.getObject(), obj);
      return true;
   }

   /** @summary Returns string with object hint
     * @desc It is either item name or object name or class name.
     * Such string typically used as object tooltip.
     * If result string larger than 20 symbols, it will be cutted. */
   getObjectHint() {
      let res = this.getItemName(), obj = this.getObject();
      if (!res) res = obj && obj.fName ? obj.fName : '';
      if (!res) res = this.getClassName();
      if (res.length > 20) res = res.slice(0, 17) + '...';
      return res;
   }

   /** @summary returns color from current list of colors
     * @desc First checks canvas painter and then just access global list of colors
     * @param {number} indx - color index
     * @return {string} with SVG color name or rgb()
     * @protected */
   getColor(indx) {
      if (!this.root_colors)
         this.root_colors = this.getCanvPainter()?.root_colors || getRootColors();

      return this.root_colors[indx];
   }

   /** @summary Add color to list of colors
     * @desc Returned color index can be used as color number in all other draw functions
     * @return {number} new color index
     * @protected */
   addColor(color) {
      if (!this.root_colors)
         this.root_colors = this.getCanvPainter()?.root_colors || getRootColors();
      let indx = this.root_colors.indexOf(color);
      if (indx >= 0) return indx;
      this.root_colors.push(color);
      return this.root_colors.length - 1;
   }

   /** @summary returns tooltip allowed flag
     * @desc If available, checks in canvas painter
     * @private */
   isTooltipAllowed() {
      let src = this.getCanvPainter() || this;
      return src.tooltip_allowed ? true : false;
   }

   /** @summary change tooltip allowed flag
     * @param {boolean|string} [on = true] set tooltip allowed state or 'toggle'
     * @private */
   setTooltipAllowed(on) {
      if (on === undefined) on = true;
      let src = this.getCanvPainter() || this;
      src.tooltip_allowed = (on == 'toggle') ? !src.tooltip_allowed : on;
   }

   /** @summary Checks if draw elements were resized and drawing should be updated.
     * @desc Redirects to {@link TPadPainter#checkCanvasResize}
     * @private */
   checkResize(arg) {
      let p = this.getCanvPainter();
      if (!p) return false;
      // only canvas should be checked
      p.checkCanvasResize(arg);
      return true;
   }

   /** @summary removes <g> element with object drawing
     * @desc generic method to delete all graphical elements, associated with the painter
     * @protected */
   removeG() {
      if (this.draw_g) {
         this.draw_g.remove();
         delete this.draw_g;
      }
   }

   /** @summary Returns created <g> element used for object drawing
     * @desc Element should be created by {@link ObjectPainter#createG}
     * @protected */
   getG() { return this.draw_g; }

   /** @summary (re)creates svg:g element for object drawings
     * @desc either one attach svg:g to pad primitives (default)
     * or svg:g element created in specified frame layer ('main_layer' will be used when true specified)
     * @param {boolean|string} [frame_layer] - when specified, <g> element will be created inside frame layer, otherwise in the pad
     * @protected */
   createG(frame_layer) {

      let layer;

      if (frame_layer) {
         let frame = this.getFrameSvg();
         if (frame.empty()) {
            console.error('Not found frame to create g element inside');
            return frame;
         }
         if (!isStr(frame_layer)) frame_layer = 'main_layer';
         layer = frame.select('.' + frame_layer);
      } else {
         layer = this.getLayerSvg('primitives_layer');
      }

      if (this.draw_g && this.draw_g.node().parentNode !== layer.node()) {
         console.log('g element changes its layer!!');
         this.removeG();
      }

      if (this.draw_g) {
         // clear all elements, keep g element on its place
         this.draw_g.selectAll('*').remove();
      } else {
         this.draw_g = layer.append('svg:g');

         if (!frame_layer)
            layer.selectChildren('.most_upper_primitives').raise();
      }

      // set attributes for debugging
      if (this.draw_object) {
         this.draw_g.attr('objname', (this.draw_object.fName || 'name').replace(/[^\w]/g, '_'));
         this.draw_g.attr('objtype', (this.draw_object._typename || 'type').replace(/[^\w]/g, '_'));
      }

      this.draw_g.property('in_frame', !!frame_layer); // indicates coordinate system

      return this.draw_g;
   }

   /** @summary Canvas main svg element
     * @return {object} d3 selection with canvas svg
     * @protected */
   getCanvSvg() { return this.selectDom().select('.root_canvas'); }

   /** @summary Pad svg element
     * @param {string} [pad_name] - pad name to select, if not specified - pad where object is drawn
     * @return {object} d3 selection with pad svg
     * @protected */
   getPadSvg(pad_name) {
      if (pad_name === undefined)
         pad_name = this.pad_name;

      let c = this.getCanvSvg();
      if (!pad_name || c.empty()) return c;

      let cp = c.property('pad_painter');
      if (cp && cp.pads_cache && cp.pads_cache[pad_name])
         return select(cp.pads_cache[pad_name]);

      c = c.select('.primitives_layer .__root_pad_' + pad_name);
      if (cp) {
         if (!cp.pads_cache) cp.pads_cache = {};
         cp.pads_cache[pad_name] = c.node();
      }
      return c;
   }

   /** @summary Method selects immediate layer under canvas/pad main element
     * @param {string} name - layer name, exits 'primitives_layer', 'btns_layer', 'info_layer'
     * @param {string} [pad_name] - pad name; current pad name  used by default
     * @protected */
   getLayerSvg(name, pad_name) {
      let svg = this.getPadSvg(pad_name);
      if (svg.empty()) return svg;

      if (name.indexOf('prim#') == 0) {
         svg = svg.select('.primitives_layer');
         name = name.slice(5);
      }

      let node = svg.node().firstChild;
      while (node) {
         let elem = select(node);
         if (elem.classed(name)) return elem;
         node = node.nextSibling;
      }

      return select(null);
   }

   /** @summary Method selects current pad name
     * @param {string} [new_name] - when specified, new current pad name will be configured
     * @return {string} previous selected pad or actual pad when new_name not specified
     * @private */
   selectCurrentPad(new_name) {
      let svg = this.getCanvSvg();
      if (svg.empty()) return '';
      let curr = svg.property('current_pad');
      if (new_name !== undefined) svg.property('current_pad', new_name);
      return curr;
   }

   /** @summary returns pad painter
     * @param {string} [pad_name] pad name or use current pad by default
     * @protected */
   getPadPainter(pad_name) {
      let elem = this.getPadSvg(isStr(pad_name) ? pad_name : undefined);
      return elem.empty() ? null : elem.property('pad_painter');
   }

   /** @summary returns canvas painter
     * @protected */
   getCanvPainter() {
      let elem = this.getCanvSvg();
      return elem.empty() ? null : elem.property('pad_painter');
   }

   /** @summary Return functor, which can convert x and y coordinates into pixels, used for drawing in the pad
     * @desc X and Y coordinates can be converted by calling func.x(x) and func.y(y)
     * Only can be used for painting in the pad, means CreateG() should be called without arguments
     * @param {boolean} isndc - if NDC coordinates will be used
     * @param {boolean} [noround] - if set, return coordinates will not be rounded
     * @protected */
   getAxisToSvgFunc(isndc, nornd) {
      let func = { isndc, nornd },
          use_frame = this.draw_g && this.draw_g.property('in_frame');
      if (use_frame) func.main = this.getFramePainter();
      if (func.main?.grx && func.main?.gry) {
         if (nornd) {
            func.x = function(x) { return this.main.grx(x); };
            func.y = function(y) { return this.main.gry(y); };
         } else {
            func.x = function(x) { return Math.round(this.main.grx(x)); };
            func.y = function(y) { return Math.round(this.main.gry(y)); };
         }
      } else if (!use_frame) {
         let pp = this.getPadPainter();
         if (!isndc) func.pad = pp?.getRootPad(true); // need for NDC conversion
         func.padw = pp?.getPadWidth() ?? 10;
         func.x = function(value) {
            if (this.pad) {
               if (this.pad.fLogx)
                  value = (value > 0) ? Math.log10(value) : this.pad.fUxmin;
               value = (value - this.pad.fX1) / (this.pad.fX2 - this.pad.fX1);
            }
            value *= this.padw;
            return this.nornd ? value : Math.round(value);
         };
         func.padh = pp?.getPadHeight() ?? 10;
         func.y = function(value) {
            if (this.pad) {
               if (this.pad.fLogy)
                  value = (value > 0) ? Math.log10(value) : this.pad.fUymin;
               value = (value - this.pad.fY1) / (this.pad.fY2 - this.pad.fY1);
            }
            value = (1 - value) * this.padh;
            return this.nornd ? value : Math.round(value);
         };
      } else {
         console.error(`Problem to create functor for ${this.getClassName()}`);
         func.x = () => 0;
         func.y = () => 0;

      }
      return func;
   }

   /** @summary Converts x or y coordinate into pad SVG coordinates.
     * @desc Only can be used for painting in the pad, means CreateG() should be called without arguments
     * @param {string} axis - name like 'x' or 'y'
     * @param {number} value - axis value to convert.
     * @param {boolean} ndc - is value in NDC coordinates
     * @param {boolean} [noround] - skip rounding
     * @return {number} value of requested coordiantes
     * @protected */
   axisToSvg(axis, value, ndc, noround) {
      let func = this.getAxisToSvgFunc(ndc, noround);
      return func[axis](value);
   }

   /** @summary Converts pad SVG x or y coordinates into axis values.
     * @desc Reverse transformation for {@link ObjectPainter#axisToSvg}
     * @param {string} axis - name like 'x' or 'y'
     * @param {number} coord - graphics coordiante.
     * @param {boolean} ndc - kind of return value
     * @return {number} value of requested coordiantes
     * @protected */
   svgToAxis(axis, coord, ndc) {
      let use_frame = this.draw_g && this.draw_g.property('in_frame');

      if (use_frame) {
         let main = this.getFramePainter();
         return main?.revertAxis(axis, coord) ?? 0;
      }

      let pp = this.getPadPainter(),
          value = !pp ? 0 : ((axis == 'y') ? (1 - coord / pp.getPadHeight()) : coord / pp.getPadWidth()),
          pad = (ndc || !pp) ? null : pp.getRootPad(true);

      if (pad) {
         if (axis == 'y') {
            value = pad.fY1 + value * (pad.fY2 - pad.fY1);
            if (pad.fLogy) value = Math.pow(10, value);
         } else {
            value = pad.fX1 + value * (pad.fX2 - pad.fX1);
            if (pad.fLogx) value = Math.pow(10, value);
         }
      }

      return value;
   }

   /** @summary Returns svg element for the frame in current pad
     * @protected */
   getFrameSvg(pad_name) {
      let layer = this.getLayerSvg('primitives_layer', pad_name);
      if (layer.empty()) return layer;
      let node = layer.node().firstChild;
      while (node) {
         let elem = select(node);
         if (elem.classed('root_frame')) return elem;
         node = node.nextSibling;
      }
      return select(null);
   }

   /** @summary Returns frame painter for current pad
     * @desc Pad has direct reference on frame if any
     * @protected */
   getFramePainter() {
      return this.getPadPainter()?.getFramePainter();
   }

   /** @summary Returns painter for main object on the pad.
     * @desc Typically it is first histogram drawn on the pad and which draws frame axes
     * But it also can be special usecase as TASImage or TGraphPolargram
     * @param {boolean} [not_store] - if true, prevent temporary storage of main painter reference
     * @protected */
   getMainPainter(not_store) {
      let res = this._main_painter;
      if (!res) {
         let pp = this.getPadPainter();
         res = pp ? pp.getMainPainter() : this.getTopPainter();
         if (!res) res = null;
         if (!not_store)
            this._main_painter = res;
      }
      return res;
   }

   /** @summary Returns true if this is main painter
     * @protected */
   isMainPainter() { return this === this.getMainPainter(); }

   /** @summary Assign this as main painter on the pad
     * @desc Main painter typically responsible for axes drawing
     * Should not be used by pad/canvas painters, but rather by objects which are drawing axis
     * @protected */
   setAsMainPainter(force) {
      let pp = this.getPadPainter();
      if (!pp)
         this.setTopPainter(); //fallback on BasePainter method
       else
         pp.setMainPainter(this, force);
   }

   /** @summary Add painter to pad list of painters
     * @param {string} [pad_name] - optional pad name where painter should be add
     * @desc Normally one should use {@link ensureTCanvas} to add painter to pad list of primitives
     * @protected */
   addToPadPrimitives(pad_name) {
      if (pad_name !== undefined) this.setPadName(pad_name);
      let pp = this.getPadPainter(pad_name); // important - pad_name must be here, otherwise PadPainter class confuses itself

      if (!pp || (pp === this)) return false;

      if (pp.painters.indexOf(this) < 0)
         pp.painters.push(this);

      if (!this.rstyle && pp.next_rstyle)
         this.rstyle = pp.next_rstyle;

      return true;
   }

   /** @summary Remove painter from pad list of painters
     * @protected */
   removeFromPadPrimitives() {
      let pp = this.getPadPainter();

      if (!pp || (pp === this)) return false;

      let k = pp.painters.indexOf(this);
      if (k >= 0) pp.painters.splice(k, 1);
      return true;
   }

   /** @summary Creates marker attributes object
     * @desc Can be used to produce markers in painter.
     * See {@link TAttMarkerHandler} for more info.
     * Instance assigned as this.markeratt data member, recognized by GED editor
     * @param {object} args - either TAttMarker or see arguments of {@link TAttMarkerHandler}
     * @return {object} created handler
     * @protected */
   createAttMarker(args) {
      if (!isObject(args))
         args = { std: true };
      else if (args.fMarkerColor !== undefined && args.fMarkerStyle !== undefined && args.fMarkerSize !== undefined)
         args = { attr: args, std: false };

      if (args.std === undefined) args.std = true;
      if (args.painter === undefined) args.painter = this;

      let handler = args.std ? this.markeratt : null;

      if (!handler)
         handler = new TAttMarkerHandler(args);
      else if (!handler.changed || args.force)
         handler.setArgs(args);

      if (args.std) this.markeratt = handler;
      return handler;
   }

   /** @summary Creates line attributes object.
     * @desc Can be used to produce lines in painter.
     * See {@link TAttLineHandler} for more info.
     * Instance assigned as this.lineatt data member, recognized by GED editor
     * @param {object} args - either TAttLine or see constructor arguments of {@link TAttLineHandler}
     * @protected */
   createAttLine(args) {
      if (!isObject(args))
         args = { std: true };
      else if (args.fLineColor !== undefined && args.fLineStyle !== undefined && args.fLineWidth !== undefined)
         args = { attr: args, std: false };

      if (args.std === undefined) args.std = true;
      if (args.painter === undefined) args.painter = this;

      let handler = args.std ? this.lineatt : null;

      if (!handler)
         handler = new TAttLineHandler(args);
      else if (!handler.changed || args.force)
         handler.setArgs(args);

      if (args.std) this.lineatt = handler;
      return handler;
   }

   /** @summary Creates fill attributes object.
     * @desc Method dedicated to create fill attributes, bound to canvas SVG
     * otherwise newly created patters will not be usable in the canvas
     * See {@link TAttFillHandler} for more info.
     * Instance assigned as this.fillatt data member, recognized by GED editors
     * @param {object} args - for special cases one can specify TAttFill as args or number of parameters
     * @param {boolean} [args.std = true] - this is standard fill attribute for object and should be used as this.fillatt
     * @param {object} [args.attr = null] - object, derived from TAttFill
     * @param {number} [args.pattern = undefined] - integer index of fill pattern
     * @param {number} [args.color = undefined] - integer index of fill color
     * @param {string} [args.color_as_svg = undefined] - color will be specified as SVG string, not as index from color palette
     * @param {number} [args.kind = undefined] - some special kind which is handled differently from normal patterns
     * @return created handle
     * @protected */
   createAttFill(args) {
      if (!isObject(args))
         args = { std: true };
      else if (args._typename && args.fFillColor !== undefined && args.fFillStyle !== undefined)
         args = { attr: args, std: false };

      if (args.std === undefined) args.std = true;

      let handler = args.std ? this.fillatt : null;

      if (!args.svg) args.svg = this.getCanvSvg();
      if (args.painter === undefined) args.painter = this;

      if (!handler)
         handler = new TAttFillHandler(args);
      else if (!handler.changed || args.force)
         handler.setArgs(args);

      if (args.std) this.fillatt = handler;
      return handler;
   }

   /** @summary call function for each painter in the pad
     * @desc Iterate over all known painters
     * @private */
   forEachPainter(userfunc, kind) {
      // iterate over all painters from pad list
      let pp = this.getPadPainter();
      if (pp) {
         pp.forEachPainterInPad(userfunc, kind);
      } else {
         let painter = this.getTopPainter();
         if (painter && (kind !== 'pads')) userfunc(painter);
      }
   }

   /** @summary indicate that redraw was invoked via interactive action (like context menu or zooming)
     * @desc Use to catch such action by GED and by server-side
     * @return {Promise} when completed
     * @private */
   async interactiveRedraw(arg, info, subelem) {

      let reason, res;
      if (isStr(info) && (info.indexOf('exec:') != 0))
         reason = info;

      if (arg == 'pad')
         res = this.redrawPad(reason);
      else if (arg !== false)
         res = this.redraw(reason);

      return getPromise(res).then(() => {
         // inform GED that something changes
         let canp = this.getCanvPainter();

         if (isFunc(canp?.producePadEvent))
            canp.producePadEvent('redraw', this.getPadPainter(), this, null, subelem);

         // inform server that drawopt changes
         if (isFunc(canp?.processChanges))
            canp.processChanges(info, this, subelem);

         return this;
      });
   }

   /** @summary Redraw all objects in the current pad
     * @param {string} [reason] - like 'resize' or 'zoom'
     * @return {Promise} when pad redraw completed
     * @protected */
   async redrawPad(reason) {
      let pp = this.getPadPainter();
      return pp ? pp.redrawPad(reason) : false;
   }

   /** @summary execute selected menu command, either locally or remotely
     * @private */
   executeMenuCommand(method) {

      if (method.fName == 'Inspect')
         // primitve inspector, keep it here
         return this.showInspector();

      return false;
   }

   /** @summary Invoke method for object via WebCanvas functionality
     * @desc Requires that painter marked with object identifier (this.snapid) or identifier provided as second argument
     * Canvas painter should exists and in non-readonly mode
     * Execution string can look like 'Print()'.
     * Many methods call can be chained with 'Print();;Update();;Clear()'
     * @private */
   submitCanvExec(exec, snapid) {
      if (!exec || !isStr(exec)) return;

      let canp = this.getCanvPainter();
      if (isFunc(canp?.submitExec))
         canp.submitExec(this, exec, snapid);
   }

   /** @summary remove all created draw attributes
     * @protected */
   deleteAttr() {
      delete this.lineatt;
      delete this.fillatt;
      delete this.markeratt;
   }

   /** @summary Show object in inspector for provided object
     * @protected */
   showInspector() {
      return false;
   }

   /** @summary Fill context menu for the object
     * @private */
   fillContextMenu(menu) {
      let title = this.getObjectHint();
      if (this.getObject() && ('_typename' in this.getObject()))
         title = this.getObject()._typename + '::' + title;

      menu.add('header:' + title);

      menu.addAttributesMenu(this);

      if ((menu.size() > 0) && this.showInspector('check'))
         menu.add('Inspect', this.showInspector);

      return menu.size() > 0;
   }

   /** @summary shows objects status
     * @desc Either used canvas painter method or globaly assigned
     * When no parameters are specified, just basic object properties are shown
     * @private */
   showObjectStatus(name, title, info, info2) {
      let cp = this.getCanvPainter();

      if (cp && !isFunc(cp.showCanvasStatus)) cp = null;

      if (!cp && !isFunc(internals.showStatus)) return false;

      if (this.enlargeMain('state') === 'on') return false;

      if ((name === undefined) && (title === undefined)) {
         let obj = this.getObject();
         if (!obj) return;
         name = this.getItemName() || obj.fName;
         title = obj.fTitle || obj._typename;
         info = obj._typename;
      }

      if (cp)
         cp.showCanvasStatus(name, title, info, info2);
      else
         internals.showStatus(name, title, info, info2);
   }

   /** @summary Redraw object
     * @desc Basic method, should be reimplemented in all derived objects
     * for the case when drawing should be repeated
     * @abstract
     * @protected */
   redraw(/* reason */) {}

   /** @summary Start text drawing
     * @desc required before any text can be drawn
     * @param {number} font_face - font id as used in ROOT font attributes
     * @param {number} font_size - font size as used in ROOT font attributes
     * @param {object} [draw_g] - element where text drawm, by default using main object <g> element
     * @param {number} [max_font_size] - maximal font size, used when text can be scaled
     * @protected */
   startTextDrawing(font_face, font_size, draw_g, max_font_size) {

      if (!draw_g) draw_g = this.draw_g;
      if (!draw_g || draw_g.empty()) return;

      let font = (font_size === 'font') ? font_face : new FontHandler(font_face, font_size),
          pp = this.getPadPainter();

      draw_g.call(font.func);

      draw_g.property('draw_text_completed', false) // indicate that draw operations submitted
            .property('all_args',[]) // array of all submitted args, makes easier to analyze them
            .property('text_font', font)
            .property('text_factor', 0.)
            .property('max_text_width', 0) // keep maximal text width, use it later
            .property('max_font_size', max_font_size)
            .property('_fast_drawing', pp?._fast_drawing || false);

      if (draw_g.property('_fast_drawing'))
         draw_g.property('_font_too_small', (max_font_size && (max_font_size < 5)) || (font.size < 4));
   }

   /** @summary Apply scaling factor to all drawn text in the <g> element
     * @desc Can be applied at any time before finishTextDrawing is called - even in the postprocess callbacks of text draw
     * @param {number} factor - scaling factor
     * @param {object} [draw_g] - drawing element for the text
     * @protected */
   scaleTextDrawing(factor, draw_g) {
      if (!draw_g) draw_g = this.draw_g;
      if (!draw_g || draw_g.empty()) return;
      if (factor && (factor > draw_g.property('text_factor')))
         draw_g.property('text_factor', factor);
   }

   /** @summary Analyze if all text draw operations are completed
     * @private */
   _checkAllTextDrawing(draw_g, resolveFunc, try_optimize) {

      let all_args = draw_g.property('all_args'), missing = 0;
      if (!all_args) {
         console.log('Text drawing is finished - why calling _checkAllTextDrawing?????');
         all_args = [];
      }

      all_args.forEach(arg => { if (!arg.ready) missing++; });

      if (missing > 0) {
         if (isFunc(resolveFunc)) {
            draw_g.node().textResolveFunc = resolveFunc;
            draw_g.node().try_optimize = try_optimize;
         }
         return;
      }

      draw_g.property('all_args', null); // clear all_args property

      // adjust font size (if there are normal text)
      let f = draw_g.property('text_factor'),
          font = draw_g.property('text_font'),
          max_sz = draw_g.property('max_font_size'),
          font_size = font.size, any_text = false, only_text = true;

      if ((f > 0) && ((f < 0.9) || (f > 1)))
         font.size = Math.max(1, Math.floor(font.size / f));

      if (max_sz && (font.size > max_sz))
         font.size = max_sz;

      if (font.size != font_size) {
         draw_g.call(font.func);
         font_size = font.size;
      }

      all_args.forEach(arg => {
         if (arg.mj_node && arg.applyAttributesToMathJax) {
            let svg = arg.mj_node.select('svg'); // MathJax svg
            arg.applyAttributesToMathJax(this, arg.mj_node, svg, arg, font_size, f);
            delete arg.mj_node; // remove reference
            only_text = false;
         } else if (arg.txt_g) {
            only_text = false;
         }
      });

      if (!resolveFunc) {
         resolveFunc = draw_g.node().textResolveFunc;
         try_optimize = draw_g.node().try_optimize;
         delete draw_g.node().textResolveFunc;
         delete draw_g.node().try_optimize;
      }

      let optimize_arr = (try_optimize && only_text) ? [] : null;

      // now process text and latex drawings
      all_args.forEach(arg => {
         let txt, is_txt, scale = 1;
         if (arg.txt_node) {
            txt = arg.txt_node;
            delete arg.txt_node;
            is_txt = true;
            if (optimize_arr !== null) optimize_arr.push(txt);
         } else if (arg.txt_g) {
            txt = arg.txt_g;
            delete arg.txt_g;
            is_txt = false;
         } else {
            return;
         }

         txt.attr('visibility', null);

         any_text = true;

         if (arg.width) {
            // adjust x position when scale into specified rectangle
            if (arg.align[0] == 'middle')
               arg.x += arg.width / 2;
             else if (arg.align[0] == 'end')
                arg.x += arg.width;
         }

         if (arg.height) {
            if (arg.align[1].indexOf('bottom') === 0)
               arg.y += arg.height;
            else if (arg.align[1] == 'middle')
               arg.y += arg.height / 2;
         }

         arg.dx = arg.dy = 0;

         if (is_txt) {

            // handle simple text drawing

            if (isNodeJs()) {
               if (arg.scale && (f > 0)) { arg.box.width *= 1/f; arg.box.height *= 1/f; }
            } else if (!arg.plain && !arg.fast) {
               // exact box dimension only required when complex text was build
               arg.box = getElementRect(txt, 'bbox');
            }

            if (arg.plain) {
               txt.attr('text-anchor', arg.align[0]);
               if (arg.align[1] == 'top')
                  txt.attr('dy', '.8em');
               else if (arg.align[1] == 'middle') {
                  if (isNodeJs()) txt.attr('dy', '.4em'); else txt.attr('dominant-baseline', 'middle');
               }
            } else {
               txt.attr('text-anchor', 'start');
               arg.dx = ((arg.align[0] == 'middle') ? -0.5 : ((arg.align[0] == 'end') ? -1 : 0)) * arg.box.width;
               arg.dy = ((arg.align[1] == 'top') ? (arg.top_shift || 1) : (arg.align[1] == 'middle') ? (arg.mid_shift || 0.5) : 0) * arg.box.height;
            }

         } else if (arg.text_rect) {

            // handle latext drawing
            let box = arg.text_rect;

            scale = (f > 0) && (Math.abs(1-f) > 0.01) ? 1/f : 1;

            arg.dx = ((arg.align[0] == 'middle') ? -0.5 : ((arg.align[0] == 'end') ? -1 : 0)) * box.width * scale;

            if (arg.align[1] == 'top')
               arg.dy = -box.y1*scale;
            else if (arg.align[1] == 'bottom')
               arg.dy = -box.y2*scale;
            else if (arg.align[1] == 'middle')
               arg.dy = -0.5*(box.y1 + box.y2)*scale;
         } else {
            console.error('text rect not calcualted - please check code');
         }

         if (!arg.rotate) { arg.x += arg.dx; arg.y += arg.dy; arg.dx = arg.dy = 0; }

         // use translate and then rotate to avoid complex sign calculations
         let trans = '';
         if (arg.y)
            trans = `translate(${Math.round(arg.x)},${Math.round(arg.y)})`;
         else if (arg.x)
            trans = `translate(${Math.round(arg.x)})`;
         if (arg.rotate)
            trans += ` rotate(${Math.round(arg.rotate)})`;
         if (scale !== 1)
            trans += ` scale(${scale.toFixed(3)})`;
         if (arg.dy)
            trans += ` translate(${Math.round(arg.dx)},${Math.round(arg.dy)})`;
         else if (arg.dx)
            trans += ` translate(${Math.round(arg.dx)})`;
         if (trans) txt.attr('transform', trans);
      });


      // when no any normal text drawn - remove font attributes
      if (!any_text)
         font.clearFont(draw_g);

      if ((optimize_arr !== null) && (optimize_arr.length > 1))
         ['fill', 'text-anchor'].forEach(name => {
            let first = optimize_arr[0].attr(name);
            optimize_arr.forEach(txt_node => {
               let value = txt_node.attr(name);
               if (!value || (value !== first)) first = undefined;
            });
            if (first) {
               draw_g.attr(name, first);
               optimize_arr.forEach(txt_node => { txt_node.attr(name, null); });
            }
         });

      // if specified, call resolve function
      if (resolveFunc) resolveFunc(this); // IMPORTANT - return painter, may use in draw methods
   }

   /** @summary Post-process plain text drawing
     * @private */
   _postprocessDrawText(arg, txt_node) {
      // complete rectangle with very rougth size estimations
      arg.box = !isNodeJs() && !settings.ApproxTextSize && !arg.fast ? getElementRect(txt_node, 'bbox') :
               (arg.text_rect || { height: arg.font_size * 1.2, width: arg.text.length * arg.font_size * arg.font.aver_width });

      txt_node.attr('visibility', 'hidden'); // hide elements until text drawing is finished

      if (arg.box.width > arg.draw_g.property('max_text_width'))
         arg.draw_g.property('max_text_width', arg.box.width);
      if (arg.scale)
         this.scaleTextDrawing(Math.max(1.05 * arg.box.width / arg.width, 1. * arg.box.height / arg.height), arg.draw_g);

      arg.result_width = arg.box.width;
      arg.result_height = arg.box.height;

      if (isFunc(arg.post_process))
         arg.post_process(this);

      return arg.box.width;
   }

   /** @summary Draw text
     * @desc The only legal way to draw text, support plain, latex and math text output
     * @param {object} arg - different text draw options
     * @param {string} arg.text - text to draw
     * @param {number} [arg.align = 12] - int value like 12 or 31
     * @param {string} [arg.align = undefined] - end;bottom
     * @param {number} [arg.x = 0] - x position
     * @param {number} [arg.y = 0] - y position
     * @param {number} [arg.width] - when specified, adjust font size in the specified box
     * @param {number} [arg.height] - when specified, adjust font size in the specified box
     * @param {number} [arg.latex] - 0 - plain text, 1 - normal TLatex, 2 - math
     * @param {string} [arg.color=black] - text color
     * @param {number} [arg.rotate] - rotaion angle
     * @param {number} [arg.font_size] - fixed font size
     * @param {object} [arg.draw_g] - element where to place text, if not specified central draw_g container is used
     * @param {function} [arg.post_process] - optional function called when specified text is drawn
     * @protected */
   drawText(arg) {

      if (!arg.text)
         arg.text = '';

      arg.draw_g = arg.draw_g || this.draw_g;
      if (!arg.draw_g || arg.draw_g.empty()) return;

      let font = arg.draw_g.property('text_font');
      arg.font = font; // use in latex conversion

      if (font) {
         if (font.color && !arg.color) arg.color = font.color;
         if (font.align && !arg.align) arg.align = font.align;
         if (font.angle && !arg.rotate) arg.rotate = font.angle;
      }

      let align = ['start', 'middle'];

      if (isStr(arg.align)) {
         align = arg.align.split(';');
         if (align.length == 1) align.push('middle');
      } else if (typeof arg.align == 'number') {
         if ((arg.align / 10) >= 3)
            align[0] = 'end';
         else if ((arg.align / 10) >= 2)
            align[0] = 'middle';
         if ((arg.align % 10) == 0)
            align[1] = 'bottom';
         else if ((arg.align % 10) == 1)
            align[1] = 'bottom-base';
         else if ((arg.align % 10) == 3)
            align[1] = 'top';
      } else if (isObject(arg.align) && (arg.align.length == 2)) {
         align = arg.align;
      }

      if (arg.latex === undefined) arg.latex = 1; //  latex 0-text, 1-latex, 2-math
      arg.align = align;
      arg.x = arg.x || 0;
      arg.y = arg.y || 0;
      arg.scale = arg.width && arg.height && !arg.font_size;
      arg.width = arg.width || 0;
      arg.height = arg.height || 0;

      if (arg.draw_g.property('_fast_drawing')) {
         if (arg.scale) {
            // area too small - ignore such drawing
            if (arg.height < 4) return 0;
         } else if (arg.font_size) {
            // font size too small
            if (arg.font_size < 4) return 0;
         } else if (arg.draw_g.property('_font_too_small')) {
            // configure font is too small - ignore drawing
            return 0;
         }
      }

      // include drawing into list of all args
      arg.draw_g.property('all_args').push(arg);
      arg.ready = false; // indicates if drawing is ready for post-processing

      let use_mathjax = (arg.latex == 2);

      if (arg.latex === 1)
         use_mathjax = (settings.Latex == constants$1.Latex.AlwaysMathJax) ||
                       ((settings.Latex == constants$1.Latex.MathJax) && arg.text.match(/[#{\\]/g)) ||
                       arg.text.match(/[\\]/g);

      if (!use_mathjax || arg.nomathjax) {

         arg.txt_node = arg.draw_g.append('svg:text');

         if (arg.color) arg.txt_node.attr('fill', arg.color);

         if (arg.font_size) arg.txt_node.attr('font-size', arg.font_size);
                       else arg.font_size = font.size;

         arg.plain = !arg.latex || (settings.Latex == constants$1.Latex.Off) || (settings.Latex == constants$1.Latex.Symbols);

         arg.simple_latex = arg.latex && (settings.Latex == constants$1.Latex.Symbols);

         if (!arg.plain || arg.simple_latex || (arg.font && arg.font.isSymbol)) {
            if (arg.simple_latex || isPlainText(arg.text) || arg.plain) {
               arg.simple_latex = true;
               producePlainText(this, arg.txt_node, arg);
            } else {
               arg.txt_node.remove(); // just remove text node,
               delete arg.txt_node;
               arg.txt_g = arg.draw_g.append('svg:g');
               produceLatex(this, arg.txt_g, arg);
            }
            arg.ready = true;
            this._postprocessDrawText(arg, arg.txt_g || arg.txt_node);

            if (arg.draw_g.property('draw_text_completed'))
               this._checkAllTextDrawing(arg.draw_g); // check if all other elements are completed
            return 0;
         }

         arg.plain = true;
         arg.txt_node.text(arg.text);
         arg.ready = true;

         return this._postprocessDrawText(arg, arg.txt_node);
      }

      arg.mj_node = arg.draw_g.append('svg:g').attr('visibility', 'hidden'); // hide text until drawing is finished

      produceMathjax(this, arg.mj_node, arg).then(() => {
         arg.ready = true;
         if (arg.draw_g.property('draw_text_completed'))
            this._checkAllTextDrawing(arg.draw_g);
      });

      return 0;
   }

   /** @summary Finish text drawing
     * @desc Should be called to complete all text drawing operations
     * @param {function} [draw_g] - <g> element for text drawing, this.draw_g used when not specified
     * @return {Promise} when text drawing completed
     * @protected */
   async finishTextDrawing(draw_g, try_optimize) {
      if (!draw_g) draw_g = this.draw_g;
      if (!draw_g || draw_g.empty())
         return false;

      draw_g.property('draw_text_completed', true); // mark that text drawing is completed

      return new Promise(resolveFunc => {
         this._checkAllTextDrawing(draw_g, resolveFunc, try_optimize);
      });
   }

   /** @summary Configure user-defined context menu for the object
     * @desc fillmenu_func will be called when context menu is actiavted
     * Arguments fillmenu_func are (menu,kind)
     * First is menu object, second is object subelement like axis 'x' or 'y'
     * Function should return promise with menu when items are filled
     * @param {function} fillmenu_func - function to fill custom context menu for oabject */
   configureUserContextMenu(fillmenu_func) {

      if (!fillmenu_func || !isFunc(fillmenu_func))
         delete this._userContextMenuFunc;
      else
         this._userContextMenuFunc = fillmenu_func;
   }

   /** @summary Fill object menu in web canvas
     * @private */
   async fillObjectExecMenu(menu, kind) {

      if (this._userContextMenuFunc)
         return this._userContextMenuFunc(menu, kind);

      let canvp = this.getCanvPainter();

      if (!this.snapid || !canvp || canvp?._readonly || !canvp?._websocket)
         return menu;

      function DoExecMenu(arg) {
         let execp = this.exec_painter || this,
            cp = execp.getCanvPainter(),
            item = execp.args_menu_items[parseInt(arg)];

         if (!item || !item.fName) return;

         // this is special entry, produced by TWebMenuItem, which recognizes editor entries itself
         if (item.fExec == 'Show:Editor') {
            if (isFunc(cp?.activateGed))
               cp.activateGed(execp);
            return;
         }

         if (isFunc(cp?.executeObjectMethod))
            if (cp.executeObjectMethod(execp, item, execp.args_menu_id)) return;

         if (execp.executeMenuCommand(item)) return;

         if (!execp.args_menu_id) return;

          if (!item.fArgs)
             if (cp?.v7canvas)
                return cp.submitExec(execp, item.fExec, kind);
             else
                return execp.submitCanvExec(item.fExec, execp.args_menu_id);

         item.fClassName = execp.getClassName();
         if ((execp.args_menu_id.indexOf('#x') > 0) || (execp.args_menu_id.indexOf('#y') > 0) || (execp.args_menu_id.indexOf('#z') > 0))
            item.fClassName = clTAxis;

          menu.showMethodArgsDialog(item).then(args => {
             if (!args) return;
             if (execp.executeMenuCommand(item, args)) return;

             let exec = item.fExec.slice(0, item.fExec.length-1) + args + ')';
             if (cp?.v7canvas)
                cp.submitExec(execp, exec, kind);
             else if (cp)
                cp.sendWebsocket(`OBJEXEC:${execp.args_menu_id}:${exec}`);
         });
      }

      const DoFillMenu = (_menu, _reqid, _resolveFunc, reply) => {

         // avoid multiple call of the callback after timeout
         if (this._got_menu) return;
         this._got_menu = true;

         if (reply && (_reqid !== reply.fId))
            console.error(`missmatch between request ${_reqid} and reply ${reply.fId} identifiers`);

         let items = reply ? reply.fItems : null;

         if (items && items.length) {
            if (_menu.size() > 0)
               _menu.add('separator');

            this.args_menu_items = items;
            this.args_menu_id = reply.fId;

            let lastclname;

            for (let n = 0; n < items.length; ++n) {
               let item = items[n];

               if (item.fClassName && lastclname && (lastclname != item.fClassName)) {
                  _menu.add('endsub:');
                  lastclname = '';
               }
               if (lastclname != item.fClassName) {
                  lastclname = item.fClassName;
                  let p = lastclname.lastIndexOf('::'),
                      shortname = (p > 0) ? lastclname.slice(p+2) : lastclname;

                  _menu.add('sub:' + shortname.replace(/[<>]/g, '_'));
               }

               if ((item.fChecked === undefined) || (item.fChecked < 0))
                  _menu.add(item.fName, n, DoExecMenu);
               else
                  _menu.addchk(item.fChecked, item.fName, n, DoExecMenu);
            }

            if (lastclname) _menu.add('endsub:');
         }

         _resolveFunc(_menu);
      };

      let reqid = this.snapid;
      if (kind) reqid += '#' + kind; // use # to separate object id from member specifier like 'x' or 'z'

      this._got_menu = false;

      // if menu painter differs from this, remember it for further usage
      if (menu.painter)
         menu.painter.exec_painter = (menu.painter !== this) ? this : undefined;

      return new Promise(resolveFunc => {

         // set timeout to avoid menu hanging
         setTimeout(() => DoFillMenu(menu, reqid, resolveFunc), 2000);

         canvp.submitMenuRequest(this, kind, reqid).then(lst => DoFillMenu(menu, reqid, resolveFunc, lst));
      });
   }

   /** @summary Configure user-defined tooltip handler
     * @desc Hook for the users to get tooltip information when mouse cursor moves over frame area
     * Hanlder function will be called every time when new data is selected
     * when mouse leave frame area, handler(null) will be called
     * @param {function} handler - function called when tooltip is produced
     * @param {number} [tmout = 100] - delay in ms before tooltip delivered */
   configureUserTooltipHandler(handler, tmout) {
      if (!handler || !isFunc(handler)) {
         delete this._user_tooltip_handler;
         delete this._user_tooltip_timeout;
      } else {
         this._user_tooltip_handler = handler;
         this._user_tooltip_timeout = tmout || 100;
      }
   }

    /** @summary Configure user-defined click handler
      * @desc Function will be called every time when frame click was perfromed
      * As argument, tooltip object with selected bins will be provided
      * If handler function returns true, default handling of click will be disabled
      * @param {function} handler - function called when mouse click is done */
   configureUserClickHandler(handler) {
      let fp = this.getFramePainter();
      if (isFunc(fp?.configureUserClickHandler))
         fp.configureUserClickHandler(handler);
   }

   /** @summary Configure user-defined dblclick handler
     * @desc Function will be called every time when double click was called
     * As argument, tooltip object with selected bins will be provided
     * If handler function returns true, default handling of dblclick (unzoom) will be disabled
     * @param {function} handler - function called when mouse double click is done */
   configureUserDblclickHandler(handler) {
      let fp = this.getFramePainter();
      if (isFunc(fp?.configureUserDblclickHandler))
         fp.configureUserDblclickHandler(handler);
   }

   /** @summary Check if user-defined tooltip function was configured
     * @return {boolean} flag is user tooltip handler was configured */
   hasUserTooltip() {
      return isFunc(this._user_tooltip_handler);
   }

   /** @summary Provide tooltips data to user-defined function
     * @param {object} data - tooltip data
     * @private */
   provideUserTooltip(data) {

      if (!this.hasUserTooltip()) return;

      if (this._user_tooltip_timeout <= 0)
         return this._user_tooltip_handler(data);

      if (this._user_tooltip_handle) {
         clearTimeout(this._user_tooltip_handle);
         delete this._user_tooltip_handle;
      }

      if (!data)
         return this._user_tooltip_handler(data);

      let d = data;

      // only after timeout user function will be called
      this._user_tooltip_handle = setTimeout(() => {
         delete this._user_tooltip_handle;
         if (this._user_tooltip_handler) this._user_tooltip_handler(d);
      }, this._user_tooltip_timeout);
   }

   /** @summary Provide projection areas
     * @param kind - 'X', 'Y' or ''
     * @private */
   async provideSpecialDrawArea(kind) {
      if (kind == this._special_draw_area)
         return true;

      return this.getCanvPainter().toggleProjection(kind).then(() => {
         this._special_draw_area = kind;
         return true;
      });
   }

   /** @summary Provide projection areas
     * @param kind - 'X', 'Y' or ''
     * @private */
   async drawInSpecialArea(obj, opt) {
      let canp = this.getCanvPainter();
      if (this._special_draw_area && isFunc(canp?.drawProjection))
         return canp.drawProjection(this._special_draw_area, obj, opt);

      return false;
   }

   /** @summary Get tooltip for painter and specified event position
     * @param {Object} evnt - object wiith clientX and clientY positions
     * @private */
   getToolTip(evnt) {
      if ((evnt?.clientX === undefined) || (evnt?.clientY === undefined)) return null;

      let frame = this.getFrameSvg();
      if (frame.empty()) return null;
      let layer = frame.select('.main_layer');
      if (layer.empty()) return null;

      let pos = pointer(evnt, layer.node()),
          pnt = { touch: false, x: pos[0], y: pos[1] };

      if (isFunc(this.extractToolTip))
         return this.extractToolTip(pnt);

      pnt.disabled = true;

      let res = isFunc(this.processTooltipEvent) ? this.processTooltipEvent(pnt) : null;

      return res?.user_info || res;
   }

} // class ObjectPainter


/** @summary Generic text drawing
  * @private */
function drawRawText(dom, txt /*, opt*/) {

   let painter = new BasePainter(dom);
   painter.txt = txt;

   painter.redrawObject = function(obj) {
      this.txt = obj;
      this.drawText();
      return true;
   };

   painter.drawText = async function() {
      let txt = (this.txt._typename && (this.txt._typename == clTObjString)) ? this.txt.fString : this.txt.value;
      if (!isStr(txt)) txt = '<undefined>';

      let mathjax = this.txt.mathjax || (settings.Latex == constants$1.Latex.AlwaysMathJax);

      if (!mathjax && !('as_is' in this.txt)) {
         let arr = txt.split('\n'); txt = '';
         for (let i = 0; i < arr.length; ++i)
            txt += `<pre style='margin:0'>${arr[i]}</pre>`;
      }

      let frame = this.selectDom(),
          main = frame.select('div');
      if (main.empty())
         main = frame.append('div').attr('style', 'max-width:100%;max-height:100%;overflow:auto');
      main.html(txt);

      // (re) set painter to first child element, base painter not requires canvas
      this.setTopPainter();

      if (mathjax)
         typesetMathjax(frame.node());

      return this;
   };

   return painter.drawText();
}

/** @summary Returns canvas painter (if any) for specified HTML element
  * @param {string|object} dom - id or DOM element
  * @private */
function getElementCanvPainter(dom) {
   return new ObjectPainter(dom).getCanvPainter();
}

/** @summary Returns main painter (if any) for specified HTML element - typically histogram painter
  * @param {string|object} dom - id or DOM element
  * @private */
function getElementMainPainter(dom) {
   return new ObjectPainter(dom).getMainPainter(true);
}

/** @summary Save object, drawn in specified element, as JSON.
  * @desc Normally it is TCanvas object with list of primitives
  * @param {string|object} dom - id of top div element or directly DOMElement
  * @return {string} produced JSON string */
function drawingJSON(dom) {
   let canp = getElementCanvPainter(dom);
   return canp ? canp.produceJSON() : '';
}


let $active_pp = null;

/** @summary Set active pad painter
  * @desc Normally be used to handle key press events, which are global in the web browser
  * @param {object} args - functions arguments
  * @param {object} args.pp - pad painter
  * @param {boolean} [args.active] - is pad activated or not
  * @private */
function selectActivePad(args) {
   if (args.active) {
      let fp = $active_pp ? $active_pp.getFramePainter() : null;
      if (fp) fp.setFrameActive(false);

      $active_pp = args.pp;

      fp = $active_pp ? $active_pp.getFramePainter() : null;
      if (fp) fp.setFrameActive(true);
   } else if ($active_pp === args.pp) {
      $active_pp = null;
   }
}

/** @summary Returns current active pad
  * @desc Should be used only for keyboard handling
  * @private */
function getActivePad() {
   return $active_pp;
}

/** @summary Check resize of drawn element
  * @param {string|object} dom - id or DOM element
  * @param {boolean|object} arg - options on how to resize
  * @desc As first argument dom one should use same argument as for the drawing
  * As second argument, one could specify 'true' value to force redrawing of
  * the element even after minimal resize
  * Or one just supply object with exact sizes like { width:300, height:200, force:true };
  * @example
  * resize('drawing', { width: 500, height: 200 });
  * resize(document.querySelector('#drawing'), true); */
function resize(dom, arg) {
   if (arg === true)
      arg = { force: true };
   else if (!isObject(arg))
      arg = null;
   let done = false;
   new ObjectPainter(dom).forEachPainter(painter => {
      if (!done && isFunc(painter.checkResize))
         done = painter.checkResize(arg);
   });
   return done;
}


/** @summary Safely remove all drawings from specified element
  * @param {string|object} dom - id or DOM element
  * @public
  * @example
  * cleanup('drawing');
  * cleanup(document.querySelector('#drawing')); */
function cleanup(dom) {
   let dummy = new ObjectPainter(dom), lst = [];
   dummy.forEachPainter(p => { if (lst.indexOf(p) < 0) lst.push(p); });
   lst.forEach(p => p.cleanup());
   dummy.selectDom().html('');
   return lst;
}

const EAxisBits = {
   kDecimals: BIT(7),
   kTickPlus: BIT(9),
   kTickMinus: BIT(10),
   kAxisRange: BIT(11),
   kCenterTitle: BIT(12),
   kCenterLabels: BIT(14),
   kRotateTitle: BIT(15),
   kPalette: BIT(16),
   kNoExponent: BIT(17),
   kLabelsHori: BIT(18),
   kLabelsVert: BIT(19),
   kLabelsDown: BIT(20),
   kLabelsUp: BIT(21),
   kIsInteger: BIT(22),
   kMoreLogLabels: BIT(23),
   kOppositeTitle: BIT(32) // atrificial bit, not possible to set in ROOT
};

/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = '146';
const MOUSE = {
	LEFT: 0,
	MIDDLE: 1,
	RIGHT: 2,
	ROTATE: 0,
	DOLLY: 1,
	PAN: 2
};
const TOUCH = {
	ROTATE: 0,
	PAN: 1,
	DOLLY_PAN: 2,
	DOLLY_ROTATE: 3
};
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBFormat = 1022; // @deprecated since r137
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBAIntegerFormat = 1033;
const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const LinearEncoding = 3000;
const sRGBEncoding = 3001;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;
const SRGBColorSpace = 'srgb';
const LinearSRGBColorSpace = 'srgb-linear';
const KeepStencilOp = 7680;
const AlwaysStencilFunc = 519;
const StaticDrawUsage = 35044;
const GLSL3 = '300 es';
const _SRGBAFormat = 1035; // fallback for WebGL 1

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

class EventDispatcher {
	addEventListener(type, listener) {
		if (this._listeners === undefined) this._listeners = {};
		const listeners = this._listeners;
		if (listeners[type] === undefined) {
			listeners[type] = [];
		}
		if (listeners[type].indexOf(listener) === -1) {
			listeners[type].push(listener);
		}
	}
	hasEventListener(type, listener) {
		if (this._listeners === undefined) return false;
		const listeners = this._listeners;
		return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
	}
	removeEventListener(type, listener) {
		if (this._listeners === undefined) return;
		const listeners = this._listeners;
		const listenerArray = listeners[type];
		if (listenerArray !== undefined) {
			const index = listenerArray.indexOf(listener);
			if (index !== -1) {
				listenerArray.splice(index, 1);
			}
		}
	}
	dispatchEvent(event) {
		if (this._listeners === undefined) return;
		const listeners = this._listeners;
		const listenerArray = listeners[event.type];
		if (listenerArray !== undefined) {
			event.target = this;

			// Make a copy, in case listeners are removed while iterating.
			const array = listenerArray.slice(0);
			for (let i = 0, l = array.length; i < l; i++) {
				array[i].call(this, event);
			}
			event.target = null;
		}
	}
}

const _lut = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff'];
let _seed = 1234567;
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function generateUUID() {
	const d0 = Math.random() * 0xffffffff | 0;
	const d1 = Math.random() * 0xffffffff | 0;
	const d2 = Math.random() * 0xffffffff | 0;
	const d3 = Math.random() * 0xffffffff | 0;
	const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];

	// .toLowerCase() here flattens concatenated strings to save heap memory space.
	return uuid.toLowerCase();
}
function clamp(value, min, max) {
	return Math.max(min, Math.min(max, value));
}

// compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function euclideanModulo(n, m) {
	return (n % m + m) % m;
}

// Linear mapping from range <a1, a2> to range <b1, b2>
function mapLinear(x, a1, a2, b1, b2) {
	return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
}

// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function inverseLerp(x, y, value) {
	if (x !== y) {
		return (value - x) / (y - x);
	} else {
		return 0;
	}
}

// https://en.wikipedia.org/wiki/Linear_interpolation
function lerp(x, y, t) {
	return (1 - t) * x + t * y;
}

// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function damp(x, y, lambda, dt) {
	return lerp(x, y, 1 - Math.exp(-lambda * dt));
}

// https://www.desmos.com/calculator/vcsjnyz7x4
function pingpong(x, length = 1) {
	return length - Math.abs(euclideanModulo(x, length * 2) - length);
}

// http://en.wikipedia.org/wiki/Smoothstep
function smoothstep(x, min, max) {
	if (x <= min) return 0;
	if (x >= max) return 1;
	x = (x - min) / (max - min);
	return x * x * (3 - 2 * x);
}
function smootherstep(x, min, max) {
	if (x <= min) return 0;
	if (x >= max) return 1;
	x = (x - min) / (max - min);
	return x * x * x * (x * (x * 6 - 15) + 10);
}

// Random integer from <low, high> interval
function randInt(low, high) {
	return low + Math.floor(Math.random() * (high - low + 1));
}

// Random float from <low, high> interval
function randFloat(low, high) {
	return low + Math.random() * (high - low);
}

// Random float from <-range/2, range/2> interval
function randFloatSpread(range) {
	return range * (0.5 - Math.random());
}

// Deterministic pseudo-random float in the interval [ 0, 1 ]
function seededRandom(s) {
	if (s !== undefined) _seed = s;

	// Mulberry32 generator

	let t = _seed += 0x6D2B79F5;
	t = Math.imul(t ^ t >>> 15, t | 1);
	t ^= t + Math.imul(t ^ t >>> 7, t | 61);
	return ((t ^ t >>> 14) >>> 0) / 4294967296;
}
function degToRad(degrees) {
	return degrees * DEG2RAD;
}
function radToDeg(radians) {
	return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
	return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
	return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
	return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q, a, b, c, order) {
	// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

	// rotations are applied to the axes in the order specified by 'order'
	// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
	// angles are in radians

	const cos = Math.cos;
	const sin = Math.sin;
	const c2 = cos(b / 2);
	const s2 = sin(b / 2);
	const c13 = cos((a + c) / 2);
	const s13 = sin((a + c) / 2);
	const c1_3 = cos((a - c) / 2);
	const s1_3 = sin((a - c) / 2);
	const c3_1 = cos((c - a) / 2);
	const s3_1 = sin((c - a) / 2);
	switch (order) {
		case 'XYX':
			q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
			break;
		case 'YZY':
			q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
			break;
		case 'ZXZ':
			q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
			break;
		case 'XZX':
			q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
			break;
		case 'YXY':
			q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
			break;
		case 'ZYZ':
			q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
			break;
		default:
			console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
	}
}
function denormalize(value, array) {
	switch (array.constructor) {
		case Float32Array:
			return value;
		case Uint16Array:
			return value / 65535.0;
		case Uint8Array:
			return value / 255.0;
		case Int16Array:
			return Math.max(value / 32767.0, -1.0);
		case Int8Array:
			return Math.max(value / 127.0, -1.0);
		default:
			throw new Error('Invalid component type.');
	}
}
function normalize(value, array) {
	switch (array.constructor) {
		case Float32Array:
			return value;
		case Uint16Array:
			return Math.round(value * 65535.0);
		case Uint8Array:
			return Math.round(value * 255.0);
		case Int16Array:
			return Math.round(value * 32767.0);
		case Int8Array:
			return Math.round(value * 127.0);
		default:
			throw new Error('Invalid component type.');
	}
}

var MathUtils = /*#__PURE__*/Object.freeze({
	__proto__: null,
	DEG2RAD: DEG2RAD,
	RAD2DEG: RAD2DEG,
	generateUUID: generateUUID,
	clamp: clamp,
	euclideanModulo: euclideanModulo,
	mapLinear: mapLinear,
	inverseLerp: inverseLerp,
	lerp: lerp,
	damp: damp,
	pingpong: pingpong,
	smoothstep: smoothstep,
	smootherstep: smootherstep,
	randInt: randInt,
	randFloat: randFloat,
	randFloatSpread: randFloatSpread,
	seededRandom: seededRandom,
	degToRad: degToRad,
	radToDeg: radToDeg,
	isPowerOfTwo: isPowerOfTwo,
	ceilPowerOfTwo: ceilPowerOfTwo,
	floorPowerOfTwo: floorPowerOfTwo,
	setQuaternionFromProperEuler: setQuaternionFromProperEuler,
	normalize: normalize,
	denormalize: denormalize
});

class Vector2 {
	constructor(x = 0, y = 0) {
		Vector2.prototype.isVector2 = true;
		this.x = x;
		this.y = y;
	}
	get width() {
		return this.x;
	}
	set width(value) {
		this.x = value;
	}
	get height() {
		return this.y;
	}
	set height(value) {
		this.y = value;
	}
	set(x, y) {
		this.x = x;
		this.y = y;
		return this;
	}
	setScalar(scalar) {
		this.x = scalar;
		this.y = scalar;
		return this;
	}
	setX(x) {
		this.x = x;
		return this;
	}
	setY(y) {
		this.y = y;
		return this;
	}
	setComponent(index, value) {
		switch (index) {
			case 0:
				this.x = value;
				break;
			case 1:
				this.y = value;
				break;
			default:
				throw new Error('index is out of range: ' + index);
		}
		return this;
	}
	getComponent(index) {
		switch (index) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			default:
				throw new Error('index is out of range: ' + index);
		}
	}
	clone() {
		return new this.constructor(this.x, this.y);
	}
	copy(v) {
		this.x = v.x;
		this.y = v.y;
		return this;
	}
	add(v) {
		this.x += v.x;
		this.y += v.y;
		return this;
	}
	addScalar(s) {
		this.x += s;
		this.y += s;
		return this;
	}
	addVectors(a, b) {
		this.x = a.x + b.x;
		this.y = a.y + b.y;
		return this;
	}
	addScaledVector(v, s) {
		this.x += v.x * s;
		this.y += v.y * s;
		return this;
	}
	sub(v) {
		this.x -= v.x;
		this.y -= v.y;
		return this;
	}
	subScalar(s) {
		this.x -= s;
		this.y -= s;
		return this;
	}
	subVectors(a, b) {
		this.x = a.x - b.x;
		this.y = a.y - b.y;
		return this;
	}
	multiply(v) {
		this.x *= v.x;
		this.y *= v.y;
		return this;
	}
	multiplyScalar(scalar) {
		this.x *= scalar;
		this.y *= scalar;
		return this;
	}
	divide(v) {
		this.x /= v.x;
		this.y /= v.y;
		return this;
	}
	divideScalar(scalar) {
		return this.multiplyScalar(1 / scalar);
	}
	applyMatrix3(m) {
		const x = this.x,
			y = this.y;
		const e = m.elements;
		this.x = e[0] * x + e[3] * y + e[6];
		this.y = e[1] * x + e[4] * y + e[7];
		return this;
	}
	min(v) {
		this.x = Math.min(this.x, v.x);
		this.y = Math.min(this.y, v.y);
		return this;
	}
	max(v) {
		this.x = Math.max(this.x, v.x);
		this.y = Math.max(this.y, v.y);
		return this;
	}
	clamp(min, max) {
		// assumes min < max, componentwise

		this.x = Math.max(min.x, Math.min(max.x, this.x));
		this.y = Math.max(min.y, Math.min(max.y, this.y));
		return this;
	}
	clampScalar(minVal, maxVal) {
		this.x = Math.max(minVal, Math.min(maxVal, this.x));
		this.y = Math.max(minVal, Math.min(maxVal, this.y));
		return this;
	}
	clampLength(min, max) {
		const length = this.length();
		return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
	}
	floor() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	}
	ceil() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	}
	round() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	}
	roundToZero() {
		this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
		this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
		return this;
	}
	negate() {
		this.x = -this.x;
		this.y = -this.y;
		return this;
	}
	dot(v) {
		return this.x * v.x + this.y * v.y;
	}
	cross(v) {
		return this.x * v.y - this.y * v.x;
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y;
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y);
	}
	normalize() {
		return this.divideScalar(this.length() || 1);
	}
	angle() {
		// computes the angle in radians with respect to the positive x-axis

		const angle = Math.atan2(-this.y, -this.x) + Math.PI;
		return angle;
	}
	distanceTo(v) {
		return Math.sqrt(this.distanceToSquared(v));
	}
	distanceToSquared(v) {
		const dx = this.x - v.x,
			dy = this.y - v.y;
		return dx * dx + dy * dy;
	}
	manhattanDistanceTo(v) {
		return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
	}
	setLength(length) {
		return this.normalize().multiplyScalar(length);
	}
	lerp(v, alpha) {
		this.x += (v.x - this.x) * alpha;
		this.y += (v.y - this.y) * alpha;
		return this;
	}
	lerpVectors(v1, v2, alpha) {
		this.x = v1.x + (v2.x - v1.x) * alpha;
		this.y = v1.y + (v2.y - v1.y) * alpha;
		return this;
	}
	equals(v) {
		return v.x === this.x && v.y === this.y;
	}
	fromArray(array, offset = 0) {
		this.x = array[offset];
		this.y = array[offset + 1];
		return this;
	}
	toArray(array = [], offset = 0) {
		array[offset] = this.x;
		array[offset + 1] = this.y;
		return array;
	}
	fromBufferAttribute(attribute, index) {
		this.x = attribute.getX(index);
		this.y = attribute.getY(index);
		return this;
	}
	rotateAround(center, angle) {
		const c = Math.cos(angle),
			s = Math.sin(angle);
		const x = this.x - center.x;
		const y = this.y - center.y;
		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;
		return this;
	}
	random() {
		this.x = Math.random();
		this.y = Math.random();
		return this;
	}
	*[Symbol.iterator]() {
		yield this.x;
		yield this.y;
	}
}

class Matrix3 {
	constructor() {
		Matrix3.prototype.isMatrix3 = true;
		this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
	}
	set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
		const te = this.elements;
		te[0] = n11;
		te[1] = n21;
		te[2] = n31;
		te[3] = n12;
		te[4] = n22;
		te[5] = n32;
		te[6] = n13;
		te[7] = n23;
		te[8] = n33;
		return this;
	}
	identity() {
		this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
		return this;
	}
	copy(m) {
		const te = this.elements;
		const me = m.elements;
		te[0] = me[0];
		te[1] = me[1];
		te[2] = me[2];
		te[3] = me[3];
		te[4] = me[4];
		te[5] = me[5];
		te[6] = me[6];
		te[7] = me[7];
		te[8] = me[8];
		return this;
	}
	extractBasis(xAxis, yAxis, zAxis) {
		xAxis.setFromMatrix3Column(this, 0);
		yAxis.setFromMatrix3Column(this, 1);
		zAxis.setFromMatrix3Column(this, 2);
		return this;
	}
	setFromMatrix4(m) {
		const me = m.elements;
		this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
		return this;
	}
	multiply(m) {
		return this.multiplyMatrices(this, m);
	}
	premultiply(m) {
		return this.multiplyMatrices(m, this);
	}
	multiplyMatrices(a, b) {
		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;
		const a11 = ae[0],
			a12 = ae[3],
			a13 = ae[6];
		const a21 = ae[1],
			a22 = ae[4],
			a23 = ae[7];
		const a31 = ae[2],
			a32 = ae[5],
			a33 = ae[8];
		const b11 = be[0],
			b12 = be[3],
			b13 = be[6];
		const b21 = be[1],
			b22 = be[4],
			b23 = be[7];
		const b31 = be[2],
			b32 = be[5],
			b33 = be[8];
		te[0] = a11 * b11 + a12 * b21 + a13 * b31;
		te[3] = a11 * b12 + a12 * b22 + a13 * b32;
		te[6] = a11 * b13 + a12 * b23 + a13 * b33;
		te[1] = a21 * b11 + a22 * b21 + a23 * b31;
		te[4] = a21 * b12 + a22 * b22 + a23 * b32;
		te[7] = a21 * b13 + a22 * b23 + a23 * b33;
		te[2] = a31 * b11 + a32 * b21 + a33 * b31;
		te[5] = a31 * b12 + a32 * b22 + a33 * b32;
		te[8] = a31 * b13 + a32 * b23 + a33 * b33;
		return this;
	}
	multiplyScalar(s) {
		const te = this.elements;
		te[0] *= s;
		te[3] *= s;
		te[6] *= s;
		te[1] *= s;
		te[4] *= s;
		te[7] *= s;
		te[2] *= s;
		te[5] *= s;
		te[8] *= s;
		return this;
	}
	determinant() {
		const te = this.elements;
		const a = te[0],
			b = te[1],
			c = te[2],
			d = te[3],
			e = te[4],
			f = te[5],
			g = te[6],
			h = te[7],
			i = te[8];
		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
	}
	invert() {
		const te = this.elements,
			n11 = te[0],
			n21 = te[1],
			n31 = te[2],
			n12 = te[3],
			n22 = te[4],
			n32 = te[5],
			n13 = te[6],
			n23 = te[7],
			n33 = te[8],
			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,
			det = n11 * t11 + n21 * t12 + n31 * t13;
		if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
		const detInv = 1 / det;
		te[0] = t11 * detInv;
		te[1] = (n31 * n23 - n33 * n21) * detInv;
		te[2] = (n32 * n21 - n31 * n22) * detInv;
		te[3] = t12 * detInv;
		te[4] = (n33 * n11 - n31 * n13) * detInv;
		te[5] = (n31 * n12 - n32 * n11) * detInv;
		te[6] = t13 * detInv;
		te[7] = (n21 * n13 - n23 * n11) * detInv;
		te[8] = (n22 * n11 - n21 * n12) * detInv;
		return this;
	}
	transpose() {
		let tmp;
		const m = this.elements;
		tmp = m[1];
		m[1] = m[3];
		m[3] = tmp;
		tmp = m[2];
		m[2] = m[6];
		m[6] = tmp;
		tmp = m[5];
		m[5] = m[7];
		m[7] = tmp;
		return this;
	}
	getNormalMatrix(matrix4) {
		return this.setFromMatrix4(matrix4).invert().transpose();
	}
	transposeIntoArray(r) {
		const m = this.elements;
		r[0] = m[0];
		r[1] = m[3];
		r[2] = m[6];
		r[3] = m[1];
		r[4] = m[4];
		r[5] = m[7];
		r[6] = m[2];
		r[7] = m[5];
		r[8] = m[8];
		return this;
	}
	setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
		const c = Math.cos(rotation);
		const s = Math.sin(rotation);
		this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
		return this;
	}
	scale(sx, sy) {
		const te = this.elements;
		te[0] *= sx;
		te[3] *= sx;
		te[6] *= sx;
		te[1] *= sy;
		te[4] *= sy;
		te[7] *= sy;
		return this;
	}
	rotate(theta) {
		const c = Math.cos(theta);
		const s = Math.sin(theta);
		const te = this.elements;
		const a11 = te[0],
			a12 = te[3],
			a13 = te[6];
		const a21 = te[1],
			a22 = te[4],
			a23 = te[7];
		te[0] = c * a11 + s * a21;
		te[3] = c * a12 + s * a22;
		te[6] = c * a13 + s * a23;
		te[1] = -s * a11 + c * a21;
		te[4] = -s * a12 + c * a22;
		te[7] = -s * a13 + c * a23;
		return this;
	}
	translate(tx, ty) {
		const te = this.elements;
		te[0] += tx * te[2];
		te[3] += tx * te[5];
		te[6] += tx * te[8];
		te[1] += ty * te[2];
		te[4] += ty * te[5];
		te[7] += ty * te[8];
		return this;
	}
	equals(matrix) {
		const te = this.elements;
		const me = matrix.elements;
		for (let i = 0; i < 9; i++) {
			if (te[i] !== me[i]) return false;
		}
		return true;
	}
	fromArray(array, offset = 0) {
		for (let i = 0; i < 9; i++) {
			this.elements[i] = array[i + offset];
		}
		return this;
	}
	toArray(array = [], offset = 0) {
		const te = this.elements;
		array[offset] = te[0];
		array[offset + 1] = te[1];
		array[offset + 2] = te[2];
		array[offset + 3] = te[3];
		array[offset + 4] = te[4];
		array[offset + 5] = te[5];
		array[offset + 6] = te[6];
		array[offset + 7] = te[7];
		array[offset + 8] = te[8];
		return array;
	}
	clone() {
		return new this.constructor().fromArray(this.elements);
	}
}

function arrayNeedsUint32(array) {
	// assumes larger values usually on last

	for (let i = array.length - 1; i >= 0; --i) {
		if (array[i] >= 65535) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565
	}

	return false;
}
function createElementNS(name) {
	return document.createElementNS('http://www.w3.org/1999/xhtml', name);
}

function SRGBToLinear(c) {
	return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
	return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}

// JavaScript RGB-to-RGB transforms, defined as
// FN[InputColorSpace][OutputColorSpace] callback functions.
const FN = {
	[SRGBColorSpace]: {
		[LinearSRGBColorSpace]: SRGBToLinear
	},
	[LinearSRGBColorSpace]: {
		[SRGBColorSpace]: LinearToSRGB
	}
};
const ColorManagement = {
	legacyMode: true,
	get workingColorSpace() {
		return LinearSRGBColorSpace;
	},
	set workingColorSpace(colorSpace) {
		console.warn('THREE.ColorManagement: .workingColorSpace is readonly.');
	},
	convert: function (color, sourceColorSpace, targetColorSpace) {
		if (this.legacyMode || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
			return color;
		}
		if (FN[sourceColorSpace] && FN[sourceColorSpace][targetColorSpace] !== undefined) {
			const fn = FN[sourceColorSpace][targetColorSpace];
			color.r = fn(color.r);
			color.g = fn(color.g);
			color.b = fn(color.b);
			return color;
		}
		throw new Error('Unsupported color space conversion.');
	},
	fromWorkingColorSpace: function (color, targetColorSpace) {
		return this.convert(color, this.workingColorSpace, targetColorSpace);
	},
	toWorkingColorSpace: function (color, sourceColorSpace) {
		return this.convert(color, sourceColorSpace, this.workingColorSpace);
	}
};

const _colorKeywords = {
	'aliceblue': 0xF0F8FF,
	'antiquewhite': 0xFAEBD7,
	'aqua': 0x00FFFF,
	'aquamarine': 0x7FFFD4,
	'azure': 0xF0FFFF,
	'beige': 0xF5F5DC,
	'bisque': 0xFFE4C4,
	'black': 0x000000,
	'blanchedalmond': 0xFFEBCD,
	'blue': 0x0000FF,
	'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A,
	'burlywood': 0xDEB887,
	'cadetblue': 0x5F9EA0,
	'chartreuse': 0x7FFF00,
	'chocolate': 0xD2691E,
	'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED,
	'cornsilk': 0xFFF8DC,
	'crimson': 0xDC143C,
	'cyan': 0x00FFFF,
	'darkblue': 0x00008B,
	'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B,
	'darkgray': 0xA9A9A9,
	'darkgreen': 0x006400,
	'darkgrey': 0xA9A9A9,
	'darkkhaki': 0xBDB76B,
	'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F,
	'darkorange': 0xFF8C00,
	'darkorchid': 0x9932CC,
	'darkred': 0x8B0000,
	'darksalmon': 0xE9967A,
	'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B,
	'darkslategray': 0x2F4F4F,
	'darkslategrey': 0x2F4F4F,
	'darkturquoise': 0x00CED1,
	'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493,
	'deepskyblue': 0x00BFFF,
	'dimgray': 0x696969,
	'dimgrey': 0x696969,
	'dodgerblue': 0x1E90FF,
	'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0,
	'forestgreen': 0x228B22,
	'fuchsia': 0xFF00FF,
	'gainsboro': 0xDCDCDC,
	'ghostwhite': 0xF8F8FF,
	'gold': 0xFFD700,
	'goldenrod': 0xDAA520,
	'gray': 0x808080,
	'green': 0x008000,
	'greenyellow': 0xADFF2F,
	'grey': 0x808080,
	'honeydew': 0xF0FFF0,
	'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C,
	'indigo': 0x4B0082,
	'ivory': 0xFFFFF0,
	'khaki': 0xF0E68C,
	'lavender': 0xE6E6FA,
	'lavenderblush': 0xFFF0F5,
	'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD,
	'lightblue': 0xADD8E6,
	'lightcoral': 0xF08080,
	'lightcyan': 0xE0FFFF,
	'lightgoldenrodyellow': 0xFAFAD2,
	'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90,
	'lightgrey': 0xD3D3D3,
	'lightpink': 0xFFB6C1,
	'lightsalmon': 0xFFA07A,
	'lightseagreen': 0x20B2AA,
	'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899,
	'lightslategrey': 0x778899,
	'lightsteelblue': 0xB0C4DE,
	'lightyellow': 0xFFFFE0,
	'lime': 0x00FF00,
	'limegreen': 0x32CD32,
	'linen': 0xFAF0E6,
	'magenta': 0xFF00FF,
	'maroon': 0x800000,
	'mediumaquamarine': 0x66CDAA,
	'mediumblue': 0x0000CD,
	'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB,
	'mediumseagreen': 0x3CB371,
	'mediumslateblue': 0x7B68EE,
	'mediumspringgreen': 0x00FA9A,
	'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585,
	'midnightblue': 0x191970,
	'mintcream': 0xF5FFFA,
	'mistyrose': 0xFFE4E1,
	'moccasin': 0xFFE4B5,
	'navajowhite': 0xFFDEAD,
	'navy': 0x000080,
	'oldlace': 0xFDF5E6,
	'olive': 0x808000,
	'olivedrab': 0x6B8E23,
	'orange': 0xFFA500,
	'orangered': 0xFF4500,
	'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA,
	'palegreen': 0x98FB98,
	'paleturquoise': 0xAFEEEE,
	'palevioletred': 0xDB7093,
	'papayawhip': 0xFFEFD5,
	'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F,
	'pink': 0xFFC0CB,
	'plum': 0xDDA0DD,
	'powderblue': 0xB0E0E6,
	'purple': 0x800080,
	'rebeccapurple': 0x663399,
	'red': 0xFF0000,
	'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1,
	'saddlebrown': 0x8B4513,
	'salmon': 0xFA8072,
	'sandybrown': 0xF4A460,
	'seagreen': 0x2E8B57,
	'seashell': 0xFFF5EE,
	'sienna': 0xA0522D,
	'silver': 0xC0C0C0,
	'skyblue': 0x87CEEB,
	'slateblue': 0x6A5ACD,
	'slategray': 0x708090,
	'slategrey': 0x708090,
	'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F,
	'steelblue': 0x4682B4,
	'tan': 0xD2B48C,
	'teal': 0x008080,
	'thistle': 0xD8BFD8,
	'tomato': 0xFF6347,
	'turquoise': 0x40E0D0,
	'violet': 0xEE82EE,
	'wheat': 0xF5DEB3,
	'white': 0xFFFFFF,
	'whitesmoke': 0xF5F5F5,
	'yellow': 0xFFFF00,
	'yellowgreen': 0x9ACD32
};
const _rgb = {
	r: 0,
	g: 0,
	b: 0
};
const _hslA = {
	h: 0,
	s: 0,
	l: 0
};
const _hslB = {
	h: 0,
	s: 0,
	l: 0
};
function hue2rgb(p, q, t) {
	if (t < 0) t += 1;
	if (t > 1) t -= 1;
	if (t < 1 / 6) return p + (q - p) * 6 * t;
	if (t < 1 / 2) return q;
	if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
	return p;
}
function toComponents(source, target) {
	target.r = source.r;
	target.g = source.g;
	target.b = source.b;
	return target;
}
class Color$1 {
	constructor(r, g, b) {
		this.isColor = true;
		this.r = 1;
		this.g = 1;
		this.b = 1;
		if (g === undefined && b === undefined) {
			// r is THREE.Color, hex or string
			return this.set(r);
		}
		return this.setRGB(r, g, b);
	}
	set(value) {
		if (value && value.isColor) {
			this.copy(value);
		} else if (typeof value === 'number') {
			this.setHex(value);
		} else if (typeof value === 'string') {
			this.setStyle(value);
		}
		return this;
	}
	setScalar(scalar) {
		this.r = scalar;
		this.g = scalar;
		this.b = scalar;
		return this;
	}
	setHex(hex, colorSpace = SRGBColorSpace) {
		hex = Math.floor(hex);
		this.r = (hex >> 16 & 255) / 255;
		this.g = (hex >> 8 & 255) / 255;
		this.b = (hex & 255) / 255;
		ColorManagement.toWorkingColorSpace(this, colorSpace);
		return this;
	}
	setRGB(r, g, b, colorSpace = LinearSRGBColorSpace) {
		this.r = r;
		this.g = g;
		this.b = b;
		ColorManagement.toWorkingColorSpace(this, colorSpace);
		return this;
	}
	setHSL(h, s, l, colorSpace = LinearSRGBColorSpace) {
		// h,s,l ranges are in 0.0 - 1.0
		h = euclideanModulo(h, 1);
		s = clamp(s, 0, 1);
		l = clamp(l, 0, 1);
		if (s === 0) {
			this.r = this.g = this.b = l;
		} else {
			const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
			const q = 2 * l - p;
			this.r = hue2rgb(q, p, h + 1 / 3);
			this.g = hue2rgb(q, p, h);
			this.b = hue2rgb(q, p, h - 1 / 3);
		}
		ColorManagement.toWorkingColorSpace(this, colorSpace);
		return this;
	}
	setStyle(style, colorSpace = SRGBColorSpace) {
		function handleAlpha(string) {
			if (string === undefined) return;
			if (parseFloat(string) < 1) {
				console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
			}
		}
		let m;
		if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
			// rgb / hsl

			let color;
			const name = m[1];
			const components = m[2];
			switch (name) {
				case 'rgb':
				case 'rgba':
					if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min(255, parseInt(color[1], 10)) / 255;
						this.g = Math.min(255, parseInt(color[2], 10)) / 255;
						this.b = Math.min(255, parseInt(color[3], 10)) / 255;
						ColorManagement.toWorkingColorSpace(this, colorSpace);
						handleAlpha(color[4]);
						return this;
					}
					if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min(100, parseInt(color[1], 10)) / 100;
						this.g = Math.min(100, parseInt(color[2], 10)) / 100;
						this.b = Math.min(100, parseInt(color[3], 10)) / 100;
						ColorManagement.toWorkingColorSpace(this, colorSpace);
						handleAlpha(color[4]);
						return this;
					}
					break;
				case 'hsl':
				case 'hsla':
					if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						const h = parseFloat(color[1]) / 360;
						const s = parseFloat(color[2]) / 100;
						const l = parseFloat(color[3]) / 100;
						handleAlpha(color[4]);
						return this.setHSL(h, s, l, colorSpace);
					}
					break;
			}
		} else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
			// hex color

			const hex = m[1];
			const size = hex.length;
			if (size === 3) {
				// #ff0
				this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
				this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
				this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
				ColorManagement.toWorkingColorSpace(this, colorSpace);
				return this;
			} else if (size === 6) {
				// #ff0000
				this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
				this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
				this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
				ColorManagement.toWorkingColorSpace(this, colorSpace);
				return this;
			}
		}
		if (style && style.length > 0) {
			return this.setColorName(style, colorSpace);
		}
		return this;
	}
	setColorName(style, colorSpace = SRGBColorSpace) {
		// color keywords
		const hex = _colorKeywords[style.toLowerCase()];
		if (hex !== undefined) {
			// red
			this.setHex(hex, colorSpace);
		} else {
			// unknown color
			console.warn('THREE.Color: Unknown color ' + style);
		}
		return this;
	}
	clone() {
		return new this.constructor(this.r, this.g, this.b);
	}
	copy(color) {
		this.r = color.r;
		this.g = color.g;
		this.b = color.b;
		return this;
	}
	copySRGBToLinear(color) {
		this.r = SRGBToLinear(color.r);
		this.g = SRGBToLinear(color.g);
		this.b = SRGBToLinear(color.b);
		return this;
	}
	copyLinearToSRGB(color) {
		this.r = LinearToSRGB(color.r);
		this.g = LinearToSRGB(color.g);
		this.b = LinearToSRGB(color.b);
		return this;
	}
	convertSRGBToLinear() {
		this.copySRGBToLinear(this);
		return this;
	}
	convertLinearToSRGB() {
		this.copyLinearToSRGB(this);
		return this;
	}
	getHex(colorSpace = SRGBColorSpace) {
		ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
		return clamp(_rgb.r * 255, 0, 255) << 16 ^ clamp(_rgb.g * 255, 0, 255) << 8 ^ clamp(_rgb.b * 255, 0, 255) << 0;
	}
	getHexString(colorSpace = SRGBColorSpace) {
		return ('000000' + this.getHex(colorSpace).toString(16)).slice(-6);
	}
	getHSL(target, colorSpace = LinearSRGBColorSpace) {
		// h,s,l ranges are in 0.0 - 1.0

		ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
		const r = _rgb.r,
			g = _rgb.g,
			b = _rgb.b;
		const max = Math.max(r, g, b);
		const min = Math.min(r, g, b);
		let hue, saturation;
		const lightness = (min + max) / 2.0;
		if (min === max) {
			hue = 0;
			saturation = 0;
		} else {
			const delta = max - min;
			saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
			switch (max) {
				case r:
					hue = (g - b) / delta + (g < b ? 6 : 0);
					break;
				case g:
					hue = (b - r) / delta + 2;
					break;
				case b:
					hue = (r - g) / delta + 4;
					break;
			}
			hue /= 6;
		}
		target.h = hue;
		target.s = saturation;
		target.l = lightness;
		return target;
	}
	getRGB(target, colorSpace = LinearSRGBColorSpace) {
		ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
		target.r = _rgb.r;
		target.g = _rgb.g;
		target.b = _rgb.b;
		return target;
	}
	getStyle(colorSpace = SRGBColorSpace) {
		ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
		if (colorSpace !== SRGBColorSpace) {
			// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
			return `color(${colorSpace} ${_rgb.r} ${_rgb.g} ${_rgb.b})`;
		}
		return `rgb(${_rgb.r * 255 | 0},${_rgb.g * 255 | 0},${_rgb.b * 255 | 0})`;
	}
	offsetHSL(h, s, l) {
		this.getHSL(_hslA);
		_hslA.h += h;
		_hslA.s += s;
		_hslA.l += l;
		this.setHSL(_hslA.h, _hslA.s, _hslA.l);
		return this;
	}
	add(color) {
		this.r += color.r;
		this.g += color.g;
		this.b += color.b;
		return this;
	}
	addColors(color1, color2) {
		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;
		return this;
	}
	addScalar(s) {
		this.r += s;
		this.g += s;
		this.b += s;
		return this;
	}
	sub(color) {
		this.r = Math.max(0, this.r - color.r);
		this.g = Math.max(0, this.g - color.g);
		this.b = Math.max(0, this.b - color.b);
		return this;
	}
	multiply(color) {
		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;
		return this;
	}
	multiplyScalar(s) {
		this.r *= s;
		this.g *= s;
		this.b *= s;
		return this;
	}
	lerp(color, alpha) {
		this.r += (color.r - this.r) * alpha;
		this.g += (color.g - this.g) * alpha;
		this.b += (color.b - this.b) * alpha;
		return this;
	}
	lerpColors(color1, color2, alpha) {
		this.r = color1.r + (color2.r - color1.r) * alpha;
		this.g = color1.g + (color2.g - color1.g) * alpha;
		this.b = color1.b + (color2.b - color1.b) * alpha;
		return this;
	}
	lerpHSL(color, alpha) {
		this.getHSL(_hslA);
		color.getHSL(_hslB);
		const h = lerp(_hslA.h, _hslB.h, alpha);
		const s = lerp(_hslA.s, _hslB.s, alpha);
		const l = lerp(_hslA.l, _hslB.l, alpha);
		this.setHSL(h, s, l);
		return this;
	}
	equals(c) {
		return c.r === this.r && c.g === this.g && c.b === this.b;
	}
	fromArray(array, offset = 0) {
		this.r = array[offset];
		this.g = array[offset + 1];
		this.b = array[offset + 2];
		return this;
	}
	toArray(array = [], offset = 0) {
		array[offset] = this.r;
		array[offset + 1] = this.g;
		array[offset + 2] = this.b;
		return array;
	}
	fromBufferAttribute(attribute, index) {
		this.r = attribute.getX(index);
		this.g = attribute.getY(index);
		this.b = attribute.getZ(index);
		return this;
	}
	toJSON() {
		return this.getHex();
	}
	*[Symbol.iterator]() {
		yield this.r;
		yield this.g;
		yield this.b;
	}
}
Color$1.NAMES = _colorKeywords;

let _canvas;
class ImageUtils {
	static getDataURL(image) {
		if (/^data:/i.test(image.src)) {
			return image.src;
		}
		if (typeof HTMLCanvasElement == 'undefined') {
			return image.src;
		}
		let canvas;
		if (image instanceof HTMLCanvasElement) {
			canvas = image;
		} else {
			if (_canvas === undefined) _canvas = createElementNS('canvas');
			_canvas.width = image.width;
			_canvas.height = image.height;
			const context = _canvas.getContext('2d');
			if (image instanceof ImageData) {
				context.putImageData(image, 0, 0);
			} else {
				context.drawImage(image, 0, 0, image.width, image.height);
			}
			canvas = _canvas;
		}
		if (canvas.width > 2048 || canvas.height > 2048) {
			console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);
			return canvas.toDataURL('image/jpeg', 0.6);
		} else {
			return canvas.toDataURL('image/png');
		}
	}
	static sRGBToLinear(image) {
		if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
			const canvas = createElementNS('canvas');
			canvas.width = image.width;
			canvas.height = image.height;
			const context = canvas.getContext('2d');
			context.drawImage(image, 0, 0, image.width, image.height);
			const imageData = context.getImageData(0, 0, image.width, image.height);
			const data = imageData.data;
			for (let i = 0; i < data.length; i++) {
				data[i] = SRGBToLinear(data[i] / 255) * 255;
			}
			context.putImageData(imageData, 0, 0);
			return canvas;
		} else if (image.data) {
			const data = image.data.slice(0);
			for (let i = 0; i < data.length; i++) {
				if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
					data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);
				} else {
					// assuming float

					data[i] = SRGBToLinear(data[i]);
				}
			}
			return {
				data: data,
				width: image.width,
				height: image.height
			};
		} else {
			console.warn('THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.');
			return image;
		}
	}
}

class Source {
	constructor(data = null) {
		this.isSource = true;
		this.uuid = generateUUID();
		this.data = data;
		this.version = 0;
	}
	set needsUpdate(value) {
		if (value === true) this.version++;
	}
	toJSON(meta) {
		const isRootObject = meta === undefined || typeof meta === 'string';
		if (!isRootObject && meta.images[this.uuid] !== undefined) {
			return meta.images[this.uuid];
		}
		const output = {
			uuid: this.uuid,
			url: ''
		};
		const data = this.data;
		if (data !== null) {
			let url;
			if (Array.isArray(data)) {
				// cube texture

				url = [];
				for (let i = 0, l = data.length; i < l; i++) {
					if (data[i].isDataTexture) {
						url.push(serializeImage(data[i].image));
					} else {
						url.push(serializeImage(data[i]));
					}
				}
			} else {
				// texture

				url = serializeImage(data);
			}
			output.url = url;
		}
		if (!isRootObject) {
			meta.images[this.uuid] = output;
		}
		return output;
	}
}
function serializeImage(image) {
	if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
		// default images

		return ImageUtils.getDataURL(image);
	} else {
		if (image.data) {
			// images of DataTexture

			return {
				data: Array.from(image.data),
				width: image.width,
				height: image.height,
				type: image.data.constructor.name
			};
		} else {
			console.warn('THREE.Texture: Unable to serialize Texture.');
			return {};
		}
	}
}

let textureId = 0;
class Texture extends EventDispatcher {
	constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
		super();
		this.isTexture = true;
		Object.defineProperty(this, 'id', {
			value: textureId++
		});
		this.uuid = generateUUID();
		this.name = '';
		this.source = new Source(image);
		this.mipmaps = [];
		this.mapping = mapping;
		this.wrapS = wrapS;
		this.wrapT = wrapT;
		this.magFilter = magFilter;
		this.minFilter = minFilter;
		this.anisotropy = anisotropy;
		this.format = format;
		this.internalFormat = null;
		this.type = type;
		this.offset = new Vector2(0, 0);
		this.repeat = new Vector2(1, 1);
		this.center = new Vector2(0, 0);
		this.rotation = 0;
		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();
		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding;
		this.userData = {};
		this.version = 0;
		this.onUpdate = null;
		this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
		this.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)
	}

	get image() {
		return this.source.data;
	}
	set image(value) {
		this.source.data = value;
	}
	updateMatrix() {
		this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(source) {
		this.name = source.name;
		this.source = source.source;
		this.mipmaps = source.mipmaps.slice(0);
		this.mapping = source.mapping;
		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;
		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;
		this.anisotropy = source.anisotropy;
		this.format = source.format;
		this.internalFormat = source.internalFormat;
		this.type = source.type;
		this.offset.copy(source.offset);
		this.repeat.copy(source.repeat);
		this.center.copy(source.center);
		this.rotation = source.rotation;
		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy(source.matrix);
		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;
		this.userData = JSON.parse(JSON.stringify(source.userData));
		this.needsUpdate = true;
		return this;
	}
	toJSON(meta) {
		const isRootObject = meta === undefined || typeof meta === 'string';
		if (!isRootObject && meta.textures[this.uuid] !== undefined) {
			return meta.textures[this.uuid];
		}
		const output = {
			metadata: {
				version: 4.5,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},
			uuid: this.uuid,
			name: this.name,
			image: this.source.toJSON(meta).uuid,
			mapping: this.mapping,
			repeat: [this.repeat.x, this.repeat.y],
			offset: [this.offset.x, this.offset.y],
			center: [this.center.x, this.center.y],
			rotation: this.rotation,
			wrap: [this.wrapS, this.wrapT],
			format: this.format,
			type: this.type,
			encoding: this.encoding,
			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,
			flipY: this.flipY,
			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment
		};
		if (JSON.stringify(this.userData) !== '{}') output.userData = this.userData;
		if (!isRootObject) {
			meta.textures[this.uuid] = output;
		}
		return output;
	}
	dispose() {
		this.dispatchEvent({
			type: 'dispose'
		});
	}
	transformUv(uv) {
		if (this.mapping !== UVMapping) return uv;
		uv.applyMatrix3(this.matrix);
		if (uv.x < 0 || uv.x > 1) {
			switch (this.wrapS) {
				case RepeatWrapping:
					uv.x = uv.x - Math.floor(uv.x);
					break;
				case ClampToEdgeWrapping:
					uv.x = uv.x < 0 ? 0 : 1;
					break;
				case MirroredRepeatWrapping:
					if (Math.abs(Math.floor(uv.x) % 2) === 1) {
						uv.x = Math.ceil(uv.x) - uv.x;
					} else {
						uv.x = uv.x - Math.floor(uv.x);
					}
					break;
			}
		}
		if (uv.y < 0 || uv.y > 1) {
			switch (this.wrapT) {
				case RepeatWrapping:
					uv.y = uv.y - Math.floor(uv.y);
					break;
				case ClampToEdgeWrapping:
					uv.y = uv.y < 0 ? 0 : 1;
					break;
				case MirroredRepeatWrapping:
					if (Math.abs(Math.floor(uv.y) % 2) === 1) {
						uv.y = Math.ceil(uv.y) - uv.y;
					} else {
						uv.y = uv.y - Math.floor(uv.y);
					}
					break;
			}
		}
		if (this.flipY) {
			uv.y = 1 - uv.y;
		}
		return uv;
	}
	set needsUpdate(value) {
		if (value === true) {
			this.version++;
			this.source.needsUpdate = true;
		}
	}
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;

class Vector4 {
	constructor(x = 0, y = 0, z = 0, w = 1) {
		Vector4.prototype.isVector4 = true;
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
	}
	get width() {
		return this.z;
	}
	set width(value) {
		this.z = value;
	}
	get height() {
		return this.w;
	}
	set height(value) {
		this.w = value;
	}
	set(x, y, z, w) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
		return this;
	}
	setScalar(scalar) {
		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;
		return this;
	}
	setX(x) {
		this.x = x;
		return this;
	}
	setY(y) {
		this.y = y;
		return this;
	}
	setZ(z) {
		this.z = z;
		return this;
	}
	setW(w) {
		this.w = w;
		return this;
	}
	setComponent(index, value) {
		switch (index) {
			case 0:
				this.x = value;
				break;
			case 1:
				this.y = value;
				break;
			case 2:
				this.z = value;
				break;
			case 3:
				this.w = value;
				break;
			default:
				throw new Error('index is out of range: ' + index);
		}
		return this;
	}
	getComponent(index) {
		switch (index) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			case 2:
				return this.z;
			case 3:
				return this.w;
			default:
				throw new Error('index is out of range: ' + index);
		}
	}
	clone() {
		return new this.constructor(this.x, this.y, this.z, this.w);
	}
	copy(v) {
		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = v.w !== undefined ? v.w : 1;
		return this;
	}
	add(v) {
		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;
		return this;
	}
	addScalar(s) {
		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;
		return this;
	}
	addVectors(a, b) {
		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;
		return this;
	}
	addScaledVector(v, s) {
		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;
		return this;
	}
	sub(v) {
		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;
		return this;
	}
	subScalar(s) {
		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;
		return this;
	}
	subVectors(a, b) {
		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;
		return this;
	}
	multiply(v) {
		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		this.w *= v.w;
		return this;
	}
	multiplyScalar(scalar) {
		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;
		return this;
	}
	applyMatrix4(m) {
		const x = this.x,
			y = this.y,
			z = this.z,
			w = this.w;
		const e = m.elements;
		this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
		this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
		this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
		this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
		return this;
	}
	divideScalar(scalar) {
		return this.multiplyScalar(1 / scalar);
	}
	setAxisAngleFromQuaternion(q) {
		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos(q.w);
		const s = Math.sqrt(1 - q.w * q.w);
		if (s < 0.0001) {
			this.x = 1;
			this.y = 0;
			this.z = 0;
		} else {
			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;
		}
		return this;
	}
	setAxisAngleFromRotationMatrix(m) {
		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		let angle, x, y, z; // variables for result
		const epsilon = 0.01,
			// margin to allow for rounding errors
			epsilon2 = 0.1,
			// margin to distinguish between 0 and 180 degrees

			te = m.elements,
			m11 = te[0],
			m12 = te[4],
			m13 = te[8],
			m21 = te[1],
			m22 = te[5],
			m23 = te[9],
			m31 = te[2],
			m32 = te[6],
			m33 = te[10];
		if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
				// this singularity is identity matrix so angle = 0

				this.set(1, 0, 0, 0);
				return this; // zero angle, arbitrary axis
			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;
			const xx = (m11 + 1) / 2;
			const yy = (m22 + 1) / 2;
			const zz = (m33 + 1) / 2;
			const xy = (m12 + m21) / 4;
			const xz = (m13 + m31) / 4;
			const yz = (m23 + m32) / 4;
			if (xx > yy && xx > zz) {
				// m11 is the largest diagonal term

				if (xx < epsilon) {
					x = 0;
					y = 0.707106781;
					z = 0.707106781;
				} else {
					x = Math.sqrt(xx);
					y = xy / x;
					z = xz / x;
				}
			} else if (yy > zz) {
				// m22 is the largest diagonal term

				if (yy < epsilon) {
					x = 0.707106781;
					y = 0;
					z = 0.707106781;
				} else {
					y = Math.sqrt(yy);
					x = xy / y;
					z = yz / y;
				}
			} else {
				// m33 is the largest diagonal term so base result on this

				if (zz < epsilon) {
					x = 0.707106781;
					y = 0.707106781;
					z = 0;
				} else {
					z = Math.sqrt(zz);
					x = xz / z;
					y = yz / z;
				}
			}
			this.set(x, y, z, angle);
			return this; // return 180 deg rotation
		}

		// as we have reached here there are no singularities so we can handle normally

		let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

		if (Math.abs(s) < 0.001) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = (m32 - m23) / s;
		this.y = (m13 - m31) / s;
		this.z = (m21 - m12) / s;
		this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
		return this;
	}
	min(v) {
		this.x = Math.min(this.x, v.x);
		this.y = Math.min(this.y, v.y);
		this.z = Math.min(this.z, v.z);
		this.w = Math.min(this.w, v.w);
		return this;
	}
	max(v) {
		this.x = Math.max(this.x, v.x);
		this.y = Math.max(this.y, v.y);
		this.z = Math.max(this.z, v.z);
		this.w = Math.max(this.w, v.w);
		return this;
	}
	clamp(min, max) {
		// assumes min < max, componentwise

		this.x = Math.max(min.x, Math.min(max.x, this.x));
		this.y = Math.max(min.y, Math.min(max.y, this.y));
		this.z = Math.max(min.z, Math.min(max.z, this.z));
		this.w = Math.max(min.w, Math.min(max.w, this.w));
		return this;
	}
	clampScalar(minVal, maxVal) {
		this.x = Math.max(minVal, Math.min(maxVal, this.x));
		this.y = Math.max(minVal, Math.min(maxVal, this.y));
		this.z = Math.max(minVal, Math.min(maxVal, this.z));
		this.w = Math.max(minVal, Math.min(maxVal, this.w));
		return this;
	}
	clampLength(min, max) {
		const length = this.length();
		return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
	}
	floor() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		this.z = Math.floor(this.z);
		this.w = Math.floor(this.w);
		return this;
	}
	ceil() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		this.z = Math.ceil(this.z);
		this.w = Math.ceil(this.w);
		return this;
	}
	round() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		this.z = Math.round(this.z);
		this.w = Math.round(this.w);
		return this;
	}
	roundToZero() {
		this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
		this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
		this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
		this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
		return this;
	}
	negate() {
		this.x = -this.x;
		this.y = -this.y;
		this.z = -this.z;
		this.w = -this.w;
		return this;
	}
	dot(v) {
		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
	}
	normalize() {
		return this.divideScalar(this.length() || 1);
	}
	setLength(length) {
		return this.normalize().multiplyScalar(length);
	}
	lerp(v, alpha) {
		this.x += (v.x - this.x) * alpha;
		this.y += (v.y - this.y) * alpha;
		this.z += (v.z - this.z) * alpha;
		this.w += (v.w - this.w) * alpha;
		return this;
	}
	lerpVectors(v1, v2, alpha) {
		this.x = v1.x + (v2.x - v1.x) * alpha;
		this.y = v1.y + (v2.y - v1.y) * alpha;
		this.z = v1.z + (v2.z - v1.z) * alpha;
		this.w = v1.w + (v2.w - v1.w) * alpha;
		return this;
	}
	equals(v) {
		return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
	}
	fromArray(array, offset = 0) {
		this.x = array[offset];
		this.y = array[offset + 1];
		this.z = array[offset + 2];
		this.w = array[offset + 3];
		return this;
	}
	toArray(array = [], offset = 0) {
		array[offset] = this.x;
		array[offset + 1] = this.y;
		array[offset + 2] = this.z;
		array[offset + 3] = this.w;
		return array;
	}
	fromBufferAttribute(attribute, index) {
		this.x = attribute.getX(index);
		this.y = attribute.getY(index);
		this.z = attribute.getZ(index);
		this.w = attribute.getW(index);
		return this;
	}
	random() {
		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		this.w = Math.random();
		return this;
	}
	*[Symbol.iterator]() {
		yield this.x;
		yield this.y;
		yield this.z;
		yield this.w;
	}
}

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
class WebGLRenderTarget extends EventDispatcher {
	constructor(width = 1, height = 1, options = {}) {
		super();
		this.isWebGLRenderTarget = true;
		this.width = width;
		this.height = height;
		this.depth = 1;
		this.scissor = new Vector4(0, 0, width, height);
		this.scissorTest = false;
		this.viewport = new Vector4(0, 0, width, height);
		const image = {
			width: width,
			height: height,
			depth: 1
		};
		this.texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
		this.texture.isRenderTargetTexture = true;
		this.texture.flipY = false;
		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
		this.samples = options.samples !== undefined ? options.samples : 0;
	}
	setSize(width, height, depth = 1) {
		if (this.width !== width || this.height !== height || this.depth !== depth) {
			this.width = width;
			this.height = height;
			this.depth = depth;
			this.texture.image.width = width;
			this.texture.image.height = height;
			this.texture.image.depth = depth;
			this.dispose();
		}
		this.viewport.set(0, 0, width, height);
		this.scissor.set(0, 0, width, height);
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(source) {
		this.width = source.width;
		this.height = source.height;
		this.depth = source.depth;
		this.viewport.copy(source.viewport);
		this.texture = source.texture.clone();
		this.texture.isRenderTargetTexture = true;

		// ensure image object is not shared, see #20328

		const image = Object.assign({}, source.texture.image);
		this.texture.source = new Source(image);
		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
		this.samples = source.samples;
		return this;
	}
	dispose() {
		this.dispatchEvent({
			type: 'dispose'
		});
	}
}

class Quaternion {
	constructor(x = 0, y = 0, z = 0, w = 1) {
		this.isQuaternion = true;
		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;
	}
	static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
		// fuzz-free, array-based Quaternion SLERP operation

		let x0 = src0[srcOffset0 + 0],
			y0 = src0[srcOffset0 + 1],
			z0 = src0[srcOffset0 + 2],
			w0 = src0[srcOffset0 + 3];
		const x1 = src1[srcOffset1 + 0],
			y1 = src1[srcOffset1 + 1],
			z1 = src1[srcOffset1 + 2],
			w1 = src1[srcOffset1 + 3];
		if (t === 0) {
			dst[dstOffset + 0] = x0;
			dst[dstOffset + 1] = y0;
			dst[dstOffset + 2] = z0;
			dst[dstOffset + 3] = w0;
			return;
		}
		if (t === 1) {
			dst[dstOffset + 0] = x1;
			dst[dstOffset + 1] = y1;
			dst[dstOffset + 2] = z1;
			dst[dstOffset + 3] = w1;
			return;
		}
		if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
			let s = 1 - t;
			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = cos >= 0 ? 1 : -1,
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if (sqrSin > Number.EPSILON) {
				const sin = Math.sqrt(sqrSin),
					len = Math.atan2(sin, cos * dir);
				s = Math.sin(s * len) / sin;
				t = Math.sin(t * len) / sin;
			}
			const tDir = t * dir;
			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if (s === 1 - t) {
				const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;
			}
		}
		dst[dstOffset] = x0;
		dst[dstOffset + 1] = y0;
		dst[dstOffset + 2] = z0;
		dst[dstOffset + 3] = w0;
	}
	static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
		const x0 = src0[srcOffset0];
		const y0 = src0[srcOffset0 + 1];
		const z0 = src0[srcOffset0 + 2];
		const w0 = src0[srcOffset0 + 3];
		const x1 = src1[srcOffset1];
		const y1 = src1[srcOffset1 + 1];
		const z1 = src1[srcOffset1 + 2];
		const w1 = src1[srcOffset1 + 3];
		dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
		return dst;
	}
	get x() {
		return this._x;
	}
	set x(value) {
		this._x = value;
		this._onChangeCallback();
	}
	get y() {
		return this._y;
	}
	set y(value) {
		this._y = value;
		this._onChangeCallback();
	}
	get z() {
		return this._z;
	}
	set z(value) {
		this._z = value;
		this._onChangeCallback();
	}
	get w() {
		return this._w;
	}
	set w(value) {
		this._w = value;
		this._onChangeCallback();
	}
	set(x, y, z, w) {
		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;
		this._onChangeCallback();
		return this;
	}
	clone() {
		return new this.constructor(this._x, this._y, this._z, this._w);
	}
	copy(quaternion) {
		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;
		this._onChangeCallback();
		return this;
	}
	setFromEuler(euler, update) {
		const x = euler._x,
			y = euler._y,
			z = euler._z,
			order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;
		const c1 = cos(x / 2);
		const c2 = cos(y / 2);
		const c3 = cos(z / 2);
		const s1 = sin(x / 2);
		const s2 = sin(y / 2);
		const s3 = sin(z / 2);
		switch (order) {
			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;
			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;
			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;
			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;
			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;
			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;
			default:
				console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
		}
		if (update !== false) this._onChangeCallback();
		return this;
	}
	setFromAxisAngle(axis, angle) {
		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		const halfAngle = angle / 2,
			s = Math.sin(halfAngle);
		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos(halfAngle);
		this._onChangeCallback();
		return this;
	}
	setFromRotationMatrix(m) {
		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,
			m11 = te[0],
			m12 = te[4],
			m13 = te[8],
			m21 = te[1],
			m22 = te[5],
			m23 = te[9],
			m31 = te[2],
			m32 = te[6],
			m33 = te[10],
			trace = m11 + m22 + m33;
		if (trace > 0) {
			const s = 0.5 / Math.sqrt(trace + 1.0);
			this._w = 0.25 / s;
			this._x = (m32 - m23) * s;
			this._y = (m13 - m31) * s;
			this._z = (m21 - m12) * s;
		} else if (m11 > m22 && m11 > m33) {
			const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
			this._w = (m32 - m23) / s;
			this._x = 0.25 * s;
			this._y = (m12 + m21) / s;
			this._z = (m13 + m31) / s;
		} else if (m22 > m33) {
			const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
			this._w = (m13 - m31) / s;
			this._x = (m12 + m21) / s;
			this._y = 0.25 * s;
			this._z = (m23 + m32) / s;
		} else {
			const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
			this._w = (m21 - m12) / s;
			this._x = (m13 + m31) / s;
			this._y = (m23 + m32) / s;
			this._z = 0.25 * s;
		}
		this._onChangeCallback();
		return this;
	}
	setFromUnitVectors(vFrom, vTo) {
		// assumes direction vectors vFrom and vTo are normalized

		let r = vFrom.dot(vTo) + 1;
		if (r < Number.EPSILON) {
			// vFrom and vTo point in opposite directions

			r = 0;
			if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
				this._x = -vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;
			} else {
				this._x = 0;
				this._y = -vFrom.z;
				this._z = vFrom.y;
				this._w = r;
			}
		} else {
			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;
		}
		return this.normalize();
	}
	angleTo(q) {
		return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
	}
	rotateTowards(q, step) {
		const angle = this.angleTo(q);
		if (angle === 0) return this;
		const t = Math.min(1, step / angle);
		this.slerp(q, t);
		return this;
	}
	identity() {
		return this.set(0, 0, 0, 1);
	}
	invert() {
		// quaternion is assumed to have unit length

		return this.conjugate();
	}
	conjugate() {
		this._x *= -1;
		this._y *= -1;
		this._z *= -1;
		this._onChangeCallback();
		return this;
	}
	dot(v) {
		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
	}
	lengthSq() {
		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	}
	length() {
		return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
	}
	normalize() {
		let l = this.length();
		if (l === 0) {
			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;
		} else {
			l = 1 / l;
			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;
		}
		this._onChangeCallback();
		return this;
	}
	multiply(q) {
		return this.multiplyQuaternions(this, q);
	}
	premultiply(q) {
		return this.multiplyQuaternions(q, this);
	}
	multiplyQuaternions(a, b) {
		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x,
			qay = a._y,
			qaz = a._z,
			qaw = a._w;
		const qbx = b._x,
			qby = b._y,
			qbz = b._z,
			qbw = b._w;
		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
		this._onChangeCallback();
		return this;
	}
	slerp(qb, t) {
		if (t === 0) return this;
		if (t === 1) return this.copy(qb);
		const x = this._x,
			y = this._y,
			z = this._z,
			w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
		if (cosHalfTheta < 0) {
			this._w = -qb._w;
			this._x = -qb._x;
			this._y = -qb._y;
			this._z = -qb._z;
			cosHalfTheta = -cosHalfTheta;
		} else {
			this.copy(qb);
		}
		if (cosHalfTheta >= 1.0) {
			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;
			return this;
		}
		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
		if (sqrSinHalfTheta <= Number.EPSILON) {
			const s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;
			this.normalize();
			this._onChangeCallback();
			return this;
		}
		const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
		const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
		const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
			ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
		this._w = w * ratioA + this._w * ratioB;
		this._x = x * ratioA + this._x * ratioB;
		this._y = y * ratioA + this._y * ratioB;
		this._z = z * ratioA + this._z * ratioB;
		this._onChangeCallback();
		return this;
	}
	slerpQuaternions(qa, qb, t) {
		return this.copy(qa).slerp(qb, t);
	}
	random() {
		// Derived from http://planning.cs.uiuc.edu/node198.html
		// Note, this source uses w, x, y, z ordering,
		// so we swap the order below.

		const u1 = Math.random();
		const sqrt1u1 = Math.sqrt(1 - u1);
		const sqrtu1 = Math.sqrt(u1);
		const u2 = 2 * Math.PI * Math.random();
		const u3 = 2 * Math.PI * Math.random();
		return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
	}
	equals(quaternion) {
		return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
	}
	fromArray(array, offset = 0) {
		this._x = array[offset];
		this._y = array[offset + 1];
		this._z = array[offset + 2];
		this._w = array[offset + 3];
		this._onChangeCallback();
		return this;
	}
	toArray(array = [], offset = 0) {
		array[offset] = this._x;
		array[offset + 1] = this._y;
		array[offset + 2] = this._z;
		array[offset + 3] = this._w;
		return array;
	}
	fromBufferAttribute(attribute, index) {
		this._x = attribute.getX(index);
		this._y = attribute.getY(index);
		this._z = attribute.getZ(index);
		this._w = attribute.getW(index);
		return this;
	}
	_onChange(callback) {
		this._onChangeCallback = callback;
		return this;
	}
	_onChangeCallback() {}
	*[Symbol.iterator]() {
		yield this._x;
		yield this._y;
		yield this._z;
		yield this._w;
	}
}

class Vector3 {
	constructor(x = 0, y = 0, z = 0) {
		Vector3.prototype.isVector3 = true;
		this.x = x;
		this.y = y;
		this.z = z;
	}
	set(x, y, z) {
		if (z === undefined) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;
		return this;
	}
	setScalar(scalar) {
		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		return this;
	}
	setX(x) {
		this.x = x;
		return this;
	}
	setY(y) {
		this.y = y;
		return this;
	}
	setZ(z) {
		this.z = z;
		return this;
	}
	setComponent(index, value) {
		switch (index) {
			case 0:
				this.x = value;
				break;
			case 1:
				this.y = value;
				break;
			case 2:
				this.z = value;
				break;
			default:
				throw new Error('index is out of range: ' + index);
		}
		return this;
	}
	getComponent(index) {
		switch (index) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			case 2:
				return this.z;
			default:
				throw new Error('index is out of range: ' + index);
		}
	}
	clone() {
		return new this.constructor(this.x, this.y, this.z);
	}
	copy(v) {
		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		return this;
	}
	add(v) {
		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		return this;
	}
	addScalar(s) {
		this.x += s;
		this.y += s;
		this.z += s;
		return this;
	}
	addVectors(a, b) {
		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		return this;
	}
	addScaledVector(v, s) {
		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		return this;
	}
	sub(v) {
		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		return this;
	}
	subScalar(s) {
		this.x -= s;
		this.y -= s;
		this.z -= s;
		return this;
	}
	subVectors(a, b) {
		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		return this;
	}
	multiply(v) {
		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		return this;
	}
	multiplyScalar(scalar) {
		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		return this;
	}
	multiplyVectors(a, b) {
		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;
		return this;
	}
	applyEuler(euler) {
		return this.applyQuaternion(_quaternion$2.setFromEuler(euler));
	}
	applyAxisAngle(axis, angle) {
		return this.applyQuaternion(_quaternion$2.setFromAxisAngle(axis, angle));
	}
	applyMatrix3(m) {
		const x = this.x,
			y = this.y,
			z = this.z;
		const e = m.elements;
		this.x = e[0] * x + e[3] * y + e[6] * z;
		this.y = e[1] * x + e[4] * y + e[7] * z;
		this.z = e[2] * x + e[5] * y + e[8] * z;
		return this;
	}
	applyNormalMatrix(m) {
		return this.applyMatrix3(m).normalize();
	}
	applyMatrix4(m) {
		const x = this.x,
			y = this.y,
			z = this.z;
		const e = m.elements;
		const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
		this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
		this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
		this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
		return this;
	}
	applyQuaternion(q) {
		const x = this.x,
			y = this.y,
			z = this.z;
		const qx = q.x,
			qy = q.y,
			qz = q.z,
			qw = q.w;

		// calculate quat * vector

		const ix = qw * x + qy * z - qz * y;
		const iy = qw * y + qz * x - qx * z;
		const iz = qw * z + qx * y - qy * x;
		const iw = -qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
		this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
		this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
		return this;
	}
	project(camera) {
		return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
	}
	unproject(camera) {
		return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
	}
	transformDirection(m) {
		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x,
			y = this.y,
			z = this.z;
		const e = m.elements;
		this.x = e[0] * x + e[4] * y + e[8] * z;
		this.y = e[1] * x + e[5] * y + e[9] * z;
		this.z = e[2] * x + e[6] * y + e[10] * z;
		return this.normalize();
	}
	divide(v) {
		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;
		return this;
	}
	divideScalar(scalar) {
		return this.multiplyScalar(1 / scalar);
	}
	min(v) {
		this.x = Math.min(this.x, v.x);
		this.y = Math.min(this.y, v.y);
		this.z = Math.min(this.z, v.z);
		return this;
	}
	max(v) {
		this.x = Math.max(this.x, v.x);
		this.y = Math.max(this.y, v.y);
		this.z = Math.max(this.z, v.z);
		return this;
	}
	clamp(min, max) {
		// assumes min < max, componentwise

		this.x = Math.max(min.x, Math.min(max.x, this.x));
		this.y = Math.max(min.y, Math.min(max.y, this.y));
		this.z = Math.max(min.z, Math.min(max.z, this.z));
		return this;
	}
	clampScalar(minVal, maxVal) {
		this.x = Math.max(minVal, Math.min(maxVal, this.x));
		this.y = Math.max(minVal, Math.min(maxVal, this.y));
		this.z = Math.max(minVal, Math.min(maxVal, this.z));
		return this;
	}
	clampLength(min, max) {
		const length = this.length();
		return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
	}
	floor() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		this.z = Math.floor(this.z);
		return this;
	}
	ceil() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		this.z = Math.ceil(this.z);
		return this;
	}
	round() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		this.z = Math.round(this.z);
		return this;
	}
	roundToZero() {
		this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
		this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
		this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
		return this;
	}
	negate() {
		this.x = -this.x;
		this.y = -this.y;
		this.z = -this.z;
		return this;
	}
	dot(v) {
		return this.x * v.x + this.y * v.y + this.z * v.z;
	}

	// TODO lengthSquared?

	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z;
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
	}
	normalize() {
		return this.divideScalar(this.length() || 1);
	}
	setLength(length) {
		return this.normalize().multiplyScalar(length);
	}
	lerp(v, alpha) {
		this.x += (v.x - this.x) * alpha;
		this.y += (v.y - this.y) * alpha;
		this.z += (v.z - this.z) * alpha;
		return this;
	}
	lerpVectors(v1, v2, alpha) {
		this.x = v1.x + (v2.x - v1.x) * alpha;
		this.y = v1.y + (v2.y - v1.y) * alpha;
		this.z = v1.z + (v2.z - v1.z) * alpha;
		return this;
	}
	cross(v) {
		return this.crossVectors(this, v);
	}
	crossVectors(a, b) {
		const ax = a.x,
			ay = a.y,
			az = a.z;
		const bx = b.x,
			by = b.y,
			bz = b.z;
		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;
		return this;
	}
	projectOnVector(v) {
		const denominator = v.lengthSq();
		if (denominator === 0) return this.set(0, 0, 0);
		const scalar = v.dot(this) / denominator;
		return this.copy(v).multiplyScalar(scalar);
	}
	projectOnPlane(planeNormal) {
		_vector$c.copy(this).projectOnVector(planeNormal);
		return this.sub(_vector$c);
	}
	reflect(normal) {
		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
	}
	angleTo(v) {
		const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
		if (denominator === 0) return Math.PI / 2;
		const theta = this.dot(v) / denominator;

		// clamp, to handle numerical problems

		return Math.acos(clamp(theta, -1, 1));
	}
	distanceTo(v) {
		return Math.sqrt(this.distanceToSquared(v));
	}
	distanceToSquared(v) {
		const dx = this.x - v.x,
			dy = this.y - v.y,
			dz = this.z - v.z;
		return dx * dx + dy * dy + dz * dz;
	}
	manhattanDistanceTo(v) {
		return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
	}
	setFromSpherical(s) {
		return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
	}
	setFromSphericalCoords(radius, phi, theta) {
		const sinPhiRadius = Math.sin(phi) * radius;
		this.x = sinPhiRadius * Math.sin(theta);
		this.y = Math.cos(phi) * radius;
		this.z = sinPhiRadius * Math.cos(theta);
		return this;
	}
	setFromCylindrical(c) {
		return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
	}
	setFromCylindricalCoords(radius, theta, y) {
		this.x = radius * Math.sin(theta);
		this.y = y;
		this.z = radius * Math.cos(theta);
		return this;
	}
	setFromMatrixPosition(m) {
		const e = m.elements;
		this.x = e[12];
		this.y = e[13];
		this.z = e[14];
		return this;
	}
	setFromMatrixScale(m) {
		const sx = this.setFromMatrixColumn(m, 0).length();
		const sy = this.setFromMatrixColumn(m, 1).length();
		const sz = this.setFromMatrixColumn(m, 2).length();
		this.x = sx;
		this.y = sy;
		this.z = sz;
		return this;
	}
	setFromMatrixColumn(m, index) {
		return this.fromArray(m.elements, index * 4);
	}
	setFromMatrix3Column(m, index) {
		return this.fromArray(m.elements, index * 3);
	}
	setFromEuler(e) {
		this.x = e._x;
		this.y = e._y;
		this.z = e._z;
		return this;
	}
	equals(v) {
		return v.x === this.x && v.y === this.y && v.z === this.z;
	}
	fromArray(array, offset = 0) {
		this.x = array[offset];
		this.y = array[offset + 1];
		this.z = array[offset + 2];
		return this;
	}
	toArray(array = [], offset = 0) {
		array[offset] = this.x;
		array[offset + 1] = this.y;
		array[offset + 2] = this.z;
		return array;
	}
	fromBufferAttribute(attribute, index) {
		this.x = attribute.getX(index);
		this.y = attribute.getY(index);
		this.z = attribute.getZ(index);
		return this;
	}
	random() {
		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		return this;
	}
	randomDirection() {
		// Derived from https://mathworld.wolfram.com/SpherePointPicking.html

		const u = (Math.random() - 0.5) * 2;
		const t = Math.random() * Math.PI * 2;
		const f = Math.sqrt(1 - u ** 2);
		this.x = f * Math.cos(t);
		this.y = f * Math.sin(t);
		this.z = u;
		return this;
	}
	*[Symbol.iterator]() {
		yield this.x;
		yield this.y;
		yield this.z;
	}
}
const _vector$c = /*@__PURE__*/new Vector3();
const _quaternion$2 = /*@__PURE__*/new Quaternion();

class Box3 {
	constructor(min = new Vector3(+Infinity, +Infinity, +Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
		this.isBox3 = true;
		this.min = min;
		this.max = max;
	}
	set(min, max) {
		this.min.copy(min);
		this.max.copy(max);
		return this;
	}
	setFromArray(array) {
		let minX = +Infinity;
		let minY = +Infinity;
		let minZ = +Infinity;
		let maxX = -Infinity;
		let maxY = -Infinity;
		let maxZ = -Infinity;
		for (let i = 0, l = array.length; i < l; i += 3) {
			const x = array[i];
			const y = array[i + 1];
			const z = array[i + 2];
			if (x < minX) minX = x;
			if (y < minY) minY = y;
			if (z < minZ) minZ = z;
			if (x > maxX) maxX = x;
			if (y > maxY) maxY = y;
			if (z > maxZ) maxZ = z;
		}
		this.min.set(minX, minY, minZ);
		this.max.set(maxX, maxY, maxZ);
		return this;
	}
	setFromBufferAttribute(attribute) {
		let minX = +Infinity;
		let minY = +Infinity;
		let minZ = +Infinity;
		let maxX = -Infinity;
		let maxY = -Infinity;
		let maxZ = -Infinity;
		for (let i = 0, l = attribute.count; i < l; i++) {
			const x = attribute.getX(i);
			const y = attribute.getY(i);
			const z = attribute.getZ(i);
			if (x < minX) minX = x;
			if (y < minY) minY = y;
			if (z < minZ) minZ = z;
			if (x > maxX) maxX = x;
			if (y > maxY) maxY = y;
			if (z > maxZ) maxZ = z;
		}
		this.min.set(minX, minY, minZ);
		this.max.set(maxX, maxY, maxZ);
		return this;
	}
	setFromPoints(points) {
		this.makeEmpty();
		for (let i = 0, il = points.length; i < il; i++) {
			this.expandByPoint(points[i]);
		}
		return this;
	}
	setFromCenterAndSize(center, size) {
		const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
		this.min.copy(center).sub(halfSize);
		this.max.copy(center).add(halfSize);
		return this;
	}
	setFromObject(object, precise = false) {
		this.makeEmpty();
		return this.expandByObject(object, precise);
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(box) {
		this.min.copy(box.min);
		this.max.copy(box.max);
		return this;
	}
	makeEmpty() {
		this.min.x = this.min.y = this.min.z = +Infinity;
		this.max.x = this.max.y = this.max.z = -Infinity;
		return this;
	}
	isEmpty() {
		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
	}
	getCenter(target) {
		return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
	}
	getSize(target) {
		return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
	}
	expandByPoint(point) {
		this.min.min(point);
		this.max.max(point);
		return this;
	}
	expandByVector(vector) {
		this.min.sub(vector);
		this.max.add(vector);
		return this;
	}
	expandByScalar(scalar) {
		this.min.addScalar(-scalar);
		this.max.addScalar(scalar);
		return this;
	}
	expandByObject(object, precise = false) {
		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		object.updateWorldMatrix(false, false);
		const geometry = object.geometry;
		if (geometry !== undefined) {
			if (precise && geometry.attributes != undefined && geometry.attributes.position !== undefined) {
				const position = geometry.attributes.position;
				for (let i = 0, l = position.count; i < l; i++) {
					_vector$b.fromBufferAttribute(position, i).applyMatrix4(object.matrixWorld);
					this.expandByPoint(_vector$b);
				}
			} else {
				if (geometry.boundingBox === null) {
					geometry.computeBoundingBox();
				}
				_box$3.copy(geometry.boundingBox);
				_box$3.applyMatrix4(object.matrixWorld);
				this.union(_box$3);
			}
		}
		const children = object.children;
		for (let i = 0, l = children.length; i < l; i++) {
			this.expandByObject(children[i], precise);
		}
		return this;
	}
	containsPoint(point) {
		return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
	}
	containsBox(box) {
		return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
	}
	getParameter(point, target) {
		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
	}
	intersectsBox(box) {
		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
	}
	intersectsSphere(sphere) {
		// Find the point on the AABB closest to the sphere center.
		this.clampPoint(sphere.center, _vector$b);

		// If that point is inside the sphere, the AABB and sphere intersect.
		return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
	}
	intersectsPlane(plane) {
		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		let min, max;
		if (plane.normal.x > 0) {
			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;
		} else {
			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;
		}
		if (plane.normal.y > 0) {
			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;
		} else {
			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;
		}
		if (plane.normal.z > 0) {
			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;
		} else {
			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;
		}
		return min <= -plane.constant && max >= -plane.constant;
	}
	intersectsTriangle(triangle) {
		if (this.isEmpty()) {
			return false;
		}

		// compute box center and extents
		this.getCenter(_center);
		_extents.subVectors(this.max, _center);

		// translate triangle to aabb origin
		_v0$2.subVectors(triangle.a, _center);
		_v1$8.subVectors(triangle.b, _center);
		_v2$5.subVectors(triangle.c, _center);

		// compute edge vectors for triangle
		_f0.subVectors(_v1$8, _v0$2);
		_f1.subVectors(_v2$5, _v1$8);
		_f2.subVectors(_v0$2, _v2$5);

		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
		if (!satForAxes(axes, _v0$2, _v1$8, _v2$5, _extents)) {
			return false;
		}

		// test 3 face normals from the aabb
		axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
		if (!satForAxes(axes, _v0$2, _v1$8, _v2$5, _extents)) {
			return false;
		}

		// finally testing the face normal of the triangle
		// use already existing triangle edge vectors here
		_triangleNormal.crossVectors(_f0, _f1);
		axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
		return satForAxes(axes, _v0$2, _v1$8, _v2$5, _extents);
	}
	clampPoint(point, target) {
		return target.copy(point).clamp(this.min, this.max);
	}
	distanceToPoint(point) {
		const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
		return clampedPoint.sub(point).length();
	}
	getBoundingSphere(target) {
		this.getCenter(target.center);
		target.radius = this.getSize(_vector$b).length() * 0.5;
		return target;
	}
	intersect(box) {
		this.min.max(box.min);
		this.max.min(box.max);

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if (this.isEmpty()) this.makeEmpty();
		return this;
	}
	union(box) {
		this.min.min(box.min);
		this.max.max(box.max);
		return this;
	}
	applyMatrix4(matrix) {
		// transform of empty box is an empty box.
		if (this.isEmpty()) return this;

		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
		_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
		_points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
		_points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
		_points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
		_points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
		_points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
		_points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
		_points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111

		this.setFromPoints(_points);
		return this;
	}
	translate(offset) {
		this.min.add(offset);
		this.max.add(offset);
		return this;
	}
	equals(box) {
		return box.min.equals(this.min) && box.max.equals(this.max);
	}
}
const _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];
const _vector$b = /*@__PURE__*/new Vector3();
const _box$3 = /*@__PURE__*/new Box3();

// triangle centered vertices

const _v0$2 = /*@__PURE__*/new Vector3();
const _v1$8 = /*@__PURE__*/new Vector3();
const _v2$5 = /*@__PURE__*/new Vector3();

// triangle edge vectors

const _f0 = /*@__PURE__*/new Vector3();
const _f1 = /*@__PURE__*/new Vector3();
const _f2 = /*@__PURE__*/new Vector3();
const _center = /*@__PURE__*/new Vector3();
const _extents = /*@__PURE__*/new Vector3();
const _triangleNormal = /*@__PURE__*/new Vector3();
const _testAxis = /*@__PURE__*/new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
	for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
		_testAxis.fromArray(axes, i);
		// project the aabb onto the separating axis
		const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
		// project all 3 vertices of the triangle onto the separating axis
		const p0 = v0.dot(_testAxis);
		const p1 = v1.dot(_testAxis);
		const p2 = v2.dot(_testAxis);
		// actual test, basically see if either of the most extreme of the triangle points intersects r
		if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
			// points of the projected triangle are outside the projected half-length of the aabb
			// the axis is separating and we can exit
			return false;
		}
	}
	return true;
}

const _box$2 = /*@__PURE__*/new Box3();
const _v1$7 = /*@__PURE__*/new Vector3();
const _v2$4 = /*@__PURE__*/new Vector3();
class Sphere {
	constructor(center = new Vector3(), radius = -1) {
		this.center = center;
		this.radius = radius;
	}
	set(center, radius) {
		this.center.copy(center);
		this.radius = radius;
		return this;
	}
	setFromPoints(points, optionalCenter) {
		const center = this.center;
		if (optionalCenter !== undefined) {
			center.copy(optionalCenter);
		} else {
			_box$2.setFromPoints(points).getCenter(center);
		}
		let maxRadiusSq = 0;
		for (let i = 0, il = points.length; i < il; i++) {
			maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
		}
		this.radius = Math.sqrt(maxRadiusSq);
		return this;
	}
	copy(sphere) {
		this.center.copy(sphere.center);
		this.radius = sphere.radius;
		return this;
	}
	isEmpty() {
		return this.radius < 0;
	}
	makeEmpty() {
		this.center.set(0, 0, 0);
		this.radius = -1;
		return this;
	}
	containsPoint(point) {
		return point.distanceToSquared(this.center) <= this.radius * this.radius;
	}
	distanceToPoint(point) {
		return point.distanceTo(this.center) - this.radius;
	}
	intersectsSphere(sphere) {
		const radiusSum = this.radius + sphere.radius;
		return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
	}
	intersectsBox(box) {
		return box.intersectsSphere(this);
	}
	intersectsPlane(plane) {
		return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
	}
	clampPoint(point, target) {
		const deltaLengthSq = this.center.distanceToSquared(point);
		target.copy(point);
		if (deltaLengthSq > this.radius * this.radius) {
			target.sub(this.center).normalize();
			target.multiplyScalar(this.radius).add(this.center);
		}
		return target;
	}
	getBoundingBox(target) {
		if (this.isEmpty()) {
			// Empty sphere produces empty bounding box
			target.makeEmpty();
			return target;
		}
		target.set(this.center, this.center);
		target.expandByScalar(this.radius);
		return target;
	}
	applyMatrix4(matrix) {
		this.center.applyMatrix4(matrix);
		this.radius = this.radius * matrix.getMaxScaleOnAxis();
		return this;
	}
	translate(offset) {
		this.center.add(offset);
		return this;
	}
	expandByPoint(point) {
		if (this.isEmpty()) {
			this.center.copy(point);
			this.radius = 0;
			return this;
		}
		_v1$7.subVectors(point, this.center);
		const lengthSq = _v1$7.lengthSq();
		if (lengthSq > this.radius * this.radius) {
			// calculate the minimal sphere

			const length = Math.sqrt(lengthSq);
			const delta = (length - this.radius) * 0.5;
			this.center.addScaledVector(_v1$7, delta / length);
			this.radius += delta;
		}
		return this;
	}
	union(sphere) {
		if (sphere.isEmpty()) {
			return this;
		}
		if (this.isEmpty()) {
			this.copy(sphere);
			return this;
		}
		if (this.center.equals(sphere.center) === true) {
			this.radius = Math.max(this.radius, sphere.radius);
		} else {
			_v2$4.subVectors(sphere.center, this.center).setLength(sphere.radius);
			this.expandByPoint(_v1$7.copy(sphere.center).add(_v2$4));
			this.expandByPoint(_v1$7.copy(sphere.center).sub(_v2$4));
		}
		return this;
	}
	equals(sphere) {
		return sphere.center.equals(this.center) && sphere.radius === this.radius;
	}
	clone() {
		return new this.constructor().copy(this);
	}
}

const _vector1 = /*@__PURE__*/new Vector3();
const _vector2$1 = /*@__PURE__*/new Vector3();
const _normalMatrix = /*@__PURE__*/new Matrix3();
class Plane {
	constructor(normal = new Vector3(1, 0, 0), constant = 0) {
		this.isPlane = true;

		// normal is assumed to be normalized

		this.normal = normal;
		this.constant = constant;
	}
	set(normal, constant) {
		this.normal.copy(normal);
		this.constant = constant;
		return this;
	}
	setComponents(x, y, z, w) {
		this.normal.set(x, y, z);
		this.constant = w;
		return this;
	}
	setFromNormalAndCoplanarPoint(normal, point) {
		this.normal.copy(normal);
		this.constant = -point.dot(this.normal);
		return this;
	}
	setFromCoplanarPoints(a, b, c) {
		const normal = _vector1.subVectors(c, b).cross(_vector2$1.subVectors(a, b)).normalize();

		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		this.setFromNormalAndCoplanarPoint(normal, a);
		return this;
	}
	copy(plane) {
		this.normal.copy(plane.normal);
		this.constant = plane.constant;
		return this;
	}
	normalize() {
		// Note: will lead to a divide by zero if the plane is invalid.

		const inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar(inverseNormalLength);
		this.constant *= inverseNormalLength;
		return this;
	}
	negate() {
		this.constant *= -1;
		this.normal.negate();
		return this;
	}
	distanceToPoint(point) {
		return this.normal.dot(point) + this.constant;
	}
	distanceToSphere(sphere) {
		return this.distanceToPoint(sphere.center) - sphere.radius;
	}
	projectPoint(point, target) {
		return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
	}
	intersectLine(line, target) {
		const direction = line.delta(_vector1);
		const denominator = this.normal.dot(direction);
		if (denominator === 0) {
			// line is coplanar, return origin
			if (this.distanceToPoint(line.start) === 0) {
				return target.copy(line.start);
			}

			// Unsure if this is the correct method to handle this case.
			return null;
		}
		const t = -(line.start.dot(this.normal) + this.constant) / denominator;
		if (t < 0 || t > 1) {
			return null;
		}
		return target.copy(direction).multiplyScalar(t).add(line.start);
	}
	intersectsLine(line) {
		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		const startSign = this.distanceToPoint(line.start);
		const endSign = this.distanceToPoint(line.end);
		return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
	}
	intersectsBox(box) {
		return box.intersectsPlane(this);
	}
	intersectsSphere(sphere) {
		return sphere.intersectsPlane(this);
	}
	coplanarPoint(target) {
		return target.copy(this.normal).multiplyScalar(-this.constant);
	}
	applyMatrix4(matrix, optionalNormalMatrix) {
		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
		const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
		const normal = this.normal.applyMatrix3(normalMatrix).normalize();
		this.constant = -referencePoint.dot(normal);
		return this;
	}
	translate(offset) {
		this.constant -= offset.dot(this.normal);
		return this;
	}
	equals(plane) {
		return plane.normal.equals(this.normal) && plane.constant === this.constant;
	}
	clone() {
		return new this.constructor().copy(this);
	}
}

const _sphere$3 = /*@__PURE__*/new Sphere();
const _vector$a = /*@__PURE__*/new Vector3();
class Frustum {
	constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
		this.planes = [p0, p1, p2, p3, p4, p5];
	}
	set(p0, p1, p2, p3, p4, p5) {
		const planes = this.planes;
		planes[0].copy(p0);
		planes[1].copy(p1);
		planes[2].copy(p2);
		planes[3].copy(p3);
		planes[4].copy(p4);
		planes[5].copy(p5);
		return this;
	}
	copy(frustum) {
		const planes = this.planes;
		for (let i = 0; i < 6; i++) {
			planes[i].copy(frustum.planes[i]);
		}
		return this;
	}
	setFromProjectionMatrix(m) {
		const planes = this.planes;
		const me = m.elements;
		const me0 = me[0],
			me1 = me[1],
			me2 = me[2],
			me3 = me[3];
		const me4 = me[4],
			me5 = me[5],
			me6 = me[6],
			me7 = me[7];
		const me8 = me[8],
			me9 = me[9],
			me10 = me[10],
			me11 = me[11];
		const me12 = me[12],
			me13 = me[13],
			me14 = me[14],
			me15 = me[15];
		planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
		planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
		planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
		planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
		planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
		planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
		return this;
	}
	intersectsObject(object) {
		const geometry = object.geometry;
		if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
		_sphere$3.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
		return this.intersectsSphere(_sphere$3);
	}
	intersectsSprite(sprite) {
		_sphere$3.center.set(0, 0, 0);
		_sphere$3.radius = 0.7071067811865476;
		_sphere$3.applyMatrix4(sprite.matrixWorld);
		return this.intersectsSphere(_sphere$3);
	}
	intersectsSphere(sphere) {
		const planes = this.planes;
		const center = sphere.center;
		const negRadius = -sphere.radius;
		for (let i = 0; i < 6; i++) {
			const distance = planes[i].distanceToPoint(center);
			if (distance < negRadius) {
				return false;
			}
		}
		return true;
	}
	intersectsBox(box) {
		const planes = this.planes;
		for (let i = 0; i < 6; i++) {
			const plane = planes[i];

			// corner at max distance

			_vector$a.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			_vector$a.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			_vector$a.z = plane.normal.z > 0 ? box.max.z : box.min.z;
			if (plane.distanceToPoint(_vector$a) < 0) {
				return false;
			}
		}
		return true;
	}
	containsPoint(point) {
		const planes = this.planes;
		for (let i = 0; i < 6; i++) {
			if (planes[i].distanceToPoint(point) < 0) {
				return false;
			}
		}
		return true;
	}
	clone() {
		return new this.constructor().copy(this);
	}
}

class Matrix4 {
	constructor() {
		Matrix4.prototype.isMatrix4 = true;
		this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	}
	set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
		const te = this.elements;
		te[0] = n11;
		te[4] = n12;
		te[8] = n13;
		te[12] = n14;
		te[1] = n21;
		te[5] = n22;
		te[9] = n23;
		te[13] = n24;
		te[2] = n31;
		te[6] = n32;
		te[10] = n33;
		te[14] = n34;
		te[3] = n41;
		te[7] = n42;
		te[11] = n43;
		te[15] = n44;
		return this;
	}
	identity() {
		this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
		return this;
	}
	clone() {
		return new Matrix4().fromArray(this.elements);
	}
	copy(m) {
		const te = this.elements;
		const me = m.elements;
		te[0] = me[0];
		te[1] = me[1];
		te[2] = me[2];
		te[3] = me[3];
		te[4] = me[4];
		te[5] = me[5];
		te[6] = me[6];
		te[7] = me[7];
		te[8] = me[8];
		te[9] = me[9];
		te[10] = me[10];
		te[11] = me[11];
		te[12] = me[12];
		te[13] = me[13];
		te[14] = me[14];
		te[15] = me[15];
		return this;
	}
	copyPosition(m) {
		const te = this.elements,
			me = m.elements;
		te[12] = me[12];
		te[13] = me[13];
		te[14] = me[14];
		return this;
	}
	setFromMatrix3(m) {
		const me = m.elements;
		this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
		return this;
	}
	extractBasis(xAxis, yAxis, zAxis) {
		xAxis.setFromMatrixColumn(this, 0);
		yAxis.setFromMatrixColumn(this, 1);
		zAxis.setFromMatrixColumn(this, 2);
		return this;
	}
	makeBasis(xAxis, yAxis, zAxis) {
		this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
		return this;
	}
	extractRotation(m) {
		// this method does not support reflection matrices

		const te = this.elements;
		const me = m.elements;
		const scaleX = 1 / _v1$6.setFromMatrixColumn(m, 0).length();
		const scaleY = 1 / _v1$6.setFromMatrixColumn(m, 1).length();
		const scaleZ = 1 / _v1$6.setFromMatrixColumn(m, 2).length();
		te[0] = me[0] * scaleX;
		te[1] = me[1] * scaleX;
		te[2] = me[2] * scaleX;
		te[3] = 0;
		te[4] = me[4] * scaleY;
		te[5] = me[5] * scaleY;
		te[6] = me[6] * scaleY;
		te[7] = 0;
		te[8] = me[8] * scaleZ;
		te[9] = me[9] * scaleZ;
		te[10] = me[10] * scaleZ;
		te[11] = 0;
		te[12] = 0;
		te[13] = 0;
		te[14] = 0;
		te[15] = 1;
		return this;
	}
	makeRotationFromEuler(euler) {
		const te = this.elements;
		const x = euler.x,
			y = euler.y,
			z = euler.z;
		const a = Math.cos(x),
			b = Math.sin(x);
		const c = Math.cos(y),
			d = Math.sin(y);
		const e = Math.cos(z),
			f = Math.sin(z);
		if (euler.order === 'XYZ') {
			const ae = a * e,
				af = a * f,
				be = b * e,
				bf = b * f;
			te[0] = c * e;
			te[4] = -c * f;
			te[8] = d;
			te[1] = af + be * d;
			te[5] = ae - bf * d;
			te[9] = -b * c;
			te[2] = bf - ae * d;
			te[6] = be + af * d;
			te[10] = a * c;
		} else if (euler.order === 'YXZ') {
			const ce = c * e,
				cf = c * f,
				de = d * e,
				df = d * f;
			te[0] = ce + df * b;
			te[4] = de * b - cf;
			te[8] = a * d;
			te[1] = a * f;
			te[5] = a * e;
			te[9] = -b;
			te[2] = cf * b - de;
			te[6] = df + ce * b;
			te[10] = a * c;
		} else if (euler.order === 'ZXY') {
			const ce = c * e,
				cf = c * f,
				de = d * e,
				df = d * f;
			te[0] = ce - df * b;
			te[4] = -a * f;
			te[8] = de + cf * b;
			te[1] = cf + de * b;
			te[5] = a * e;
			te[9] = df - ce * b;
			te[2] = -a * d;
			te[6] = b;
			te[10] = a * c;
		} else if (euler.order === 'ZYX') {
			const ae = a * e,
				af = a * f,
				be = b * e,
				bf = b * f;
			te[0] = c * e;
			te[4] = be * d - af;
			te[8] = ae * d + bf;
			te[1] = c * f;
			te[5] = bf * d + ae;
			te[9] = af * d - be;
			te[2] = -d;
			te[6] = b * c;
			te[10] = a * c;
		} else if (euler.order === 'YZX') {
			const ac = a * c,
				ad = a * d,
				bc = b * c,
				bd = b * d;
			te[0] = c * e;
			te[4] = bd - ac * f;
			te[8] = bc * f + ad;
			te[1] = f;
			te[5] = a * e;
			te[9] = -b * e;
			te[2] = -d * e;
			te[6] = ad * f + bc;
			te[10] = ac - bd * f;
		} else if (euler.order === 'XZY') {
			const ac = a * c,
				ad = a * d,
				bc = b * c,
				bd = b * d;
			te[0] = c * e;
			te[4] = -f;
			te[8] = d * e;
			te[1] = ac * f + bd;
			te[5] = a * e;
			te[9] = ad * f - bc;
			te[2] = bc * f - ad;
			te[6] = b * e;
			te[10] = bd * f + ac;
		}

		// bottom row
		te[3] = 0;
		te[7] = 0;
		te[11] = 0;

		// last column
		te[12] = 0;
		te[13] = 0;
		te[14] = 0;
		te[15] = 1;
		return this;
	}
	makeRotationFromQuaternion(q) {
		return this.compose(_zero, q, _one);
	}
	lookAt(eye, target, up) {
		const te = this.elements;
		_z.subVectors(eye, target);
		if (_z.lengthSq() === 0) {
			// eye and target are in the same position

			_z.z = 1;
		}
		_z.normalize();
		_x.crossVectors(up, _z);
		if (_x.lengthSq() === 0) {
			// up and z are parallel

			if (Math.abs(up.z) === 1) {
				_z.x += 0.0001;
			} else {
				_z.z += 0.0001;
			}
			_z.normalize();
			_x.crossVectors(up, _z);
		}
		_x.normalize();
		_y.crossVectors(_z, _x);
		te[0] = _x.x;
		te[4] = _y.x;
		te[8] = _z.x;
		te[1] = _x.y;
		te[5] = _y.y;
		te[9] = _z.y;
		te[2] = _x.z;
		te[6] = _y.z;
		te[10] = _z.z;
		return this;
	}
	multiply(m) {
		return this.multiplyMatrices(this, m);
	}
	premultiply(m) {
		return this.multiplyMatrices(m, this);
	}
	multiplyMatrices(a, b) {
		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;
		const a11 = ae[0],
			a12 = ae[4],
			a13 = ae[8],
			a14 = ae[12];
		const a21 = ae[1],
			a22 = ae[5],
			a23 = ae[9],
			a24 = ae[13];
		const a31 = ae[2],
			a32 = ae[6],
			a33 = ae[10],
			a34 = ae[14];
		const a41 = ae[3],
			a42 = ae[7],
			a43 = ae[11],
			a44 = ae[15];
		const b11 = be[0],
			b12 = be[4],
			b13 = be[8],
			b14 = be[12];
		const b21 = be[1],
			b22 = be[5],
			b23 = be[9],
			b24 = be[13];
		const b31 = be[2],
			b32 = be[6],
			b33 = be[10],
			b34 = be[14];
		const b41 = be[3],
			b42 = be[7],
			b43 = be[11],
			b44 = be[15];
		te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
		te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
		te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
		te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
		return this;
	}
	multiplyScalar(s) {
		const te = this.elements;
		te[0] *= s;
		te[4] *= s;
		te[8] *= s;
		te[12] *= s;
		te[1] *= s;
		te[5] *= s;
		te[9] *= s;
		te[13] *= s;
		te[2] *= s;
		te[6] *= s;
		te[10] *= s;
		te[14] *= s;
		te[3] *= s;
		te[7] *= s;
		te[11] *= s;
		te[15] *= s;
		return this;
	}
	determinant() {
		const te = this.elements;
		const n11 = te[0],
			n12 = te[4],
			n13 = te[8],
			n14 = te[12];
		const n21 = te[1],
			n22 = te[5],
			n23 = te[9],
			n24 = te[13];
		const n31 = te[2],
			n32 = te[6],
			n33 = te[10],
			n34 = te[14];
		const n41 = te[3],
			n42 = te[7],
			n43 = te[11],
			n44 = te[15];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
	}
	transpose() {
		const te = this.elements;
		let tmp;
		tmp = te[1];
		te[1] = te[4];
		te[4] = tmp;
		tmp = te[2];
		te[2] = te[8];
		te[8] = tmp;
		tmp = te[6];
		te[6] = te[9];
		te[9] = tmp;
		tmp = te[3];
		te[3] = te[12];
		te[12] = tmp;
		tmp = te[7];
		te[7] = te[13];
		te[13] = tmp;
		tmp = te[11];
		te[11] = te[14];
		te[14] = tmp;
		return this;
	}
	setPosition(x, y, z) {
		const te = this.elements;
		if (x.isVector3) {
			te[12] = x.x;
			te[13] = x.y;
			te[14] = x.z;
		} else {
			te[12] = x;
			te[13] = y;
			te[14] = z;
		}
		return this;
	}
	invert() {
		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,
			n11 = te[0],
			n21 = te[1],
			n31 = te[2],
			n41 = te[3],
			n12 = te[4],
			n22 = te[5],
			n32 = te[6],
			n42 = te[7],
			n13 = te[8],
			n23 = te[9],
			n33 = te[10],
			n43 = te[11],
			n14 = te[12],
			n24 = te[13],
			n34 = te[14],
			n44 = te[15],
			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
		if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
		const detInv = 1 / det;
		te[0] = t11 * detInv;
		te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
		te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
		te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
		te[4] = t12 * detInv;
		te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
		te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
		te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
		te[8] = t13 * detInv;
		te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
		te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
		te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
		te[12] = t14 * detInv;
		te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
		te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
		te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
		return this;
	}
	scale(v) {
		const te = this.elements;
		const x = v.x,
			y = v.y,
			z = v.z;
		te[0] *= x;
		te[4] *= y;
		te[8] *= z;
		te[1] *= x;
		te[5] *= y;
		te[9] *= z;
		te[2] *= x;
		te[6] *= y;
		te[10] *= z;
		te[3] *= x;
		te[7] *= y;
		te[11] *= z;
		return this;
	}
	getMaxScaleOnAxis() {
		const te = this.elements;
		const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
		const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
		const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
		return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
	}
	makeTranslation(x, y, z) {
		this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
		return this;
	}
	makeRotationX(theta) {
		const c = Math.cos(theta),
			s = Math.sin(theta);
		this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
		return this;
	}
	makeRotationY(theta) {
		const c = Math.cos(theta),
			s = Math.sin(theta);
		this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
		return this;
	}
	makeRotationZ(theta) {
		const c = Math.cos(theta),
			s = Math.sin(theta);
		this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
		return this;
	}
	makeRotationAxis(axis, angle) {
		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos(angle);
		const s = Math.sin(angle);
		const t = 1 - c;
		const x = axis.x,
			y = axis.y,
			z = axis.z;
		const tx = t * x,
			ty = t * y;
		this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
		return this;
	}
	makeScale(x, y, z) {
		this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
		return this;
	}
	makeShear(xy, xz, yx, yz, zx, zy) {
		this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
		return this;
	}
	compose(position, quaternion, scale) {
		const te = this.elements;
		const x = quaternion._x,
			y = quaternion._y,
			z = quaternion._z,
			w = quaternion._w;
		const x2 = x + x,
			y2 = y + y,
			z2 = z + z;
		const xx = x * x2,
			xy = x * y2,
			xz = x * z2;
		const yy = y * y2,
			yz = y * z2,
			zz = z * z2;
		const wx = w * x2,
			wy = w * y2,
			wz = w * z2;
		const sx = scale.x,
			sy = scale.y,
			sz = scale.z;
		te[0] = (1 - (yy + zz)) * sx;
		te[1] = (xy + wz) * sx;
		te[2] = (xz - wy) * sx;
		te[3] = 0;
		te[4] = (xy - wz) * sy;
		te[5] = (1 - (xx + zz)) * sy;
		te[6] = (yz + wx) * sy;
		te[7] = 0;
		te[8] = (xz + wy) * sz;
		te[9] = (yz - wx) * sz;
		te[10] = (1 - (xx + yy)) * sz;
		te[11] = 0;
		te[12] = position.x;
		te[13] = position.y;
		te[14] = position.z;
		te[15] = 1;
		return this;
	}
	decompose(position, quaternion, scale) {
		const te = this.elements;
		let sx = _v1$6.set(te[0], te[1], te[2]).length();
		const sy = _v1$6.set(te[4], te[5], te[6]).length();
		const sz = _v1$6.set(te[8], te[9], te[10]).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if (det < 0) sx = -sx;
		position.x = te[12];
		position.y = te[13];
		position.z = te[14];

		// scale the rotation part
		_m1$2.copy(this);
		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;
		_m1$2.elements[0] *= invSX;
		_m1$2.elements[1] *= invSX;
		_m1$2.elements[2] *= invSX;
		_m1$2.elements[4] *= invSY;
		_m1$2.elements[5] *= invSY;
		_m1$2.elements[6] *= invSY;
		_m1$2.elements[8] *= invSZ;
		_m1$2.elements[9] *= invSZ;
		_m1$2.elements[10] *= invSZ;
		quaternion.setFromRotationMatrix(_m1$2);
		scale.x = sx;
		scale.y = sy;
		scale.z = sz;
		return this;
	}
	makePerspective(left, right, top, bottom, near, far) {
		const te = this.elements;
		const x = 2 * near / (right - left);
		const y = 2 * near / (top - bottom);
		const a = (right + left) / (right - left);
		const b = (top + bottom) / (top - bottom);
		const c = -(far + near) / (far - near);
		const d = -2 * far * near / (far - near);
		te[0] = x;
		te[4] = 0;
		te[8] = a;
		te[12] = 0;
		te[1] = 0;
		te[5] = y;
		te[9] = b;
		te[13] = 0;
		te[2] = 0;
		te[6] = 0;
		te[10] = c;
		te[14] = d;
		te[3] = 0;
		te[7] = 0;
		te[11] = -1;
		te[15] = 0;
		return this;
	}
	makeOrthographic(left, right, top, bottom, near, far) {
		const te = this.elements;
		const w = 1.0 / (right - left);
		const h = 1.0 / (top - bottom);
		const p = 1.0 / (far - near);
		const x = (right + left) * w;
		const y = (top + bottom) * h;
		const z = (far + near) * p;
		te[0] = 2 * w;
		te[4] = 0;
		te[8] = 0;
		te[12] = -x;
		te[1] = 0;
		te[5] = 2 * h;
		te[9] = 0;
		te[13] = -y;
		te[2] = 0;
		te[6] = 0;
		te[10] = -2 * p;
		te[14] = -z;
		te[3] = 0;
		te[7] = 0;
		te[11] = 0;
		te[15] = 1;
		return this;
	}
	equals(matrix) {
		const te = this.elements;
		const me = matrix.elements;
		for (let i = 0; i < 16; i++) {
			if (te[i] !== me[i]) return false;
		}
		return true;
	}
	fromArray(array, offset = 0) {
		for (let i = 0; i < 16; i++) {
			this.elements[i] = array[i + offset];
		}
		return this;
	}
	toArray(array = [], offset = 0) {
		const te = this.elements;
		array[offset] = te[0];
		array[offset + 1] = te[1];
		array[offset + 2] = te[2];
		array[offset + 3] = te[3];
		array[offset + 4] = te[4];
		array[offset + 5] = te[5];
		array[offset + 6] = te[6];
		array[offset + 7] = te[7];
		array[offset + 8] = te[8];
		array[offset + 9] = te[9];
		array[offset + 10] = te[10];
		array[offset + 11] = te[11];
		array[offset + 12] = te[12];
		array[offset + 13] = te[13];
		array[offset + 14] = te[14];
		array[offset + 15] = te[15];
		return array;
	}
}
const _v1$6 = /*@__PURE__*/new Vector3();
const _m1$2 = /*@__PURE__*/new Matrix4();
const _zero = /*@__PURE__*/new Vector3(0, 0, 0);
const _one = /*@__PURE__*/new Vector3(1, 1, 1);
const _x = /*@__PURE__*/new Vector3();
const _y = /*@__PURE__*/new Vector3();
const _z = /*@__PURE__*/new Vector3();

function WebGLAnimation() {
	let context = null;
	let isAnimating = false;
	let animationLoop = null;
	let requestId = null;
	function onAnimationFrame(time, frame) {
		animationLoop(time, frame);
		requestId = context.requestAnimationFrame(onAnimationFrame);
	}
	return {
		start: function () {
			if (isAnimating === true) return;
			if (animationLoop === null) return;
			requestId = context.requestAnimationFrame(onAnimationFrame);
			isAnimating = true;
		},
		stop: function () {
			context.cancelAnimationFrame(requestId);
			isAnimating = false;
		},
		setAnimationLoop: function (callback) {
			animationLoop = callback;
		},
		setContext: function (value) {
			context = value;
		}
	};
}

function WebGLAttributes(gl, capabilities) {
	const isWebGL2 = capabilities.isWebGL2;
	const buffers = new WeakMap();
	function createBuffer(attribute, bufferType) {
		const array = attribute.array;
		const usage = attribute.usage;
		const buffer = gl.createBuffer();
		gl.bindBuffer(bufferType, buffer);
		gl.bufferData(bufferType, array, usage);
		attribute.onUploadCallback();
		let type;
		if (array instanceof Float32Array) {
			type = gl.FLOAT;
		} else if (array instanceof Uint16Array) {
			if (attribute.isFloat16BufferAttribute) {
				if (isWebGL2) {
					type = gl.HALF_FLOAT;
				} else {
					throw new Error('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');
				}
			} else {
				type = gl.UNSIGNED_SHORT;
			}
		} else if (array instanceof Int16Array) {
			type = gl.SHORT;
		} else if (array instanceof Uint32Array) {
			type = gl.UNSIGNED_INT;
		} else if (array instanceof Int32Array) {
			type = gl.INT;
		} else if (array instanceof Int8Array) {
			type = gl.BYTE;
		} else if (array instanceof Uint8Array) {
			type = gl.UNSIGNED_BYTE;
		} else if (array instanceof Uint8ClampedArray) {
			type = gl.UNSIGNED_BYTE;
		} else {
			throw new Error('THREE.WebGLAttributes: Unsupported buffer data format: ' + array);
		}
		return {
			buffer: buffer,
			type: type,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version
		};
	}
	function updateBuffer(buffer, attribute, bufferType) {
		const array = attribute.array;
		const updateRange = attribute.updateRange;
		gl.bindBuffer(bufferType, buffer);
		if (updateRange.count === -1) {
			// Not using update ranges

			gl.bufferSubData(bufferType, 0, array);
		} else {
			if (isWebGL2) {
				gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
			} else {
				gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
			}
			updateRange.count = -1; // reset range
		}
	}

	//

	function get(attribute) {
		if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
		return buffers.get(attribute);
	}
	function remove(attribute) {
		if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
		const data = buffers.get(attribute);
		if (data) {
			gl.deleteBuffer(data.buffer);
			buffers.delete(attribute);
		}
	}
	function update(attribute, bufferType) {
		if (attribute.isGLBufferAttribute) {
			const cached = buffers.get(attribute);
			if (!cached || cached.version < attribute.version) {
				buffers.set(attribute, {
					buffer: attribute.buffer,
					type: attribute.type,
					bytesPerElement: attribute.elementSize,
					version: attribute.version
				});
			}
			return;
		}
		if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
		const data = buffers.get(attribute);
		if (data === undefined) {
			buffers.set(attribute, createBuffer(attribute, bufferType));
		} else if (data.version < attribute.version) {
			updateBuffer(data.buffer, attribute, bufferType);
			data.version = attribute.version;
		}
	}
	return {
		get: get,
		remove: remove,
		update: update
	};
}

const _vector$9 = /*@__PURE__*/new Vector3();
const _vector2 = /*@__PURE__*/new Vector2();
class BufferAttribute {
	constructor(array, itemSize, normalized) {
		if (Array.isArray(array)) {
			throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
		}
		this.isBufferAttribute = true;
		this.name = '';
		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized === true;
		this.usage = StaticDrawUsage;
		this.updateRange = {
			offset: 0,
			count: -1
		};
		this.version = 0;
	}
	onUploadCallback() {}
	set needsUpdate(value) {
		if (value === true) this.version++;
	}
	setUsage(value) {
		this.usage = value;
		return this;
	}
	copy(source) {
		this.name = source.name;
		this.array = new source.array.constructor(source.array);
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;
		this.usage = source.usage;
		return this;
	}
	copyAt(index1, attribute, index2) {
		index1 *= this.itemSize;
		index2 *= attribute.itemSize;
		for (let i = 0, l = this.itemSize; i < l; i++) {
			this.array[index1 + i] = attribute.array[index2 + i];
		}
		return this;
	}
	copyArray(array) {
		this.array.set(array);
		return this;
	}
	applyMatrix3(m) {
		if (this.itemSize === 2) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector2.fromBufferAttribute(this, i);
				_vector2.applyMatrix3(m);
				this.setXY(i, _vector2.x, _vector2.y);
			}
		} else if (this.itemSize === 3) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$9.fromBufferAttribute(this, i);
				_vector$9.applyMatrix3(m);
				this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
			}
		}
		return this;
	}
	applyMatrix4(m) {
		for (let i = 0, l = this.count; i < l; i++) {
			_vector$9.fromBufferAttribute(this, i);
			_vector$9.applyMatrix4(m);
			this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
		}
		return this;
	}
	applyNormalMatrix(m) {
		for (let i = 0, l = this.count; i < l; i++) {
			_vector$9.fromBufferAttribute(this, i);
			_vector$9.applyNormalMatrix(m);
			this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
		}
		return this;
	}
	transformDirection(m) {
		for (let i = 0, l = this.count; i < l; i++) {
			_vector$9.fromBufferAttribute(this, i);
			_vector$9.transformDirection(m);
			this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
		}
		return this;
	}
	set(value, offset = 0) {
		// Matching BufferAttribute constructor, do not normalize the array.
		this.array.set(value, offset);
		return this;
	}
	getX(index) {
		let x = this.array[index * this.itemSize];
		if (this.normalized) x = denormalize(x, this.array);
		return x;
	}
	setX(index, x) {
		if (this.normalized) x = normalize(x, this.array);
		this.array[index * this.itemSize] = x;
		return this;
	}
	getY(index) {
		let y = this.array[index * this.itemSize + 1];
		if (this.normalized) y = denormalize(y, this.array);
		return y;
	}
	setY(index, y) {
		if (this.normalized) y = normalize(y, this.array);
		this.array[index * this.itemSize + 1] = y;
		return this;
	}
	getZ(index) {
		let z = this.array[index * this.itemSize + 2];
		if (this.normalized) z = denormalize(z, this.array);
		return z;
	}
	setZ(index, z) {
		if (this.normalized) z = normalize(z, this.array);
		this.array[index * this.itemSize + 2] = z;
		return this;
	}
	getW(index) {
		let w = this.array[index * this.itemSize + 3];
		if (this.normalized) w = denormalize(w, this.array);
		return w;
	}
	setW(index, w) {
		if (this.normalized) w = normalize(w, this.array);
		this.array[index * this.itemSize + 3] = w;
		return this;
	}
	setXY(index, x, y) {
		index *= this.itemSize;
		if (this.normalized) {
			x = normalize(x, this.array);
			y = normalize(y, this.array);
		}
		this.array[index + 0] = x;
		this.array[index + 1] = y;
		return this;
	}
	setXYZ(index, x, y, z) {
		index *= this.itemSize;
		if (this.normalized) {
			x = normalize(x, this.array);
			y = normalize(y, this.array);
			z = normalize(z, this.array);
		}
		this.array[index + 0] = x;
		this.array[index + 1] = y;
		this.array[index + 2] = z;
		return this;
	}
	setXYZW(index, x, y, z, w) {
		index *= this.itemSize;
		if (this.normalized) {
			x = normalize(x, this.array);
			y = normalize(y, this.array);
			z = normalize(z, this.array);
			w = normalize(w, this.array);
		}
		this.array[index + 0] = x;
		this.array[index + 1] = y;
		this.array[index + 2] = z;
		this.array[index + 3] = w;
		return this;
	}
	onUpload(callback) {
		this.onUploadCallback = callback;
		return this;
	}
	clone() {
		return new this.constructor(this.array, this.itemSize).copy(this);
	}
	toJSON() {
		const data = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.from(this.array),
			normalized: this.normalized
		};
		if (this.name !== '') data.name = this.name;
		if (this.usage !== StaticDrawUsage) data.usage = this.usage;
		if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;
		return data;
	}

	// @deprecated

	copyColorsArray() {
		console.error('THREE.BufferAttribute: copyColorsArray() was removed in r144.');
	}
	copyVector2sArray() {
		console.error('THREE.BufferAttribute: copyVector2sArray() was removed in r144.');
	}
	copyVector3sArray() {
		console.error('THREE.BufferAttribute: copyVector3sArray() was removed in r144.');
	}
	copyVector4sArray() {
		console.error('THREE.BufferAttribute: copyVector4sArray() was removed in r144.');
	}
}
class Uint16BufferAttribute extends BufferAttribute {
	constructor(array, itemSize, normalized) {
		super(new Uint16Array(array), itemSize, normalized);
	}
}
class Uint32BufferAttribute extends BufferAttribute {
	constructor(array, itemSize, normalized) {
		super(new Uint32Array(array), itemSize, normalized);
	}
}
class Float32BufferAttribute extends BufferAttribute {
	constructor(array, itemSize, normalized) {
		super(new Float32Array(array), itemSize, normalized);
	}
}

const _matrix$1 = /*@__PURE__*/new Matrix4();
const _quaternion$1 = /*@__PURE__*/new Quaternion();
class Euler {
	constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
		this.isEuler = true;
		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;
	}
	get x() {
		return this._x;
	}
	set x(value) {
		this._x = value;
		this._onChangeCallback();
	}
	get y() {
		return this._y;
	}
	set y(value) {
		this._y = value;
		this._onChangeCallback();
	}
	get z() {
		return this._z;
	}
	set z(value) {
		this._z = value;
		this._onChangeCallback();
	}
	get order() {
		return this._order;
	}
	set order(value) {
		this._order = value;
		this._onChangeCallback();
	}
	set(x, y, z, order = this._order) {
		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;
		this._onChangeCallback();
		return this;
	}
	clone() {
		return new this.constructor(this._x, this._y, this._z, this._order);
	}
	copy(euler) {
		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;
		this._onChangeCallback();
		return this;
	}
	setFromRotationMatrix(m, order = this._order, update = true) {
		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements;
		const m11 = te[0],
			m12 = te[4],
			m13 = te[8];
		const m21 = te[1],
			m22 = te[5],
			m23 = te[9];
		const m31 = te[2],
			m32 = te[6],
			m33 = te[10];
		switch (order) {
			case 'XYZ':
				this._y = Math.asin(clamp(m13, -1, 1));
				if (Math.abs(m13) < 0.9999999) {
					this._x = Math.atan2(-m23, m33);
					this._z = Math.atan2(-m12, m11);
				} else {
					this._x = Math.atan2(m32, m22);
					this._z = 0;
				}
				break;
			case 'YXZ':
				this._x = Math.asin(-clamp(m23, -1, 1));
				if (Math.abs(m23) < 0.9999999) {
					this._y = Math.atan2(m13, m33);
					this._z = Math.atan2(m21, m22);
				} else {
					this._y = Math.atan2(-m31, m11);
					this._z = 0;
				}
				break;
			case 'ZXY':
				this._x = Math.asin(clamp(m32, -1, 1));
				if (Math.abs(m32) < 0.9999999) {
					this._y = Math.atan2(-m31, m33);
					this._z = Math.atan2(-m12, m22);
				} else {
					this._y = 0;
					this._z = Math.atan2(m21, m11);
				}
				break;
			case 'ZYX':
				this._y = Math.asin(-clamp(m31, -1, 1));
				if (Math.abs(m31) < 0.9999999) {
					this._x = Math.atan2(m32, m33);
					this._z = Math.atan2(m21, m11);
				} else {
					this._x = 0;
					this._z = Math.atan2(-m12, m22);
				}
				break;
			case 'YZX':
				this._z = Math.asin(clamp(m21, -1, 1));
				if (Math.abs(m21) < 0.9999999) {
					this._x = Math.atan2(-m23, m22);
					this._y = Math.atan2(-m31, m11);
				} else {
					this._x = 0;
					this._y = Math.atan2(m13, m33);
				}
				break;
			case 'XZY':
				this._z = Math.asin(-clamp(m12, -1, 1));
				if (Math.abs(m12) < 0.9999999) {
					this._x = Math.atan2(m32, m22);
					this._y = Math.atan2(m13, m11);
				} else {
					this._x = Math.atan2(-m23, m33);
					this._y = 0;
				}
				break;
			default:
				console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
		}
		this._order = order;
		if (update === true) this._onChangeCallback();
		return this;
	}
	setFromQuaternion(q, order, update) {
		_matrix$1.makeRotationFromQuaternion(q);
		return this.setFromRotationMatrix(_matrix$1, order, update);
	}
	setFromVector3(v, order = this._order) {
		return this.set(v.x, v.y, v.z, order);
	}
	reorder(newOrder) {
		// WARNING: this discards revolution information -bhouston

		_quaternion$1.setFromEuler(this);
		return this.setFromQuaternion(_quaternion$1, newOrder);
	}
	equals(euler) {
		return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
	}
	fromArray(array) {
		this._x = array[0];
		this._y = array[1];
		this._z = array[2];
		if (array[3] !== undefined) this._order = array[3];
		this._onChangeCallback();
		return this;
	}
	toArray(array = [], offset = 0) {
		array[offset] = this._x;
		array[offset + 1] = this._y;
		array[offset + 2] = this._z;
		array[offset + 3] = this._order;
		return array;
	}
	_onChange(callback) {
		this._onChangeCallback = callback;
		return this;
	}
	_onChangeCallback() {}
	*[Symbol.iterator]() {
		yield this._x;
		yield this._y;
		yield this._z;
		yield this._order;
	}

	// @deprecated since r138, 02cf0df1cb4575d5842fef9c85bb5a89fe020d53

	toVector3() {
		console.error('THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead');
	}
}
Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];

class Layers {
	constructor() {
		this.mask = 1 | 0;
	}
	set(channel) {
		this.mask = (1 << channel | 0) >>> 0;
	}
	enable(channel) {
		this.mask |= 1 << channel | 0;
	}
	enableAll() {
		this.mask = 0xffffffff | 0;
	}
	toggle(channel) {
		this.mask ^= 1 << channel | 0;
	}
	disable(channel) {
		this.mask &= ~(1 << channel | 0);
	}
	disableAll() {
		this.mask = 0;
	}
	test(layers) {
		return (this.mask & layers.mask) !== 0;
	}
	isEnabled(channel) {
		return (this.mask & (1 << channel | 0)) !== 0;
	}
}

let _object3DId = 0;
const _v1$5 = /*@__PURE__*/new Vector3();
const _q1 = /*@__PURE__*/new Quaternion();
const _m1$1 = /*@__PURE__*/new Matrix4();
const _target = /*@__PURE__*/new Vector3();
const _position$1 = /*@__PURE__*/new Vector3();
const _scale = /*@__PURE__*/new Vector3();
const _quaternion = /*@__PURE__*/new Quaternion();
const _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);
const _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);
const _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);
const _addedEvent = {
	type: 'added'
};
const _removedEvent = {
	type: 'removed'
};
class Object3D extends EventDispatcher {
	constructor() {
		super();
		this.isObject3D = true;
		Object.defineProperty(this, 'id', {
			value: _object3DId++
		});
		this.uuid = generateUUID();
		this.name = '';
		this.type = 'Object3D';
		this.parent = null;
		this.children = [];
		this.up = Object3D.DefaultUp.clone();
		const position = new Vector3();
		const rotation = new Euler();
		const quaternion = new Quaternion();
		const scale = new Vector3(1, 1, 1);
		function onRotationChange() {
			quaternion.setFromEuler(rotation, false);
		}
		function onQuaternionChange() {
			rotation.setFromQuaternion(quaternion, undefined, false);
		}
		rotation._onChange(onRotationChange);
		quaternion._onChange(onQuaternionChange);
		Object.defineProperties(this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		});
		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();
		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;
		this.matrixWorldAutoUpdate = Object3D.DefaultMatrixWorldAutoUpdate; // checked by the renderer

		this.layers = new Layers();
		this.visible = true;
		this.castShadow = false;
		this.receiveShadow = false;
		this.frustumCulled = true;
		this.renderOrder = 0;
		this.animations = [];
		this.userData = {};
	}
	onBeforeRender( /* renderer, scene, camera, geometry, material, group */) {}
	onAfterRender( /* renderer, scene, camera, geometry, material, group */) {}
	applyMatrix4(matrix) {
		if (this.matrixAutoUpdate) this.updateMatrix();
		this.matrix.premultiply(matrix);
		this.matrix.decompose(this.position, this.quaternion, this.scale);
	}
	applyQuaternion(q) {
		this.quaternion.premultiply(q);
		return this;
	}
	setRotationFromAxisAngle(axis, angle) {
		// assumes axis is normalized

		this.quaternion.setFromAxisAngle(axis, angle);
	}
	setRotationFromEuler(euler) {
		this.quaternion.setFromEuler(euler, true);
	}
	setRotationFromMatrix(m) {
		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix(m);
	}
	setRotationFromQuaternion(q) {
		// assumes q is normalized

		this.quaternion.copy(q);
	}
	rotateOnAxis(axis, angle) {
		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle(axis, angle);
		this.quaternion.multiply(_q1);
		return this;
	}
	rotateOnWorldAxis(axis, angle) {
		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle(axis, angle);
		this.quaternion.premultiply(_q1);
		return this;
	}
	rotateX(angle) {
		return this.rotateOnAxis(_xAxis, angle);
	}
	rotateY(angle) {
		return this.rotateOnAxis(_yAxis, angle);
	}
	rotateZ(angle) {
		return this.rotateOnAxis(_zAxis, angle);
	}
	translateOnAxis(axis, distance) {
		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1$5.copy(axis).applyQuaternion(this.quaternion);
		this.position.add(_v1$5.multiplyScalar(distance));
		return this;
	}
	translateX(distance) {
		return this.translateOnAxis(_xAxis, distance);
	}
	translateY(distance) {
		return this.translateOnAxis(_yAxis, distance);
	}
	translateZ(distance) {
		return this.translateOnAxis(_zAxis, distance);
	}
	localToWorld(vector) {
		return vector.applyMatrix4(this.matrixWorld);
	}
	worldToLocal(vector) {
		return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
	}
	lookAt(x, y, z) {
		// This method does not support objects having non-uniformly-scaled parent(s)

		if (x.isVector3) {
			_target.copy(x);
		} else {
			_target.set(x, y, z);
		}
		const parent = this.parent;
		this.updateWorldMatrix(true, false);
		_position$1.setFromMatrixPosition(this.matrixWorld);
		if (this.isCamera || this.isLight) {
			_m1$1.lookAt(_position$1, _target, this.up);
		} else {
			_m1$1.lookAt(_target, _position$1, this.up);
		}
		this.quaternion.setFromRotationMatrix(_m1$1);
		if (parent) {
			_m1$1.extractRotation(parent.matrixWorld);
			_q1.setFromRotationMatrix(_m1$1);
			this.quaternion.premultiply(_q1.invert());
		}
	}
	add(object) {
		if (arguments.length > 1) {
			for (let i = 0; i < arguments.length; i++) {
				this.add(arguments[i]);
			}
			return this;
		}
		if (object === this) {
			console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
			return this;
		}
		if (object && object.isObject3D) {
			if (object.parent !== null) {
				object.parent.remove(object);
			}
			object.parent = this;
			this.children.push(object);
			object.dispatchEvent(_addedEvent);
		} else {
			console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
		}
		return this;
	}
	remove(object) {
		if (arguments.length > 1) {
			for (let i = 0; i < arguments.length; i++) {
				this.remove(arguments[i]);
			}
			return this;
		}
		const index = this.children.indexOf(object);
		if (index !== -1) {
			object.parent = null;
			this.children.splice(index, 1);
			object.dispatchEvent(_removedEvent);
		}
		return this;
	}
	removeFromParent() {
		const parent = this.parent;
		if (parent !== null) {
			parent.remove(this);
		}
		return this;
	}
	clear() {
		for (let i = 0; i < this.children.length; i++) {
			const object = this.children[i];
			object.parent = null;
			object.dispatchEvent(_removedEvent);
		}
		this.children.length = 0;
		return this;
	}
	attach(object) {
		// adds object as a child of this, while maintaining the object's world transform

		// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

		this.updateWorldMatrix(true, false);
		_m1$1.copy(this.matrixWorld).invert();
		if (object.parent !== null) {
			object.parent.updateWorldMatrix(true, false);
			_m1$1.multiply(object.parent.matrixWorld);
		}
		object.applyMatrix4(_m1$1);
		this.add(object);
		object.updateWorldMatrix(false, true);
		return this;
	}
	getObjectById(id) {
		return this.getObjectByProperty('id', id);
	}
	getObjectByName(name) {
		return this.getObjectByProperty('name', name);
	}
	getObjectByProperty(name, value) {
		if (this[name] === value) return this;
		for (let i = 0, l = this.children.length; i < l; i++) {
			const child = this.children[i];
			const object = child.getObjectByProperty(name, value);
			if (object !== undefined) {
				return object;
			}
		}
		return undefined;
	}
	getWorldPosition(target) {
		this.updateWorldMatrix(true, false);
		return target.setFromMatrixPosition(this.matrixWorld);
	}
	getWorldQuaternion(target) {
		this.updateWorldMatrix(true, false);
		this.matrixWorld.decompose(_position$1, target, _scale);
		return target;
	}
	getWorldScale(target) {
		this.updateWorldMatrix(true, false);
		this.matrixWorld.decompose(_position$1, _quaternion, target);
		return target;
	}
	getWorldDirection(target) {
		this.updateWorldMatrix(true, false);
		const e = this.matrixWorld.elements;
		return target.set(e[8], e[9], e[10]).normalize();
	}
	raycast( /* raycaster, intersects */) {}
	traverse(callback) {
		callback(this);
		const children = this.children;
		for (let i = 0, l = children.length; i < l; i++) {
			children[i].traverse(callback);
		}
	}
	traverseVisible(callback) {
		if (this.visible === false) return;
		callback(this);
		const children = this.children;
		for (let i = 0, l = children.length; i < l; i++) {
			children[i].traverseVisible(callback);
		}
	}
	traverseAncestors(callback) {
		const parent = this.parent;
		if (parent !== null) {
			callback(parent);
			parent.traverseAncestors(callback);
		}
	}
	updateMatrix() {
		this.matrix.compose(this.position, this.quaternion, this.scale);
		this.matrixWorldNeedsUpdate = true;
	}
	updateMatrixWorld(force) {
		if (this.matrixAutoUpdate) this.updateMatrix();
		if (this.matrixWorldNeedsUpdate || force) {
			if (this.parent === null) {
				this.matrixWorld.copy(this.matrix);
			} else {
				this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
			}
			this.matrixWorldNeedsUpdate = false;
			force = true;
		}

		// update children

		const children = this.children;
		for (let i = 0, l = children.length; i < l; i++) {
			const child = children[i];
			if (child.matrixWorldAutoUpdate === true || force === true) {
				child.updateMatrixWorld(force);
			}
		}
	}
	updateWorldMatrix(updateParents, updateChildren) {
		const parent = this.parent;
		if (updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true) {
			parent.updateWorldMatrix(true, false);
		}
		if (this.matrixAutoUpdate) this.updateMatrix();
		if (this.parent === null) {
			this.matrixWorld.copy(this.matrix);
		} else {
			this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
		}

		// update children

		if (updateChildren === true) {
			const children = this.children;
			for (let i = 0, l = children.length; i < l; i++) {
				const child = children[i];
				if (child.matrixWorldAutoUpdate === true) {
					child.updateWorldMatrix(false, true);
				}
			}
		}
	}
	toJSON(meta) {
		// meta is a string when called from JSON.stringify
		const isRootObject = meta === undefined || typeof meta === 'string';
		const output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if (isRootObject) {
			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {},
				skeletons: {},
				animations: {},
				nodes: {}
			};
			output.metadata = {
				version: 4.5,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};
		}

		// standard Object3D serialization

		const object = {};
		object.uuid = this.uuid;
		object.type = this.type;
		if (this.name !== '') object.name = this.name;
		if (this.castShadow === true) object.castShadow = true;
		if (this.receiveShadow === true) object.receiveShadow = true;
		if (this.visible === false) object.visible = false;
		if (this.frustumCulled === false) object.frustumCulled = false;
		if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
		if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();
		if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;

		// object specific properties

		if (this.isInstancedMesh) {
			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();
			if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
		}

		//

		function serialize(library, element) {
			if (library[element.uuid] === undefined) {
				library[element.uuid] = element.toJSON(meta);
			}
			return element.uuid;
		}
		if (this.isScene) {
			if (this.background) {
				if (this.background.isColor) {
					object.background = this.background.toJSON();
				} else if (this.background.isTexture) {
					object.background = this.background.toJSON(meta).uuid;
				}
			}
			if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
				object.environment = this.environment.toJSON(meta).uuid;
			}
		} else if (this.isMesh || this.isLine || this.isPoints) {
			object.geometry = serialize(meta.geometries, this.geometry);
			const parameters = this.geometry.parameters;
			if (parameters !== undefined && parameters.shapes !== undefined) {
				const shapes = parameters.shapes;
				if (Array.isArray(shapes)) {
					for (let i = 0, l = shapes.length; i < l; i++) {
						const shape = shapes[i];
						serialize(meta.shapes, shape);
					}
				} else {
					serialize(meta.shapes, shapes);
				}
			}
		}
		if (this.isSkinnedMesh) {
			object.bindMode = this.bindMode;
			object.bindMatrix = this.bindMatrix.toArray();
			if (this.skeleton !== undefined) {
				serialize(meta.skeletons, this.skeleton);
				object.skeleton = this.skeleton.uuid;
			}
		}
		if (this.material !== undefined) {
			if (Array.isArray(this.material)) {
				const uuids = [];
				for (let i = 0, l = this.material.length; i < l; i++) {
					uuids.push(serialize(meta.materials, this.material[i]));
				}
				object.material = uuids;
			} else {
				object.material = serialize(meta.materials, this.material);
			}
		}

		//

		if (this.children.length > 0) {
			object.children = [];
			for (let i = 0; i < this.children.length; i++) {
				object.children.push(this.children[i].toJSON(meta).object);
			}
		}

		//

		if (this.animations.length > 0) {
			object.animations = [];
			for (let i = 0; i < this.animations.length; i++) {
				const animation = this.animations[i];
				object.animations.push(serialize(meta.animations, animation));
			}
		}
		if (isRootObject) {
			const geometries = extractFromCache(meta.geometries);
			const materials = extractFromCache(meta.materials);
			const textures = extractFromCache(meta.textures);
			const images = extractFromCache(meta.images);
			const shapes = extractFromCache(meta.shapes);
			const skeletons = extractFromCache(meta.skeletons);
			const animations = extractFromCache(meta.animations);
			const nodes = extractFromCache(meta.nodes);
			if (geometries.length > 0) output.geometries = geometries;
			if (materials.length > 0) output.materials = materials;
			if (textures.length > 0) output.textures = textures;
			if (images.length > 0) output.images = images;
			if (shapes.length > 0) output.shapes = shapes;
			if (skeletons.length > 0) output.skeletons = skeletons;
			if (animations.length > 0) output.animations = animations;
			if (nodes.length > 0) output.nodes = nodes;
		}
		output.object = object;
		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache(cache) {
			const values = [];
			for (const key in cache) {
				const data = cache[key];
				delete data.metadata;
				values.push(data);
			}
			return values;
		}
	}
	clone(recursive) {
		return new this.constructor().copy(this, recursive);
	}
	copy(source, recursive = true) {
		this.name = source.name;
		this.up.copy(source.up);
		this.position.copy(source.position);
		this.rotation.order = source.rotation.order;
		this.quaternion.copy(source.quaternion);
		this.scale.copy(source.scale);
		this.matrix.copy(source.matrix);
		this.matrixWorld.copy(source.matrixWorld);
		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
		this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
		this.layers.mask = source.layers.mask;
		this.visible = source.visible;
		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;
		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;
		this.userData = JSON.parse(JSON.stringify(source.userData));
		if (recursive === true) {
			for (let i = 0; i < source.children.length; i++) {
				const child = source.children[i];
				this.add(child.clone());
			}
		}
		return this;
	}
}
Object3D.DefaultUp = /*@__PURE__*/new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.DefaultMatrixWorldAutoUpdate = true;

let _id$1 = 0;
const _m1 = /*@__PURE__*/new Matrix4();
const _obj = /*@__PURE__*/new Object3D();
const _offset = /*@__PURE__*/new Vector3();
const _box$1 = /*@__PURE__*/new Box3();
const _boxMorphTargets = /*@__PURE__*/new Box3();
const _vector$8 = /*@__PURE__*/new Vector3();
class BufferGeometry extends EventDispatcher {
	constructor() {
		super();
		this.isBufferGeometry = true;
		Object.defineProperty(this, 'id', {
			value: _id$1++
		});
		this.uuid = generateUUID();
		this.name = '';
		this.type = 'BufferGeometry';
		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.morphTargetsRelative = false;
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;
		this.drawRange = {
			start: 0,
			count: Infinity
		};
		this.userData = {};
	}
	getIndex() {
		return this.index;
	}
	setIndex(index) {
		if (Array.isArray(index)) {
			this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
		} else {
			this.index = index;
		}
		return this;
	}
	getAttribute(name) {
		return this.attributes[name];
	}
	setAttribute(name, attribute) {
		this.attributes[name] = attribute;
		return this;
	}
	deleteAttribute(name) {
		delete this.attributes[name];
		return this;
	}
	hasAttribute(name) {
		return this.attributes[name] !== undefined;
	}
	addGroup(start, count, materialIndex = 0) {
		this.groups.push({
			start: start,
			count: count,
			materialIndex: materialIndex
		});
	}
	clearGroups() {
		this.groups = [];
	}
	setDrawRange(start, count) {
		this.drawRange.start = start;
		this.drawRange.count = count;
	}
	applyMatrix4(matrix) {
		const position = this.attributes.position;
		if (position !== undefined) {
			position.applyMatrix4(matrix);
			position.needsUpdate = true;
		}
		const normal = this.attributes.normal;
		if (normal !== undefined) {
			const normalMatrix = new Matrix3().getNormalMatrix(matrix);
			normal.applyNormalMatrix(normalMatrix);
			normal.needsUpdate = true;
		}
		const tangent = this.attributes.tangent;
		if (tangent !== undefined) {
			tangent.transformDirection(matrix);
			tangent.needsUpdate = true;
		}
		if (this.boundingBox !== null) {
			this.computeBoundingBox();
		}
		if (this.boundingSphere !== null) {
			this.computeBoundingSphere();
		}
		return this;
	}
	applyQuaternion(q) {
		_m1.makeRotationFromQuaternion(q);
		this.applyMatrix4(_m1);
		return this;
	}
	rotateX(angle) {
		// rotate geometry around world x-axis

		_m1.makeRotationX(angle);
		this.applyMatrix4(_m1);
		return this;
	}
	rotateY(angle) {
		// rotate geometry around world y-axis

		_m1.makeRotationY(angle);
		this.applyMatrix4(_m1);
		return this;
	}
	rotateZ(angle) {
		// rotate geometry around world z-axis

		_m1.makeRotationZ(angle);
		this.applyMatrix4(_m1);
		return this;
	}
	translate(x, y, z) {
		// translate geometry

		_m1.makeTranslation(x, y, z);
		this.applyMatrix4(_m1);
		return this;
	}
	scale(x, y, z) {
		// scale geometry

		_m1.makeScale(x, y, z);
		this.applyMatrix4(_m1);
		return this;
	}
	lookAt(vector) {
		_obj.lookAt(vector);
		_obj.updateMatrix();
		this.applyMatrix4(_obj.matrix);
		return this;
	}
	center() {
		this.computeBoundingBox();
		this.boundingBox.getCenter(_offset).negate();
		this.translate(_offset.x, _offset.y, _offset.z);
		return this;
	}
	setFromPoints(points) {
		const position = [];
		for (let i = 0, l = points.length; i < l; i++) {
			const point = points[i];
			position.push(point.x, point.y, point.z || 0);
		}
		this.setAttribute('position', new Float32BufferAttribute(position, 3));
		return this;
	}
	computeBoundingBox() {
		if (this.boundingBox === null) {
			this.boundingBox = new Box3();
		}
		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;
		if (position && position.isGLBufferAttribute) {
			console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
			this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
			return;
		}
		if (position !== undefined) {
			this.boundingBox.setFromBufferAttribute(position);

			// process morph attributes if present

			if (morphAttributesPosition) {
				for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
					const morphAttribute = morphAttributesPosition[i];
					_box$1.setFromBufferAttribute(morphAttribute);
					if (this.morphTargetsRelative) {
						_vector$8.addVectors(this.boundingBox.min, _box$1.min);
						this.boundingBox.expandByPoint(_vector$8);
						_vector$8.addVectors(this.boundingBox.max, _box$1.max);
						this.boundingBox.expandByPoint(_vector$8);
					} else {
						this.boundingBox.expandByPoint(_box$1.min);
						this.boundingBox.expandByPoint(_box$1.max);
					}
				}
			}
		} else {
			this.boundingBox.makeEmpty();
		}
		if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
			console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
		}
	}
	computeBoundingSphere() {
		if (this.boundingSphere === null) {
			this.boundingSphere = new Sphere();
		}
		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;
		if (position && position.isGLBufferAttribute) {
			console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
			this.boundingSphere.set(new Vector3(), Infinity);
			return;
		}
		if (position) {
			// first, find the center of the bounding sphere

			const center = this.boundingSphere.center;
			_box$1.setFromBufferAttribute(position);

			// process morph attributes if present

			if (morphAttributesPosition) {
				for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
					const morphAttribute = morphAttributesPosition[i];
					_boxMorphTargets.setFromBufferAttribute(morphAttribute);
					if (this.morphTargetsRelative) {
						_vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
						_box$1.expandByPoint(_vector$8);
						_vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
						_box$1.expandByPoint(_vector$8);
					} else {
						_box$1.expandByPoint(_boxMorphTargets.min);
						_box$1.expandByPoint(_boxMorphTargets.max);
					}
				}
			}
			_box$1.getCenter(center);

			// second, try to find a boundingSphere with a radius smaller than the
			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			let maxRadiusSq = 0;
			for (let i = 0, il = position.count; i < il; i++) {
				_vector$8.fromBufferAttribute(position, i);
				maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
			}

			// process morph attributes if present

			if (morphAttributesPosition) {
				for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
					const morphAttribute = morphAttributesPosition[i];
					const morphTargetsRelative = this.morphTargetsRelative;
					for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
						_vector$8.fromBufferAttribute(morphAttribute, j);
						if (morphTargetsRelative) {
							_offset.fromBufferAttribute(position, j);
							_vector$8.add(_offset);
						}
						maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
					}
				}
			}
			this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
			if (isNaN(this.boundingSphere.radius)) {
				console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
			}
		}
	}
	computeTangents() {
		const index = this.index;
		const attributes = this.attributes;

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
			console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
			return;
		}
		const indices = index.array;
		const positions = attributes.position.array;
		const normals = attributes.normal.array;
		const uvs = attributes.uv.array;
		const nVertices = positions.length / 3;
		if (this.hasAttribute('tangent') === false) {
			this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));
		}
		const tangents = this.getAttribute('tangent').array;
		const tan1 = [],
			tan2 = [];
		for (let i = 0; i < nVertices; i++) {
			tan1[i] = new Vector3();
			tan2[i] = new Vector3();
		}
		const vA = new Vector3(),
			vB = new Vector3(),
			vC = new Vector3(),
			uvA = new Vector2(),
			uvB = new Vector2(),
			uvC = new Vector2(),
			sdir = new Vector3(),
			tdir = new Vector3();
		function handleTriangle(a, b, c) {
			vA.fromArray(positions, a * 3);
			vB.fromArray(positions, b * 3);
			vC.fromArray(positions, c * 3);
			uvA.fromArray(uvs, a * 2);
			uvB.fromArray(uvs, b * 2);
			uvC.fromArray(uvs, c * 2);
			vB.sub(vA);
			vC.sub(vA);
			uvB.sub(uvA);
			uvC.sub(uvA);
			const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);

			// silently ignore degenerate uv triangles having coincident or colinear vertices

			if (!isFinite(r)) return;
			sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
			tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
			tan1[a].add(sdir);
			tan1[b].add(sdir);
			tan1[c].add(sdir);
			tan2[a].add(tdir);
			tan2[b].add(tdir);
			tan2[c].add(tdir);
		}
		let groups = this.groups;
		if (groups.length === 0) {
			groups = [{
				start: 0,
				count: indices.length
			}];
		}
		for (let i = 0, il = groups.length; i < il; ++i) {
			const group = groups[i];
			const start = group.start;
			const count = group.count;
			for (let j = start, jl = start + count; j < jl; j += 3) {
				handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
			}
		}
		const tmp = new Vector3(),
			tmp2 = new Vector3();
		const n = new Vector3(),
			n2 = new Vector3();
		function handleVertex(v) {
			n.fromArray(normals, v * 3);
			n2.copy(n);
			const t = tan1[v];

			// Gram-Schmidt orthogonalize

			tmp.copy(t);
			tmp.sub(n.multiplyScalar(n.dot(t))).normalize();

			// Calculate handedness

			tmp2.crossVectors(n2, t);
			const test = tmp2.dot(tan2[v]);
			const w = test < 0.0 ? -1.0 : 1.0;
			tangents[v * 4] = tmp.x;
			tangents[v * 4 + 1] = tmp.y;
			tangents[v * 4 + 2] = tmp.z;
			tangents[v * 4 + 3] = w;
		}
		for (let i = 0, il = groups.length; i < il; ++i) {
			const group = groups[i];
			const start = group.start;
			const count = group.count;
			for (let j = start, jl = start + count; j < jl; j += 3) {
				handleVertex(indices[j + 0]);
				handleVertex(indices[j + 1]);
				handleVertex(indices[j + 2]);
			}
		}
	}
	computeVertexNormals() {
		const index = this.index;
		const positionAttribute = this.getAttribute('position');
		if (positionAttribute !== undefined) {
			let normalAttribute = this.getAttribute('normal');
			if (normalAttribute === undefined) {
				normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
				this.setAttribute('normal', normalAttribute);
			} else {
				// reset existing normals to zero

				for (let i = 0, il = normalAttribute.count; i < il; i++) {
					normalAttribute.setXYZ(i, 0, 0, 0);
				}
			}
			const pA = new Vector3(),
				pB = new Vector3(),
				pC = new Vector3();
			const nA = new Vector3(),
				nB = new Vector3(),
				nC = new Vector3();
			const cb = new Vector3(),
				ab = new Vector3();

			// indexed elements

			if (index) {
				for (let i = 0, il = index.count; i < il; i += 3) {
					const vA = index.getX(i + 0);
					const vB = index.getX(i + 1);
					const vC = index.getX(i + 2);
					pA.fromBufferAttribute(positionAttribute, vA);
					pB.fromBufferAttribute(positionAttribute, vB);
					pC.fromBufferAttribute(positionAttribute, vC);
					cb.subVectors(pC, pB);
					ab.subVectors(pA, pB);
					cb.cross(ab);
					nA.fromBufferAttribute(normalAttribute, vA);
					nB.fromBufferAttribute(normalAttribute, vB);
					nC.fromBufferAttribute(normalAttribute, vC);
					nA.add(cb);
					nB.add(cb);
					nC.add(cb);
					normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
					normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
					normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
				}
			} else {
				// non-indexed elements (unconnected triangle soup)

				for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
					pA.fromBufferAttribute(positionAttribute, i + 0);
					pB.fromBufferAttribute(positionAttribute, i + 1);
					pC.fromBufferAttribute(positionAttribute, i + 2);
					cb.subVectors(pC, pB);
					ab.subVectors(pA, pB);
					cb.cross(ab);
					normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
					normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
					normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
				}
			}
			this.normalizeNormals();
			normalAttribute.needsUpdate = true;
		}
	}

	// @deprecated since r144

	merge() {
		console.error('THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead.');
		return this;
	}
	normalizeNormals() {
		const normals = this.attributes.normal;
		for (let i = 0, il = normals.count; i < il; i++) {
			_vector$8.fromBufferAttribute(normals, i);
			_vector$8.normalize();
			normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
		}
	}
	toNonIndexed() {
		function convertBufferAttribute(attribute, indices) {
			const array = attribute.array;
			const itemSize = attribute.itemSize;
			const normalized = attribute.normalized;
			const array2 = new array.constructor(indices.length * itemSize);
			let index = 0,
				index2 = 0;
			for (let i = 0, l = indices.length; i < l; i++) {
				if (attribute.isInterleavedBufferAttribute) {
					index = indices[i] * attribute.data.stride + attribute.offset;
				} else {
					index = indices[i] * itemSize;
				}
				for (let j = 0; j < itemSize; j++) {
					array2[index2++] = array[index++];
				}
			}
			return new BufferAttribute(array2, itemSize, normalized);
		}

		//

		if (this.index === null) {
			console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
			return this;
		}
		const geometry2 = new BufferGeometry();
		const indices = this.index.array;
		const attributes = this.attributes;

		// attributes

		for (const name in attributes) {
			const attribute = attributes[name];
			const newAttribute = convertBufferAttribute(attribute, indices);
			geometry2.setAttribute(name, newAttribute);
		}

		// morph attributes

		const morphAttributes = this.morphAttributes;
		for (const name in morphAttributes) {
			const morphArray = [];
			const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

			for (let i = 0, il = morphAttribute.length; i < il; i++) {
				const attribute = morphAttribute[i];
				const newAttribute = convertBufferAttribute(attribute, indices);
				morphArray.push(newAttribute);
			}
			geometry2.morphAttributes[name] = morphArray;
		}
		geometry2.morphTargetsRelative = this.morphTargetsRelative;

		// groups

		const groups = this.groups;
		for (let i = 0, l = groups.length; i < l; i++) {
			const group = groups[i];
			geometry2.addGroup(group.start, group.count, group.materialIndex);
		}
		return geometry2;
	}
	toJSON() {
		const data = {
			metadata: {
				version: 4.5,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if (this.name !== '') data.name = this.name;
		if (Object.keys(this.userData).length > 0) data.userData = this.userData;
		if (this.parameters !== undefined) {
			const parameters = this.parameters;
			for (const key in parameters) {
				if (parameters[key] !== undefined) data[key] = parameters[key];
			}
			return data;
		}

		// for simplicity the code assumes attributes are not shared across geometries, see #15811

		data.data = {
			attributes: {}
		};
		const index = this.index;
		if (index !== null) {
			data.data.index = {
				type: index.array.constructor.name,
				array: Array.prototype.slice.call(index.array)
			};
		}
		const attributes = this.attributes;
		for (const key in attributes) {
			const attribute = attributes[key];
			data.data.attributes[key] = attribute.toJSON(data.data);
		}
		const morphAttributes = {};
		let hasMorphAttributes = false;
		for (const key in this.morphAttributes) {
			const attributeArray = this.morphAttributes[key];
			const array = [];
			for (let i = 0, il = attributeArray.length; i < il; i++) {
				const attribute = attributeArray[i];
				array.push(attribute.toJSON(data.data));
			}
			if (array.length > 0) {
				morphAttributes[key] = array;
				hasMorphAttributes = true;
			}
		}
		if (hasMorphAttributes) {
			data.data.morphAttributes = morphAttributes;
			data.data.morphTargetsRelative = this.morphTargetsRelative;
		}
		const groups = this.groups;
		if (groups.length > 0) {
			data.data.groups = JSON.parse(JSON.stringify(groups));
		}
		const boundingSphere = this.boundingSphere;
		if (boundingSphere !== null) {
			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};
		}
		return data;
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(source) {
		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// used for storing cloned, shared data

		const data = {};

		// name

		this.name = source.name;

		// index

		const index = source.index;
		if (index !== null) {
			this.setIndex(index.clone(data));
		}

		// attributes

		const attributes = source.attributes;
		for (const name in attributes) {
			const attribute = attributes[name];
			this.setAttribute(name, attribute.clone(data));
		}

		// morph attributes

		const morphAttributes = source.morphAttributes;
		for (const name in morphAttributes) {
			const array = [];
			const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

			for (let i = 0, l = morphAttribute.length; i < l; i++) {
				array.push(morphAttribute[i].clone(data));
			}
			this.morphAttributes[name] = array;
		}
		this.morphTargetsRelative = source.morphTargetsRelative;

		// groups

		const groups = source.groups;
		for (let i = 0, l = groups.length; i < l; i++) {
			const group = groups[i];
			this.addGroup(group.start, group.count, group.materialIndex);
		}

		// bounding box

		const boundingBox = source.boundingBox;
		if (boundingBox !== null) {
			this.boundingBox = boundingBox.clone();
		}

		// bounding sphere

		const boundingSphere = source.boundingSphere;
		if (boundingSphere !== null) {
			this.boundingSphere = boundingSphere.clone();
		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		// user data

		this.userData = source.userData;

		// geometry generator parameters

		if (source.parameters !== undefined) this.parameters = Object.assign({}, source.parameters);
		return this;
	}
	dispose() {
		this.dispatchEvent({
			type: 'dispose'
		});
	}
}

class BoxGeometry extends BufferGeometry {
	constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
		super();
		this.type = 'BoxGeometry';
		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};
		const scope = this;

		// segments

		widthSegments = Math.floor(widthSegments);
		heightSegments = Math.floor(heightSegments);
		depthSegments = Math.floor(depthSegments);

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let numberOfVertices = 0;
		let groupStart = 0;

		// build each side of the box geometry

		buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
		buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
		buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
		buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
		buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
		buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz

		// build geometry

		this.setIndex(indices);
		this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
			const segmentWidth = width / gridX;
			const segmentHeight = height / gridY;
			const widthHalf = width / 2;
			const heightHalf = height / 2;
			const depthHalf = depth / 2;
			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;
			let vertexCounter = 0;
			let groupCount = 0;
			const vector = new Vector3();

			// generate vertices, normals and uvs

			for (let iy = 0; iy < gridY1; iy++) {
				const y = iy * segmentHeight - heightHalf;
				for (let ix = 0; ix < gridX1; ix++) {
					const x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[u] = x * udir;
					vector[v] = y * vdir;
					vector[w] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push(vector.x, vector.y, vector.z);

					// set values to correct vector component

					vector[u] = 0;
					vector[v] = 0;
					vector[w] = depth > 0 ? 1 : -1;

					// now apply vector to normal buffer

					normals.push(vector.x, vector.y, vector.z);

					// uvs

					uvs.push(ix / gridX);
					uvs.push(1 - iy / gridY);

					// counters

					vertexCounter += 1;
				}
			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for (let iy = 0; iy < gridY; iy++) {
				for (let ix = 0; ix < gridX; ix++) {
					const a = numberOfVertices + ix + gridX1 * iy;
					const b = numberOfVertices + ix + gridX1 * (iy + 1);
					const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
					const d = numberOfVertices + (ix + 1) + gridX1 * iy;

					// faces

					indices.push(a, b, d);
					indices.push(b, c, d);

					// increase counter

					groupCount += 6;
				}
			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup(groupStart, groupCount, materialIndex);

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;
		}
	}
	static fromJSON(data) {
		return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
	}
}

class PlaneGeometry extends BufferGeometry {
	constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
		super();
		this.type = 'PlaneGeometry';
		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};
		const width_half = width / 2;
		const height_half = height / 2;
		const gridX = Math.floor(widthSegments);
		const gridY = Math.floor(heightSegments);
		const gridX1 = gridX + 1;
		const gridY1 = gridY + 1;
		const segment_width = width / gridX;
		const segment_height = height / gridY;

		//

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];
		for (let iy = 0; iy < gridY1; iy++) {
			const y = iy * segment_height - height_half;
			for (let ix = 0; ix < gridX1; ix++) {
				const x = ix * segment_width - width_half;
				vertices.push(x, -y, 0);
				normals.push(0, 0, 1);
				uvs.push(ix / gridX);
				uvs.push(1 - iy / gridY);
			}
		}
		for (let iy = 0; iy < gridY; iy++) {
			for (let ix = 0; ix < gridX; ix++) {
				const a = ix + gridX1 * iy;
				const b = ix + gridX1 * (iy + 1);
				const c = ix + 1 + gridX1 * (iy + 1);
				const d = ix + 1 + gridX1 * iy;
				indices.push(a, b, d);
				indices.push(b, c, d);
			}
		}
		this.setIndex(indices);
		this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
	}
	static fromJSON(data) {
		return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
	}
}

let materialId = 0;
class Material extends EventDispatcher {
	constructor() {
		super();
		this.isMaterial = true;
		Object.defineProperty(this, 'id', {
			value: materialId++
		});
		this.uuid = generateUUID();
		this.name = '';
		this.type = 'Material';
		this.blending = NormalBlending;
		this.side = FrontSide;
		this.vertexColors = false;
		this.opacity = 1;
		this.transparent = false;
		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;
		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;
		this.stencilWriteMask = 0xff;
		this.stencilFunc = AlwaysStencilFunc;
		this.stencilRef = 0;
		this.stencilFuncMask = 0xff;
		this.stencilFail = KeepStencilOp;
		this.stencilZFail = KeepStencilOp;
		this.stencilZPass = KeepStencilOp;
		this.stencilWrite = false;
		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;
		this.shadowSide = null;
		this.colorWrite = true;
		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;
		this.dithering = false;
		this.alphaToCoverage = false;
		this.premultipliedAlpha = false;
		this.visible = true;
		this.toneMapped = true;
		this.userData = {};
		this.version = 0;
		this._alphaTest = 0;
	}
	get alphaTest() {
		return this._alphaTest;
	}
	set alphaTest(value) {
		if (this._alphaTest > 0 !== value > 0) {
			this.version++;
		}
		this._alphaTest = value;
	}
	onBuild( /* shaderobject, renderer */) {}
	onBeforeRender( /* renderer, scene, camera, geometry, object, group */) {}
	onBeforeCompile( /* shaderobject, renderer */) {}
	customProgramCacheKey() {
		return this.onBeforeCompile.toString();
	}
	setValues(values) {
		if (values === undefined) return;
		for (const key in values) {
			const newValue = values[key];
			if (newValue === undefined) {
				console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
				continue;
			}
			const currentValue = this[key];
			if (currentValue === undefined) {
				console.warn('THREE.' + this.type + ': \'' + key + '\' is not a property of this material.');
				continue;
			}
			if (currentValue && currentValue.isColor) {
				currentValue.set(newValue);
			} else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
				currentValue.copy(newValue);
			} else {
				this[key] = newValue;
			}
		}
	}
	toJSON(meta) {
		const isRootObject = meta === undefined || typeof meta === 'string';
		if (isRootObject) {
			meta = {
				textures: {},
				images: {}
			};
		}
		const data = {
			metadata: {
				version: 4.5,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;
		if (this.name !== '') data.name = this.name;
		if (this.color && this.color.isColor) data.color = this.color.getHex();
		if (this.roughness !== undefined) data.roughness = this.roughness;
		if (this.metalness !== undefined) data.metalness = this.metalness;
		if (this.sheen !== undefined) data.sheen = this.sheen;
		if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
		if (this.sheenRoughness !== undefined) data.sheenRoughness = this.sheenRoughness;
		if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
		if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
		if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
		if (this.specularIntensity !== undefined) data.specularIntensity = this.specularIntensity;
		if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
		if (this.shininess !== undefined) data.shininess = this.shininess;
		if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
		if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;
		if (this.clearcoatMap && this.clearcoatMap.isTexture) {
			data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
		}
		if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
		}
		if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
		}
		if (this.iridescence !== undefined) data.iridescence = this.iridescence;
		if (this.iridescenceIOR !== undefined) data.iridescenceIOR = this.iridescenceIOR;
		if (this.iridescenceThicknessRange !== undefined) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
		if (this.iridescenceMap && this.iridescenceMap.isTexture) {
			data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
		}
		if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
			data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
		}
		if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
		if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
		if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
		if (this.lightMap && this.lightMap.isTexture) {
			data.lightMap = this.lightMap.toJSON(meta).uuid;
			data.lightMapIntensity = this.lightMapIntensity;
		}
		if (this.aoMap && this.aoMap.isTexture) {
			data.aoMap = this.aoMap.toJSON(meta).uuid;
			data.aoMapIntensity = this.aoMapIntensity;
		}
		if (this.bumpMap && this.bumpMap.isTexture) {
			data.bumpMap = this.bumpMap.toJSON(meta).uuid;
			data.bumpScale = this.bumpScale;
		}
		if (this.normalMap && this.normalMap.isTexture) {
			data.normalMap = this.normalMap.toJSON(meta).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();
		}
		if (this.displacementMap && this.displacementMap.isTexture) {
			data.displacementMap = this.displacementMap.toJSON(meta).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;
		}
		if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
		if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
		if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
		if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
		if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
		if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
		if (this.envMap && this.envMap.isTexture) {
			data.envMap = this.envMap.toJSON(meta).uuid;
			if (this.combine !== undefined) data.combine = this.combine;
		}
		if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
		if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;
		if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;
		if (this.gradientMap && this.gradientMap.isTexture) {
			data.gradientMap = this.gradientMap.toJSON(meta).uuid;
		}
		if (this.transmission !== undefined) data.transmission = this.transmission;
		if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
		if (this.thickness !== undefined) data.thickness = this.thickness;
		if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
		if (this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;
		if (this.attenuationColor !== undefined) data.attenuationColor = this.attenuationColor.getHex();
		if (this.size !== undefined) data.size = this.size;
		if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
		if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
		if (this.blending !== NormalBlending) data.blending = this.blending;
		if (this.side !== FrontSide) data.side = this.side;
		if (this.vertexColors) data.vertexColors = true;
		if (this.opacity < 1) data.opacity = this.opacity;
		if (this.transparent === true) data.transparent = this.transparent;
		data.depthFunc = this.depthFunc;
		data.depthTest = this.depthTest;
		data.depthWrite = this.depthWrite;
		data.colorWrite = this.colorWrite;
		data.stencilWrite = this.stencilWrite;
		data.stencilWriteMask = this.stencilWriteMask;
		data.stencilFunc = this.stencilFunc;
		data.stencilRef = this.stencilRef;
		data.stencilFuncMask = this.stencilFuncMask;
		data.stencilFail = this.stencilFail;
		data.stencilZFail = this.stencilZFail;
		data.stencilZPass = this.stencilZPass;

		// rotation (SpriteMaterial)
		if (this.rotation !== undefined && this.rotation !== 0) data.rotation = this.rotation;
		if (this.polygonOffset === true) data.polygonOffset = true;
		if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
		if (this.linewidth !== undefined && this.linewidth !== 1) data.linewidth = this.linewidth;
		if (this.dashSize !== undefined) data.dashSize = this.dashSize;
		if (this.gapSize !== undefined) data.gapSize = this.gapSize;
		if (this.scale !== undefined) data.scale = this.scale;
		if (this.dithering === true) data.dithering = true;
		if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
		if (this.alphaToCoverage === true) data.alphaToCoverage = this.alphaToCoverage;
		if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
		if (this.wireframe === true) data.wireframe = this.wireframe;
		if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
		if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
		if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
		if (this.flatShading === true) data.flatShading = this.flatShading;
		if (this.visible === false) data.visible = false;
		if (this.toneMapped === false) data.toneMapped = false;
		if (this.fog === false) data.fog = false;
		if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache(cache) {
			const values = [];
			for (const key in cache) {
				const data = cache[key];
				delete data.metadata;
				values.push(data);
			}
			return values;
		}
		if (isRootObject) {
			const textures = extractFromCache(meta.textures);
			const images = extractFromCache(meta.images);
			if (textures.length > 0) data.textures = textures;
			if (images.length > 0) data.images = images;
		}
		return data;
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(source) {
		this.name = source.name;
		this.blending = source.blending;
		this.side = source.side;
		this.vertexColors = source.vertexColors;
		this.opacity = source.opacity;
		this.transparent = source.transparent;
		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;
		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;
		this.stencilWriteMask = source.stencilWriteMask;
		this.stencilFunc = source.stencilFunc;
		this.stencilRef = source.stencilRef;
		this.stencilFuncMask = source.stencilFuncMask;
		this.stencilFail = source.stencilFail;
		this.stencilZFail = source.stencilZFail;
		this.stencilZPass = source.stencilZPass;
		this.stencilWrite = source.stencilWrite;
		const srcPlanes = source.clippingPlanes;
		let dstPlanes = null;
		if (srcPlanes !== null) {
			const n = srcPlanes.length;
			dstPlanes = new Array(n);
			for (let i = 0; i !== n; ++i) {
				dstPlanes[i] = srcPlanes[i].clone();
			}
		}
		this.clippingPlanes = dstPlanes;
		this.clipIntersection = source.clipIntersection;
		this.clipShadows = source.clipShadows;
		this.shadowSide = source.shadowSide;
		this.colorWrite = source.colorWrite;
		this.precision = source.precision;
		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;
		this.dithering = source.dithering;
		this.alphaTest = source.alphaTest;
		this.alphaToCoverage = source.alphaToCoverage;
		this.premultipliedAlpha = source.premultipliedAlpha;
		this.visible = source.visible;
		this.toneMapped = source.toneMapped;
		this.userData = JSON.parse(JSON.stringify(source.userData));
		return this;
	}
	dispose() {
		this.dispatchEvent({
			type: 'dispose'
		});
	}
	set needsUpdate(value) {
		if (value === true) this.version++;
	}
}

/**
 * Uniform Utilities
 */

function cloneUniforms(src) {
	const dst = {};
	for (const u in src) {
		dst[u] = {};
		for (const p in src[u]) {
			const property = src[u][p];
			if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
				dst[u][p] = property.clone();
			} else if (Array.isArray(property)) {
				dst[u][p] = property.slice();
			} else {
				dst[u][p] = property;
			}
		}
	}
	return dst;
}
function mergeUniforms(uniforms) {
	const merged = {};
	for (let u = 0; u < uniforms.length; u++) {
		const tmp = cloneUniforms(uniforms[u]);
		for (const p in tmp) {
			merged[p] = tmp[p];
		}
	}
	return merged;
}
function cloneUniformsGroups(src) {
	const dst = [];
	for (let u = 0; u < src.length; u++) {
		dst.push(src[u].clone());
	}
	return dst;
}

// Legacy

const UniformsUtils = {
	clone: cloneUniforms,
	merge: mergeUniforms
};

var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

class ShaderMaterial extends Material {
	constructor(parameters) {
		super();
		this.isShaderMaterial = true;
		this.type = 'ShaderMaterial';
		this.defines = {};
		this.uniforms = {};
		this.uniformsGroups = [];
		this.vertexShader = default_vertex;
		this.fragmentShader = default_fragment;
		this.linewidth = 1;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.extensions = {
			derivatives: false,
			// set to use derivatives
			fragDepth: false,
			// set to use fragment depth values
			drawBuffers: false,
			// set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [1, 1, 1],
			'uv': [0, 0],
			'uv2': [0, 0]
		};
		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;
		this.glslVersion = null;
		if (parameters !== undefined) {
			this.setValues(parameters);
		}
	}
	copy(source) {
		super.copy(source);
		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;
		this.uniforms = cloneUniforms(source.uniforms);
		this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
		this.defines = Object.assign({}, source.defines);
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.fog = source.fog;
		this.lights = source.lights;
		this.clipping = source.clipping;
		this.extensions = Object.assign({}, source.extensions);
		this.glslVersion = source.glslVersion;
		return this;
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		data.glslVersion = this.glslVersion;
		data.uniforms = {};
		for (const name in this.uniforms) {
			const uniform = this.uniforms[name];
			const value = uniform.value;
			if (value && value.isTexture) {
				data.uniforms[name] = {
					type: 't',
					value: value.toJSON(meta).uuid
				};
			} else if (value && value.isColor) {
				data.uniforms[name] = {
					type: 'c',
					value: value.getHex()
				};
			} else if (value && value.isVector2) {
				data.uniforms[name] = {
					type: 'v2',
					value: value.toArray()
				};
			} else if (value && value.isVector3) {
				data.uniforms[name] = {
					type: 'v3',
					value: value.toArray()
				};
			} else if (value && value.isVector4) {
				data.uniforms[name] = {
					type: 'v4',
					value: value.toArray()
				};
			} else if (value && value.isMatrix3) {
				data.uniforms[name] = {
					type: 'm3',
					value: value.toArray()
				};
			} else if (value && value.isMatrix4) {
				data.uniforms[name] = {
					type: 'm4',
					value: value.toArray()
				};
			} else {
				data.uniforms[name] = {
					value: value
				};

				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
			}
		}

		if (Object.keys(this.defines).length > 0) data.defines = this.defines;
		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;
		const extensions = {};
		for (const key in this.extensions) {
			if (this.extensions[key] === true) extensions[key] = true;
		}
		if (Object.keys(extensions).length > 0) data.extensions = extensions;
		return data;
	}
}

const _vector$7 = /*@__PURE__*/new Vector3();
const _segCenter = /*@__PURE__*/new Vector3();
const _segDir = /*@__PURE__*/new Vector3();
const _diff = /*@__PURE__*/new Vector3();
const _edge1 = /*@__PURE__*/new Vector3();
const _edge2 = /*@__PURE__*/new Vector3();
const _normal$1 = /*@__PURE__*/new Vector3();
class Ray {
	constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
		this.origin = origin;
		this.direction = direction;
	}
	set(origin, direction) {
		this.origin.copy(origin);
		this.direction.copy(direction);
		return this;
	}
	copy(ray) {
		this.origin.copy(ray.origin);
		this.direction.copy(ray.direction);
		return this;
	}
	at(t, target) {
		return target.copy(this.direction).multiplyScalar(t).add(this.origin);
	}
	lookAt(v) {
		this.direction.copy(v).sub(this.origin).normalize();
		return this;
	}
	recast(t) {
		this.origin.copy(this.at(t, _vector$7));
		return this;
	}
	closestPointToPoint(point, target) {
		target.subVectors(point, this.origin);
		const directionDistance = target.dot(this.direction);
		if (directionDistance < 0) {
			return target.copy(this.origin);
		}
		return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
	}
	distanceToPoint(point) {
		return Math.sqrt(this.distanceSqToPoint(point));
	}
	distanceSqToPoint(point) {
		const directionDistance = _vector$7.subVectors(point, this.origin).dot(this.direction);

		// point behind the ray

		if (directionDistance < 0) {
			return this.origin.distanceToSquared(point);
		}
		_vector$7.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
		return _vector$7.distanceToSquared(point);
	}
	distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		_segCenter.copy(v0).add(v1).multiplyScalar(0.5);
		_segDir.copy(v1).sub(v0).normalize();
		_diff.copy(this.origin).sub(_segCenter);
		const segExtent = v0.distanceTo(v1) * 0.5;
		const a01 = -this.direction.dot(_segDir);
		const b0 = _diff.dot(this.direction);
		const b1 = -_diff.dot(_segDir);
		const c = _diff.lengthSq();
		const det = Math.abs(1 - a01 * a01);
		let s0, s1, sqrDist, extDet;
		if (det > 0) {
			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;
			if (s0 >= 0) {
				if (s1 >= -extDet) {
					if (s1 <= extDet) {
						// region 0
						// Minimum at interior points of ray and segment.

						const invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
					} else {
						// region 1

						s1 = segExtent;
						s0 = Math.max(0, -(a01 * s1 + b0));
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					}
				} else {
					// region 5

					s1 = -segExtent;
					s0 = Math.max(0, -(a01 * s1 + b0));
					sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
				}
			} else {
				if (s1 <= -extDet) {
					// region 4

					s0 = Math.max(0, -(-a01 * segExtent + b0));
					s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
					sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
				} else if (s1 <= extDet) {
					// region 3

					s0 = 0;
					s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
					sqrDist = s1 * (s1 + 2 * b1) + c;
				} else {
					// region 2

					s0 = Math.max(0, -(a01 * segExtent + b0));
					s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
					sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
				}
			}
		} else {
			// Ray and segment are parallel.

			s1 = a01 > 0 ? -segExtent : segExtent;
			s0 = Math.max(0, -(a01 * s1 + b0));
			sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
		}
		if (optionalPointOnRay) {
			optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
		}
		if (optionalPointOnSegment) {
			optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
		}
		return sqrDist;
	}
	intersectSphere(sphere, target) {
		_vector$7.subVectors(sphere.center, this.origin);
		const tca = _vector$7.dot(this.direction);
		const d2 = _vector$7.dot(_vector$7) - tca * tca;
		const radius2 = sphere.radius * sphere.radius;
		if (d2 > radius2) return null;
		const thc = Math.sqrt(radius2 - d2);

		// t0 = first intersect point - entrance on front of sphere
		const t0 = tca - thc;

		// t1 = second intersect point - exit point on back of sphere
		const t1 = tca + thc;

		// test to see if both t0 and t1 are behind the ray - if so, return null
		if (t0 < 0 && t1 < 0) return null;

		// test to see if t0 is behind the ray:
		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		// in order to always return an intersect point that is in front of the ray.
		if (t0 < 0) return this.at(t1, target);

		// else t0 is in front of the ray, so return the first collision point scaled by t0
		return this.at(t0, target);
	}
	intersectsSphere(sphere) {
		return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
	}
	distanceToPlane(plane) {
		const denominator = plane.normal.dot(this.direction);
		if (denominator === 0) {
			// line is coplanar, return origin
			if (plane.distanceToPoint(this.origin) === 0) {
				return 0;
			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;
		}
		const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;
	}
	intersectPlane(plane, target) {
		const t = this.distanceToPlane(plane);
		if (t === null) {
			return null;
		}
		return this.at(t, target);
	}
	intersectsPlane(plane) {
		// check if the ray lies on the plane first

		const distToPoint = plane.distanceToPoint(this.origin);
		if (distToPoint === 0) {
			return true;
		}
		const denominator = plane.normal.dot(this.direction);
		if (denominator * distToPoint < 0) {
			return true;
		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;
	}
	intersectBox(box, target) {
		let tmin, tmax, tymin, tymax, tzmin, tzmax;
		const invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;
		const origin = this.origin;
		if (invdirx >= 0) {
			tmin = (box.min.x - origin.x) * invdirx;
			tmax = (box.max.x - origin.x) * invdirx;
		} else {
			tmin = (box.max.x - origin.x) * invdirx;
			tmax = (box.min.x - origin.x) * invdirx;
		}
		if (invdiry >= 0) {
			tymin = (box.min.y - origin.y) * invdiry;
			tymax = (box.max.y - origin.y) * invdiry;
		} else {
			tymin = (box.max.y - origin.y) * invdiry;
			tymax = (box.min.y - origin.y) * invdiry;
		}
		if (tmin > tymax || tymin > tmax) return null;
		if (tymin > tmin || isNaN(tmin)) tmin = tymin;
		if (tymax < tmax || isNaN(tmax)) tmax = tymax;
		if (invdirz >= 0) {
			tzmin = (box.min.z - origin.z) * invdirz;
			tzmax = (box.max.z - origin.z) * invdirz;
		} else {
			tzmin = (box.max.z - origin.z) * invdirz;
			tzmax = (box.min.z - origin.z) * invdirz;
		}
		if (tmin > tzmax || tzmin > tmax) return null;
		if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
		if (tzmax < tmax || tmax !== tmax) tmax = tzmax;

		//return point closest to the ray (positive side)

		if (tmax < 0) return null;
		return this.at(tmin >= 0 ? tmin : tmax, target);
	}
	intersectsBox(box) {
		return this.intersectBox(box, _vector$7) !== null;
	}
	intersectTriangle(a, b, c, backfaceCulling, target) {
		// Compute the offset origin, edges, and normal.

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		_edge1.subVectors(b, a);
		_edge2.subVectors(c, a);
		_normal$1.crossVectors(_edge1, _edge2);

		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		//	 |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		//	 |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		//	 |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		let DdN = this.direction.dot(_normal$1);
		let sign;
		if (DdN > 0) {
			if (backfaceCulling) return null;
			sign = 1;
		} else if (DdN < 0) {
			sign = -1;
			DdN = -DdN;
		} else {
			return null;
		}
		_diff.subVectors(this.origin, a);
		const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));

		// b1 < 0, no intersection
		if (DdQxE2 < 0) {
			return null;
		}
		const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));

		// b2 < 0, no intersection
		if (DdE1xQ < 0) {
			return null;
		}

		// b1+b2 > 1, no intersection
		if (DdQxE2 + DdE1xQ > DdN) {
			return null;
		}

		// Line intersects triangle, check if ray does.
		const QdN = -sign * _diff.dot(_normal$1);

		// t < 0, no intersection
		if (QdN < 0) {
			return null;
		}

		// Ray intersects triangle.
		return this.at(QdN / DdN, target);
	}
	applyMatrix4(matrix4) {
		this.origin.applyMatrix4(matrix4);
		this.direction.transformDirection(matrix4);
		return this;
	}
	equals(ray) {
		return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
	}
	clone() {
		return new this.constructor().copy(this);
	}
}

const _v0$1 = /*@__PURE__*/new Vector3();
const _v1$4 = /*@__PURE__*/new Vector3();
const _v2$3 = /*@__PURE__*/new Vector3();
const _v3$2 = /*@__PURE__*/new Vector3();
const _vab = /*@__PURE__*/new Vector3();
const _vac = /*@__PURE__*/new Vector3();
const _vbc = /*@__PURE__*/new Vector3();
const _vap = /*@__PURE__*/new Vector3();
const _vbp = /*@__PURE__*/new Vector3();
const _vcp = /*@__PURE__*/new Vector3();
class Triangle {
	constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
		this.a = a;
		this.b = b;
		this.c = c;
	}
	static getNormal(a, b, c, target) {
		target.subVectors(c, b);
		_v0$1.subVectors(a, b);
		target.cross(_v0$1);
		const targetLengthSq = target.lengthSq();
		if (targetLengthSq > 0) {
			return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
		}
		return target.set(0, 0, 0);
	}

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	static getBarycoord(point, a, b, c, target) {
		_v0$1.subVectors(c, a);
		_v1$4.subVectors(b, a);
		_v2$3.subVectors(point, a);
		const dot00 = _v0$1.dot(_v0$1);
		const dot01 = _v0$1.dot(_v1$4);
		const dot02 = _v0$1.dot(_v2$3);
		const dot11 = _v1$4.dot(_v1$4);
		const dot12 = _v1$4.dot(_v2$3);
		const denom = dot00 * dot11 - dot01 * dot01;

		// collinear or singular triangle
		if (denom === 0) {
			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return target.set(-2, -1, -1);
		}
		const invDenom = 1 / denom;
		const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
		const v = (dot00 * dot12 - dot01 * dot02) * invDenom;

		// barycentric coordinates must always sum to 1
		return target.set(1 - u - v, v, u);
	}
	static containsPoint(point, a, b, c) {
		this.getBarycoord(point, a, b, c, _v3$2);
		return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
	}
	static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
		this.getBarycoord(point, p1, p2, p3, _v3$2);
		target.set(0, 0);
		target.addScaledVector(uv1, _v3$2.x);
		target.addScaledVector(uv2, _v3$2.y);
		target.addScaledVector(uv3, _v3$2.z);
		return target;
	}
	static isFrontFacing(a, b, c, direction) {
		_v0$1.subVectors(c, b);
		_v1$4.subVectors(a, b);

		// strictly front facing
		return _v0$1.cross(_v1$4).dot(direction) < 0 ? true : false;
	}
	set(a, b, c) {
		this.a.copy(a);
		this.b.copy(b);
		this.c.copy(c);
		return this;
	}
	setFromPointsAndIndices(points, i0, i1, i2) {
		this.a.copy(points[i0]);
		this.b.copy(points[i1]);
		this.c.copy(points[i2]);
		return this;
	}
	setFromAttributeAndIndices(attribute, i0, i1, i2) {
		this.a.fromBufferAttribute(attribute, i0);
		this.b.fromBufferAttribute(attribute, i1);
		this.c.fromBufferAttribute(attribute, i2);
		return this;
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(triangle) {
		this.a.copy(triangle.a);
		this.b.copy(triangle.b);
		this.c.copy(triangle.c);
		return this;
	}
	getArea() {
		_v0$1.subVectors(this.c, this.b);
		_v1$4.subVectors(this.a, this.b);
		return _v0$1.cross(_v1$4).length() * 0.5;
	}
	getMidpoint(target) {
		return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
	}
	getNormal(target) {
		return Triangle.getNormal(this.a, this.b, this.c, target);
	}
	getPlane(target) {
		return target.setFromCoplanarPoints(this.a, this.b, this.c);
	}
	getBarycoord(point, target) {
		return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
	}
	getUV(point, uv1, uv2, uv3, target) {
		return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
	}
	containsPoint(point) {
		return Triangle.containsPoint(point, this.a, this.b, this.c);
	}
	isFrontFacing(direction) {
		return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
	}
	intersectsBox(box) {
		return box.intersectsTriangle(this);
	}
	closestPointToPoint(p, target) {
		const a = this.a,
			b = this.b,
			c = this.c;
		let v, w;

		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
		// basically, we're distinguishing which of the voronoi regions of the triangle
		// the point lies in with the minimum amount of redundant computation.

		_vab.subVectors(b, a);
		_vac.subVectors(c, a);
		_vap.subVectors(p, a);
		const d1 = _vab.dot(_vap);
		const d2 = _vac.dot(_vap);
		if (d1 <= 0 && d2 <= 0) {
			// vertex region of A; barycentric coords (1, 0, 0)
			return target.copy(a);
		}
		_vbp.subVectors(p, b);
		const d3 = _vab.dot(_vbp);
		const d4 = _vac.dot(_vbp);
		if (d3 >= 0 && d4 <= d3) {
			// vertex region of B; barycentric coords (0, 1, 0)
			return target.copy(b);
		}
		const vc = d1 * d4 - d3 * d2;
		if (vc <= 0 && d1 >= 0 && d3 <= 0) {
			v = d1 / (d1 - d3);
			// edge region of AB; barycentric coords (1-v, v, 0)
			return target.copy(a).addScaledVector(_vab, v);
		}
		_vcp.subVectors(p, c);
		const d5 = _vab.dot(_vcp);
		const d6 = _vac.dot(_vcp);
		if (d6 >= 0 && d5 <= d6) {
			// vertex region of C; barycentric coords (0, 0, 1)
			return target.copy(c);
		}
		const vb = d5 * d2 - d1 * d6;
		if (vb <= 0 && d2 >= 0 && d6 <= 0) {
			w = d2 / (d2 - d6);
			// edge region of AC; barycentric coords (1-w, 0, w)
			return target.copy(a).addScaledVector(_vac, w);
		}
		const va = d3 * d6 - d5 * d4;
		if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
			_vbc.subVectors(c, b);
			w = (d4 - d3) / (d4 - d3 + (d5 - d6));
			// edge region of BC; barycentric coords (0, 1-w, w)
			return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
		}

		// face region
		const denom = 1 / (va + vb + vc);
		// u = va * denom
		v = vb * denom;
		w = vc * denom;
		return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
	}
	equals(triangle) {
		return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
	}
}

class MeshBasicMaterial extends Material {
	constructor(parameters) {
		super();
		this.isMeshBasicMaterial = true;
		this.type = 'MeshBasicMaterial';
		this.color = new Color$1(0xffffff); // emissive

		this.map = null;
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
		this.specularMap = null;
		this.alphaMap = null;
		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.map = source.map;
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
		this.specularMap = source.specularMap;
		this.alphaMap = source.alphaMap;
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
		this.fog = source.fog;
		return this;
	}
}

const _inverseMatrix$2 = /*@__PURE__*/new Matrix4();
const _ray$2 = /*@__PURE__*/new Ray();
const _sphere$2 = /*@__PURE__*/new Sphere();
const _vA$1 = /*@__PURE__*/new Vector3();
const _vB$1 = /*@__PURE__*/new Vector3();
const _vC$1 = /*@__PURE__*/new Vector3();
const _tempA = /*@__PURE__*/new Vector3();
const _tempB = /*@__PURE__*/new Vector3();
const _tempC = /*@__PURE__*/new Vector3();
const _morphA = /*@__PURE__*/new Vector3();
const _morphB = /*@__PURE__*/new Vector3();
const _morphC = /*@__PURE__*/new Vector3();
const _uvA$1 = /*@__PURE__*/new Vector2();
const _uvB$1 = /*@__PURE__*/new Vector2();
const _uvC$1 = /*@__PURE__*/new Vector2();
const _intersectionPoint = /*@__PURE__*/new Vector3();
const _intersectionPointWorld = /*@__PURE__*/new Vector3();
class Mesh extends Object3D {
	constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
		super();
		this.isMesh = true;
		this.type = 'Mesh';
		this.geometry = geometry;
		this.material = material;
		this.updateMorphTargets();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		if (source.morphTargetInfluences !== undefined) {
			this.morphTargetInfluences = source.morphTargetInfluences.slice();
		}
		if (source.morphTargetDictionary !== undefined) {
			this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
		}
		this.material = source.material;
		this.geometry = source.geometry;
		return this;
	}
	updateMorphTargets() {
		const geometry = this.geometry;
		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys(morphAttributes);
		if (keys.length > 0) {
			const morphAttribute = morphAttributes[keys[0]];
			if (morphAttribute !== undefined) {
				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};
				for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
					const name = morphAttribute[m].name || String(m);
					this.morphTargetInfluences.push(0);
					this.morphTargetDictionary[name] = m;
				}
			}
		}
	}
	raycast(raycaster, intersects) {
		const geometry = this.geometry;
		const material = this.material;
		const matrixWorld = this.matrixWorld;
		if (material === undefined) return;

		// Checking boundingSphere distance to ray

		if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
		_sphere$2.copy(geometry.boundingSphere);
		_sphere$2.applyMatrix4(matrixWorld);
		if (raycaster.ray.intersectsSphere(_sphere$2) === false) return;

		//

		_inverseMatrix$2.copy(matrixWorld).invert();
		_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);

		// Check boundingBox before continuing

		if (geometry.boundingBox !== null) {
			if (_ray$2.intersectsBox(geometry.boundingBox) === false) return;
		}
		let intersection;
		const index = geometry.index;
		const position = geometry.attributes.position;
		const morphPosition = geometry.morphAttributes.position;
		const morphTargetsRelative = geometry.morphTargetsRelative;
		const uv = geometry.attributes.uv;
		const uv2 = geometry.attributes.uv2;
		const groups = geometry.groups;
		const drawRange = geometry.drawRange;
		if (index !== null) {
			// indexed buffer geometry

			if (Array.isArray(material)) {
				for (let i = 0, il = groups.length; i < il; i++) {
					const group = groups[i];
					const groupMaterial = material[group.materialIndex];
					const start = Math.max(group.start, drawRange.start);
					const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
					for (let j = start, jl = end; j < jl; j += 3) {
						const a = index.getX(j);
						const b = index.getX(j + 1);
						const c = index.getX(j + 2);
						intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
						if (intersection) {
							intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push(intersection);
						}
					}
				}
			} else {
				const start = Math.max(0, drawRange.start);
				const end = Math.min(index.count, drawRange.start + drawRange.count);
				for (let i = start, il = end; i < il; i += 3) {
					const a = index.getX(i);
					const b = index.getX(i + 1);
					const c = index.getX(i + 2);
					intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
					if (intersection) {
						intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics
						intersects.push(intersection);
					}
				}
			}
		} else if (position !== undefined) {
			// non-indexed buffer geometry

			if (Array.isArray(material)) {
				for (let i = 0, il = groups.length; i < il; i++) {
					const group = groups[i];
					const groupMaterial = material[group.materialIndex];
					const start = Math.max(group.start, drawRange.start);
					const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
					for (let j = start, jl = end; j < jl; j += 3) {
						const a = j;
						const b = j + 1;
						const c = j + 2;
						intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
						if (intersection) {
							intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push(intersection);
						}
					}
				}
			} else {
				const start = Math.max(0, drawRange.start);
				const end = Math.min(position.count, drawRange.start + drawRange.count);
				for (let i = start, il = end; i < il; i += 3) {
					const a = i;
					const b = i + 1;
					const c = i + 2;
					intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
					if (intersection) {
						intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics
						intersects.push(intersection);
					}
				}
			}
		}
	}
}
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
	let intersect;
	if (material.side === BackSide) {
		intersect = ray.intersectTriangle(pC, pB, pA, true, point);
	} else {
		intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
	}
	if (intersect === null) return null;
	_intersectionPointWorld.copy(point);
	_intersectionPointWorld.applyMatrix4(object.matrixWorld);
	const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
	if (distance < raycaster.near || distance > raycaster.far) return null;
	return {
		distance: distance,
		point: _intersectionPointWorld.clone(),
		object: object
	};
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
	_vA$1.fromBufferAttribute(position, a);
	_vB$1.fromBufferAttribute(position, b);
	_vC$1.fromBufferAttribute(position, c);
	const morphInfluences = object.morphTargetInfluences;
	if (morphPosition && morphInfluences) {
		_morphA.set(0, 0, 0);
		_morphB.set(0, 0, 0);
		_morphC.set(0, 0, 0);
		for (let i = 0, il = morphPosition.length; i < il; i++) {
			const influence = morphInfluences[i];
			const morphAttribute = morphPosition[i];
			if (influence === 0) continue;
			_tempA.fromBufferAttribute(morphAttribute, a);
			_tempB.fromBufferAttribute(morphAttribute, b);
			_tempC.fromBufferAttribute(morphAttribute, c);
			if (morphTargetsRelative) {
				_morphA.addScaledVector(_tempA, influence);
				_morphB.addScaledVector(_tempB, influence);
				_morphC.addScaledVector(_tempC, influence);
			} else {
				_morphA.addScaledVector(_tempA.sub(_vA$1), influence);
				_morphB.addScaledVector(_tempB.sub(_vB$1), influence);
				_morphC.addScaledVector(_tempC.sub(_vC$1), influence);
			}
		}
		_vA$1.add(_morphA);
		_vB$1.add(_morphB);
		_vC$1.add(_morphC);
	}
	if (object.isSkinnedMesh) {
		object.boneTransform(a, _vA$1);
		object.boneTransform(b, _vB$1);
		object.boneTransform(c, _vC$1);
	}
	const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
	if (intersection) {
		if (uv) {
			_uvA$1.fromBufferAttribute(uv, a);
			_uvB$1.fromBufferAttribute(uv, b);
			_uvC$1.fromBufferAttribute(uv, c);
			intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
		}
		if (uv2) {
			_uvA$1.fromBufferAttribute(uv2, a);
			_uvB$1.fromBufferAttribute(uv2, b);
			_uvC$1.fromBufferAttribute(uv2, c);
			intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
		}
		const face = {
			a: a,
			b: b,
			c: c,
			normal: new Vector3(),
			materialIndex: 0
		};
		Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
		intersection.face = face;
	}
	return intersection;
}

var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";

var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";

var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";

var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

var begin_vertex = "vec3 transformed = vec3( position );";

var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n		float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n		float x2 = x * x;\n		float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n		return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif";

var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,	0.0556434,\n\t\t-1.5371385,	1.8760108, -0.2040259,\n\t\t-0.4985314,	0.0415560,	1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";

var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

var encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";

var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";

var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";

var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}";

var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";

var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";

var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert\n#define Material_LightProbeLOD( material )\t(0)";

var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";

var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";

var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif";

var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(		0, 1,		0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";

var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";

var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";

var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";

var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";

var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";

var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";

var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";

var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";

var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t	texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t	f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t	texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t	f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

var shadowmap_vertex = "#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif";

var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(	1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,	1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,	1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif";

var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";

var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

const vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
const fragment$h = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
const fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
const fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
const fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

const vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
const fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";

const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";
const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

const vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

const ShaderChunk = {
	alphamap_fragment: alphamap_fragment,
	alphamap_pars_fragment: alphamap_pars_fragment,
	alphatest_fragment: alphatest_fragment,
	alphatest_pars_fragment: alphatest_pars_fragment,
	aomap_fragment: aomap_fragment,
	aomap_pars_fragment: aomap_pars_fragment,
	begin_vertex: begin_vertex,
	beginnormal_vertex: beginnormal_vertex,
	bsdfs: bsdfs,
	iridescence_fragment: iridescence_fragment,
	bumpmap_pars_fragment: bumpmap_pars_fragment,
	clipping_planes_fragment: clipping_planes_fragment,
	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	clipping_planes_vertex: clipping_planes_vertex,
	color_fragment: color_fragment,
	color_pars_fragment: color_pars_fragment,
	color_pars_vertex: color_pars_vertex,
	color_vertex: color_vertex,
	common: common,
	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	defaultnormal_vertex: defaultnormal_vertex,
	displacementmap_pars_vertex: displacementmap_pars_vertex,
	displacementmap_vertex: displacementmap_vertex,
	emissivemap_fragment: emissivemap_fragment,
	emissivemap_pars_fragment: emissivemap_pars_fragment,
	encodings_fragment: encodings_fragment,
	encodings_pars_fragment: encodings_pars_fragment,
	envmap_fragment: envmap_fragment,
	envmap_common_pars_fragment: envmap_common_pars_fragment,
	envmap_pars_fragment: envmap_pars_fragment,
	envmap_pars_vertex: envmap_pars_vertex,
	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
	envmap_vertex: envmap_vertex,
	fog_vertex: fog_vertex,
	fog_pars_vertex: fog_pars_vertex,
	fog_fragment: fog_fragment,
	fog_pars_fragment: fog_pars_fragment,
	gradientmap_pars_fragment: gradientmap_pars_fragment,
	lightmap_fragment: lightmap_fragment,
	lightmap_pars_fragment: lightmap_pars_fragment,
	lights_lambert_fragment: lights_lambert_fragment,
	lights_lambert_pars_fragment: lights_lambert_pars_fragment,
	lights_pars_begin: lights_pars_begin,
	lights_toon_fragment: lights_toon_fragment,
	lights_toon_pars_fragment: lights_toon_pars_fragment,
	lights_phong_fragment: lights_phong_fragment,
	lights_phong_pars_fragment: lights_phong_pars_fragment,
	lights_physical_fragment: lights_physical_fragment,
	lights_physical_pars_fragment: lights_physical_pars_fragment,
	lights_fragment_begin: lights_fragment_begin,
	lights_fragment_maps: lights_fragment_maps,
	lights_fragment_end: lights_fragment_end,
	logdepthbuf_fragment: logdepthbuf_fragment,
	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	logdepthbuf_vertex: logdepthbuf_vertex,
	map_fragment: map_fragment,
	map_pars_fragment: map_pars_fragment,
	map_particle_fragment: map_particle_fragment,
	map_particle_pars_fragment: map_particle_pars_fragment,
	metalnessmap_fragment: metalnessmap_fragment,
	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	morphcolor_vertex: morphcolor_vertex,
	morphnormal_vertex: morphnormal_vertex,
	morphtarget_pars_vertex: morphtarget_pars_vertex,
	morphtarget_vertex: morphtarget_vertex,
	normal_fragment_begin: normal_fragment_begin,
	normal_fragment_maps: normal_fragment_maps,
	normal_pars_fragment: normal_pars_fragment,
	normal_pars_vertex: normal_pars_vertex,
	normal_vertex: normal_vertex,
	normalmap_pars_fragment: normalmap_pars_fragment,
	clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
	clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
	clearcoat_pars_fragment: clearcoat_pars_fragment,
	iridescence_pars_fragment: iridescence_pars_fragment,
	output_fragment: output_fragment,
	packing: packing,
	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	project_vertex: project_vertex,
	dithering_fragment: dithering_fragment,
	dithering_pars_fragment: dithering_pars_fragment,
	roughnessmap_fragment: roughnessmap_fragment,
	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	shadowmap_pars_fragment: shadowmap_pars_fragment,
	shadowmap_pars_vertex: shadowmap_pars_vertex,
	shadowmap_vertex: shadowmap_vertex,
	shadowmask_pars_fragment: shadowmask_pars_fragment,
	skinbase_vertex: skinbase_vertex,
	skinning_pars_vertex: skinning_pars_vertex,
	skinning_vertex: skinning_vertex,
	skinnormal_vertex: skinnormal_vertex,
	specularmap_fragment: specularmap_fragment,
	specularmap_pars_fragment: specularmap_pars_fragment,
	tonemapping_fragment: tonemapping_fragment,
	tonemapping_pars_fragment: tonemapping_pars_fragment,
	transmission_fragment: transmission_fragment,
	transmission_pars_fragment: transmission_pars_fragment,
	uv_pars_fragment: uv_pars_fragment,
	uv_pars_vertex: uv_pars_vertex,
	uv_vertex: uv_vertex,
	uv2_pars_fragment: uv2_pars_fragment,
	uv2_pars_vertex: uv2_pars_vertex,
	uv2_vertex: uv2_vertex,
	worldpos_vertex: worldpos_vertex,
	background_vert: vertex$h,
	background_frag: fragment$h,
	backgroundCube_vert: vertex$g,
	backgroundCube_frag: fragment$g,
	cube_vert: vertex$f,
	cube_frag: fragment$f,
	depth_vert: vertex$e,
	depth_frag: fragment$e,
	distanceRGBA_vert: vertex$d,
	distanceRGBA_frag: fragment$d,
	equirect_vert: vertex$c,
	equirect_frag: fragment$c,
	linedashed_vert: vertex$b,
	linedashed_frag: fragment$b,
	meshbasic_vert: vertex$a,
	meshbasic_frag: fragment$a,
	meshlambert_vert: vertex$9,
	meshlambert_frag: fragment$9,
	meshmatcap_vert: vertex$8,
	meshmatcap_frag: fragment$8,
	meshnormal_vert: vertex$7,
	meshnormal_frag: fragment$7,
	meshphong_vert: vertex$6,
	meshphong_frag: fragment$6,
	meshphysical_vert: vertex$5,
	meshphysical_frag: fragment$5,
	meshtoon_vert: vertex$4,
	meshtoon_frag: fragment$4,
	points_vert: vertex$3,
	points_frag: fragment$3,
	shadow_vert: vertex$2,
	shadow_frag: fragment$2,
	sprite_vert: vertex$1,
	sprite_frag: fragment$1
};

/**
 * Uniforms library for shared webgl shaders
 */

const UniformsLib = {
	common: {
		diffuse: {
			value: /*@__PURE__*/new Color$1(0xffffff)
		},
		opacity: {
			value: 1.0
		},
		map: {
			value: null
		},
		uvTransform: {
			value: /*@__PURE__*/new Matrix3()
		},
		uv2Transform: {
			value: /*@__PURE__*/new Matrix3()
		},
		alphaMap: {
			value: null
		},
		alphaTest: {
			value: 0
		}
	},
	specularmap: {
		specularMap: {
			value: null
		}
	},
	envmap: {
		envMap: {
			value: null
		},
		flipEnvMap: {
			value: -1
		},
		reflectivity: {
			value: 1.0
		},
		// basic, lambert, phong
		ior: {
			value: 1.5
		},
		// physical
		refractionRatio: {
			value: 0.98
		} // basic, lambert, phong
	},

	aomap: {
		aoMap: {
			value: null
		},
		aoMapIntensity: {
			value: 1
		}
	},
	lightmap: {
		lightMap: {
			value: null
		},
		lightMapIntensity: {
			value: 1
		}
	},
	emissivemap: {
		emissiveMap: {
			value: null
		}
	},
	bumpmap: {
		bumpMap: {
			value: null
		},
		bumpScale: {
			value: 1
		}
	},
	normalmap: {
		normalMap: {
			value: null
		},
		normalScale: {
			value: /*@__PURE__*/new Vector2(1, 1)
		}
	},
	displacementmap: {
		displacementMap: {
			value: null
		},
		displacementScale: {
			value: 1
		},
		displacementBias: {
			value: 0
		}
	},
	roughnessmap: {
		roughnessMap: {
			value: null
		}
	},
	metalnessmap: {
		metalnessMap: {
			value: null
		}
	},
	gradientmap: {
		gradientMap: {
			value: null
		}
	},
	fog: {
		fogDensity: {
			value: 0.00025
		},
		fogNear: {
			value: 1
		},
		fogFar: {
			value: 2000
		},
		fogColor: {
			value: /*@__PURE__*/new Color$1(0xffffff)
		}
	},
	lights: {
		ambientLightColor: {
			value: []
		},
		lightProbe: {
			value: []
		},
		directionalLights: {
			value: [],
			properties: {
				direction: {},
				color: {}
			}
		},
		directionalLightShadows: {
			value: [],
			properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			}
		},
		directionalShadowMap: {
			value: []
		},
		directionalShadowMatrix: {
			value: []
		},
		spotLights: {
			value: [],
			properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {}
			}
		},
		spotLightShadows: {
			value: [],
			properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			}
		},
		spotLightMap: {
			value: []
		},
		spotShadowMap: {
			value: []
		},
		spotLightMatrix: {
			value: []
		},
		pointLights: {
			value: [],
			properties: {
				color: {},
				position: {},
				decay: {},
				distance: {}
			}
		},
		pointLightShadows: {
			value: [],
			properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			}
		},
		pointShadowMap: {
			value: []
		},
		pointShadowMatrix: {
			value: []
		},
		hemisphereLights: {
			value: [],
			properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			}
		},
		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		rectAreaLights: {
			value: [],
			properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			}
		},
		ltc_1: {
			value: null
		},
		ltc_2: {
			value: null
		}
	},
	points: {
		diffuse: {
			value: /*@__PURE__*/new Color$1(0xffffff)
		},
		opacity: {
			value: 1.0
		},
		size: {
			value: 1.0
		},
		scale: {
			value: 1.0
		},
		map: {
			value: null
		},
		alphaMap: {
			value: null
		},
		alphaTest: {
			value: 0
		},
		uvTransform: {
			value: /*@__PURE__*/new Matrix3()
		}
	},
	sprite: {
		diffuse: {
			value: /*@__PURE__*/new Color$1(0xffffff)
		},
		opacity: {
			value: 1.0
		},
		center: {
			value: /*@__PURE__*/new Vector2(0.5, 0.5)
		},
		rotation: {
			value: 0.0
		},
		map: {
			value: null
		},
		alphaMap: {
			value: null
		},
		alphaTest: {
			value: 0
		},
		uvTransform: {
			value: /*@__PURE__*/new Matrix3()
		}
	}
};

const ShaderLib = {
	basic: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag
	},
	lambert: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
			emissive: {
				value: /*@__PURE__*/new Color$1(0x000000)
			}
		}]),
		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag
	},
	phong: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
			emissive: {
				value: /*@__PURE__*/new Color$1(0x000000)
			},
			specular: {
				value: /*@__PURE__*/new Color$1(0x111111)
			},
			shininess: {
				value: 30
			}
		}]),
		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag
	},
	standard: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
			emissive: {
				value: /*@__PURE__*/new Color$1(0x000000)
			},
			roughness: {
				value: 1.0
			},
			metalness: {
				value: 0.0
			},
			envMapIntensity: {
				value: 1
			} // temporary
		}]),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag
	},
	toon: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
			emissive: {
				value: /*@__PURE__*/new Color$1(0x000000)
			}
		}]),
		vertexShader: ShaderChunk.meshtoon_vert,
		fragmentShader: ShaderChunk.meshtoon_frag
	},
	matcap: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
			matcap: {
				value: null
			}
		}]),
		vertexShader: ShaderChunk.meshmatcap_vert,
		fragmentShader: ShaderChunk.meshmatcap_frag
	},
	points: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.points, UniformsLib.fog]),
		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag
	},
	dashed: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.fog, {
			scale: {
				value: 1
			},
			dashSize: {
				value: 1
			},
			totalSize: {
				value: 2
			}
		}]),
		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag
	},
	depth: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag
	},
	normal: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
			opacity: {
				value: 1.0
			}
		}]),
		vertexShader: ShaderChunk.meshnormal_vert,
		fragmentShader: ShaderChunk.meshnormal_frag
	},
	sprite: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
		vertexShader: ShaderChunk.sprite_vert,
		fragmentShader: ShaderChunk.sprite_frag
	},
	background: {
		uniforms: {
			uvTransform: {
				value: /*@__PURE__*/new Matrix3()
			},
			t2D: {
				value: null
			}
		},
		vertexShader: ShaderChunk.background_vert,
		fragmentShader: ShaderChunk.background_frag
	},
	backgroundCube: {
		uniforms: {
			envMap: {
				value: null
			},
			flipEnvMap: {
				value: -1
			},
			backgroundBlurriness: {
				value: 0
			}
		},
		vertexShader: ShaderChunk.backgroundCube_vert,
		fragmentShader: ShaderChunk.backgroundCube_frag
	},
	cube: {
		uniforms: {
			tCube: {
				value: null
			},
			tFlip: {
				value: -1
			},
			opacity: {
				value: 1.0
			}
		},
		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag
	},
	equirect: {
		uniforms: {
			tEquirect: {
				value: null
			}
		},
		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag
	},
	distanceRGBA: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
			referencePosition: {
				value: /*@__PURE__*/new Vector3()
			},
			nearDistance: {
				value: 1
			},
			farDistance: {
				value: 1000
			}
		}]),
		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag
	},
	shadow: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
			color: {
				value: /*@__PURE__*/new Color$1(0x00000)
			},
			opacity: {
				value: 1.0
			}
		}]),
		vertexShader: ShaderChunk.shadow_vert,
		fragmentShader: ShaderChunk.shadow_frag
	}
};
ShaderLib.physical = {
	uniforms: /*@__PURE__*/mergeUniforms([ShaderLib.standard.uniforms, {
		clearcoat: {
			value: 0
		},
		clearcoatMap: {
			value: null
		},
		clearcoatRoughness: {
			value: 0
		},
		clearcoatRoughnessMap: {
			value: null
		},
		clearcoatNormalScale: {
			value: /*@__PURE__*/new Vector2(1, 1)
		},
		clearcoatNormalMap: {
			value: null
		},
		iridescence: {
			value: 0
		},
		iridescenceMap: {
			value: null
		},
		iridescenceIOR: {
			value: 1.3
		},
		iridescenceThicknessMinimum: {
			value: 100
		},
		iridescenceThicknessMaximum: {
			value: 400
		},
		iridescenceThicknessMap: {
			value: null
		},
		sheen: {
			value: 0
		},
		sheenColor: {
			value: /*@__PURE__*/new Color$1(0x000000)
		},
		sheenColorMap: {
			value: null
		},
		sheenRoughness: {
			value: 1
		},
		sheenRoughnessMap: {
			value: null
		},
		transmission: {
			value: 0
		},
		transmissionMap: {
			value: null
		},
		transmissionSamplerSize: {
			value: /*@__PURE__*/new Vector2()
		},
		transmissionSamplerMap: {
			value: null
		},
		thickness: {
			value: 0
		},
		thicknessMap: {
			value: null
		},
		attenuationDistance: {
			value: 0
		},
		attenuationColor: {
			value: /*@__PURE__*/new Color$1(0x000000)
		},
		specularIntensity: {
			value: 1
		},
		specularIntensityMap: {
			value: null
		},
		specularColor: {
			value: /*@__PURE__*/new Color$1(1, 1, 1)
		},
		specularColorMap: {
			value: null
		}
	}]),
	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag
};

function WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
	const clearColor = new Color$1(0x000000);
	let clearAlpha = alpha === true ? 0 : 1;
	let planeMesh;
	let boxMesh;
	let currentBackground = null;
	let currentBackgroundVersion = 0;
	let currentTonemapping = null;
	function render(renderList, scene) {
		let forceClear = false;
		let background = scene.isScene === true ? scene.background : null;
		if (background && background.isTexture) {
			const usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background
			background = (usePMREM ? cubeuvmaps : cubemaps).get(background);
		}

		// Ignore background in AR
		// TODO: Reconsider this.

		const xr = renderer.xr;
		const session = xr.getSession && xr.getSession();
		if (session && session.environmentBlendMode === 'additive') {
			background = null;
		}
		if (background === null) {
			setClear(clearColor, clearAlpha);
		} else if (background && background.isColor) {
			setClear(background, 1);
			forceClear = true;
		}
		if (renderer.autoClear || forceClear) {
			renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
		}
		if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
			if (boxMesh === undefined) {
				boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
					name: 'BackgroundCubeMaterial',
					uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
					vertexShader: ShaderLib.backgroundCube.vertexShader,
					fragmentShader: ShaderLib.backgroundCube.fragmentShader,
					side: BackSide,
					depthTest: false,
					depthWrite: false,
					fog: false
				}));
				boxMesh.geometry.deleteAttribute('normal');
				boxMesh.geometry.deleteAttribute('uv');
				boxMesh.onBeforeRender = function (renderer, scene, camera) {
					this.matrixWorld.copyPosition(camera.matrixWorld);
				};

				// add "envMap" material property so the renderer can evaluate it like for built-in materials
				Object.defineProperty(boxMesh.material, 'envMap', {
					get: function () {
						return this.uniforms.envMap.value;
					}
				});
				objects.update(boxMesh);
			}
			boxMesh.material.uniforms.envMap.value = background;
			boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
			boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
			if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
				boxMesh.material.needsUpdate = true;
				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;
			}
			boxMesh.layers.enableAll();

			// push to the pre-sorted opaque render list
			renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
		} else if (background && background.isTexture) {
			if (planeMesh === undefined) {
				planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
					name: 'BackgroundMaterial',
					uniforms: cloneUniforms(ShaderLib.background.uniforms),
					vertexShader: ShaderLib.background.vertexShader,
					fragmentShader: ShaderLib.background.fragmentShader,
					side: FrontSide,
					depthTest: false,
					depthWrite: false,
					fog: false
				}));
				planeMesh.geometry.deleteAttribute('normal');

				// add "map" material property so the renderer can evaluate it like for built-in materials
				Object.defineProperty(planeMesh.material, 'map', {
					get: function () {
						return this.uniforms.t2D.value;
					}
				});
				objects.update(planeMesh);
			}
			planeMesh.material.uniforms.t2D.value = background;
			if (background.matrixAutoUpdate === true) {
				background.updateMatrix();
			}
			planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
			if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
				planeMesh.material.needsUpdate = true;
				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;
			}
			planeMesh.layers.enableAll();

			// push to the pre-sorted opaque render list
			renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
		}
	}
	function setClear(color, alpha) {
		state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
	}
	return {
		getClearColor: function () {
			return clearColor;
		},
		setClearColor: function (color, alpha = 1) {
			clearColor.set(color);
			clearAlpha = alpha;
			setClear(clearColor, clearAlpha);
		},
		getClearAlpha: function () {
			return clearAlpha;
		},
		setClearAlpha: function (alpha) {
			clearAlpha = alpha;
			setClear(clearColor, clearAlpha);
		},
		render: render
	};
}

function WebGLBindingStates(gl, extensions, attributes, capabilities) {
	const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
	const extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
	const vaoAvailable = capabilities.isWebGL2 || extension !== null;
	const bindingStates = {};
	const defaultState = createBindingState(null);
	let currentState = defaultState;
	let forceUpdate = false;
	function setup(object, material, program, geometry, index) {
		let updateBuffers = false;
		if (vaoAvailable) {
			const state = getBindingState(geometry, program, material);
			if (currentState !== state) {
				currentState = state;
				bindVertexArrayObject(currentState.object);
			}
			updateBuffers = needsUpdate(object, geometry, program, index);
			if (updateBuffers) saveCache(object, geometry, program, index);
		} else {
			const wireframe = material.wireframe === true;
			if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
				currentState.geometry = geometry.id;
				currentState.program = program.id;
				currentState.wireframe = wireframe;
				updateBuffers = true;
			}
		}
		if (index !== null) {
			attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
		}
		if (updateBuffers || forceUpdate) {
			forceUpdate = false;
			setupVertexAttributes(object, material, program, geometry);
			if (index !== null) {
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
			}
		}
	}
	function createVertexArrayObject() {
		if (capabilities.isWebGL2) return gl.createVertexArray();
		return extension.createVertexArrayOES();
	}
	function bindVertexArrayObject(vao) {
		if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
		return extension.bindVertexArrayOES(vao);
	}
	function deleteVertexArrayObject(vao) {
		if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
		return extension.deleteVertexArrayOES(vao);
	}
	function getBindingState(geometry, program, material) {
		const wireframe = material.wireframe === true;
		let programMap = bindingStates[geometry.id];
		if (programMap === undefined) {
			programMap = {};
			bindingStates[geometry.id] = programMap;
		}
		let stateMap = programMap[program.id];
		if (stateMap === undefined) {
			stateMap = {};
			programMap[program.id] = stateMap;
		}
		let state = stateMap[wireframe];
		if (state === undefined) {
			state = createBindingState(createVertexArrayObject());
			stateMap[wireframe] = state;
		}
		return state;
	}
	function createBindingState(vao) {
		const newAttributes = [];
		const enabledAttributes = [];
		const attributeDivisors = [];
		for (let i = 0; i < maxVertexAttributes; i++) {
			newAttributes[i] = 0;
			enabledAttributes[i] = 0;
			attributeDivisors[i] = 0;
		}
		return {
			// for backward compatibility on non-VAO support browser
			geometry: null,
			program: null,
			wireframe: false,
			newAttributes: newAttributes,
			enabledAttributes: enabledAttributes,
			attributeDivisors: attributeDivisors,
			object: vao,
			attributes: {},
			index: null
		};
	}
	function needsUpdate(object, geometry, program, index) {
		const cachedAttributes = currentState.attributes;
		const geometryAttributes = geometry.attributes;
		let attributesNum = 0;
		const programAttributes = program.getAttributes();
		for (const name in programAttributes) {
			const programAttribute = programAttributes[name];
			if (programAttribute.location >= 0) {
				const cachedAttribute = cachedAttributes[name];
				let geometryAttribute = geometryAttributes[name];
				if (geometryAttribute === undefined) {
					if (name === 'instanceMatrix' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
					if (name === 'instanceColor' && object.instanceColor) geometryAttribute = object.instanceColor;
				}
				if (cachedAttribute === undefined) return true;
				if (cachedAttribute.attribute !== geometryAttribute) return true;
				if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data) return true;
				attributesNum++;
			}
		}
		if (currentState.attributesNum !== attributesNum) return true;
		if (currentState.index !== index) return true;
		return false;
	}
	function saveCache(object, geometry, program, index) {
		const cache = {};
		const attributes = geometry.attributes;
		let attributesNum = 0;
		const programAttributes = program.getAttributes();
		for (const name in programAttributes) {
			const programAttribute = programAttributes[name];
			if (programAttribute.location >= 0) {
				let attribute = attributes[name];
				if (attribute === undefined) {
					if (name === 'instanceMatrix' && object.instanceMatrix) attribute = object.instanceMatrix;
					if (name === 'instanceColor' && object.instanceColor) attribute = object.instanceColor;
				}
				const data = {};
				data.attribute = attribute;
				if (attribute && attribute.data) {
					data.data = attribute.data;
				}
				cache[name] = data;
				attributesNum++;
			}
		}
		currentState.attributes = cache;
		currentState.attributesNum = attributesNum;
		currentState.index = index;
	}
	function initAttributes() {
		const newAttributes = currentState.newAttributes;
		for (let i = 0, il = newAttributes.length; i < il; i++) {
			newAttributes[i] = 0;
		}
	}
	function enableAttribute(attribute) {
		enableAttributeAndDivisor(attribute, 0);
	}
	function enableAttributeAndDivisor(attribute, meshPerAttribute) {
		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;
		const attributeDivisors = currentState.attributeDivisors;
		newAttributes[attribute] = 1;
		if (enabledAttributes[attribute] === 0) {
			gl.enableVertexAttribArray(attribute);
			enabledAttributes[attribute] = 1;
		}
		if (attributeDivisors[attribute] !== meshPerAttribute) {
			const extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
			extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
			attributeDivisors[attribute] = meshPerAttribute;
		}
	}
	function disableUnusedAttributes() {
		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;
		for (let i = 0, il = enabledAttributes.length; i < il; i++) {
			if (enabledAttributes[i] !== newAttributes[i]) {
				gl.disableVertexAttribArray(i);
				enabledAttributes[i] = 0;
			}
		}
	}
	function vertexAttribPointer(index, size, type, normalized, stride, offset) {
		if (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) {
			gl.vertexAttribIPointer(index, size, type, stride, offset);
		} else {
			gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
		}
	}
	function setupVertexAttributes(object, material, program, geometry) {
		if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
			if (extensions.get('ANGLE_instanced_arrays') === null) return;
		}
		initAttributes();
		const geometryAttributes = geometry.attributes;
		const programAttributes = program.getAttributes();
		const materialDefaultAttributeValues = material.defaultAttributeValues;
		for (const name in programAttributes) {
			const programAttribute = programAttributes[name];
			if (programAttribute.location >= 0) {
				let geometryAttribute = geometryAttributes[name];
				if (geometryAttribute === undefined) {
					if (name === 'instanceMatrix' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
					if (name === 'instanceColor' && object.instanceColor) geometryAttribute = object.instanceColor;
				}
				if (geometryAttribute !== undefined) {
					const normalized = geometryAttribute.normalized;
					const size = geometryAttribute.itemSize;
					const attribute = attributes.get(geometryAttribute);

					// TODO Attribute may not be available on context restore

					if (attribute === undefined) continue;
					const buffer = attribute.buffer;
					const type = attribute.type;
					const bytesPerElement = attribute.bytesPerElement;
					if (geometryAttribute.isInterleavedBufferAttribute) {
						const data = geometryAttribute.data;
						const stride = data.stride;
						const offset = geometryAttribute.offset;
						if (data.isInstancedInterleavedBuffer) {
							for (let i = 0; i < programAttribute.locationSize; i++) {
								enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
							}
							if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {
								geometry._maxInstanceCount = data.meshPerAttribute * data.count;
							}
						} else {
							for (let i = 0; i < programAttribute.locationSize; i++) {
								enableAttribute(programAttribute.location + i);
							}
						}
						gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
						for (let i = 0; i < programAttribute.locationSize; i++) {
							vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * i) * bytesPerElement);
						}
					} else {
						if (geometryAttribute.isInstancedBufferAttribute) {
							for (let i = 0; i < programAttribute.locationSize; i++) {
								enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);
							}
							if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {
								geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
							}
						} else {
							for (let i = 0; i < programAttribute.locationSize; i++) {
								enableAttribute(programAttribute.location + i);
							}
						}
						gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
						for (let i = 0; i < programAttribute.locationSize; i++) {
							vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i * bytesPerElement);
						}
					}
				} else if (materialDefaultAttributeValues !== undefined) {
					const value = materialDefaultAttributeValues[name];
					if (value !== undefined) {
						switch (value.length) {
							case 2:
								gl.vertexAttrib2fv(programAttribute.location, value);
								break;
							case 3:
								gl.vertexAttrib3fv(programAttribute.location, value);
								break;
							case 4:
								gl.vertexAttrib4fv(programAttribute.location, value);
								break;
							default:
								gl.vertexAttrib1fv(programAttribute.location, value);
						}
					}
				}
			}
		}
		disableUnusedAttributes();
	}
	function dispose() {
		reset();
		for (const geometryId in bindingStates) {
			const programMap = bindingStates[geometryId];
			for (const programId in programMap) {
				const stateMap = programMap[programId];
				for (const wireframe in stateMap) {
					deleteVertexArrayObject(stateMap[wireframe].object);
					delete stateMap[wireframe];
				}
				delete programMap[programId];
			}
			delete bindingStates[geometryId];
		}
	}
	function releaseStatesOfGeometry(geometry) {
		if (bindingStates[geometry.id] === undefined) return;
		const programMap = bindingStates[geometry.id];
		for (const programId in programMap) {
			const stateMap = programMap[programId];
			for (const wireframe in stateMap) {
				deleteVertexArrayObject(stateMap[wireframe].object);
				delete stateMap[wireframe];
			}
			delete programMap[programId];
		}
		delete bindingStates[geometry.id];
	}
	function releaseStatesOfProgram(program) {
		for (const geometryId in bindingStates) {
			const programMap = bindingStates[geometryId];
			if (programMap[program.id] === undefined) continue;
			const stateMap = programMap[program.id];
			for (const wireframe in stateMap) {
				deleteVertexArrayObject(stateMap[wireframe].object);
				delete stateMap[wireframe];
			}
			delete programMap[program.id];
		}
	}
	function reset() {
		resetDefaultState();
		forceUpdate = true;
		if (currentState === defaultState) return;
		currentState = defaultState;
		bindVertexArrayObject(currentState.object);
	}

	// for backward-compatibility

	function resetDefaultState() {
		defaultState.geometry = null;
		defaultState.program = null;
		defaultState.wireframe = false;
	}
	return {
		setup: setup,
		reset: reset,
		resetDefaultState: resetDefaultState,
		dispose: dispose,
		releaseStatesOfGeometry: releaseStatesOfGeometry,
		releaseStatesOfProgram: releaseStatesOfProgram,
		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		disableUnusedAttributes: disableUnusedAttributes
	};
}

function WebGLBufferRenderer(gl, extensions, info, capabilities) {
	const isWebGL2 = capabilities.isWebGL2;
	let mode;
	function setMode(value) {
		mode = value;
	}
	function render(start, count) {
		gl.drawArrays(mode, start, count);
		info.update(count, mode, 1);
	}
	function renderInstances(start, count, primcount) {
		if (primcount === 0) return;
		let extension, methodName;
		if (isWebGL2) {
			extension = gl;
			methodName = 'drawArraysInstanced';
		} else {
			extension = extensions.get('ANGLE_instanced_arrays');
			methodName = 'drawArraysInstancedANGLE';
			if (extension === null) {
				console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
				return;
			}
		}
		extension[methodName](mode, start, count, primcount);
		info.update(count, mode, primcount);
	}

	//

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;
}

function WebGLCapabilities(gl, extensions, parameters) {
	let maxAnisotropy;
	function getMaxAnisotropy() {
		if (maxAnisotropy !== undefined) return maxAnisotropy;
		if (extensions.has('EXT_texture_filter_anisotropic') === true) {
			const extension = extensions.get('EXT_texture_filter_anisotropic');
			maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
		} else {
			maxAnisotropy = 0;
		}
		return maxAnisotropy;
	}
	function getMaxPrecision(precision) {
		if (precision === 'highp') {
			if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
				return 'highp';
			}
			precision = 'mediump';
		}
		if (precision === 'mediump') {
			if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
				return 'mediump';
			}
		}
		return 'lowp';
	}
	const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
	let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	const maxPrecision = getMaxPrecision(precision);
	if (maxPrecision !== precision) {
		console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
		precision = maxPrecision;
	}
	const drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers');
	const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
	const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
	const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
	const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
	const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
	const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
	const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
	const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
	const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
	const vertexTextures = maxVertexTextures > 0;
	const floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float');
	const floatVertexTextures = vertexTextures && floatFragmentTextures;
	const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
	return {
		isWebGL2: isWebGL2,
		drawBuffers: drawBuffers,
		getMaxAnisotropy: getMaxAnisotropy,
		getMaxPrecision: getMaxPrecision,
		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,
		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,
		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,
		vertexTextures: vertexTextures,
		floatFragmentTextures: floatFragmentTextures,
		floatVertexTextures: floatVertexTextures,
		maxSamples: maxSamples
	};
}

function WebGLClipping(properties) {
	const scope = this;
	let globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false;
	const plane = new Plane(),
		viewNormalMatrix = new Matrix3(),
		uniform = {
			value: null,
			needsUpdate: false
		};
	this.uniform = uniform;
	this.numPlanes = 0;
	this.numIntersection = 0;
	this.init = function (planes, enableLocalClipping, camera) {
		const enabled = planes.length !== 0 || enableLocalClipping ||
		// enable state of previous frame - the clipping code has to
		// run another frame in order to reset the state:
		numGlobalPlanes !== 0 || localClippingEnabled;
		localClippingEnabled = enableLocalClipping;
		globalState = projectPlanes(planes, camera, 0);
		numGlobalPlanes = planes.length;
		return enabled;
	};
	this.beginShadows = function () {
		renderingShadows = true;
		projectPlanes(null);
	};
	this.endShadows = function () {
		renderingShadows = false;
		resetGlobalState();
	};
	this.setState = function (material, camera, useCache) {
		const planes = material.clippingPlanes,
			clipIntersection = material.clipIntersection,
			clipShadows = material.clipShadows;
		const materialProperties = properties.get(material);
		if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
			// there's no local clipping

			if (renderingShadows) {
				// there's no global clipping

				projectPlanes(null);
			} else {
				resetGlobalState();
			}
		} else {
			const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4;
			let dstArray = materialProperties.clippingState || null;
			uniform.value = dstArray; // ensure unique state

			dstArray = projectPlanes(planes, camera, lGlobal, useCache);
			for (let i = 0; i !== lGlobal; ++i) {
				dstArray[i] = globalState[i];
			}
			materialProperties.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;
		}
	};
	function resetGlobalState() {
		if (uniform.value !== globalState) {
			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;
		}
		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;
	}
	function projectPlanes(planes, camera, dstOffset, skipTransform) {
		const nPlanes = planes !== null ? planes.length : 0;
		let dstArray = null;
		if (nPlanes !== 0) {
			dstArray = uniform.value;
			if (skipTransform !== true || dstArray === null) {
				const flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;
				viewNormalMatrix.getNormalMatrix(viewMatrix);
				if (dstArray === null || dstArray.length < flatSize) {
					dstArray = new Float32Array(flatSize);
				}
				for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
					plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
					plane.normal.toArray(dstArray, i4);
					dstArray[i4 + 3] = plane.constant;
				}
			}
			uniform.value = dstArray;
			uniform.needsUpdate = true;
		}
		scope.numPlanes = nPlanes;
		scope.numIntersection = 0;
		return dstArray;
	}
}

class Camera extends Object3D {
	constructor() {
		super();
		this.isCamera = true;
		this.type = 'Camera';
		this.matrixWorldInverse = new Matrix4();
		this.projectionMatrix = new Matrix4();
		this.projectionMatrixInverse = new Matrix4();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.matrixWorldInverse.copy(source.matrixWorldInverse);
		this.projectionMatrix.copy(source.projectionMatrix);
		this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
		return this;
	}
	getWorldDirection(target) {
		this.updateWorldMatrix(true, false);
		const e = this.matrixWorld.elements;
		return target.set(-e[8], -e[9], -e[10]).normalize();
	}
	updateMatrixWorld(force) {
		super.updateMatrixWorld(force);
		this.matrixWorldInverse.copy(this.matrixWorld).invert();
	}
	updateWorldMatrix(updateParents, updateChildren) {
		super.updateWorldMatrix(updateParents, updateChildren);
		this.matrixWorldInverse.copy(this.matrixWorld).invert();
	}
	clone() {
		return new this.constructor().copy(this);
	}
}

class PerspectiveCamera extends Camera {
	constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {
		super();
		this.isPerspectiveCamera = true;
		this.type = 'PerspectiveCamera';
		this.fov = fov;
		this.zoom = 1;
		this.near = near;
		this.far = far;
		this.focus = 10;
		this.aspect = aspect;
		this.view = null;
		this.filmGauge = 35; // width of the film (default in millimeters)
		this.filmOffset = 0; // horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.fov = source.fov;
		this.zoom = source.zoom;
		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;
		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign({}, source.view);
		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;
		return this;
	}

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength(focalLength) {
		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
		this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
		this.updateProjectionMatrix();
	}

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength() {
		const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
		return 0.5 * this.getFilmHeight() / vExtentSlope;
	}
	getEffectiveFOV() {
		return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
	}
	getFilmWidth() {
		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min(this.aspect, 1);
	}
	getFilmHeight() {
		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max(this.aspect, 1);
	}

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *	 +---+---+---+
	 *	 | A | B | C |
	 *	 +---+---+---+
	 *	 | D | E | F |
	 *	 +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *	 const w = 1920;
	 *	 const h = 1080;
	 *	 const fullWidth = w * 3;
	 *	 const fullHeight = h * 2;
	 *
	 *	 --A--
	 *	 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *	 --B--
	 *	 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *	 --C--
	 *	 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *	 --D--
	 *	 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *	 --E--
	 *	 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *	 --F--
	 *	 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *	 Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset(fullWidth, fullHeight, x, y, width, height) {
		this.aspect = fullWidth / fullHeight;
		if (this.view === null) {
			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};
		}
		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;
		this.updateProjectionMatrix();
	}
	clearViewOffset() {
		if (this.view !== null) {
			this.view.enabled = false;
		}
		this.updateProjectionMatrix();
	}
	updateProjectionMatrix() {
		const near = this.near;
		let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
		let height = 2 * top;
		let width = this.aspect * height;
		let left = -0.5 * width;
		const view = this.view;
		if (this.view !== null && this.view.enabled) {
			const fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;
			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;
		}
		const skew = this.filmOffset;
		if (skew !== 0) left += near * skew / this.getFilmWidth();
		this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
		this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		data.object.fov = this.fov;
		data.object.zoom = this.zoom;
		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;
		data.object.aspect = this.aspect;
		if (this.view !== null) data.object.view = Object.assign({}, this.view);
		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;
		return data;
	}
}

const fov = 90,
	aspect = 1;
class CubeCamera extends Object3D {
	constructor(near, far, renderTarget) {
		super();
		this.type = 'CubeCamera';
		this.renderTarget = renderTarget;
		const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
		cameraPX.layers = this.layers;
		cameraPX.up.set(0, -1, 0);
		cameraPX.lookAt(new Vector3(1, 0, 0));
		this.add(cameraPX);
		const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
		cameraNX.layers = this.layers;
		cameraNX.up.set(0, -1, 0);
		cameraNX.lookAt(new Vector3(-1, 0, 0));
		this.add(cameraNX);
		const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
		cameraPY.layers = this.layers;
		cameraPY.up.set(0, 0, 1);
		cameraPY.lookAt(new Vector3(0, 1, 0));
		this.add(cameraPY);
		const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
		cameraNY.layers = this.layers;
		cameraNY.up.set(0, 0, -1);
		cameraNY.lookAt(new Vector3(0, -1, 0));
		this.add(cameraNY);
		const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
		cameraPZ.layers = this.layers;
		cameraPZ.up.set(0, -1, 0);
		cameraPZ.lookAt(new Vector3(0, 0, 1));
		this.add(cameraPZ);
		const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
		cameraNZ.layers = this.layers;
		cameraNZ.up.set(0, -1, 0);
		cameraNZ.lookAt(new Vector3(0, 0, -1));
		this.add(cameraNZ);
	}
	update(renderer, scene) {
		if (this.parent === null) this.updateMatrixWorld();
		const renderTarget = this.renderTarget;
		const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
		const currentRenderTarget = renderer.getRenderTarget();
		const currentToneMapping = renderer.toneMapping;
		const currentXrEnabled = renderer.xr.enabled;
		renderer.toneMapping = NoToneMapping;
		renderer.xr.enabled = false;
		const generateMipmaps = renderTarget.texture.generateMipmaps;
		renderTarget.texture.generateMipmaps = false;
		renderer.setRenderTarget(renderTarget, 0);
		renderer.render(scene, cameraPX);
		renderer.setRenderTarget(renderTarget, 1);
		renderer.render(scene, cameraNX);
		renderer.setRenderTarget(renderTarget, 2);
		renderer.render(scene, cameraPY);
		renderer.setRenderTarget(renderTarget, 3);
		renderer.render(scene, cameraNY);
		renderer.setRenderTarget(renderTarget, 4);
		renderer.render(scene, cameraPZ);
		renderTarget.texture.generateMipmaps = generateMipmaps;
		renderer.setRenderTarget(renderTarget, 5);
		renderer.render(scene, cameraNZ);
		renderer.setRenderTarget(currentRenderTarget);
		renderer.toneMapping = currentToneMapping;
		renderer.xr.enabled = currentXrEnabled;
		renderTarget.texture.needsPMREMUpdate = true;
	}
}

class CubeTexture extends Texture {
	constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
		super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
		this.isCubeTexture = true;
		this.flipY = false;
	}
	get images() {
		return this.image;
	}
	set images(value) {
		this.image = value;
	}
}

class WebGLCubeRenderTarget extends WebGLRenderTarget {
	constructor(size = 1, options = {}) {
		super(size, size, options);
		this.isWebGLCubeRenderTarget = true;
		const image = {
			width: size,
			height: size,
			depth: 1
		};
		const images = [image, image, image, image, image, image];
		this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);

		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
		// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
		// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

		this.texture.isRenderTargetTexture = true;
		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
	}
	fromEquirectangularTexture(renderer, texture) {
		this.texture.type = texture.type;
		this.texture.encoding = texture.encoding;
		this.texture.generateMipmaps = texture.generateMipmaps;
		this.texture.minFilter = texture.minFilter;
		this.texture.magFilter = texture.magFilter;
		const shader = {
			uniforms: {
				tEquirect: {
					value: null
				}
			},
			vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
			fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
		};
		const geometry = new BoxGeometry(5, 5, 5);
		const material = new ShaderMaterial({
			name: 'CubemapFromEquirect',
			uniforms: cloneUniforms(shader.uniforms),
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			side: BackSide,
			blending: NoBlending
		});
		material.uniforms.tEquirect.value = texture;
		const mesh = new Mesh(geometry, material);
		const currentMinFilter = texture.minFilter;

		// Avoid blurred poles
		if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
		const camera = new CubeCamera(1, 10, this);
		camera.update(renderer, mesh);
		texture.minFilter = currentMinFilter;
		mesh.geometry.dispose();
		mesh.material.dispose();
		return this;
	}
	clear(renderer, color, depth, stencil) {
		const currentRenderTarget = renderer.getRenderTarget();
		for (let i = 0; i < 6; i++) {
			renderer.setRenderTarget(this, i);
			renderer.clear(color, depth, stencil);
		}
		renderer.setRenderTarget(currentRenderTarget);
	}
}

function WebGLCubeMaps(renderer) {
	let cubemaps = new WeakMap();
	function mapTextureMapping(texture, mapping) {
		if (mapping === EquirectangularReflectionMapping) {
			texture.mapping = CubeReflectionMapping;
		} else if (mapping === EquirectangularRefractionMapping) {
			texture.mapping = CubeRefractionMapping;
		}
		return texture;
	}
	function get(texture) {
		if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
			const mapping = texture.mapping;
			if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
				if (cubemaps.has(texture)) {
					const cubemap = cubemaps.get(texture).texture;
					return mapTextureMapping(cubemap, texture.mapping);
				} else {
					const image = texture.image;
					if (image && image.height > 0) {
						const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
						renderTarget.fromEquirectangularTexture(renderer, texture);
						cubemaps.set(texture, renderTarget);
						texture.addEventListener('dispose', onTextureDispose);
						return mapTextureMapping(renderTarget.texture, texture.mapping);
					} else {
						// image not yet ready. try the conversion next frame

						return null;
					}
				}
			}
		}
		return texture;
	}
	function onTextureDispose(event) {
		const texture = event.target;
		texture.removeEventListener('dispose', onTextureDispose);
		const cubemap = cubemaps.get(texture);
		if (cubemap !== undefined) {
			cubemaps.delete(texture);
			cubemap.dispose();
		}
	}
	function dispose() {
		cubemaps = new WeakMap();
	}
	return {
		get: get,
		dispose: dispose
	};
}

class OrthographicCamera extends Camera {
	constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {
		super();
		this.isOrthographicCamera = true;
		this.type = 'OrthographicCamera';
		this.zoom = 1;
		this.view = null;
		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;
		this.near = near;
		this.far = far;
		this.updateProjectionMatrix();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;
		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign({}, source.view);
		return this;
	}
	setViewOffset(fullWidth, fullHeight, x, y, width, height) {
		if (this.view === null) {
			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};
		}
		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;
		this.updateProjectionMatrix();
	}
	clearViewOffset() {
		if (this.view !== null) {
			this.view.enabled = false;
		}
		this.updateProjectionMatrix();
	}
	updateProjectionMatrix() {
		const dx = (this.right - this.left) / (2 * this.zoom);
		const dy = (this.top - this.bottom) / (2 * this.zoom);
		const cx = (this.right + this.left) / 2;
		const cy = (this.top + this.bottom) / 2;
		let left = cx - dx;
		let right = cx + dx;
		let top = cy + dy;
		let bottom = cy - dy;
		if (this.view !== null && this.view.enabled) {
			const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
			const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
			left += scaleW * this.view.offsetX;
			right = left + scaleW * this.view.width;
			top -= scaleH * this.view.offsetY;
			bottom = top - scaleH * this.view.height;
		}
		this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
		this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;
		if (this.view !== null) data.object.view = Object.assign({}, this.view);
		return data;
	}
}

const LOD_MIN = 4;

// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];

// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;
const _flatCamera = /*@__PURE__*/new OrthographicCamera();
const _clearColor = /*@__PURE__*/new Color$1();
let _oldTarget = null;

// Golden Ratio
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;

// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections = [/*@__PURE__*/new Vector3(1, 1, 1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-PHI, INV_PHI, 0)];

/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/

class PMREMGenerator {
	constructor(renderer) {
		this._renderer = renderer;
		this._pingPongRenderTarget = null;
		this._lodMax = 0;
		this._cubeSize = 0;
		this._lodPlanes = [];
		this._sizeLods = [];
		this._sigmas = [];
		this._blurMaterial = null;
		this._cubemapMaterial = null;
		this._equirectMaterial = null;
		this._compileMaterial(this._blurMaterial);
	}

	/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */
	fromScene(scene, sigma = 0, near = 0.1, far = 100) {
		_oldTarget = this._renderer.getRenderTarget();
		this._setSize(256);
		const cubeUVRenderTarget = this._allocateTargets();
		cubeUVRenderTarget.depthBuffer = true;
		this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
		if (sigma > 0) {
			this._blur(cubeUVRenderTarget, 0, 0, sigma);
		}
		this._applyPMREM(cubeUVRenderTarget);
		this._cleanup(cubeUVRenderTarget);
		return cubeUVRenderTarget;
	}

	/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * or HDR. The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromEquirectangular(equirectangular, renderTarget = null) {
		return this._fromTexture(equirectangular, renderTarget);
	}

	/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * or HDR. The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromCubemap(cubemap, renderTarget = null) {
		return this._fromTexture(cubemap, renderTarget);
	}

	/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileCubemapShader() {
		if (this._cubemapMaterial === null) {
			this._cubemapMaterial = _getCubemapMaterial();
			this._compileMaterial(this._cubemapMaterial);
		}
	}

	/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileEquirectangularShader() {
		if (this._equirectMaterial === null) {
			this._equirectMaterial = _getEquirectMaterial();
			this._compileMaterial(this._equirectMaterial);
		}
	}

	/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */
	dispose() {
		this._dispose();
		if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
		if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
	}

	// private interface

	_setSize(cubeSize) {
		this._lodMax = Math.floor(Math.log2(cubeSize));
		this._cubeSize = Math.pow(2, this._lodMax);
	}
	_dispose() {
		if (this._blurMaterial !== null) this._blurMaterial.dispose();
		if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
		for (let i = 0; i < this._lodPlanes.length; i++) {
			this._lodPlanes[i].dispose();
		}
	}
	_cleanup(outputTarget) {
		this._renderer.setRenderTarget(_oldTarget);
		outputTarget.scissorTest = false;
		_setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
	}
	_fromTexture(texture, renderTarget) {
		if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
			this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
		} else {
			// Equirectangular

			this._setSize(texture.image.width / 4);
		}
		_oldTarget = this._renderer.getRenderTarget();
		const cubeUVRenderTarget = renderTarget || this._allocateTargets();
		this._textureToCubeUV(texture, cubeUVRenderTarget);
		this._applyPMREM(cubeUVRenderTarget);
		this._cleanup(cubeUVRenderTarget);
		return cubeUVRenderTarget;
	}
	_allocateTargets() {
		const width = 3 * Math.max(this._cubeSize, 16 * 7);
		const height = 4 * this._cubeSize;
		const params = {
			magFilter: LinearFilter,
			minFilter: LinearFilter,
			generateMipmaps: false,
			type: HalfFloatType,
			format: RGBAFormat,
			encoding: LinearEncoding,
			depthBuffer: false
		};
		const cubeUVRenderTarget = _createRenderTarget(width, height, params);
		if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width) {
			if (this._pingPongRenderTarget !== null) {
				this._dispose();
			}
			this._pingPongRenderTarget = _createRenderTarget(width, height, params);
			const {
				_lodMax
			} = this;
			({
				sizeLods: this._sizeLods,
				lodPlanes: this._lodPlanes,
				sigmas: this._sigmas
			} = _createPlanes(_lodMax));
			this._blurMaterial = _getBlurShader(_lodMax, width, height);
		}
		return cubeUVRenderTarget;
	}
	_compileMaterial(material) {
		const tmpMesh = new Mesh(this._lodPlanes[0], material);
		this._renderer.compile(tmpMesh, _flatCamera);
	}
	_sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
		const fov = 90;
		const aspect = 1;
		const cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
		const upSign = [1, -1, 1, 1, 1, 1];
		const forwardSign = [1, 1, 1, -1, -1, -1];
		const renderer = this._renderer;
		const originalAutoClear = renderer.autoClear;
		const toneMapping = renderer.toneMapping;
		renderer.getClearColor(_clearColor);
		renderer.toneMapping = NoToneMapping;
		renderer.autoClear = false;
		const backgroundMaterial = new MeshBasicMaterial({
			name: 'PMREM.Background',
			side: BackSide,
			depthWrite: false,
			depthTest: false
		});
		const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
		let useSolidColor = false;
		const background = scene.background;
		if (background) {
			if (background.isColor) {
				backgroundMaterial.color.copy(background);
				scene.background = null;
				useSolidColor = true;
			}
		} else {
			backgroundMaterial.color.copy(_clearColor);
			useSolidColor = true;
		}
		for (let i = 0; i < 6; i++) {
			const col = i % 3;
			if (col === 0) {
				cubeCamera.up.set(0, upSign[i], 0);
				cubeCamera.lookAt(forwardSign[i], 0, 0);
			} else if (col === 1) {
				cubeCamera.up.set(0, 0, upSign[i]);
				cubeCamera.lookAt(0, forwardSign[i], 0);
			} else {
				cubeCamera.up.set(0, upSign[i], 0);
				cubeCamera.lookAt(0, 0, forwardSign[i]);
			}
			const size = this._cubeSize;
			_setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
			renderer.setRenderTarget(cubeUVRenderTarget);
			if (useSolidColor) {
				renderer.render(backgroundBox, cubeCamera);
			}
			renderer.render(scene, cubeCamera);
		}
		backgroundBox.geometry.dispose();
		backgroundBox.material.dispose();
		renderer.toneMapping = toneMapping;
		renderer.autoClear = originalAutoClear;
		scene.background = background;
	}
	_textureToCubeUV(texture, cubeUVRenderTarget) {
		const renderer = this._renderer;
		const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
		if (isCubeTexture) {
			if (this._cubemapMaterial === null) {
				this._cubemapMaterial = _getCubemapMaterial();
			}
			this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
		} else {
			if (this._equirectMaterial === null) {
				this._equirectMaterial = _getEquirectMaterial();
			}
		}
		const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
		const mesh = new Mesh(this._lodPlanes[0], material);
		const uniforms = material.uniforms;
		uniforms['envMap'].value = texture;
		const size = this._cubeSize;
		_setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
		renderer.setRenderTarget(cubeUVRenderTarget);
		renderer.render(mesh, _flatCamera);
	}
	_applyPMREM(cubeUVRenderTarget) {
		const renderer = this._renderer;
		const autoClear = renderer.autoClear;
		renderer.autoClear = false;
		for (let i = 1; i < this._lodPlanes.length; i++) {
			const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
			const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];
			this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
		}
		renderer.autoClear = autoClear;
	}

	/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */
	_blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
		const pingPongRenderTarget = this._pingPongRenderTarget;
		this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);
		this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
	}
	_halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
		const renderer = this._renderer;
		const blurMaterial = this._blurMaterial;
		if (direction !== 'latitudinal' && direction !== 'longitudinal') {
			console.error('blur direction must be either latitudinal or longitudinal!');
		}

		// Number of standard deviations at which to cut off the discrete approximation.
		const STANDARD_DEVIATIONS = 3;
		const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
		const blurUniforms = blurMaterial.uniforms;
		const pixels = this._sizeLods[lodIn] - 1;
		const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
		const sigmaPixels = sigmaRadians / radiansPerPixel;
		const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
		if (samples > MAX_SAMPLES) {
			console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
		}
		const weights = [];
		let sum = 0;
		for (let i = 0; i < MAX_SAMPLES; ++i) {
			const x = i / sigmaPixels;
			const weight = Math.exp(-x * x / 2);
			weights.push(weight);
			if (i === 0) {
				sum += weight;
			} else if (i < samples) {
				sum += 2 * weight;
			}
		}
		for (let i = 0; i < weights.length; i++) {
			weights[i] = weights[i] / sum;
		}
		blurUniforms['envMap'].value = targetIn.texture;
		blurUniforms['samples'].value = samples;
		blurUniforms['weights'].value = weights;
		blurUniforms['latitudinal'].value = direction === 'latitudinal';
		if (poleAxis) {
			blurUniforms['poleAxis'].value = poleAxis;
		}
		const {
			_lodMax
		} = this;
		blurUniforms['dTheta'].value = radiansPerPixel;
		blurUniforms['mipInt'].value = _lodMax - lodIn;
		const outputSize = this._sizeLods[lodOut];
		const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
		const y = 4 * (this._cubeSize - outputSize);
		_setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
		renderer.setRenderTarget(targetOut);
		renderer.render(blurMesh, _flatCamera);
	}
}
function _createPlanes(lodMax) {
	const lodPlanes = [];
	const sizeLods = [];
	const sigmas = [];
	let lod = lodMax;
	const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
	for (let i = 0; i < totalLods; i++) {
		const sizeLod = Math.pow(2, lod);
		sizeLods.push(sizeLod);
		let sigma = 1.0 / sizeLod;
		if (i > lodMax - LOD_MIN) {
			sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
		} else if (i === 0) {
			sigma = 0;
		}
		sigmas.push(sigma);
		const texelSize = 1.0 / (sizeLod - 2);
		const min = -texelSize;
		const max = 1 + texelSize;
		const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
		const cubeFaces = 6;
		const vertices = 6;
		const positionSize = 3;
		const uvSize = 2;
		const faceIndexSize = 1;
		const position = new Float32Array(positionSize * vertices * cubeFaces);
		const uv = new Float32Array(uvSize * vertices * cubeFaces);
		const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
		for (let face = 0; face < cubeFaces; face++) {
			const x = face % 3 * 2 / 3 - 1;
			const y = face > 2 ? 0 : -1;
			const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
			position.set(coordinates, positionSize * vertices * face);
			uv.set(uv1, uvSize * vertices * face);
			const fill = [face, face, face, face, face, face];
			faceIndex.set(fill, faceIndexSize * vertices * face);
		}
		const planes = new BufferGeometry();
		planes.setAttribute('position', new BufferAttribute(position, positionSize));
		planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
		planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));
		lodPlanes.push(planes);
		if (lod > LOD_MIN) {
			lod--;
		}
	}
	return {
		lodPlanes,
		sizeLods,
		sigmas
	};
}
function _createRenderTarget(width, height, params) {
	const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
	cubeUVRenderTarget.scissorTest = true;
	return cubeUVRenderTarget;
}
function _setViewport(target, x, y, width, height) {
	target.viewport.set(x, y, width, height);
	target.scissor.set(x, y, width, height);
}
function _getBlurShader(lodMax, width, height) {
	const weights = new Float32Array(MAX_SAMPLES);
	const poleAxis = new Vector3(0, 1, 0);
	const shaderMaterial = new ShaderMaterial({
		name: 'SphericalGaussianBlur',
		defines: {
			'n': MAX_SAMPLES,
			'CUBEUV_TEXEL_WIDTH': 1.0 / width,
			'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
			'CUBEUV_MAX_MIP': `${lodMax}.0`
		},
		uniforms: {
			'envMap': {
				value: null
			},
			'samples': {
				value: 1
			},
			'weights': {
				value: weights
			},
			'latitudinal': {
				value: false
			},
			'dTheta': {
				value: 0
			},
			'mipInt': {
				value: 0
			},
			'poleAxis': {
				value: poleAxis
			}
		},
		vertexShader: _getCommonVertexShader(),
		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
		blending: NoBlending,
		depthTest: false,
		depthWrite: false
	});
	return shaderMaterial;
}
function _getEquirectMaterial() {
	return new ShaderMaterial({
		name: 'EquirectangularToCubeUV',
		uniforms: {
			'envMap': {
				value: null
			}
		},
		vertexShader: _getCommonVertexShader(),
		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
		blending: NoBlending,
		depthTest: false,
		depthWrite: false
	});
}
function _getCubemapMaterial() {
	return new ShaderMaterial({
		name: 'CubemapToCubeUV',
		uniforms: {
			'envMap': {
				value: null
			},
			'flipEnvMap': {
				value: -1
			}
		},
		vertexShader: _getCommonVertexShader(),
		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
		blending: NoBlending,
		depthTest: false,
		depthWrite: false
	});
}
function _getCommonVertexShader() {
	return (/* glsl */`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
	);
}

function WebGLCubeUVMaps(renderer) {
	let cubeUVmaps = new WeakMap();
	let pmremGenerator = null;
	function get(texture) {
		if (texture && texture.isTexture) {
			const mapping = texture.mapping;
			const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
			const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;

			// equirect/cube map to cubeUV conversion

			if (isEquirectMap || isCubeMap) {
				if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {
					texture.needsPMREMUpdate = false;
					let renderTarget = cubeUVmaps.get(texture);
					if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
					renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
					cubeUVmaps.set(texture, renderTarget);
					return renderTarget.texture;
				} else {
					if (cubeUVmaps.has(texture)) {
						return cubeUVmaps.get(texture).texture;
					} else {
						const image = texture.image;
						if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
							if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
							const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
							cubeUVmaps.set(texture, renderTarget);
							texture.addEventListener('dispose', onTextureDispose);
							return renderTarget.texture;
						} else {
							// image not yet ready. try the conversion next frame

							return null;
						}
					}
				}
			}
		}
		return texture;
	}
	function isCubeTextureComplete(image) {
		let count = 0;
		const length = 6;
		for (let i = 0; i < length; i++) {
			if (image[i] !== undefined) count++;
		}
		return count === length;
	}
	function onTextureDispose(event) {
		const texture = event.target;
		texture.removeEventListener('dispose', onTextureDispose);
		const cubemapUV = cubeUVmaps.get(texture);
		if (cubemapUV !== undefined) {
			cubeUVmaps.delete(texture);
			cubemapUV.dispose();
		}
	}
	function dispose() {
		cubeUVmaps = new WeakMap();
		if (pmremGenerator !== null) {
			pmremGenerator.dispose();
			pmremGenerator = null;
		}
	}
	return {
		get: get,
		dispose: dispose
	};
}

function WebGLExtensions(gl) {
	const extensions = {};
	function getExtension(name) {
		if (extensions[name] !== undefined) {
			return extensions[name];
		}
		let extension;
		switch (name) {
			case 'WEBGL_depth_texture':
				extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
				break;
			case 'EXT_texture_filter_anisotropic':
				extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
				break;
			case 'WEBGL_compressed_texture_s3tc':
				extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
				break;
			case 'WEBGL_compressed_texture_pvrtc':
				extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
				break;
			default:
				extension = gl.getExtension(name);
		}
		extensions[name] = extension;
		return extension;
	}
	return {
		has: function (name) {
			return getExtension(name) !== null;
		},
		init: function (capabilities) {
			if (capabilities.isWebGL2) {
				getExtension('EXT_color_buffer_float');
			} else {
				getExtension('WEBGL_depth_texture');
				getExtension('OES_texture_float');
				getExtension('OES_texture_half_float');
				getExtension('OES_texture_half_float_linear');
				getExtension('OES_standard_derivatives');
				getExtension('OES_element_index_uint');
				getExtension('OES_vertex_array_object');
				getExtension('ANGLE_instanced_arrays');
			}
			getExtension('OES_texture_float_linear');
			getExtension('EXT_color_buffer_half_float');
			getExtension('WEBGL_multisampled_render_to_texture');
		},
		get: function (name) {
			const extension = getExtension(name);
			if (extension === null) {
				console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
			}
			return extension;
		}
	};
}

function WebGLGeometries(gl, attributes, info, bindingStates) {
	const geometries = {};
	const wireframeAttributes = new WeakMap();
	function onGeometryDispose(event) {
		const geometry = event.target;
		if (geometry.index !== null) {
			attributes.remove(geometry.index);
		}
		for (const name in geometry.attributes) {
			attributes.remove(geometry.attributes[name]);
		}
		geometry.removeEventListener('dispose', onGeometryDispose);
		delete geometries[geometry.id];
		const attribute = wireframeAttributes.get(geometry);
		if (attribute) {
			attributes.remove(attribute);
			wireframeAttributes.delete(geometry);
		}
		bindingStates.releaseStatesOfGeometry(geometry);
		if (geometry.isInstancedBufferGeometry === true) {
			delete geometry._maxInstanceCount;
		}

		//

		info.memory.geometries--;
	}
	function get(object, geometry) {
		if (geometries[geometry.id] === true) return geometry;
		geometry.addEventListener('dispose', onGeometryDispose);
		geometries[geometry.id] = true;
		info.memory.geometries++;
		return geometry;
	}
	function update(geometry) {
		const geometryAttributes = geometry.attributes;

		// Updating index buffer in VAO now. See WebGLBindingStates.

		for (const name in geometryAttributes) {
			attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
		}

		// morph targets

		const morphAttributes = geometry.morphAttributes;
		for (const name in morphAttributes) {
			const array = morphAttributes[name];
			for (let i = 0, l = array.length; i < l; i++) {
				attributes.update(array[i], gl.ARRAY_BUFFER);
			}
		}
	}
	function updateWireframeAttribute(geometry) {
		const indices = [];
		const geometryIndex = geometry.index;
		const geometryPosition = geometry.attributes.position;
		let version = 0;
		if (geometryIndex !== null) {
			const array = geometryIndex.array;
			version = geometryIndex.version;
			for (let i = 0, l = array.length; i < l; i += 3) {
				const a = array[i + 0];
				const b = array[i + 1];
				const c = array[i + 2];
				indices.push(a, b, b, c, c, a);
			}
		} else {
			const array = geometryPosition.array;
			version = geometryPosition.version;
			for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
				const a = i + 0;
				const b = i + 1;
				const c = i + 2;
				indices.push(a, b, b, c, c, a);
			}
		}
		const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
		attribute.version = version;

		// Updating index buffer in VAO now. See WebGLBindingStates

		//

		const previousAttribute = wireframeAttributes.get(geometry);
		if (previousAttribute) attributes.remove(previousAttribute);

		//

		wireframeAttributes.set(geometry, attribute);
	}
	function getWireframeAttribute(geometry) {
		const currentAttribute = wireframeAttributes.get(geometry);
		if (currentAttribute) {
			const geometryIndex = geometry.index;
			if (geometryIndex !== null) {
				// if the attribute is obsolete, create a new one

				if (currentAttribute.version < geometryIndex.version) {
					updateWireframeAttribute(geometry);
				}
			}
		} else {
			updateWireframeAttribute(geometry);
		}
		return wireframeAttributes.get(geometry);
	}
	return {
		get: get,
		update: update,
		getWireframeAttribute: getWireframeAttribute
	};
}

function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
	const isWebGL2 = capabilities.isWebGL2;
	let mode;
	function setMode(value) {
		mode = value;
	}
	let type, bytesPerElement;
	function setIndex(value) {
		type = value.type;
		bytesPerElement = value.bytesPerElement;
	}
	function render(start, count) {
		gl.drawElements(mode, count, type, start * bytesPerElement);
		info.update(count, mode, 1);
	}
	function renderInstances(start, count, primcount) {
		if (primcount === 0) return;
		let extension, methodName;
		if (isWebGL2) {
			extension = gl;
			methodName = 'drawElementsInstanced';
		} else {
			extension = extensions.get('ANGLE_instanced_arrays');
			methodName = 'drawElementsInstancedANGLE';
			if (extension === null) {
				console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
				return;
			}
		}
		extension[methodName](mode, count, type, start * bytesPerElement, primcount);
		info.update(count, mode, primcount);
	}

	//

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;
}

function WebGLInfo(gl) {
	const memory = {
		geometries: 0,
		textures: 0
	};
	const render = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};
	function update(count, mode, instanceCount) {
		render.calls++;
		switch (mode) {
			case gl.TRIANGLES:
				render.triangles += instanceCount * (count / 3);
				break;
			case gl.LINES:
				render.lines += instanceCount * (count / 2);
				break;
			case gl.LINE_STRIP:
				render.lines += instanceCount * (count - 1);
				break;
			case gl.LINE_LOOP:
				render.lines += instanceCount * count;
				break;
			case gl.POINTS:
				render.points += instanceCount * count;
				break;
			default:
				console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
				break;
		}
	}
	function reset() {
		render.frame++;
		render.calls = 0;
		render.triangles = 0;
		render.points = 0;
		render.lines = 0;
	}
	return {
		memory: memory,
		render: render,
		programs: null,
		autoReset: true,
		reset: reset,
		update: update
	};
}

class DataArrayTexture extends Texture {
	constructor(data = null, width = 1, height = 1, depth = 1) {
		super(null);
		this.isDataArrayTexture = true;
		this.image = {
			data,
			width,
			height,
			depth
		};
		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;
		this.wrapR = ClampToEdgeWrapping;
		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;
	}
}

function numericalSort(a, b) {
	return a[0] - b[0];
}
function absNumericalSort(a, b) {
	return Math.abs(b[1]) - Math.abs(a[1]);
}
function WebGLMorphtargets(gl, capabilities, textures) {
	const influencesList = {};
	const morphInfluences = new Float32Array(8);
	const morphTextures = new WeakMap();
	const morph = new Vector4();
	const workInfluences = [];
	for (let i = 0; i < 8; i++) {
		workInfluences[i] = [i, 0];
	}
	function update(object, geometry, material, program) {
		const objectInfluences = object.morphTargetInfluences;
		if (capabilities.isWebGL2 === true) {
			// instead of using attributes, the WebGL 2 code path encodes morph targets
			// into an array of data textures. Each layer represents a single morph target.

			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
			const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
			let entry = morphTextures.get(geometry);
			if (entry === undefined || entry.count !== morphTargetsCount) {
				if (entry !== undefined) entry.texture.dispose();
				const hasMorphPosition = geometry.morphAttributes.position !== undefined;
				const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
				const hasMorphColors = geometry.morphAttributes.color !== undefined;
				const morphTargets = geometry.morphAttributes.position || [];
				const morphNormals = geometry.morphAttributes.normal || [];
				const morphColors = geometry.morphAttributes.color || [];
				let vertexDataCount = 0;
				if (hasMorphPosition === true) vertexDataCount = 1;
				if (hasMorphNormals === true) vertexDataCount = 2;
				if (hasMorphColors === true) vertexDataCount = 3;
				let width = geometry.attributes.position.count * vertexDataCount;
				let height = 1;
				if (width > capabilities.maxTextureSize) {
					height = Math.ceil(width / capabilities.maxTextureSize);
					width = capabilities.maxTextureSize;
				}
				const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
				const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
				texture.type = FloatType;
				texture.needsUpdate = true;

				// fill buffer

				const vertexDataStride = vertexDataCount * 4;
				for (let i = 0; i < morphTargetsCount; i++) {
					const morphTarget = morphTargets[i];
					const morphNormal = morphNormals[i];
					const morphColor = morphColors[i];
					const offset = width * height * 4 * i;
					for (let j = 0; j < morphTarget.count; j++) {
						const stride = j * vertexDataStride;
						if (hasMorphPosition === true) {
							morph.fromBufferAttribute(morphTarget, j);
							buffer[offset + stride + 0] = morph.x;
							buffer[offset + stride + 1] = morph.y;
							buffer[offset + stride + 2] = morph.z;
							buffer[offset + stride + 3] = 0;
						}
						if (hasMorphNormals === true) {
							morph.fromBufferAttribute(morphNormal, j);
							buffer[offset + stride + 4] = morph.x;
							buffer[offset + stride + 5] = morph.y;
							buffer[offset + stride + 6] = morph.z;
							buffer[offset + stride + 7] = 0;
						}
						if (hasMorphColors === true) {
							morph.fromBufferAttribute(morphColor, j);
							buffer[offset + stride + 8] = morph.x;
							buffer[offset + stride + 9] = morph.y;
							buffer[offset + stride + 10] = morph.z;
							buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
						}
					}
				}
				entry = {
					count: morphTargetsCount,
					texture: texture,
					size: new Vector2(width, height)
				};
				morphTextures.set(geometry, entry);
				function disposeTexture() {
					texture.dispose();
					morphTextures.delete(geometry);
					geometry.removeEventListener('dispose', disposeTexture);
				}
				geometry.addEventListener('dispose', disposeTexture);
			}

			//

			let morphInfluencesSum = 0;
			for (let i = 0; i < objectInfluences.length; i++) {
				morphInfluencesSum += objectInfluences[i];
			}
			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
			program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
			program.getUniforms().setValue(gl, 'morphTargetInfluences', objectInfluences);
			program.getUniforms().setValue(gl, 'morphTargetsTexture', entry.texture, textures);
			program.getUniforms().setValue(gl, 'morphTargetsTextureSize', entry.size);
		} else {
			// When object doesn't have morph target influences defined, we treat it as a 0-length array
			// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

			const length = objectInfluences === undefined ? 0 : objectInfluences.length;
			let influences = influencesList[geometry.id];
			if (influences === undefined || influences.length !== length) {
				// initialise list

				influences = [];
				for (let i = 0; i < length; i++) {
					influences[i] = [i, 0];
				}
				influencesList[geometry.id] = influences;
			}

			// Collect influences

			for (let i = 0; i < length; i++) {
				const influence = influences[i];
				influence[0] = i;
				influence[1] = objectInfluences[i];
			}
			influences.sort(absNumericalSort);
			for (let i = 0; i < 8; i++) {
				if (i < length && influences[i][1]) {
					workInfluences[i][0] = influences[i][0];
					workInfluences[i][1] = influences[i][1];
				} else {
					workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
					workInfluences[i][1] = 0;
				}
			}
			workInfluences.sort(numericalSort);
			const morphTargets = geometry.morphAttributes.position;
			const morphNormals = geometry.morphAttributes.normal;
			let morphInfluencesSum = 0;
			for (let i = 0; i < 8; i++) {
				const influence = workInfluences[i];
				const index = influence[0];
				const value = influence[1];
				if (index !== Number.MAX_SAFE_INTEGER && value) {
					if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {
						geometry.setAttribute('morphTarget' + i, morphTargets[index]);
					}
					if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {
						geometry.setAttribute('morphNormal' + i, morphNormals[index]);
					}
					morphInfluences[i] = value;
					morphInfluencesSum += value;
				} else {
					if (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {
						geometry.deleteAttribute('morphTarget' + i);
					}
					if (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {
						geometry.deleteAttribute('morphNormal' + i);
					}
					morphInfluences[i] = 0;
				}
			}

			// GLSL shader uses formula baseinfluence * base + sum(target * influence)
			// This allows us to switch between absolute morphs and relative morphs without changing shader code
			// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
			program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
			program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
		}
	}
	return {
		update: update
	};
}

function WebGLObjects(gl, geometries, attributes, info) {
	let updateMap = new WeakMap();
	function update(object) {
		const frame = info.render.frame;
		const geometry = object.geometry;
		const buffergeometry = geometries.get(object, geometry);

		// Update once per frame

		if (updateMap.get(buffergeometry) !== frame) {
			geometries.update(buffergeometry);
			updateMap.set(buffergeometry, frame);
		}
		if (object.isInstancedMesh) {
			if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {
				object.addEventListener('dispose', onInstancedMeshDispose);
			}
			attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
			if (object.instanceColor !== null) {
				attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
			}
		}
		return buffergeometry;
	}
	function dispose() {
		updateMap = new WeakMap();
	}
	function onInstancedMeshDispose(event) {
		const instancedMesh = event.target;
		instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);
		attributes.remove(instancedMesh.instanceMatrix);
		if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
	}
	return {
		update: update,
		dispose: dispose
	};
}

class Data3DTexture extends Texture {
	constructor(data = null, width = 1, height = 1, depth = 1) {
		// We're going to add .setXXX() methods for setting properties later.
		// Users can still set in DataTexture3D directly.
		//
		//	const texture = new THREE.DataTexture3D( data, width, height, depth );
		// 	texture.anisotropy = 16;
		//
		// See #14839

		super(null);
		this.isData3DTexture = true;
		this.image = {
			data,
			width,
			height,
			depth
		};
		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;
		this.wrapR = ClampToEdgeWrapping;
		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;
	}
}

/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *		the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with	name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */
const emptyTexture = /*@__PURE__*/new Texture();
const emptyArrayTexture = /*@__PURE__*/new DataArrayTexture();
const empty3dTexture = /*@__PURE__*/new Data3DTexture();
const emptyCubeTexture = /*@__PURE__*/new CubeTexture();

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

const arrayCacheF32 = [];
const arrayCacheI32 = [];

// Float32Array caches used for uploading Matrix uniforms

const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);

// Flattening for arrays of vectors and matrices

function flatten(array, nBlocks, blockSize) {
	const firstElem = array[0];
	if (firstElem <= 0 || firstElem > 0) return array;
	// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983

	const n = nBlocks * blockSize;
	let r = arrayCacheF32[n];
	if (r === undefined) {
		r = new Float32Array(n);
		arrayCacheF32[n] = r;
	}
	if (nBlocks !== 0) {
		firstElem.toArray(r, 0);
		for (let i = 1, offset = 0; i !== nBlocks; ++i) {
			offset += blockSize;
			array[i].toArray(r, offset);
		}
	}
	return r;
}
function arraysEqual(a, b) {
	if (a.length !== b.length) return false;
	for (let i = 0, l = a.length; i < l; i++) {
		if (a[i] !== b[i]) return false;
	}
	return true;
}
function copyArray(a, b) {
	for (let i = 0, l = b.length; i < l; i++) {
		a[i] = b[i];
	}
}

// Texture unit allocation

function allocTexUnits(textures, n) {
	let r = arrayCacheI32[n];
	if (r === undefined) {
		r = new Int32Array(n);
		arrayCacheI32[n] = r;
	}
	for (let i = 0; i !== n; ++i) {
		r[i] = textures.allocateTextureUnit();
	}
	return r;
}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValueV1f(gl, v) {
	const cache = this.cache;
	if (cache[0] === v) return;
	gl.uniform1f(this.addr, v);
	cache[0] = v;
}

// Single float vector (from flat array or THREE.VectorN)

function setValueV2f(gl, v) {
	const cache = this.cache;
	if (v.x !== undefined) {
		if (cache[0] !== v.x || cache[1] !== v.y) {
			gl.uniform2f(this.addr, v.x, v.y);
			cache[0] = v.x;
			cache[1] = v.y;
		}
	} else {
		if (arraysEqual(cache, v)) return;
		gl.uniform2fv(this.addr, v);
		copyArray(cache, v);
	}
}
function setValueV3f(gl, v) {
	const cache = this.cache;
	if (v.x !== undefined) {
		if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
			gl.uniform3f(this.addr, v.x, v.y, v.z);
			cache[0] = v.x;
			cache[1] = v.y;
			cache[2] = v.z;
		}
	} else if (v.r !== undefined) {
		if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
			gl.uniform3f(this.addr, v.r, v.g, v.b);
			cache[0] = v.r;
			cache[1] = v.g;
			cache[2] = v.b;
		}
	} else {
		if (arraysEqual(cache, v)) return;
		gl.uniform3fv(this.addr, v);
		copyArray(cache, v);
	}
}
function setValueV4f(gl, v) {
	const cache = this.cache;
	if (v.x !== undefined) {
		if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
			gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
			cache[0] = v.x;
			cache[1] = v.y;
			cache[2] = v.z;
			cache[3] = v.w;
		}
	} else {
		if (arraysEqual(cache, v)) return;
		gl.uniform4fv(this.addr, v);
		copyArray(cache, v);
	}
}

// Single matrix (from flat array or THREE.MatrixN)

function setValueM2(gl, v) {
	const cache = this.cache;
	const elements = v.elements;
	if (elements === undefined) {
		if (arraysEqual(cache, v)) return;
		gl.uniformMatrix2fv(this.addr, false, v);
		copyArray(cache, v);
	} else {
		if (arraysEqual(cache, elements)) return;
		mat2array.set(elements);
		gl.uniformMatrix2fv(this.addr, false, mat2array);
		copyArray(cache, elements);
	}
}
function setValueM3(gl, v) {
	const cache = this.cache;
	const elements = v.elements;
	if (elements === undefined) {
		if (arraysEqual(cache, v)) return;
		gl.uniformMatrix3fv(this.addr, false, v);
		copyArray(cache, v);
	} else {
		if (arraysEqual(cache, elements)) return;
		mat3array.set(elements);
		gl.uniformMatrix3fv(this.addr, false, mat3array);
		copyArray(cache, elements);
	}
}
function setValueM4(gl, v) {
	const cache = this.cache;
	const elements = v.elements;
	if (elements === undefined) {
		if (arraysEqual(cache, v)) return;
		gl.uniformMatrix4fv(this.addr, false, v);
		copyArray(cache, v);
	} else {
		if (arraysEqual(cache, elements)) return;
		mat4array.set(elements);
		gl.uniformMatrix4fv(this.addr, false, mat4array);
		copyArray(cache, elements);
	}
}

// Single integer / boolean

function setValueV1i(gl, v) {
	const cache = this.cache;
	if (cache[0] === v) return;
	gl.uniform1i(this.addr, v);
	cache[0] = v;
}

// Single integer / boolean vector (from flat array or THREE.VectorN)

function setValueV2i(gl, v) {
	const cache = this.cache;
	if (v.x !== undefined) {
		if (cache[0] !== v.x || cache[1] !== v.y) {
			gl.uniform2i(this.addr, v.x, v.y);
			cache[0] = v.x;
			cache[1] = v.y;
		}
	} else {
		if (arraysEqual(cache, v)) return;
		gl.uniform2iv(this.addr, v);
		copyArray(cache, v);
	}
}
function setValueV3i(gl, v) {
	const cache = this.cache;
	if (v.x !== undefined) {
		if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
			gl.uniform3i(this.addr, v.x, v.y, v.z);
			cache[0] = v.x;
			cache[1] = v.y;
			cache[2] = v.z;
		}
	} else {
		if (arraysEqual(cache, v)) return;
		gl.uniform3iv(this.addr, v);
		copyArray(cache, v);
	}
}
function setValueV4i(gl, v) {
	const cache = this.cache;
	if (v.x !== undefined) {
		if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
			gl.uniform4i(this.addr, v.x, v.y, v.z, v.w);
			cache[0] = v.x;
			cache[1] = v.y;
			cache[2] = v.z;
			cache[3] = v.w;
		}
	} else {
		if (arraysEqual(cache, v)) return;
		gl.uniform4iv(this.addr, v);
		copyArray(cache, v);
	}
}

// Single unsigned integer

function setValueV1ui(gl, v) {
	const cache = this.cache;
	if (cache[0] === v) return;
	gl.uniform1ui(this.addr, v);
	cache[0] = v;
}

// Single unsigned integer vector (from flat array or THREE.VectorN)

function setValueV2ui(gl, v) {
	const cache = this.cache;
	if (v.x !== undefined) {
		if (cache[0] !== v.x || cache[1] !== v.y) {
			gl.uniform2ui(this.addr, v.x, v.y);
			cache[0] = v.x;
			cache[1] = v.y;
		}
	} else {
		if (arraysEqual(cache, v)) return;
		gl.uniform2uiv(this.addr, v);
		copyArray(cache, v);
	}
}
function setValueV3ui(gl, v) {
	const cache = this.cache;
	if (v.x !== undefined) {
		if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
			gl.uniform3ui(this.addr, v.x, v.y, v.z);
			cache[0] = v.x;
			cache[1] = v.y;
			cache[2] = v.z;
		}
	} else {
		if (arraysEqual(cache, v)) return;
		gl.uniform3uiv(this.addr, v);
		copyArray(cache, v);
	}
}
function setValueV4ui(gl, v) {
	const cache = this.cache;
	if (v.x !== undefined) {
		if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
			gl.uniform4ui(this.addr, v.x, v.y, v.z, v.w);
			cache[0] = v.x;
			cache[1] = v.y;
			cache[2] = v.z;
			cache[3] = v.w;
		}
	} else {
		if (arraysEqual(cache, v)) return;
		gl.uniform4uiv(this.addr, v);
		copyArray(cache, v);
	}
}

// Single texture (2D / Cube)

function setValueT1(gl, v, textures) {
	const cache = this.cache;
	const unit = textures.allocateTextureUnit();
	if (cache[0] !== unit) {
		gl.uniform1i(this.addr, unit);
		cache[0] = unit;
	}
	textures.setTexture2D(v || emptyTexture, unit);
}
function setValueT3D1(gl, v, textures) {
	const cache = this.cache;
	const unit = textures.allocateTextureUnit();
	if (cache[0] !== unit) {
		gl.uniform1i(this.addr, unit);
		cache[0] = unit;
	}
	textures.setTexture3D(v || empty3dTexture, unit);
}
function setValueT6(gl, v, textures) {
	const cache = this.cache;
	const unit = textures.allocateTextureUnit();
	if (cache[0] !== unit) {
		gl.uniform1i(this.addr, unit);
		cache[0] = unit;
	}
	textures.setTextureCube(v || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
	const cache = this.cache;
	const unit = textures.allocateTextureUnit();
	if (cache[0] !== unit) {
		gl.uniform1i(this.addr, unit);
		cache[0] = unit;
	}
	textures.setTexture2DArray(v || emptyArrayTexture, unit);
}

// Helper to pick the right setter for the singular case

function getSingularSetter(type) {
	switch (type) {
		case 0x1406:
			return setValueV1f;
		// FLOAT
		case 0x8b50:
			return setValueV2f;
		// _VEC2
		case 0x8b51:
			return setValueV3f;
		// _VEC3
		case 0x8b52:
			return setValueV4f;
		// _VEC4

		case 0x8b5a:
			return setValueM2;
		// _MAT2
		case 0x8b5b:
			return setValueM3;
		// _MAT3
		case 0x8b5c:
			return setValueM4;
		// _MAT4

		case 0x1404:
		case 0x8b56:
			return setValueV1i;
		// INT, BOOL
		case 0x8b53:
		case 0x8b57:
			return setValueV2i;
		// _VEC2
		case 0x8b54:
		case 0x8b58:
			return setValueV3i;
		// _VEC3
		case 0x8b55:
		case 0x8b59:
			return setValueV4i;
		// _VEC4

		case 0x1405:
			return setValueV1ui;
		// UINT
		case 0x8dc6:
			return setValueV2ui;
		// _VEC2
		case 0x8dc7:
			return setValueV3ui;
		// _VEC3
		case 0x8dc8:
			return setValueV4ui;
		// _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62:
			// SAMPLER_2D_SHADOW
			return setValueT1;
		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3:
			// UNSIGNED_INT_SAMPLER_3D
			return setValueT3D1;
		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5:
			// SAMPLER_CUBE_SHADOW
			return setValueT6;
		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4:
			// SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArray1;
	}
}

// Array of scalars

function setValueV1fArray(gl, v) {
	gl.uniform1fv(this.addr, v);
}

// Array of vectors (from flat array or array of THREE.VectorN)

function setValueV2fArray(gl, v) {
	const data = flatten(v, this.size, 2);
	gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
	const data = flatten(v, this.size, 3);
	gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
	const data = flatten(v, this.size, 4);
	gl.uniform4fv(this.addr, data);
}

// Array of matrices (from flat array or array of THREE.MatrixN)

function setValueM2Array(gl, v) {
	const data = flatten(v, this.size, 4);
	gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
	const data = flatten(v, this.size, 9);
	gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
	const data = flatten(v, this.size, 16);
	gl.uniformMatrix4fv(this.addr, false, data);
}

// Array of integer / boolean

function setValueV1iArray(gl, v) {
	gl.uniform1iv(this.addr, v);
}

// Array of integer / boolean vectors (from flat array)

function setValueV2iArray(gl, v) {
	gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
	gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
	gl.uniform4iv(this.addr, v);
}

// Array of unsigned integer

function setValueV1uiArray(gl, v) {
	gl.uniform1uiv(this.addr, v);
}

// Array of unsigned integer vectors (from flat array)

function setValueV2uiArray(gl, v) {
	gl.uniform2uiv(this.addr, v);
}
function setValueV3uiArray(gl, v) {
	gl.uniform3uiv(this.addr, v);
}
function setValueV4uiArray(gl, v) {
	gl.uniform4uiv(this.addr, v);
}

// Array of textures (2D / 3D / Cube / 2DArray)

function setValueT1Array(gl, v, textures) {
	const cache = this.cache;
	const n = v.length;
	const units = allocTexUnits(textures, n);
	if (!arraysEqual(cache, units)) {
		gl.uniform1iv(this.addr, units);
		copyArray(cache, units);
	}
	for (let i = 0; i !== n; ++i) {
		textures.setTexture2D(v[i] || emptyTexture, units[i]);
	}
}
function setValueT3DArray(gl, v, textures) {
	const cache = this.cache;
	const n = v.length;
	const units = allocTexUnits(textures, n);
	if (!arraysEqual(cache, units)) {
		gl.uniform1iv(this.addr, units);
		copyArray(cache, units);
	}
	for (let i = 0; i !== n; ++i) {
		textures.setTexture3D(v[i] || empty3dTexture, units[i]);
	}
}
function setValueT6Array(gl, v, textures) {
	const cache = this.cache;
	const n = v.length;
	const units = allocTexUnits(textures, n);
	if (!arraysEqual(cache, units)) {
		gl.uniform1iv(this.addr, units);
		copyArray(cache, units);
	}
	for (let i = 0; i !== n; ++i) {
		textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);
	}
}
function setValueT2DArrayArray(gl, v, textures) {
	const cache = this.cache;
	const n = v.length;
	const units = allocTexUnits(textures, n);
	if (!arraysEqual(cache, units)) {
		gl.uniform1iv(this.addr, units);
		copyArray(cache, units);
	}
	for (let i = 0; i !== n; ++i) {
		textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);
	}
}

// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter(type) {
	switch (type) {
		case 0x1406:
			return setValueV1fArray;
		// FLOAT
		case 0x8b50:
			return setValueV2fArray;
		// _VEC2
		case 0x8b51:
			return setValueV3fArray;
		// _VEC3
		case 0x8b52:
			return setValueV4fArray;
		// _VEC4

		case 0x8b5a:
			return setValueM2Array;
		// _MAT2
		case 0x8b5b:
			return setValueM3Array;
		// _MAT3
		case 0x8b5c:
			return setValueM4Array;
		// _MAT4

		case 0x1404:
		case 0x8b56:
			return setValueV1iArray;
		// INT, BOOL
		case 0x8b53:
		case 0x8b57:
			return setValueV2iArray;
		// _VEC2
		case 0x8b54:
		case 0x8b58:
			return setValueV3iArray;
		// _VEC3
		case 0x8b55:
		case 0x8b59:
			return setValueV4iArray;
		// _VEC4

		case 0x1405:
			return setValueV1uiArray;
		// UINT
		case 0x8dc6:
			return setValueV2uiArray;
		// _VEC2
		case 0x8dc7:
			return setValueV3uiArray;
		// _VEC3
		case 0x8dc8:
			return setValueV4uiArray;
		// _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62:
			// SAMPLER_2D_SHADOW
			return setValueT1Array;
		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3:
			// UNSIGNED_INT_SAMPLER_3D
			return setValueT3DArray;
		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5:
			// SAMPLER_CUBE_SHADOW
			return setValueT6Array;
		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4:
			// SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArrayArray;
	}
}

// --- Uniform Classes ---

class SingleUniform {
	constructor(id, activeInfo, addr) {
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter(activeInfo.type);

		// this.path = activeInfo.name; // DEBUG
	}
}

class PureArrayUniform {
	constructor(id, activeInfo, addr) {
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter(activeInfo.type);

		// this.path = activeInfo.name; // DEBUG
	}
}

class StructuredUniform {
	constructor(id) {
		this.id = id;
		this.seq = [];
		this.map = {};
	}
	setValue(gl, value, textures) {
		const seq = this.seq;
		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i];
			u.setValue(gl, value[u.id], textures);
		}
	}
}

// --- Top-level ---

// Parser - builds up the property tree from the path strings

const RePathPart = /(\w+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//	- followed by an optional right bracket (found when array index)
//	- followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform(container, uniformObject) {
	container.seq.push(uniformObject);
	container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
	const path = activeInfo.name,
		pathLength = path.length;

	// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex = 0;
	while (true) {
		const match = RePathPart.exec(path),
			matchEnd = RePathPart.lastIndex;
		let id = match[1];
		const idIsIndex = match[2] === ']',
			subscript = match[3];
		if (idIsIndex) id = id | 0; // convert to integer

		if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
			// bare name or "pure" bottom-level array "[0]" suffix

			addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
			break;
		} else {
			// step into inner node / create it in case it doesn't exist

			const map = container.map;
			let next = map[id];
			if (next === undefined) {
				next = new StructuredUniform(id);
				addUniform(container, next);
			}
			container = next;
		}
	}
}

// Root Container

class WebGLUniforms {
	constructor(gl, program) {
		this.seq = [];
		this.map = {};
		const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
		for (let i = 0; i < n; ++i) {
			const info = gl.getActiveUniform(program, i),
				addr = gl.getUniformLocation(program, info.name);
			parseUniform(info, addr, this);
		}
	}
	setValue(gl, name, value, textures) {
		const u = this.map[name];
		if (u !== undefined) u.setValue(gl, value, textures);
	}
	setOptional(gl, object, name) {
		const v = object[name];
		if (v !== undefined) this.setValue(gl, name, v);
	}
	static upload(gl, seq, values, textures) {
		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i],
				v = values[u.id];
			if (v.needsUpdate !== false) {
				// note: always updating when .needsUpdate is undefined
				u.setValue(gl, v.value, textures);
			}
		}
	}
	static seqWithValue(seq, values) {
		const r = [];
		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i];
			if (u.id in values) r.push(u);
		}
		return r;
	}
}

function WebGLShader(gl, type, string) {
	const shader = gl.createShader(type);
	gl.shaderSource(shader, string);
	gl.compileShader(shader);
	return shader;
}

let programIdCount = 0;
function handleSource(string, errorLine) {
	const lines = string.split('\n');
	const lines2 = [];
	const from = Math.max(errorLine - 6, 0);
	const to = Math.min(errorLine + 6, lines.length);
	for (let i = from; i < to; i++) {
		const line = i + 1;
		lines2.push(`${line === errorLine ? '>' : ' '} ${line}: ${lines[i]}`);
	}
	return lines2.join('\n');
}
function getEncodingComponents(encoding) {
	switch (encoding) {
		case LinearEncoding:
			return ['Linear', '( value )'];
		case sRGBEncoding:
			return ['sRGB', '( value )'];
		default:
			console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
			return ['Linear', '( value )'];
	}
}
function getShaderErrors(gl, shader, type) {
	const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
	const errors = gl.getShaderInfoLog(shader).trim();
	if (status && errors === '') return '';
	const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
	if (errorMatches) {
		// --enable-privileged-webgl-extension
		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		const errorLine = parseInt(errorMatches[1]);
		return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource(gl.getShaderSource(shader), errorLine);
	} else {
		return errors;
	}
}
function getTexelEncodingFunction(functionName, encoding) {
	const components = getEncodingComponents(encoding);
	return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
}
function getToneMappingFunction(functionName, toneMapping) {
	let toneMappingName;
	switch (toneMapping) {
		case LinearToneMapping:
			toneMappingName = 'Linear';
			break;
		case ReinhardToneMapping:
			toneMappingName = 'Reinhard';
			break;
		case CineonToneMapping:
			toneMappingName = 'OptimizedCineon';
			break;
		case ACESFilmicToneMapping:
			toneMappingName = 'ACESFilmic';
			break;
		case CustomToneMapping:
			toneMappingName = 'Custom';
			break;
		default:
			console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
			toneMappingName = 'Linear';
	}
	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
}
function generateExtensions(parameters) {
	const chunks = [parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
	return chunks.filter(filterEmptyLine).join('\n');
}
function generateDefines(defines) {
	const chunks = [];
	for (const name in defines) {
		const value = defines[name];
		if (value === false) continue;
		chunks.push('#define ' + name + ' ' + value);
	}
	return chunks.join('\n');
}
function fetchAttributeLocations(gl, program) {
	const attributes = {};
	const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
	for (let i = 0; i < n; i++) {
		const info = gl.getActiveAttrib(program, i);
		const name = info.name;
		let locationSize = 1;
		if (info.type === gl.FLOAT_MAT2) locationSize = 2;
		if (info.type === gl.FLOAT_MAT3) locationSize = 3;
		if (info.type === gl.FLOAT_MAT4) locationSize = 4;

		// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

		attributes[name] = {
			type: info.type,
			location: gl.getAttribLocation(program, name),
			locationSize: locationSize
		};
	}
	return attributes;
}
function filterEmptyLine(string) {
	return string !== '';
}
function replaceLightNums(string, parameters) {
	const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
	return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
	return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}

// Resolve Includes

const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
	return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match, include) {
	const string = ShaderChunk[include];
	if (string === undefined) {
		throw new Error('Can not resolve #include <' + include + '>');
	}
	return resolveIncludes(string);
}

// Unroll Loops

const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
	return string.replace(unrollLoopPattern, loopReplacer);
}
function loopReplacer(match, start, end, snippet) {
	let string = '';
	for (let i = parseInt(start); i < parseInt(end); i++) {
		string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);
	}
	return string;
}

//

function generatePrecision(parameters) {
	let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';
	if (parameters.precision === 'highp') {
		precisionstring += '\n#define HIGH_PRECISION';
	} else if (parameters.precision === 'mediump') {
		precisionstring += '\n#define MEDIUM_PRECISION';
	} else if (parameters.precision === 'lowp') {
		precisionstring += '\n#define LOW_PRECISION';
	}
	return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
	let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
	if (parameters.shadowMapType === PCFShadowMap) {
		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
	} else if (parameters.shadowMapType === PCFSoftShadowMap) {
		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
	} else if (parameters.shadowMapType === VSMShadowMap) {
		shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
	}
	return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
	let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
	if (parameters.envMap) {
		switch (parameters.envMapMode) {
			case CubeReflectionMapping:
			case CubeRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;
			case CubeUVReflectionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;
		}
	}
	return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
	let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
	if (parameters.envMap) {
		switch (parameters.envMapMode) {
			case CubeRefractionMapping:
				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;
		}
	}
	return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
	let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';
	if (parameters.envMap) {
		switch (parameters.combine) {
			case MultiplyOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;
			case MixOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;
			case AddOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;
		}
	}
	return envMapBlendingDefine;
}
function generateCubeUVSize(parameters) {
	const imageHeight = parameters.envMapCubeUVHeight;
	if (imageHeight === null) return null;
	const maxMip = Math.log2(imageHeight) - 2;
	const texelHeight = 1.0 / imageHeight;
	const texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
	return {
		texelWidth,
		texelHeight,
		maxMip
	};
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
	// TODO Send this event to Three.js DevTools
	// console.log( 'WebGLProgram', cacheKey );

	const gl = renderer.getContext();
	const defines = parameters.defines;
	let vertexShader = parameters.vertexShader;
	let fragmentShader = parameters.fragmentShader;
	const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
	const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
	const envMapModeDefine = generateEnvMapModeDefine(parameters);
	const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
	const envMapCubeUVSize = generateCubeUVSize(parameters);
	const customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
	const customDefines = generateDefines(defines);
	const program = gl.createProgram();
	let prefixVertex, prefixFragment;
	let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';
	if (parameters.isRawShaderMaterial) {
		prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');
		if (prefixVertex.length > 0) {
			prefixVertex += '\n';
		}
		prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');
		if (prefixFragment.length > 0) {
			prefixFragment += '\n';
		}
	} else {
		prefixVertex = [generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '', parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '', parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '', parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.morphColors && parameters.isWebGL2 ? '#define USE_MORPHCOLORS' : '', parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? '#define MORPHTARGETS_TEXTURE' : '', parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '', parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '	attribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '	attribute vec3 instanceColor;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#if defined( USE_COLOR_ALPHA )', '	attribute vec4 color;', '#elif defined( USE_COLOR )', '	attribute vec3 color;', '#endif', '#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
		prefixFragment = [customExtensions, generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '', envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '', envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoat ? '#define USE_CLEARCOAT' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.iridescence ? '#define USE_IRIDESCENCE' : '', parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '', parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '', parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.alphaTest ? '#define USE_ALPHATEST' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '', parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '',
		// this code is required here because it is used by the toneMapping() function defined below
		parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', parameters.opaque ? '#define OPAQUE' : '', ShaderChunk['encodings_pars_fragment'],
		// this code is required here because it is used by the various encoding/decoding function defined below
		getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding), parameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
	}
	vertexShader = resolveIncludes(vertexShader);
	vertexShader = replaceLightNums(vertexShader, parameters);
	vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
	fragmentShader = resolveIncludes(fragmentShader);
	fragmentShader = replaceLightNums(fragmentShader, parameters);
	fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
	vertexShader = unrollLoops(vertexShader);
	fragmentShader = unrollLoops(fragmentShader);
	if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
		// GLSL 3.0 conversion for built-in materials and ShaderMaterial

		versionString = '#version 300 es\n';
		prefixVertex = ['precision mediump sampler2DArray;', '#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
		prefixFragment = ['#define varying in', parameters.glslVersion === GLSL3 ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;', parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
	}
	const vertexGlsl = versionString + prefixVertex + vertexShader;
	const fragmentGlsl = versionString + prefixFragment + fragmentShader;

	// console.log( '*VERTEX*', vertexGlsl );
	// console.log( '*FRAGMENT*', fragmentGlsl );

	const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
	const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
	gl.attachShader(program, glVertexShader);
	gl.attachShader(program, glFragmentShader);

	// Force a particular attribute to index 0.

	if (parameters.index0AttributeName !== undefined) {
		gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
	} else if (parameters.morphTargets === true) {
		// programs with morphTargets displace position out of attribute 0
		gl.bindAttribLocation(program, 0, 'position');
	}
	gl.linkProgram(program);

	// check for link errors
	if (renderer.debug.checkShaderErrors) {
		const programLog = gl.getProgramInfoLog(program).trim();
		const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
		const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
		let runnable = true;
		let haveDiagnostics = true;
		if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
			runnable = false;
			const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
			const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
			console.error('THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' + 'VALIDATE_STATUS ' + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + '\n\n' + 'Program Info Log: ' + programLog + '\n' + vertexErrors + '\n' + fragmentErrors);
		} else if (programLog !== '') {
			console.warn('THREE.WebGLProgram: Program Info Log:', programLog);
		} else if (vertexLog === '' || fragmentLog === '') {
			haveDiagnostics = false;
		}
		if (haveDiagnostics) {
			this.diagnostics = {
				runnable: runnable,
				programLog: programLog,
				vertexShader: {
					log: vertexLog,
					prefix: prefixVertex
				},
				fragmentShader: {
					log: fragmentLog,
					prefix: prefixFragment
				}
			};
		}
	}

	// Clean up

	// Crashes in iOS9 and iOS10. #18402
	// gl.detachShader( program, glVertexShader );
	// gl.detachShader( program, glFragmentShader );

	gl.deleteShader(glVertexShader);
	gl.deleteShader(glFragmentShader);

	// set up caching for uniform locations

	let cachedUniforms;
	this.getUniforms = function () {
		if (cachedUniforms === undefined) {
			cachedUniforms = new WebGLUniforms(gl, program);
		}
		return cachedUniforms;
	};

	// set up caching for attribute locations

	let cachedAttributes;
	this.getAttributes = function () {
		if (cachedAttributes === undefined) {
			cachedAttributes = fetchAttributeLocations(gl, program);
		}
		return cachedAttributes;
	};

	// free resource

	this.destroy = function () {
		bindingStates.releaseStatesOfProgram(this);
		gl.deleteProgram(program);
		this.program = undefined;
	};

	//

	this.name = parameters.shaderName;
	this.id = programIdCount++;
	this.cacheKey = cacheKey;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;
	return this;
}

let _id = 0;
class WebGLShaderCache {
	constructor() {
		this.shaderCache = new Map();
		this.materialCache = new Map();
	}
	update(material) {
		const vertexShader = material.vertexShader;
		const fragmentShader = material.fragmentShader;
		const vertexShaderStage = this._getShaderStage(vertexShader);
		const fragmentShaderStage = this._getShaderStage(fragmentShader);
		const materialShaders = this._getShaderCacheForMaterial(material);
		if (materialShaders.has(vertexShaderStage) === false) {
			materialShaders.add(vertexShaderStage);
			vertexShaderStage.usedTimes++;
		}
		if (materialShaders.has(fragmentShaderStage) === false) {
			materialShaders.add(fragmentShaderStage);
			fragmentShaderStage.usedTimes++;
		}
		return this;
	}
	remove(material) {
		const materialShaders = this.materialCache.get(material);
		for (const shaderStage of materialShaders) {
			shaderStage.usedTimes--;
			if (shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code);
		}
		this.materialCache.delete(material);
		return this;
	}
	getVertexShaderID(material) {
		return this._getShaderStage(material.vertexShader).id;
	}
	getFragmentShaderID(material) {
		return this._getShaderStage(material.fragmentShader).id;
	}
	dispose() {
		this.shaderCache.clear();
		this.materialCache.clear();
	}
	_getShaderCacheForMaterial(material) {
		const cache = this.materialCache;
		let set = cache.get(material);
		if (set === undefined) {
			set = new Set();
			cache.set(material, set);
		}
		return set;
	}
	_getShaderStage(code) {
		const cache = this.shaderCache;
		let stage = cache.get(code);
		if (stage === undefined) {
			stage = new WebGLShaderStage(code);
			cache.set(code, stage);
		}
		return stage;
	}
}
class WebGLShaderStage {
	constructor(code) {
		this.id = _id++;
		this.code = code;
		this.usedTimes = 0;
	}
}

function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
	const _programLayers = new Layers();
	const _customShaders = new WebGLShaderCache();
	const programs = [];
	const isWebGL2 = capabilities.isWebGL2;
	const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
	const vertexTextures = capabilities.vertexTextures;
	let precision = capabilities.precision;
	const shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshDistanceMaterial: 'distanceRGBA',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'toon',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		MeshMatcapMaterial: 'matcap',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points',
		ShadowMaterial: 'shadow',
		SpriteMaterial: 'sprite'
	};
	function getParameters(material, lights, shadows, scene, object) {
		const fog = scene.fog;
		const geometry = object.geometry;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;
		const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
		const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
		const shaderID = shaderIDs[material.type];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		if (material.precision !== null) {
			precision = capabilities.getMaxPrecision(material.precision);
			if (precision !== material.precision) {
				console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
			}
		}

		//

		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
		let morphTextureStride = 0;
		if (geometry.morphAttributes.position !== undefined) morphTextureStride = 1;
		if (geometry.morphAttributes.normal !== undefined) morphTextureStride = 2;
		if (geometry.morphAttributes.color !== undefined) morphTextureStride = 3;

		//

		let vertexShader, fragmentShader;
		let customVertexShaderID, customFragmentShaderID;
		if (shaderID) {
			const shader = ShaderLib[shaderID];
			vertexShader = shader.vertexShader;
			fragmentShader = shader.fragmentShader;
		} else {
			vertexShader = material.vertexShader;
			fragmentShader = material.fragmentShader;
			_customShaders.update(material);
			customVertexShaderID = _customShaders.getVertexShaderID(material);
			customFragmentShaderID = _customShaders.getFragmentShaderID(material);
		}
		const currentRenderTarget = renderer.getRenderTarget();
		const useAlphaTest = material.alphaTest > 0;
		const useClearcoat = material.clearcoat > 0;
		const useIridescence = material.iridescence > 0;
		const parameters = {
			isWebGL2: isWebGL2,
			shaderID: shaderID,
			shaderName: material.type,
			vertexShader: vertexShader,
			fragmentShader: fragmentShader,
			defines: material.defines,
			customVertexShaderID: customVertexShaderID,
			customFragmentShaderID: customFragmentShaderID,
			isRawShaderMaterial: material.isRawShaderMaterial === true,
			glslVersion: material.glslVersion,
			precision: precision,
			instancing: object.isInstancedMesh === true,
			instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
			supportsVertexTextures: vertexTextures,
			outputEncoding: currentRenderTarget === null ? renderer.outputEncoding : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding,
			map: !!material.map,
			matcap: !!material.matcap,
			envMap: !!envMap,
			envMapMode: envMap && envMap.mapping,
			envMapCubeUVHeight: envMapCubeUVHeight,
			lightMap: !!material.lightMap,
			aoMap: !!material.aoMap,
			emissiveMap: !!material.emissiveMap,
			bumpMap: !!material.bumpMap,
			normalMap: !!material.normalMap,
			objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
			tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
			decodeVideoTexture: !!material.map && material.map.isVideoTexture === true && material.map.encoding === sRGBEncoding,
			clearcoat: useClearcoat,
			clearcoatMap: useClearcoat && !!material.clearcoatMap,
			clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
			clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
			iridescence: useIridescence,
			iridescenceMap: useIridescence && !!material.iridescenceMap,
			iridescenceThicknessMap: useIridescence && !!material.iridescenceThicknessMap,
			displacementMap: !!material.displacementMap,
			roughnessMap: !!material.roughnessMap,
			metalnessMap: !!material.metalnessMap,
			specularMap: !!material.specularMap,
			specularIntensityMap: !!material.specularIntensityMap,
			specularColorMap: !!material.specularColorMap,
			opaque: material.transparent === false && material.blending === NormalBlending,
			alphaMap: !!material.alphaMap,
			alphaTest: useAlphaTest,
			gradientMap: !!material.gradientMap,
			sheen: material.sheen > 0,
			sheenColorMap: !!material.sheenColorMap,
			sheenRoughnessMap: !!material.sheenRoughnessMap,
			transmission: material.transmission > 0,
			transmissionMap: !!material.transmissionMap,
			thicknessMap: !!material.thicknessMap,
			combine: material.combine,
			vertexTangents: !!material.normalMap && !!geometry.attributes.tangent,
			vertexColors: material.vertexColors,
			vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
			vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.iridescenceMap || !!material.iridescenceThicknessMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || !!material.sheenRoughnessMap,
			uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.iridescenceMap || !!material.iridescenceThicknessMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
			fog: !!fog,
			useFog: material.fog === true,
			fogExp2: fog && fog.isFogExp2,
			flatShading: !!material.flatShading,
			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: logarithmicDepthBuffer,
			skinning: object.isSkinnedMesh === true,
			morphTargets: geometry.morphAttributes.position !== undefined,
			morphNormals: geometry.morphAttributes.normal !== undefined,
			morphColors: geometry.morphAttributes.color !== undefined,
			morphTargetsCount: morphTargetsCount,
			morphTextureStride: morphTextureStride,
			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numSpotLightMaps: lights.spotLightMap.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,
			numDirLightShadows: lights.directionalShadowMap.length,
			numPointLightShadows: lights.pointShadowMap.length,
			numSpotLightShadows: lights.spotShadowMap.length,
			numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
			numClippingPlanes: clipping.numPlanes,
			numClipIntersection: clipping.numIntersection,
			dithering: material.dithering,
			shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,
			toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
			physicallyCorrectLights: renderer.physicallyCorrectLights,
			premultipliedAlpha: material.premultipliedAlpha,
			doubleSided: material.side === DoubleSide,
			flipSided: material.side === BackSide,
			useDepthPacking: !!material.depthPacking,
			depthPacking: material.depthPacking || 0,
			index0AttributeName: material.index0AttributeName,
			extensionDerivatives: material.extensions && material.extensions.derivatives,
			extensionFragDepth: material.extensions && material.extensions.fragDepth,
			extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
			extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
			rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
			rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
			rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),
			customProgramCacheKey: material.customProgramCacheKey()
		};
		return parameters;
	}
	function getProgramCacheKey(parameters) {
		const array = [];
		if (parameters.shaderID) {
			array.push(parameters.shaderID);
		} else {
			array.push(parameters.customVertexShaderID);
			array.push(parameters.customFragmentShaderID);
		}
		if (parameters.defines !== undefined) {
			for (const name in parameters.defines) {
				array.push(name);
				array.push(parameters.defines[name]);
			}
		}
		if (parameters.isRawShaderMaterial === false) {
			getProgramCacheKeyParameters(array, parameters);
			getProgramCacheKeyBooleans(array, parameters);
			array.push(renderer.outputEncoding);
		}
		array.push(parameters.customProgramCacheKey);
		return array.join();
	}
	function getProgramCacheKeyParameters(array, parameters) {
		array.push(parameters.precision);
		array.push(parameters.outputEncoding);
		array.push(parameters.envMapMode);
		array.push(parameters.envMapCubeUVHeight);
		array.push(parameters.combine);
		array.push(parameters.vertexUvs);
		array.push(parameters.fogExp2);
		array.push(parameters.sizeAttenuation);
		array.push(parameters.morphTargetsCount);
		array.push(parameters.morphAttributeCount);
		array.push(parameters.numDirLights);
		array.push(parameters.numPointLights);
		array.push(parameters.numSpotLights);
		array.push(parameters.numSpotLightMaps);
		array.push(parameters.numHemiLights);
		array.push(parameters.numRectAreaLights);
		array.push(parameters.numDirLightShadows);
		array.push(parameters.numPointLightShadows);
		array.push(parameters.numSpotLightShadows);
		array.push(parameters.numSpotLightShadowsWithMaps);
		array.push(parameters.shadowMapType);
		array.push(parameters.toneMapping);
		array.push(parameters.numClippingPlanes);
		array.push(parameters.numClipIntersection);
		array.push(parameters.depthPacking);
	}
	function getProgramCacheKeyBooleans(array, parameters) {
		_programLayers.disableAll();
		if (parameters.isWebGL2) _programLayers.enable(0);
		if (parameters.supportsVertexTextures) _programLayers.enable(1);
		if (parameters.instancing) _programLayers.enable(2);
		if (parameters.instancingColor) _programLayers.enable(3);
		if (parameters.map) _programLayers.enable(4);
		if (parameters.matcap) _programLayers.enable(5);
		if (parameters.envMap) _programLayers.enable(6);
		if (parameters.lightMap) _programLayers.enable(7);
		if (parameters.aoMap) _programLayers.enable(8);
		if (parameters.emissiveMap) _programLayers.enable(9);
		if (parameters.bumpMap) _programLayers.enable(10);
		if (parameters.normalMap) _programLayers.enable(11);
		if (parameters.objectSpaceNormalMap) _programLayers.enable(12);
		if (parameters.tangentSpaceNormalMap) _programLayers.enable(13);
		if (parameters.clearcoat) _programLayers.enable(14);
		if (parameters.clearcoatMap) _programLayers.enable(15);
		if (parameters.clearcoatRoughnessMap) _programLayers.enable(16);
		if (parameters.clearcoatNormalMap) _programLayers.enable(17);
		if (parameters.iridescence) _programLayers.enable(18);
		if (parameters.iridescenceMap) _programLayers.enable(19);
		if (parameters.iridescenceThicknessMap) _programLayers.enable(20);
		if (parameters.displacementMap) _programLayers.enable(21);
		if (parameters.specularMap) _programLayers.enable(22);
		if (parameters.roughnessMap) _programLayers.enable(23);
		if (parameters.metalnessMap) _programLayers.enable(24);
		if (parameters.gradientMap) _programLayers.enable(25);
		if (parameters.alphaMap) _programLayers.enable(26);
		if (parameters.alphaTest) _programLayers.enable(27);
		if (parameters.vertexColors) _programLayers.enable(28);
		if (parameters.vertexAlphas) _programLayers.enable(29);
		if (parameters.vertexUvs) _programLayers.enable(30);
		if (parameters.vertexTangents) _programLayers.enable(31);
		if (parameters.uvsVertexOnly) _programLayers.enable(32);
		array.push(_programLayers.mask);
		_programLayers.disableAll();
		if (parameters.fog) _programLayers.enable(0);
		if (parameters.useFog) _programLayers.enable(1);
		if (parameters.flatShading) _programLayers.enable(2);
		if (parameters.logarithmicDepthBuffer) _programLayers.enable(3);
		if (parameters.skinning) _programLayers.enable(4);
		if (parameters.morphTargets) _programLayers.enable(5);
		if (parameters.morphNormals) _programLayers.enable(6);
		if (parameters.morphColors) _programLayers.enable(7);
		if (parameters.premultipliedAlpha) _programLayers.enable(8);
		if (parameters.shadowMapEnabled) _programLayers.enable(9);
		if (parameters.physicallyCorrectLights) _programLayers.enable(10);
		if (parameters.doubleSided) _programLayers.enable(11);
		if (parameters.flipSided) _programLayers.enable(12);
		if (parameters.useDepthPacking) _programLayers.enable(13);
		if (parameters.dithering) _programLayers.enable(14);
		if (parameters.specularIntensityMap) _programLayers.enable(15);
		if (parameters.specularColorMap) _programLayers.enable(16);
		if (parameters.transmission) _programLayers.enable(17);
		if (parameters.transmissionMap) _programLayers.enable(18);
		if (parameters.thicknessMap) _programLayers.enable(19);
		if (parameters.sheen) _programLayers.enable(20);
		if (parameters.sheenColorMap) _programLayers.enable(21);
		if (parameters.sheenRoughnessMap) _programLayers.enable(22);
		if (parameters.decodeVideoTexture) _programLayers.enable(23);
		if (parameters.opaque) _programLayers.enable(24);
		array.push(_programLayers.mask);
	}
	function getUniforms(material) {
		const shaderID = shaderIDs[material.type];
		let uniforms;
		if (shaderID) {
			const shader = ShaderLib[shaderID];
			uniforms = UniformsUtils.clone(shader.uniforms);
		} else {
			uniforms = material.uniforms;
		}
		return uniforms;
	}
	function acquireProgram(parameters, cacheKey) {
		let program;

		// Check if code has been already compiled
		for (let p = 0, pl = programs.length; p < pl; p++) {
			const preexistingProgram = programs[p];
			if (preexistingProgram.cacheKey === cacheKey) {
				program = preexistingProgram;
				++program.usedTimes;
				break;
			}
		}
		if (program === undefined) {
			program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
			programs.push(program);
		}
		return program;
	}
	function releaseProgram(program) {
		if (--program.usedTimes === 0) {
			// Remove from unordered set
			const i = programs.indexOf(program);
			programs[i] = programs[programs.length - 1];
			programs.pop();

			// Free WebGL resources
			program.destroy();
		}
	}
	function releaseShaderCache(material) {
		_customShaders.remove(material);
	}
	function dispose() {
		_customShaders.dispose();
	}
	return {
		getParameters: getParameters,
		getProgramCacheKey: getProgramCacheKey,
		getUniforms: getUniforms,
		acquireProgram: acquireProgram,
		releaseProgram: releaseProgram,
		releaseShaderCache: releaseShaderCache,
		// Exposed for resource monitoring & error feedback via renderer.info:
		programs: programs,
		dispose: dispose
	};
}

function WebGLProperties() {
	let properties = new WeakMap();
	function get(object) {
		let map = properties.get(object);
		if (map === undefined) {
			map = {};
			properties.set(object, map);
		}
		return map;
	}
	function remove(object) {
		properties.delete(object);
	}
	function update(object, key, value) {
		properties.get(object)[key] = value;
	}
	function dispose() {
		properties = new WeakMap();
	}
	return {
		get: get,
		remove: remove,
		update: update,
		dispose: dispose
	};
}

function painterSortStable(a, b) {
	if (a.groupOrder !== b.groupOrder) {
		return a.groupOrder - b.groupOrder;
	} else if (a.renderOrder !== b.renderOrder) {
		return a.renderOrder - b.renderOrder;
	} else if (a.material.id !== b.material.id) {
		return a.material.id - b.material.id;
	} else if (a.z !== b.z) {
		return a.z - b.z;
	} else {
		return a.id - b.id;
	}
}
function reversePainterSortStable(a, b) {
	if (a.groupOrder !== b.groupOrder) {
		return a.groupOrder - b.groupOrder;
	} else if (a.renderOrder !== b.renderOrder) {
		return a.renderOrder - b.renderOrder;
	} else if (a.z !== b.z) {
		return b.z - a.z;
	} else {
		return a.id - b.id;
	}
}
function WebGLRenderList() {
	const renderItems = [];
	let renderItemsIndex = 0;
	const opaque = [];
	const transmissive = [];
	const transparent = [];
	function init() {
		renderItemsIndex = 0;
		opaque.length = 0;
		transmissive.length = 0;
		transparent.length = 0;
	}
	function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
		let renderItem = renderItems[renderItemsIndex];
		if (renderItem === undefined) {
			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				groupOrder: groupOrder,
				renderOrder: object.renderOrder,
				z: z,
				group: group
			};
			renderItems[renderItemsIndex] = renderItem;
		} else {
			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;
		}
		renderItemsIndex++;
		return renderItem;
	}
	function push(object, geometry, material, groupOrder, z, group) {
		const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
		if (material.transmission > 0.0) {
			transmissive.push(renderItem);
		} else if (material.transparent === true) {
			transparent.push(renderItem);
		} else {
			opaque.push(renderItem);
		}
	}
	function unshift(object, geometry, material, groupOrder, z, group) {
		const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
		if (material.transmission > 0.0) {
			transmissive.unshift(renderItem);
		} else if (material.transparent === true) {
			transparent.unshift(renderItem);
		} else {
			opaque.unshift(renderItem);
		}
	}
	function sort(customOpaqueSort, customTransparentSort) {
		if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
		if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
		if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
	}
	function finish() {
		// Clear references from inactive renderItems in the list

		for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
			const renderItem = renderItems[i];
			if (renderItem.id === null) break;
			renderItem.id = null;
			renderItem.object = null;
			renderItem.geometry = null;
			renderItem.material = null;
			renderItem.group = null;
		}
	}
	return {
		opaque: opaque,
		transmissive: transmissive,
		transparent: transparent,
		init: init,
		push: push,
		unshift: unshift,
		finish: finish,
		sort: sort
	};
}
function WebGLRenderLists() {
	let lists = new WeakMap();
	function get(scene, renderCallDepth) {
		const listArray = lists.get(scene);
		let list;
		if (listArray === undefined) {
			list = new WebGLRenderList();
			lists.set(scene, [list]);
		} else {
			if (renderCallDepth >= listArray.length) {
				list = new WebGLRenderList();
				listArray.push(list);
			} else {
				list = listArray[renderCallDepth];
			}
		}
		return list;
	}
	function dispose() {
		lists = new WeakMap();
	}
	return {
		get: get,
		dispose: dispose
	};
}

function UniformsCache() {
	const lights = {};
	return {
		get: function (light) {
			if (lights[light.id] !== undefined) {
				return lights[light.id];
			}
			let uniforms;
			switch (light.type) {
				case 'DirectionalLight':
					uniforms = {
						direction: new Vector3(),
						color: new Color$1()
					};
					break;
				case 'SpotLight':
					uniforms = {
						position: new Vector3(),
						direction: new Vector3(),
						color: new Color$1(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0
					};
					break;
				case 'PointLight':
					uniforms = {
						position: new Vector3(),
						color: new Color$1(),
						distance: 0,
						decay: 0
					};
					break;
				case 'HemisphereLight':
					uniforms = {
						direction: new Vector3(),
						skyColor: new Color$1(),
						groundColor: new Color$1()
					};
					break;
				case 'RectAreaLight':
					uniforms = {
						color: new Color$1(),
						position: new Vector3(),
						halfWidth: new Vector3(),
						halfHeight: new Vector3()
					};
					break;
			}
			lights[light.id] = uniforms;
			return uniforms;
		}
	};
}
function ShadowUniformsCache() {
	const lights = {};
	return {
		get: function (light) {
			if (lights[light.id] !== undefined) {
				return lights[light.id];
			}
			let uniforms;
			switch (light.type) {
				case 'DirectionalLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;
				case 'SpotLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;
				case 'PointLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2(),
						shadowCameraNear: 1,
						shadowCameraFar: 1000
					};
					break;

				// TODO (abelnation): set RectAreaLight shadow uniforms
			}

			lights[light.id] = uniforms;
			return uniforms;
		}
	};
}
let nextVersion = 0;
function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
	return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
}
function WebGLLights(extensions, capabilities) {
	const cache = new UniformsCache();
	const shadowCache = ShadowUniformsCache();
	const state = {
		version: 0,
		hash: {
			directionalLength: -1,
			pointLength: -1,
			spotLength: -1,
			rectAreaLength: -1,
			hemiLength: -1,
			numDirectionalShadows: -1,
			numPointShadows: -1,
			numSpotShadows: -1,
			numSpotMaps: -1
		},
		ambient: [0, 0, 0],
		probe: [],
		directional: [],
		directionalShadow: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotLightMap: [],
		spotShadow: [],
		spotShadowMap: [],
		spotLightMatrix: [],
		rectArea: [],
		rectAreaLTC1: null,
		rectAreaLTC2: null,
		point: [],
		pointShadow: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: [],
		numSpotLightShadowsWithMaps: 0
	};
	for (let i = 0; i < 9; i++) state.probe.push(new Vector3());
	const vector3 = new Vector3();
	const matrix4 = new Matrix4();
	const matrix42 = new Matrix4();
	function setup(lights, physicallyCorrectLights) {
		let r = 0,
			g = 0,
			b = 0;
		for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);
		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;
		let numDirectionalShadows = 0;
		let numPointShadows = 0;
		let numSpotShadows = 0;
		let numSpotMaps = 0;
		let numSpotShadowsWithMaps = 0;

		// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]
		lights.sort(shadowCastingAndTexturingLightsFirst);

		// artist-friendly light intensity scaling factor
		const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
		for (let i = 0, l = lights.length; i < l; i++) {
			const light = lights[i];
			const color = light.color;
			const intensity = light.intensity;
			const distance = light.distance;
			const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
			if (light.isAmbientLight) {
				r += color.r * intensity * scaleFactor;
				g += color.g * intensity * scaleFactor;
				b += color.b * intensity * scaleFactor;
			} else if (light.isLightProbe) {
				for (let j = 0; j < 9; j++) {
					state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
				}
			} else if (light.isDirectionalLight) {
				const uniforms = cache.get(light);
				uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
				if (light.castShadow) {
					const shadow = light.shadow;
					const shadowUniforms = shadowCache.get(light);
					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;
					state.directionalShadow[directionalLength] = shadowUniforms;
					state.directionalShadowMap[directionalLength] = shadowMap;
					state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
					numDirectionalShadows++;
				}
				state.directional[directionalLength] = uniforms;
				directionalLength++;
			} else if (light.isSpotLight) {
				const uniforms = cache.get(light);
				uniforms.position.setFromMatrixPosition(light.matrixWorld);
				uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
				uniforms.distance = distance;
				uniforms.coneCos = Math.cos(light.angle);
				uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
				uniforms.decay = light.decay;
				state.spot[spotLength] = uniforms;
				const shadow = light.shadow;
				if (light.map) {
					state.spotLightMap[numSpotMaps] = light.map;
					numSpotMaps++;

					// make sure the lightMatrix is up to date
					// TODO : do it if required only
					shadow.updateMatrices(light);
					if (light.castShadow) numSpotShadowsWithMaps++;
				}
				state.spotLightMatrix[spotLength] = shadow.matrix;
				if (light.castShadow) {
					const shadowUniforms = shadowCache.get(light);
					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;
					state.spotShadow[spotLength] = shadowUniforms;
					state.spotShadowMap[spotLength] = shadowMap;
					numSpotShadows++;
				}
				spotLength++;
			} else if (light.isRectAreaLight) {
				const uniforms = cache.get(light);

				// (a) intensity is the total visible light emitted
				//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

				// (b) intensity is the brightness of the light
				uniforms.color.copy(color).multiplyScalar(intensity);
				uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
				uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
				state.rectArea[rectAreaLength] = uniforms;
				rectAreaLength++;
			} else if (light.isPointLight) {
				const uniforms = cache.get(light);
				uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
				uniforms.distance = light.distance;
				uniforms.decay = light.decay;
				if (light.castShadow) {
					const shadow = light.shadow;
					const shadowUniforms = shadowCache.get(light);
					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;
					shadowUniforms.shadowCameraNear = shadow.camera.near;
					shadowUniforms.shadowCameraFar = shadow.camera.far;
					state.pointShadow[pointLength] = shadowUniforms;
					state.pointShadowMap[pointLength] = shadowMap;
					state.pointShadowMatrix[pointLength] = light.shadow.matrix;
					numPointShadows++;
				}
				state.point[pointLength] = uniforms;
				pointLength++;
			} else if (light.isHemisphereLight) {
				const uniforms = cache.get(light);
				uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
				uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
				state.hemi[hemiLength] = uniforms;
				hemiLength++;
			}
		}
		if (rectAreaLength > 0) {
			if (capabilities.isWebGL2) {
				// WebGL 2

				state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
				state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
			} else {
				// WebGL 1

				if (extensions.has('OES_texture_float_linear') === true) {
					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
				} else if (extensions.has('OES_texture_half_float_linear') === true) {
					state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
					state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
				} else {
					console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');
				}
			}
		}
		state.ambient[0] = r;
		state.ambient[1] = g;
		state.ambient[2] = b;
		const hash = state.hash;
		if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps) {
			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;
			state.directionalShadow.length = numDirectionalShadows;
			state.directionalShadowMap.length = numDirectionalShadows;
			state.pointShadow.length = numPointShadows;
			state.pointShadowMap.length = numPointShadows;
			state.spotShadow.length = numSpotShadows;
			state.spotShadowMap.length = numSpotShadows;
			state.directionalShadowMatrix.length = numDirectionalShadows;
			state.pointShadowMatrix.length = numPointShadows;
			state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
			state.spotLightMap.length = numSpotMaps;
			state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
			hash.directionalLength = directionalLength;
			hash.pointLength = pointLength;
			hash.spotLength = spotLength;
			hash.rectAreaLength = rectAreaLength;
			hash.hemiLength = hemiLength;
			hash.numDirectionalShadows = numDirectionalShadows;
			hash.numPointShadows = numPointShadows;
			hash.numSpotShadows = numSpotShadows;
			hash.numSpotMaps = numSpotMaps;
			state.version = nextVersion++;
		}
	}
	function setupView(lights, camera) {
		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;
		const viewMatrix = camera.matrixWorldInverse;
		for (let i = 0, l = lights.length; i < l; i++) {
			const light = lights[i];
			if (light.isDirectionalLight) {
				const uniforms = state.directional[directionalLength];
				uniforms.direction.setFromMatrixPosition(light.matrixWorld);
				vector3.setFromMatrixPosition(light.target.matrixWorld);
				uniforms.direction.sub(vector3);
				uniforms.direction.transformDirection(viewMatrix);
				directionalLength++;
			} else if (light.isSpotLight) {
				const uniforms = state.spot[spotLength];
				uniforms.position.setFromMatrixPosition(light.matrixWorld);
				uniforms.position.applyMatrix4(viewMatrix);
				uniforms.direction.setFromMatrixPosition(light.matrixWorld);
				vector3.setFromMatrixPosition(light.target.matrixWorld);
				uniforms.direction.sub(vector3);
				uniforms.direction.transformDirection(viewMatrix);
				spotLength++;
			} else if (light.isRectAreaLight) {
				const uniforms = state.rectArea[rectAreaLength];
				uniforms.position.setFromMatrixPosition(light.matrixWorld);
				uniforms.position.applyMatrix4(viewMatrix);

				// extract local rotation of light to derive width/height half vectors
				matrix42.identity();
				matrix4.copy(light.matrixWorld);
				matrix4.premultiply(viewMatrix);
				matrix42.extractRotation(matrix4);
				uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
				uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
				uniforms.halfWidth.applyMatrix4(matrix42);
				uniforms.halfHeight.applyMatrix4(matrix42);
				rectAreaLength++;
			} else if (light.isPointLight) {
				const uniforms = state.point[pointLength];
				uniforms.position.setFromMatrixPosition(light.matrixWorld);
				uniforms.position.applyMatrix4(viewMatrix);
				pointLength++;
			} else if (light.isHemisphereLight) {
				const uniforms = state.hemi[hemiLength];
				uniforms.direction.setFromMatrixPosition(light.matrixWorld);
				uniforms.direction.transformDirection(viewMatrix);
				hemiLength++;
			}
		}
	}
	return {
		setup: setup,
		setupView: setupView,
		state: state
	};
}

function WebGLRenderState(extensions, capabilities) {
	const lights = new WebGLLights(extensions, capabilities);
	const lightsArray = [];
	const shadowsArray = [];
	function init() {
		lightsArray.length = 0;
		shadowsArray.length = 0;
	}
	function pushLight(light) {
		lightsArray.push(light);
	}
	function pushShadow(shadowLight) {
		shadowsArray.push(shadowLight);
	}
	function setupLights(physicallyCorrectLights) {
		lights.setup(lightsArray, physicallyCorrectLights);
	}
	function setupLightsView(camera) {
		lights.setupView(lightsArray, camera);
	}
	const state = {
		lightsArray: lightsArray,
		shadowsArray: shadowsArray,
		lights: lights
	};
	return {
		init: init,
		state: state,
		setupLights: setupLights,
		setupLightsView: setupLightsView,
		pushLight: pushLight,
		pushShadow: pushShadow
	};
}
function WebGLRenderStates(extensions, capabilities) {
	let renderStates = new WeakMap();
	function get(scene, renderCallDepth = 0) {
		const renderStateArray = renderStates.get(scene);
		let renderState;
		if (renderStateArray === undefined) {
			renderState = new WebGLRenderState(extensions, capabilities);
			renderStates.set(scene, [renderState]);
		} else {
			if (renderCallDepth >= renderStateArray.length) {
				renderState = new WebGLRenderState(extensions, capabilities);
				renderStateArray.push(renderState);
			} else {
				renderState = renderStateArray[renderCallDepth];
			}
		}
		return renderState;
	}
	function dispose() {
		renderStates = new WeakMap();
	}
	return {
		get: get,
		dispose: dispose
	};
}

class MeshDepthMaterial extends Material {
	constructor(parameters) {
		super();
		this.isMeshDepthMaterial = true;
		this.type = 'MeshDepthMaterial';
		this.depthPacking = BasicDepthPacking;
		this.map = null;
		this.alphaMap = null;
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.depthPacking = source.depthPacking;
		this.map = source.map;
		this.alphaMap = source.alphaMap;
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		return this;
	}
}

class MeshDistanceMaterial extends Material {
	constructor(parameters) {
		super();
		this.isMeshDistanceMaterial = true;
		this.type = 'MeshDistanceMaterial';
		this.referencePosition = new Vector3();
		this.nearDistance = 1;
		this.farDistance = 1000;
		this.map = null;
		this.alphaMap = null;
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.referencePosition.copy(source.referencePosition);
		this.nearDistance = source.nearDistance;
		this.farDistance = source.farDistance;
		this.map = source.map;
		this.alphaMap = source.alphaMap;
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		return this;
	}
}

const vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

function WebGLShadowMap(_renderer, _objects, _capabilities) {
	let _frustum = new Frustum();
	const _shadowMapSize = new Vector2(),
		_viewportSize = new Vector2(),
		_viewport = new Vector4(),
		_depthMaterial = new MeshDepthMaterial({
			depthPacking: RGBADepthPacking
		}),
		_distanceMaterial = new MeshDistanceMaterial(),
		_materialCache = {},
		_maxTextureSize = _capabilities.maxTextureSize;
	const shadowSide = {
		0: BackSide,
		1: FrontSide,
		2: DoubleSide
	};
	const shadowMaterialVertical = new ShaderMaterial({
		defines: {
			VSM_SAMPLES: 8
		},
		uniforms: {
			shadow_pass: {
				value: null
			},
			resolution: {
				value: new Vector2()
			},
			radius: {
				value: 4.0
			}
		},
		vertexShader: vertex,
		fragmentShader: fragment
	});
	const shadowMaterialHorizontal = shadowMaterialVertical.clone();
	shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
	const fullScreenTri = new BufferGeometry();
	fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
	const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
	const scope = this;
	this.enabled = false;
	this.autoUpdate = true;
	this.needsUpdate = false;
	this.type = PCFShadowMap;
	this.render = function (lights, scene, camera) {
		if (scope.enabled === false) return;
		if (scope.autoUpdate === false && scope.needsUpdate === false) return;
		if (lights.length === 0) return;
		const currentRenderTarget = _renderer.getRenderTarget();
		const activeCubeFace = _renderer.getActiveCubeFace();
		const activeMipmapLevel = _renderer.getActiveMipmapLevel();
		const _state = _renderer.state;

		// Set GL state for depth map.
		_state.setBlending(NoBlending);
		_state.buffers.color.setClear(1, 1, 1, 1);
		_state.buffers.depth.setTest(true);
		_state.setScissorTest(false);

		// render depth map

		for (let i = 0, il = lights.length; i < il; i++) {
			const light = lights[i];
			const shadow = light.shadow;
			if (shadow === undefined) {
				console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
				continue;
			}
			if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
			_shadowMapSize.copy(shadow.mapSize);
			const shadowFrameExtents = shadow.getFrameExtents();
			_shadowMapSize.multiply(shadowFrameExtents);
			_viewportSize.copy(shadow.mapSize);
			if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
				if (_shadowMapSize.x > _maxTextureSize) {
					_viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
					_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
					shadow.mapSize.x = _viewportSize.x;
				}
				if (_shadowMapSize.y > _maxTextureSize) {
					_viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
					_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
					shadow.mapSize.y = _viewportSize.y;
				}
			}
			if (shadow.map === null) {
				const pars = this.type !== VSMShadowMap ? {
					minFilter: NearestFilter,
					magFilter: NearestFilter
				} : {};
				shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
				shadow.map.texture.name = light.name + '.shadowMap';
				shadow.camera.updateProjectionMatrix();
			}
			_renderer.setRenderTarget(shadow.map);
			_renderer.clear();
			const viewportCount = shadow.getViewportCount();
			for (let vp = 0; vp < viewportCount; vp++) {
				const viewport = shadow.getViewport(vp);
				_viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
				_state.viewport(_viewport);
				shadow.updateMatrices(light, vp);
				_frustum = shadow.getFrustum();
				renderObject(scene, camera, shadow.camera, light, this.type);
			}

			// do blur pass for VSM

			if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
				VSMPass(shadow, camera);
			}
			shadow.needsUpdate = false;
		}
		scope.needsUpdate = false;
		_renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
	};
	function VSMPass(shadow, camera) {
		const geometry = _objects.update(fullScreenMesh);
		if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
			shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
			shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
			shadowMaterialVertical.needsUpdate = true;
			shadowMaterialHorizontal.needsUpdate = true;
		}
		if (shadow.mapPass === null) {
			shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
		}

		// vertical pass

		shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
		shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialVertical.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget(shadow.mapPass);
		_renderer.clear();
		_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);

		// horizontal pass

		shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
		shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget(shadow.map);
		_renderer.clear();
		_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
	}
	function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type) {
		let result = null;
		const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
		if (customMaterial !== undefined) {
			result = customMaterial;
		} else {
			result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
		}
		if (_renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
			// in this case we need a unique material instance reflecting the
			// appropriate state

			const keyA = result.uuid,
				keyB = material.uuid;
			let materialsForVariant = _materialCache[keyA];
			if (materialsForVariant === undefined) {
				materialsForVariant = {};
				_materialCache[keyA] = materialsForVariant;
			}
			let cachedMaterial = materialsForVariant[keyB];
			if (cachedMaterial === undefined) {
				cachedMaterial = result.clone();
				materialsForVariant[keyB] = cachedMaterial;
			}
			result = cachedMaterial;
		}
		result.visible = material.visible;
		result.wireframe = material.wireframe;
		if (type === VSMShadowMap) {
			result.side = material.shadowSide !== null ? material.shadowSide : material.side;
		} else {
			result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
		}
		result.alphaMap = material.alphaMap;
		result.alphaTest = material.alphaTest;
		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;
		result.clipIntersection = material.clipIntersection;
		result.displacementMap = material.displacementMap;
		result.displacementScale = material.displacementScale;
		result.displacementBias = material.displacementBias;
		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;
		if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
			result.referencePosition.setFromMatrixPosition(light.matrixWorld);
			result.nearDistance = shadowCameraNear;
			result.farDistance = shadowCameraFar;
		}
		return result;
	}
	function renderObject(object, camera, shadowCamera, light, type) {
		if (object.visible === false) return;
		const visible = object.layers.test(camera.layers);
		if (visible && (object.isMesh || object.isLine || object.isPoints)) {
			if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
				object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
				const geometry = _objects.update(object);
				const material = object.material;
				if (Array.isArray(material)) {
					const groups = geometry.groups;
					for (let k = 0, kl = groups.length; k < kl; k++) {
						const group = groups[k];
						const groupMaterial = material[group.materialIndex];
						if (groupMaterial && groupMaterial.visible) {
							const depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
							_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
						}
					}
				} else if (material.visible) {
					const depthMaterial = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);
					_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
				}
			}
		}
		const children = object.children;
		for (let i = 0, l = children.length; i < l; i++) {
			renderObject(children[i], camera, shadowCamera, light, type);
		}
	}
}

function WebGLState(gl, extensions, capabilities) {
	const isWebGL2 = capabilities.isWebGL2;
	function ColorBuffer() {
		let locked = false;
		const color = new Vector4();
		let currentColorMask = null;
		const currentColorClear = new Vector4(0, 0, 0, 0);
		return {
			setMask: function (colorMask) {
				if (currentColorMask !== colorMask && !locked) {
					gl.colorMask(colorMask, colorMask, colorMask, colorMask);
					currentColorMask = colorMask;
				}
			},
			setLocked: function (lock) {
				locked = lock;
			},
			setClear: function (r, g, b, a, premultipliedAlpha) {
				if (premultipliedAlpha === true) {
					r *= a;
					g *= a;
					b *= a;
				}
				color.set(r, g, b, a);
				if (currentColorClear.equals(color) === false) {
					gl.clearColor(r, g, b, a);
					currentColorClear.copy(color);
				}
			},
			reset: function () {
				locked = false;
				currentColorMask = null;
				currentColorClear.set(-1, 0, 0, 0); // set to invalid state
			}
		};
	}

	function DepthBuffer() {
		let locked = false;
		let currentDepthMask = null;
		let currentDepthFunc = null;
		let currentDepthClear = null;
		return {
			setTest: function (depthTest) {
				if (depthTest) {
					enable(gl.DEPTH_TEST);
				} else {
					disable(gl.DEPTH_TEST);
				}
			},
			setMask: function (depthMask) {
				if (currentDepthMask !== depthMask && !locked) {
					gl.depthMask(depthMask);
					currentDepthMask = depthMask;
				}
			},
			setFunc: function (depthFunc) {
				if (currentDepthFunc !== depthFunc) {
					switch (depthFunc) {
						case NeverDepth:
							gl.depthFunc(gl.NEVER);
							break;
						case AlwaysDepth:
							gl.depthFunc(gl.ALWAYS);
							break;
						case LessDepth:
							gl.depthFunc(gl.LESS);
							break;
						case LessEqualDepth:
							gl.depthFunc(gl.LEQUAL);
							break;
						case EqualDepth:
							gl.depthFunc(gl.EQUAL);
							break;
						case GreaterEqualDepth:
							gl.depthFunc(gl.GEQUAL);
							break;
						case GreaterDepth:
							gl.depthFunc(gl.GREATER);
							break;
						case NotEqualDepth:
							gl.depthFunc(gl.NOTEQUAL);
							break;
						default:
							gl.depthFunc(gl.LEQUAL);
					}
					currentDepthFunc = depthFunc;
				}
			},
			setLocked: function (lock) {
				locked = lock;
			},
			setClear: function (depth) {
				if (currentDepthClear !== depth) {
					gl.clearDepth(depth);
					currentDepthClear = depth;
				}
			},
			reset: function () {
				locked = false;
				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;
			}
		};
	}
	function StencilBuffer() {
		let locked = false;
		let currentStencilMask = null;
		let currentStencilFunc = null;
		let currentStencilRef = null;
		let currentStencilFuncMask = null;
		let currentStencilFail = null;
		let currentStencilZFail = null;
		let currentStencilZPass = null;
		let currentStencilClear = null;
		return {
			setTest: function (stencilTest) {
				if (!locked) {
					if (stencilTest) {
						enable(gl.STENCIL_TEST);
					} else {
						disable(gl.STENCIL_TEST);
					}
				}
			},
			setMask: function (stencilMask) {
				if (currentStencilMask !== stencilMask && !locked) {
					gl.stencilMask(stencilMask);
					currentStencilMask = stencilMask;
				}
			},
			setFunc: function (stencilFunc, stencilRef, stencilMask) {
				if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
					gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;
				}
			},
			setOp: function (stencilFail, stencilZFail, stencilZPass) {
				if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
					gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;
				}
			},
			setLocked: function (lock) {
				locked = lock;
			},
			setClear: function (stencil) {
				if (currentStencilClear !== stencil) {
					gl.clearStencil(stencil);
					currentStencilClear = stencil;
				}
			},
			reset: function () {
				locked = false;
				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;
			}
		};
	}

	//

	const colorBuffer = new ColorBuffer();
	const depthBuffer = new DepthBuffer();
	const stencilBuffer = new StencilBuffer();
	const uboBindings = new WeakMap();
	const uboProgamMap = new WeakMap();
	let enabledCapabilities = {};
	let currentBoundFramebuffers = {};
	let currentDrawbuffers = new WeakMap();
	let defaultDrawbuffers = [];
	let currentProgram = null;
	let currentBlendingEnabled = false;
	let currentBlending = null;
	let currentBlendEquation = null;
	let currentBlendSrc = null;
	let currentBlendDst = null;
	let currentBlendEquationAlpha = null;
	let currentBlendSrcAlpha = null;
	let currentBlendDstAlpha = null;
	let currentPremultipledAlpha = false;
	let currentFlipSided = null;
	let currentCullFace = null;
	let currentLineWidth = null;
	let currentPolygonOffsetFactor = null;
	let currentPolygonOffsetUnits = null;
	const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
	let lineWidthAvailable = false;
	let version = 0;
	const glVersion = gl.getParameter(gl.VERSION);
	if (glVersion.indexOf('WebGL') !== -1) {
		version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
		lineWidthAvailable = version >= 1.0;
	} else if (glVersion.indexOf('OpenGL ES') !== -1) {
		version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
		lineWidthAvailable = version >= 2.0;
	}
	let currentTextureSlot = null;
	let currentBoundTextures = {};
	const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
	const viewportParam = gl.getParameter(gl.VIEWPORT);
	const currentScissor = new Vector4().fromArray(scissorParam);
	const currentViewport = new Vector4().fromArray(viewportParam);
	function createTexture(type, target, count) {
		const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
		const texture = gl.createTexture();
		gl.bindTexture(type, texture);
		gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		for (let i = 0; i < count; i++) {
			gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
		}
		return texture;
	}
	const emptyTextures = {};
	emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
	emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);

	// init

	colorBuffer.setClear(0, 0, 0, 1);
	depthBuffer.setClear(1);
	stencilBuffer.setClear(0);
	enable(gl.DEPTH_TEST);
	depthBuffer.setFunc(LessEqualDepth);
	setFlipSided(false);
	setCullFace(CullFaceBack);
	enable(gl.CULL_FACE);
	setBlending(NoBlending);

	//

	function enable(id) {
		if (enabledCapabilities[id] !== true) {
			gl.enable(id);
			enabledCapabilities[id] = true;
		}
	}
	function disable(id) {
		if (enabledCapabilities[id] !== false) {
			gl.disable(id);
			enabledCapabilities[id] = false;
		}
	}
	function bindFramebuffer(target, framebuffer) {
		if (currentBoundFramebuffers[target] !== framebuffer) {
			gl.bindFramebuffer(target, framebuffer);
			currentBoundFramebuffers[target] = framebuffer;
			if (isWebGL2) {
				// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER

				if (target === gl.DRAW_FRAMEBUFFER) {
					currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
				}
				if (target === gl.FRAMEBUFFER) {
					currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
				}
			}
			return true;
		}
		return false;
	}
	function drawBuffers(renderTarget, framebuffer) {
		let drawBuffers = defaultDrawbuffers;
		let needsUpdate = false;
		if (renderTarget) {
			drawBuffers = currentDrawbuffers.get(framebuffer);
			if (drawBuffers === undefined) {
				drawBuffers = [];
				currentDrawbuffers.set(framebuffer, drawBuffers);
			}
			if (renderTarget.isWebGLMultipleRenderTargets) {
				const textures = renderTarget.texture;
				if (drawBuffers.length !== textures.length || drawBuffers[0] !== gl.COLOR_ATTACHMENT0) {
					for (let i = 0, il = textures.length; i < il; i++) {
						drawBuffers[i] = gl.COLOR_ATTACHMENT0 + i;
					}
					drawBuffers.length = textures.length;
					needsUpdate = true;
				}
			} else {
				if (drawBuffers[0] !== gl.COLOR_ATTACHMENT0) {
					drawBuffers[0] = gl.COLOR_ATTACHMENT0;
					needsUpdate = true;
				}
			}
		} else {
			if (drawBuffers[0] !== gl.BACK) {
				drawBuffers[0] = gl.BACK;
				needsUpdate = true;
			}
		}
		if (needsUpdate) {
			if (capabilities.isWebGL2) {
				gl.drawBuffers(drawBuffers);
			} else {
				extensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(drawBuffers);
			}
		}
	}
	function useProgram(program) {
		if (currentProgram !== program) {
			gl.useProgram(program);
			currentProgram = program;
			return true;
		}
		return false;
	}
	const equationToGL = {
		[AddEquation]: gl.FUNC_ADD,
		[SubtractEquation]: gl.FUNC_SUBTRACT,
		[ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
	};
	if (isWebGL2) {
		equationToGL[MinEquation] = gl.MIN;
		equationToGL[MaxEquation] = gl.MAX;
	} else {
		const extension = extensions.get('EXT_blend_minmax');
		if (extension !== null) {
			equationToGL[MinEquation] = extension.MIN_EXT;
			equationToGL[MaxEquation] = extension.MAX_EXT;
		}
	}
	const factorToGL = {
		[ZeroFactor]: gl.ZERO,
		[OneFactor]: gl.ONE,
		[SrcColorFactor]: gl.SRC_COLOR,
		[SrcAlphaFactor]: gl.SRC_ALPHA,
		[SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
		[DstColorFactor]: gl.DST_COLOR,
		[DstAlphaFactor]: gl.DST_ALPHA,
		[OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
		[OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
		[OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
		[OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
	};
	function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
		if (blending === NoBlending) {
			if (currentBlendingEnabled === true) {
				disable(gl.BLEND);
				currentBlendingEnabled = false;
			}
			return;
		}
		if (currentBlendingEnabled === false) {
			enable(gl.BLEND);
			currentBlendingEnabled = true;
		}
		if (blending !== CustomBlending) {
			if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
				if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
					gl.blendEquation(gl.FUNC_ADD);
					currentBlendEquation = AddEquation;
					currentBlendEquationAlpha = AddEquation;
				}
				if (premultipliedAlpha) {
					switch (blending) {
						case NormalBlending:
							gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
							break;
						case AdditiveBlending:
							gl.blendFunc(gl.ONE, gl.ONE);
							break;
						case SubtractiveBlending:
							gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
							break;
						case MultiplyBlending:
							gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
							break;
						default:
							console.error('THREE.WebGLState: Invalid blending: ', blending);
							break;
					}
				} else {
					switch (blending) {
						case NormalBlending:
							gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
							break;
						case AdditiveBlending:
							gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
							break;
						case SubtractiveBlending:
							gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
							break;
						case MultiplyBlending:
							gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
							break;
						default:
							console.error('THREE.WebGLState: Invalid blending: ', blending);
							break;
					}
				}
				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;
				currentBlending = blending;
				currentPremultipledAlpha = premultipliedAlpha;
			}
			return;
		}

		// custom blending

		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;
		if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
			gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
			currentBlendEquation = blendEquation;
			currentBlendEquationAlpha = blendEquationAlpha;
		}
		if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
			gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
			currentBlendSrc = blendSrc;
			currentBlendDst = blendDst;
			currentBlendSrcAlpha = blendSrcAlpha;
			currentBlendDstAlpha = blendDstAlpha;
		}
		currentBlending = blending;
		currentPremultipledAlpha = null;
	}
	function setMaterial(material, frontFaceCW) {
		material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
		let flipSided = material.side === BackSide;
		if (frontFaceCW) flipSided = !flipSided;
		setFlipSided(flipSided);
		material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
		depthBuffer.setFunc(material.depthFunc);
		depthBuffer.setTest(material.depthTest);
		depthBuffer.setMask(material.depthWrite);
		colorBuffer.setMask(material.colorWrite);
		const stencilWrite = material.stencilWrite;
		stencilBuffer.setTest(stencilWrite);
		if (stencilWrite) {
			stencilBuffer.setMask(material.stencilWriteMask);
			stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
			stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
		}
		setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
		material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
	}

	//

	function setFlipSided(flipSided) {
		if (currentFlipSided !== flipSided) {
			if (flipSided) {
				gl.frontFace(gl.CW);
			} else {
				gl.frontFace(gl.CCW);
			}
			currentFlipSided = flipSided;
		}
	}
	function setCullFace(cullFace) {
		if (cullFace !== CullFaceNone) {
			enable(gl.CULL_FACE);
			if (cullFace !== currentCullFace) {
				if (cullFace === CullFaceBack) {
					gl.cullFace(gl.BACK);
				} else if (cullFace === CullFaceFront) {
					gl.cullFace(gl.FRONT);
				} else {
					gl.cullFace(gl.FRONT_AND_BACK);
				}
			}
		} else {
			disable(gl.CULL_FACE);
		}
		currentCullFace = cullFace;
	}
	function setLineWidth(width) {
		if (width !== currentLineWidth) {
			if (lineWidthAvailable) gl.lineWidth(width);
			currentLineWidth = width;
		}
	}
	function setPolygonOffset(polygonOffset, factor, units) {
		if (polygonOffset) {
			enable(gl.POLYGON_OFFSET_FILL);
			if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
				gl.polygonOffset(factor, units);
				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;
			}
		} else {
			disable(gl.POLYGON_OFFSET_FILL);
		}
	}
	function setScissorTest(scissorTest) {
		if (scissorTest) {
			enable(gl.SCISSOR_TEST);
		} else {
			disable(gl.SCISSOR_TEST);
		}
	}

	// texture

	function activeTexture(webglSlot) {
		if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;
		if (currentTextureSlot !== webglSlot) {
			gl.activeTexture(webglSlot);
			currentTextureSlot = webglSlot;
		}
	}
	function bindTexture(webglType, webglTexture, webglSlot) {
		if (webglSlot === undefined) {
			if (currentTextureSlot === null) {
				webglSlot = gl.TEXTURE0 + maxTextures - 1;
			} else {
				webglSlot = currentTextureSlot;
			}
		}
		let boundTexture = currentBoundTextures[webglSlot];
		if (boundTexture === undefined) {
			boundTexture = {
				type: undefined,
				texture: undefined
			};
			currentBoundTextures[webglSlot] = boundTexture;
		}
		if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
			if (currentTextureSlot !== webglSlot) {
				gl.activeTexture(webglSlot);
				currentTextureSlot = webglSlot;
			}
			gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;
		}
	}
	function unbindTexture() {
		const boundTexture = currentBoundTextures[currentTextureSlot];
		if (boundTexture !== undefined && boundTexture.type !== undefined) {
			gl.bindTexture(boundTexture.type, null);
			boundTexture.type = undefined;
			boundTexture.texture = undefined;
		}
	}
	function compressedTexImage2D() {
		try {
			gl.compressedTexImage2D.apply(gl, arguments);
		} catch (error) {
			console.error('THREE.WebGLState:', error);
		}
	}
	function compressedTexImage3D() {
		try {
			gl.compressedTexImage3D.apply(gl, arguments);
		} catch (error) {
			console.error('THREE.WebGLState:', error);
		}
	}
	function texSubImage2D() {
		try {
			gl.texSubImage2D.apply(gl, arguments);
		} catch (error) {
			console.error('THREE.WebGLState:', error);
		}
	}
	function texSubImage3D() {
		try {
			gl.texSubImage3D.apply(gl, arguments);
		} catch (error) {
			console.error('THREE.WebGLState:', error);
		}
	}
	function compressedTexSubImage2D() {
		try {
			gl.compressedTexSubImage2D.apply(gl, arguments);
		} catch (error) {
			console.error('THREE.WebGLState:', error);
		}
	}
	function compressedTexSubImage3D() {
		try {
			gl.compressedTexSubImage3D.apply(gl, arguments);
		} catch (error) {
			console.error('THREE.WebGLState:', error);
		}
	}
	function texStorage2D() {
		try {
			gl.texStorage2D.apply(gl, arguments);
		} catch (error) {
			console.error('THREE.WebGLState:', error);
		}
	}
	function texStorage3D() {
		try {
			gl.texStorage3D.apply(gl, arguments);
		} catch (error) {
			console.error('THREE.WebGLState:', error);
		}
	}
	function texImage2D() {
		try {
			gl.texImage2D.apply(gl, arguments);
		} catch (error) {
			console.error('THREE.WebGLState:', error);
		}
	}
	function texImage3D() {
		try {
			gl.texImage3D.apply(gl, arguments);
		} catch (error) {
			console.error('THREE.WebGLState:', error);
		}
	}

	//

	function scissor(scissor) {
		if (currentScissor.equals(scissor) === false) {
			gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
			currentScissor.copy(scissor);
		}
	}
	function viewport(viewport) {
		if (currentViewport.equals(viewport) === false) {
			gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
			currentViewport.copy(viewport);
		}
	}
	function updateUBOMapping(uniformsGroup, program) {
		let mapping = uboProgamMap.get(program);
		if (mapping === undefined) {
			mapping = new WeakMap();
			uboProgamMap.set(program, mapping);
		}
		let blockIndex = mapping.get(uniformsGroup);
		if (blockIndex === undefined) {
			blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name);
			mapping.set(uniformsGroup, blockIndex);
		}
	}
	function uniformBlockBinding(uniformsGroup, program) {
		const mapping = uboProgamMap.get(program);
		const blockIndex = mapping.get(uniformsGroup);
		if (uboBindings.get(uniformsGroup) !== blockIndex) {
			// bind shader specific block index to global block point

			gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
			uboBindings.set(uniformsGroup, blockIndex);
		}
	}

	//

	function reset() {
		// reset state

		gl.disable(gl.BLEND);
		gl.disable(gl.CULL_FACE);
		gl.disable(gl.DEPTH_TEST);
		gl.disable(gl.POLYGON_OFFSET_FILL);
		gl.disable(gl.SCISSOR_TEST);
		gl.disable(gl.STENCIL_TEST);
		gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
		gl.blendEquation(gl.FUNC_ADD);
		gl.blendFunc(gl.ONE, gl.ZERO);
		gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
		gl.colorMask(true, true, true, true);
		gl.clearColor(0, 0, 0, 0);
		gl.depthMask(true);
		gl.depthFunc(gl.LESS);
		gl.clearDepth(1);
		gl.stencilMask(0xffffffff);
		gl.stencilFunc(gl.ALWAYS, 0, 0xffffffff);
		gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
		gl.clearStencil(0);
		gl.cullFace(gl.BACK);
		gl.frontFace(gl.CCW);
		gl.polygonOffset(0, 0);
		gl.activeTexture(gl.TEXTURE0);
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		if (isWebGL2 === true) {
			gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
			gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
		}
		gl.useProgram(null);
		gl.lineWidth(1);
		gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
		gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

		// reset internals

		enabledCapabilities = {};
		currentTextureSlot = null;
		currentBoundTextures = {};
		currentBoundFramebuffers = {};
		currentDrawbuffers = new WeakMap();
		defaultDrawbuffers = [];
		currentProgram = null;
		currentBlendingEnabled = false;
		currentBlending = null;
		currentBlendEquation = null;
		currentBlendSrc = null;
		currentBlendDst = null;
		currentBlendEquationAlpha = null;
		currentBlendSrcAlpha = null;
		currentBlendDstAlpha = null;
		currentPremultipledAlpha = false;
		currentFlipSided = null;
		currentCullFace = null;
		currentLineWidth = null;
		currentPolygonOffsetFactor = null;
		currentPolygonOffsetUnits = null;
		currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
		currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();
	}
	return {
		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},
		enable: enable,
		disable: disable,
		bindFramebuffer: bindFramebuffer,
		drawBuffers: drawBuffers,
		useProgram: useProgram,
		setBlending: setBlending,
		setMaterial: setMaterial,
		setFlipSided: setFlipSided,
		setCullFace: setCullFace,
		setLineWidth: setLineWidth,
		setPolygonOffset: setPolygonOffset,
		setScissorTest: setScissorTest,
		activeTexture: activeTexture,
		bindTexture: bindTexture,
		unbindTexture: unbindTexture,
		compressedTexImage2D: compressedTexImage2D,
		compressedTexImage3D: compressedTexImage3D,
		texImage2D: texImage2D,
		texImage3D: texImage3D,
		updateUBOMapping: updateUBOMapping,
		uniformBlockBinding: uniformBlockBinding,
		texStorage2D: texStorage2D,
		texStorage3D: texStorage3D,
		texSubImage2D: texSubImage2D,
		texSubImage3D: texSubImage3D,
		compressedTexSubImage2D: compressedTexSubImage2D,
		compressedTexSubImage3D: compressedTexSubImage3D,
		scissor: scissor,
		viewport: viewport,
		reset: reset
	};
}

function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
	const isWebGL2 = capabilities.isWebGL2;
	const maxTextures = capabilities.maxTextures;
	const maxCubemapSize = capabilities.maxCubemapSize;
	const maxTextureSize = capabilities.maxTextureSize;
	const maxSamples = capabilities.maxSamples;
	const multisampledRTTExt = extensions.has('WEBGL_multisampled_render_to_texture') ? extensions.get('WEBGL_multisampled_render_to_texture') : null;
	const supportsInvalidateFramebuffer = /OculusBrowser/g.test(typeof navigator === 'undefined' ? '' : navigator.userAgent);
	const _videoTextures = new WeakMap();
	let _canvas;
	const _sources = new WeakMap(); // maps WebglTexture objects to instances of Source

	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

	let useOffscreenCanvas = false;
	try {
		useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
		// eslint-disable-next-line compat/compat
		&& new OffscreenCanvas(1, 1).getContext('2d') !== null;
	} catch (err) {

		// Ignore any errors
	}
	function createCanvas(width, height) {
		// Use OffscreenCanvas when available. Specially needed in web workers

		return useOffscreenCanvas ?
		// eslint-disable-next-line compat/compat
		new OffscreenCanvas(width, height) : createElementNS('canvas');
	}
	function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
		let scale = 1;

		// handle case if texture exceeds max size

		if (image.width > maxSize || image.height > maxSize) {
			scale = maxSize / Math.max(image.width, image.height);
		}

		// only perform resize if necessary

		if (scale < 1 || needsPowerOfTwo === true) {
			// only perform resize for certain image types

			if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
				const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
				const width = floor(scale * image.width);
				const height = floor(scale * image.height);
				if (_canvas === undefined) _canvas = createCanvas(width, height);

				// cube textures can't reuse the same canvas

				const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
				canvas.width = width;
				canvas.height = height;
				const context = canvas.getContext('2d');
				context.drawImage(image, 0, 0, width, height);
				console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
				return canvas;
			} else {
				if ('data' in image) {
					console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
				}
				return image;
			}
		}
		return image;
	}
	function isPowerOfTwo$1(image) {
		return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
	}
	function textureNeedsPowerOfTwo(texture) {
		if (isWebGL2) return false;
		return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
	}
	function textureNeedsGenerateMipmaps(texture, supportsMips) {
		return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
	}
	function generateMipmap(target) {
		_gl.generateMipmap(target);
	}
	function getInternalFormat(internalFormatName, glFormat, glType, encoding, forceLinearEncoding = false) {
		if (isWebGL2 === false) return glFormat;
		if (internalFormatName !== null) {
			if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
			console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
		}
		let internalFormat = glFormat;
		if (glFormat === _gl.RED) {
			if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
			if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
			if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
		}
		if (glFormat === _gl.RG) {
			if (glType === _gl.FLOAT) internalFormat = _gl.RG32F;
			if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RG16F;
			if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8;
		}
		if (glFormat === _gl.RGBA) {
			if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
			if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
			if (glType === _gl.UNSIGNED_BYTE) internalFormat = encoding === sRGBEncoding && forceLinearEncoding === false ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
			if (glType === _gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = _gl.RGBA4;
			if (glType === _gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = _gl.RGB5_A1;
		}
		if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
			extensions.get('EXT_color_buffer_float');
		}
		return internalFormat;
	}
	function getMipLevels(texture, image, supportsMips) {
		if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
			return Math.log2(Math.max(image.width, image.height)) + 1;
		} else if (texture.mipmaps !== undefined && texture.mipmaps.length > 0) {
			// user-defined mipmaps

			return texture.mipmaps.length;
		} else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
			return image.mipmaps.length;
		} else {
			// texture without mipmaps (only base level)

			return 1;
		}
	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback(f) {
		if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
			return _gl.NEAREST;
		}
		return _gl.LINEAR;
	}

	//

	function onTextureDispose(event) {
		const texture = event.target;
		texture.removeEventListener('dispose', onTextureDispose);
		deallocateTexture(texture);
		if (texture.isVideoTexture) {
			_videoTextures.delete(texture);
		}
	}
	function onRenderTargetDispose(event) {
		const renderTarget = event.target;
		renderTarget.removeEventListener('dispose', onRenderTargetDispose);
		deallocateRenderTarget(renderTarget);
	}

	//

	function deallocateTexture(texture) {
		const textureProperties = properties.get(texture);
		if (textureProperties.__webglInit === undefined) return;

		// check if it's necessary to remove the WebGLTexture object

		const source = texture.source;
		const webglTextures = _sources.get(source);
		if (webglTextures) {
			const webglTexture = webglTextures[textureProperties.__cacheKey];
			webglTexture.usedTimes--;

			// the WebGLTexture object is not used anymore, remove it

			if (webglTexture.usedTimes === 0) {
				deleteTexture(texture);
			}

			// remove the weak map entry if no WebGLTexture uses the source anymore

			if (Object.keys(webglTextures).length === 0) {
				_sources.delete(source);
			}
		}
		properties.remove(texture);
	}
	function deleteTexture(texture) {
		const textureProperties = properties.get(texture);
		_gl.deleteTexture(textureProperties.__webglTexture);
		const source = texture.source;
		const webglTextures = _sources.get(source);
		delete webglTextures[textureProperties.__cacheKey];
		info.memory.textures--;
	}
	function deallocateRenderTarget(renderTarget) {
		const texture = renderTarget.texture;
		const renderTargetProperties = properties.get(renderTarget);
		const textureProperties = properties.get(texture);
		if (textureProperties.__webglTexture !== undefined) {
			_gl.deleteTexture(textureProperties.__webglTexture);
			info.memory.textures--;
		}
		if (renderTarget.depthTexture) {
			renderTarget.depthTexture.dispose();
		}
		if (renderTarget.isWebGLCubeRenderTarget) {
			for (let i = 0; i < 6; i++) {
				_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
				if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
			}
		} else {
			_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
			if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
			if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
			if (renderTargetProperties.__webglColorRenderbuffer) {
				for (let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i++) {
					if (renderTargetProperties.__webglColorRenderbuffer[i]) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i]);
				}
			}
			if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
		}
		if (renderTarget.isWebGLMultipleRenderTargets) {
			for (let i = 0, il = texture.length; i < il; i++) {
				const attachmentProperties = properties.get(texture[i]);
				if (attachmentProperties.__webglTexture) {
					_gl.deleteTexture(attachmentProperties.__webglTexture);
					info.memory.textures--;
				}
				properties.remove(texture[i]);
			}
		}
		properties.remove(texture);
		properties.remove(renderTarget);
	}

	//

	let textureUnits = 0;
	function resetTextureUnits() {
		textureUnits = 0;
	}
	function allocateTextureUnit() {
		const textureUnit = textureUnits;
		if (textureUnit >= maxTextures) {
			console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
		}
		textureUnits += 1;
		return textureUnit;
	}
	function getTextureCacheKey(texture) {
		const array = [];
		array.push(texture.wrapS);
		array.push(texture.wrapT);
		array.push(texture.wrapR || 0);
		array.push(texture.magFilter);
		array.push(texture.minFilter);
		array.push(texture.anisotropy);
		array.push(texture.internalFormat);
		array.push(texture.format);
		array.push(texture.type);
		array.push(texture.generateMipmaps);
		array.push(texture.premultiplyAlpha);
		array.push(texture.flipY);
		array.push(texture.unpackAlignment);
		array.push(texture.encoding);
		return array.join();
	}

	//

	function setTexture2D(texture, slot) {
		const textureProperties = properties.get(texture);
		if (texture.isVideoTexture) updateVideoTexture(texture);
		if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
			const image = texture.image;
			if (image === null) {
				console.warn('THREE.WebGLRenderer: Texture marked for update but no image data found.');
			} else if (image.complete === false) {
				console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
			} else {
				uploadTexture(textureProperties, texture, slot);
				return;
			}
		}
		state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
	}
	function setTexture2DArray(texture, slot) {
		const textureProperties = properties.get(texture);
		if (texture.version > 0 && textureProperties.__version !== texture.version) {
			uploadTexture(textureProperties, texture, slot);
			return;
		}
		state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
	}
	function setTexture3D(texture, slot) {
		const textureProperties = properties.get(texture);
		if (texture.version > 0 && textureProperties.__version !== texture.version) {
			uploadTexture(textureProperties, texture, slot);
			return;
		}
		state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
	}
	function setTextureCube(texture, slot) {
		const textureProperties = properties.get(texture);
		if (texture.version > 0 && textureProperties.__version !== texture.version) {
			uploadCubeTexture(textureProperties, texture, slot);
			return;
		}
		state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
	}
	const wrappingToGL = {
		[RepeatWrapping]: _gl.REPEAT,
		[ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
		[MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
	};
	const filterToGL = {
		[NearestFilter]: _gl.NEAREST,
		[NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
		[NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
		[LinearFilter]: _gl.LINEAR,
		[LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
		[LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
	};
	function setTextureParameters(textureType, texture, supportsMips) {
		if (supportsMips) {
			_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
			_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
			if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
			}
			_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
			_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
		} else {
			_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
			_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
			if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
			}
			if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
				console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
			}
			_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
			_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
			if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
				console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
			}
		}
		if (extensions.has('EXT_texture_filter_anisotropic') === true) {
			const extension = extensions.get('EXT_texture_filter_anisotropic');
			if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2
			if (isWebGL2 === false && texture.type === HalfFloatType && extensions.has('OES_texture_half_float_linear') === false) return; // verify extension for WebGL 1 only

			if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
				_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
				properties.get(texture).__currentAnisotropy = texture.anisotropy;
			}
		}
	}
	function initTexture(textureProperties, texture) {
		let forceUpload = false;
		if (textureProperties.__webglInit === undefined) {
			textureProperties.__webglInit = true;
			texture.addEventListener('dispose', onTextureDispose);
		}

		// create Source <-> WebGLTextures mapping if necessary

		const source = texture.source;
		let webglTextures = _sources.get(source);
		if (webglTextures === undefined) {
			webglTextures = {};
			_sources.set(source, webglTextures);
		}

		// check if there is already a WebGLTexture object for the given texture parameters

		const textureCacheKey = getTextureCacheKey(texture);
		if (textureCacheKey !== textureProperties.__cacheKey) {
			// if not, create a new instance of WebGLTexture

			if (webglTextures[textureCacheKey] === undefined) {
				// create new entry

				webglTextures[textureCacheKey] = {
					texture: _gl.createTexture(),
					usedTimes: 0
				};
				info.memory.textures++;

				// when a new instance of WebGLTexture was created, a texture upload is required
				// even if the image contents are identical

				forceUpload = true;
			}
			webglTextures[textureCacheKey].usedTimes++;

			// every time the texture cache key changes, it's necessary to check if an instance of
			// WebGLTexture can be deleted in order to avoid a memory leak.

			const webglTexture = webglTextures[textureProperties.__cacheKey];
			if (webglTexture !== undefined) {
				webglTextures[textureProperties.__cacheKey].usedTimes--;
				if (webglTexture.usedTimes === 0) {
					deleteTexture(texture);
				}
			}

			// store references to cache key and WebGLTexture object

			textureProperties.__cacheKey = textureCacheKey;
			textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
		}
		return forceUpload;
	}
	function uploadTexture(textureProperties, texture, slot) {
		let textureType = _gl.TEXTURE_2D;
		if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) textureType = _gl.TEXTURE_2D_ARRAY;
		if (texture.isData3DTexture) textureType = _gl.TEXTURE_3D;
		const forceUpload = initTexture(textureProperties, texture);
		const source = texture.source;
		state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
		const sourceProperties = properties.get(source);
		if (source.version !== sourceProperties.__version || forceUpload === true) {
			state.activeTexture(_gl.TEXTURE0 + slot);
			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
			_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);
			const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
			let image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
			image = verifyColorSpace(texture, image);
			const supportsMips = isPowerOfTwo$1(image) || isWebGL2,
				glFormat = utils.convert(texture.format, texture.encoding);
			let glType = utils.convert(texture.type),
				glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture);
			setTextureParameters(textureType, texture, supportsMips);
			let mipmap;
			const mipmaps = texture.mipmaps;
			const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
			const allocateMemory = sourceProperties.__version === undefined || forceUpload === true;
			const levels = getMipLevels(texture, image, supportsMips);
			if (texture.isDepthTexture) {
				// populate depth texture with dummy data

				glInternalFormat = _gl.DEPTH_COMPONENT;
				if (isWebGL2) {
					if (texture.type === FloatType) {
						glInternalFormat = _gl.DEPTH_COMPONENT32F;
					} else if (texture.type === UnsignedIntType) {
						glInternalFormat = _gl.DEPTH_COMPONENT24;
					} else if (texture.type === UnsignedInt248Type) {
						glInternalFormat = _gl.DEPTH24_STENCIL8;
					} else {
						glInternalFormat = _gl.DEPTH_COMPONENT16; // WebGL2 requires sized internalformat for glTexImage2D
					}
				} else {
					if (texture.type === FloatType) {
						console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
					}
				}

				// validation checks for WebGL 1

				if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
						console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
						texture.type = UnsignedIntType;
						glType = utils.convert(texture.type);
					}
				}
				if (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					glInternalFormat = _gl.DEPTH_STENCIL;

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if (texture.type !== UnsignedInt248Type) {
						console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
						texture.type = UnsignedInt248Type;
						glType = utils.convert(texture.type);
					}
				}

				//

				if (allocateMemory) {
					if (useTexStorage) {
						state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);
					} else {
						state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
					}
				}
			} else if (texture.isDataTexture) {
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if (mipmaps.length > 0 && supportsMips) {
					if (useTexStorage && allocateMemory) {
						state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
					}
					for (let i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i];
						if (useTexStorage) {
							state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
						} else {
							state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
						}
					}
					texture.generateMipmaps = false;
				} else {
					if (useTexStorage) {
						if (allocateMemory) {
							state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
						}
						state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
					} else {
						state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
					}
				}
			} else if (texture.isCompressedTexture) {
				if (texture.isCompressedArrayTexture) {
					if (useTexStorage && allocateMemory) {
						state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);
					}
					for (let i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i];
						if (texture.format !== RGBAFormat) {
							if (glFormat !== null) {
								if (useTexStorage) {
									state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0);
								} else {
									state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0);
								}
							} else {
								console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
							}
						} else {
							if (useTexStorage) {
								state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
							} else {
								state.texImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);
							}
						}
					}
				} else {
					if (useTexStorage && allocateMemory) {
						state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
					}
					for (let i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i];
						if (texture.format !== RGBAFormat) {
							if (glFormat !== null) {
								if (useTexStorage) {
									state.compressedTexSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
								} else {
									state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
								}
							} else {
								console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
							}
						} else {
							if (useTexStorage) {
								state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
							} else {
								state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
							}
						}
					}
				}
			} else if (texture.isDataArrayTexture) {
				if (useTexStorage) {
					if (allocateMemory) {
						state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);
					}
					state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
				} else {
					state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
				}
			} else if (texture.isData3DTexture) {
				if (useTexStorage) {
					if (allocateMemory) {
						state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);
					}
					state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
				} else {
					state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
				}
			} else if (texture.isFramebufferTexture) {
				if (allocateMemory) {
					if (useTexStorage) {
						state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
					} else {
						let width = image.width,
							height = image.height;
						for (let i = 0; i < levels; i++) {
							state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null);
							width >>= 1;
							height >>= 1;
						}
					}
				}
			} else {
				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if (mipmaps.length > 0 && supportsMips) {
					if (useTexStorage && allocateMemory) {
						state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
					}
					for (let i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i];
						if (useTexStorage) {
							state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap);
						} else {
							state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
						}
					}
					texture.generateMipmaps = false;
				} else {
					if (useTexStorage) {
						if (allocateMemory) {
							state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
						}
						state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
					} else {
						state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
					}
				}
			}
			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				generateMipmap(textureType);
			}
			sourceProperties.__version = source.version;
			if (texture.onUpdate) texture.onUpdate(texture);
		}
		textureProperties.__version = texture.version;
	}
	function uploadCubeTexture(textureProperties, texture, slot) {
		if (texture.image.length !== 6) return;
		const forceUpload = initTexture(textureProperties, texture);
		const source = texture.source;
		state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
		const sourceProperties = properties.get(source);
		if (source.version !== sourceProperties.__version || forceUpload === true) {
			state.activeTexture(_gl.TEXTURE0 + slot);
			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
			_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);
			const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
			const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
			const cubeImage = [];
			for (let i = 0; i < 6; i++) {
				if (!isCompressed && !isDataTexture) {
					cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
				} else {
					cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
				}
				cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);
			}
			const image = cubeImage[0],
				supportsMips = isPowerOfTwo$1(image) || isWebGL2,
				glFormat = utils.convert(texture.format, texture.encoding),
				glType = utils.convert(texture.type),
				glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
			const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
			const allocateMemory = sourceProperties.__version === undefined || forceUpload === true;
			let levels = getMipLevels(texture, image, supportsMips);
			setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
			let mipmaps;
			if (isCompressed) {
				if (useTexStorage && allocateMemory) {
					state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);
				}
				for (let i = 0; i < 6; i++) {
					mipmaps = cubeImage[i].mipmaps;
					for (let j = 0; j < mipmaps.length; j++) {
						const mipmap = mipmaps[j];
						if (texture.format !== RGBAFormat) {
							if (glFormat !== null) {
								if (useTexStorage) {
									state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
								} else {
									state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
								}
							} else {
								console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
							}
						} else {
							if (useTexStorage) {
								state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
							} else {
								state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
							}
						}
					}
				}
			} else {
				mipmaps = texture.mipmaps;
				if (useTexStorage && allocateMemory) {
					// TODO: Uniformly handle mipmap definitions
					// Normal textures and compressed cube textures define base level + mips with their mipmap array
					// Uncompressed cube textures use their mipmap array only for mips (no base level)

					if (mipmaps.length > 0) levels++;
					state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
				}
				for (let i = 0; i < 6; i++) {
					if (isDataTexture) {
						if (useTexStorage) {
							state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data);
						} else {
							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
						}
						for (let j = 0; j < mipmaps.length; j++) {
							const mipmap = mipmaps[j];
							const mipmapImage = mipmap.image[i].image;
							if (useTexStorage) {
								state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
							} else {
								state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
							}
						}
					} else {
						if (useTexStorage) {
							state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[i]);
						} else {
							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
						}
						for (let j = 0; j < mipmaps.length; j++) {
							const mipmap = mipmaps[j];
							if (useTexStorage) {
								state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[i]);
							} else {
								state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
							}
						}
					}
				}
			}
			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				// We assume images for cube map have the same size.
				generateMipmap(_gl.TEXTURE_CUBE_MAP);
			}
			sourceProperties.__version = source.version;
			if (texture.onUpdate) texture.onUpdate(texture);
		}
		textureProperties.__version = texture.version;
	}

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
		const glFormat = utils.convert(texture.format, texture.encoding);
		const glType = utils.convert(texture.type);
		const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
		const renderTargetProperties = properties.get(renderTarget);
		if (!renderTargetProperties.__hasExternalTextures) {
			if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
				state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
			} else {
				state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
			}
		}
		state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
		if (useMultisampledRTT(renderTarget)) {
			multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
		} else if (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) {
			// see #24753

			_gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
		}
		state.bindFramebuffer(_gl.FRAMEBUFFER, null);
	}

	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
		_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
		if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
			let glInternalFormat = _gl.DEPTH_COMPONENT16;
			if (isMultisample || useMultisampledRTT(renderTarget)) {
				const depthTexture = renderTarget.depthTexture;
				if (depthTexture && depthTexture.isDepthTexture) {
					if (depthTexture.type === FloatType) {
						glInternalFormat = _gl.DEPTH_COMPONENT32F;
					} else if (depthTexture.type === UnsignedIntType) {
						glInternalFormat = _gl.DEPTH_COMPONENT24;
					}
				}
				const samples = getRenderTargetSamples(renderTarget);
				if (useMultisampledRTT(renderTarget)) {
					multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
				}
			} else {
				_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
			}
			_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
		} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
			const samples = getRenderTargetSamples(renderTarget);
			if (isMultisample && useMultisampledRTT(renderTarget) === false) {
				_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
			} else if (useMultisampledRTT(renderTarget)) {
				multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
			} else {
				_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
			}
			_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
		} else {
			const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
			for (let i = 0; i < textures.length; i++) {
				const texture = textures[i];
				const glFormat = utils.convert(texture.format, texture.encoding);
				const glType = utils.convert(texture.type);
				const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
				const samples = getRenderTargetSamples(renderTarget);
				if (isMultisample && useMultisampledRTT(renderTarget) === false) {
					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
				} else if (useMultisampledRTT(renderTarget)) {
					multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
				}
			}
		}
		_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture(framebuffer, renderTarget) {
		const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
		if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
		state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
		if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
			throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
		}

		// upload an empty depth texture with framebuffer size
		if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;
		}
		setTexture2D(renderTarget.depthTexture, 0);
		const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
		const samples = getRenderTargetSamples(renderTarget);
		if (renderTarget.depthTexture.format === DepthFormat) {
			if (useMultisampledRTT(renderTarget)) {
				multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
			} else {
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
			}
		} else if (renderTarget.depthTexture.format === DepthStencilFormat) {
			if (useMultisampledRTT(renderTarget)) {
				multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
			} else {
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
			}
		} else {
			throw new Error('Unknown depthTexture format');
		}
	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer(renderTarget) {
		const renderTargetProperties = properties.get(renderTarget);
		const isCube = renderTarget.isWebGLCubeRenderTarget === true;
		if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
			if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
			setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
		} else {
			if (isCube) {
				renderTargetProperties.__webglDepthbuffer = [];
				for (let i = 0; i < 6; i++) {
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
					renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
					setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
				}
			} else {
				state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
			}
		}
		state.bindFramebuffer(_gl.FRAMEBUFFER, null);
	}

	// rebind framebuffer with external textures
	function rebindTextures(renderTarget, colorTexture, depthTexture) {
		const renderTargetProperties = properties.get(renderTarget);
		if (colorTexture !== undefined) {
			setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
		}
		if (depthTexture !== undefined) {
			setupDepthRenderbuffer(renderTarget);
		}
	}

	// Set up GL resources for the render target
	function setupRenderTarget(renderTarget) {
		const texture = renderTarget.texture;
		const renderTargetProperties = properties.get(renderTarget);
		const textureProperties = properties.get(texture);
		renderTarget.addEventListener('dispose', onRenderTargetDispose);
		if (renderTarget.isWebGLMultipleRenderTargets !== true) {
			if (textureProperties.__webglTexture === undefined) {
				textureProperties.__webglTexture = _gl.createTexture();
			}
			textureProperties.__version = texture.version;
			info.memory.textures++;
		}
		const isCube = renderTarget.isWebGLCubeRenderTarget === true;
		const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
		const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;

		// Setup framebuffer

		if (isCube) {
			renderTargetProperties.__webglFramebuffer = [];
			for (let i = 0; i < 6; i++) {
				renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
			}
		} else {
			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
			if (isMultipleRenderTargets) {
				if (capabilities.drawBuffers) {
					const textures = renderTarget.texture;
					for (let i = 0, il = textures.length; i < il; i++) {
						const attachmentProperties = properties.get(textures[i]);
						if (attachmentProperties.__webglTexture === undefined) {
							attachmentProperties.__webglTexture = _gl.createTexture();
							info.memory.textures++;
						}
					}
				} else {
					console.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');
				}
			}
			if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
				const textures = isMultipleRenderTargets ? texture : [texture];
				renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
				renderTargetProperties.__webglColorRenderbuffer = [];
				state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
				for (let i = 0; i < textures.length; i++) {
					const texture = textures[i];
					renderTargetProperties.__webglColorRenderbuffer[i] = _gl.createRenderbuffer();
					_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
					const glFormat = utils.convert(texture.format, texture.encoding);
					const glType = utils.convert(texture.type);
					const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, renderTarget.isXRRenderTarget === true);
					const samples = getRenderTargetSamples(renderTarget);
					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
					_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
				}
				_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
				if (renderTarget.depthBuffer) {
					renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
				}
				state.bindFramebuffer(_gl.FRAMEBUFFER, null);
			}
		}

		// Setup color buffer

		if (isCube) {
			state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
			setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
			for (let i = 0; i < 6; i++) {
				setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
			}
			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				generateMipmap(_gl.TEXTURE_CUBE_MAP);
			}
			state.unbindTexture();
		} else if (isMultipleRenderTargets) {
			const textures = renderTarget.texture;
			for (let i = 0, il = textures.length; i < il; i++) {
				const attachment = textures[i];
				const attachmentProperties = properties.get(attachment);
				state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
				setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);
				setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D);
				if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
					generateMipmap(_gl.TEXTURE_2D);
				}
			}
			state.unbindTexture();
		} else {
			let glTextureType = _gl.TEXTURE_2D;
			if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
				if (isWebGL2) {
					glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
				} else {
					console.error('THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.');
				}
			}
			state.bindTexture(glTextureType, textureProperties.__webglTexture);
			setTextureParameters(glTextureType, texture, supportsMips);
			setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType);
			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				generateMipmap(glTextureType);
			}
			state.unbindTexture();
		}

		// Setup depth and stencil buffers

		if (renderTarget.depthBuffer) {
			setupDepthRenderbuffer(renderTarget);
		}
	}
	function updateRenderTargetMipmap(renderTarget) {
		const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
		const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
		for (let i = 0, il = textures.length; i < il; i++) {
			const texture = textures[i];
			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
				const webglTexture = properties.get(texture).__webglTexture;
				state.bindTexture(target, webglTexture);
				generateMipmap(target);
				state.unbindTexture();
			}
		}
	}
	function updateMultisampleRenderTarget(renderTarget) {
		if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
			const textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [renderTarget.texture];
			const width = renderTarget.width;
			const height = renderTarget.height;
			let mask = _gl.COLOR_BUFFER_BIT;
			const invalidationArray = [];
			const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
			const renderTargetProperties = properties.get(renderTarget);
			const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;

			// If MRT we need to remove FBO attachments
			if (isMultipleRenderTargets) {
				for (let i = 0; i < textures.length; i++) {
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
					_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null);
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
					_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0);
				}
			}
			state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
			state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
			for (let i = 0; i < textures.length; i++) {
				invalidationArray.push(_gl.COLOR_ATTACHMENT0 + i);
				if (renderTarget.depthBuffer) {
					invalidationArray.push(depthStyle);
				}
				const ignoreDepthValues = renderTargetProperties.__ignoreDepthValues !== undefined ? renderTargetProperties.__ignoreDepthValues : false;
				if (ignoreDepthValues === false) {
					if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
					if (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
				}
				if (isMultipleRenderTargets) {
					_gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
				}
				if (ignoreDepthValues === true) {
					_gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, [depthStyle]);
					_gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
				}
				if (isMultipleRenderTargets) {
					const webglTexture = properties.get(textures[i]).__webglTexture;
					_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);
				}
				_gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
				if (supportsInvalidateFramebuffer) {
					_gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArray);
				}
			}
			state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
			state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);

			// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
			if (isMultipleRenderTargets) {
				for (let i = 0; i < textures.length; i++) {
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
					_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
					const webglTexture = properties.get(textures[i]).__webglTexture;
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
					_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0);
				}
			}
			state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
		}
	}
	function getRenderTargetSamples(renderTarget) {
		return Math.min(maxSamples, renderTarget.samples);
	}
	function useMultisampledRTT(renderTarget) {
		const renderTargetProperties = properties.get(renderTarget);
		return isWebGL2 && renderTarget.samples > 0 && extensions.has('WEBGL_multisampled_render_to_texture') === true && renderTargetProperties.__useRenderToTexture !== false;
	}
	function updateVideoTexture(texture) {
		const frame = info.render.frame;

		// Check the last frame we updated the VideoTexture

		if (_videoTextures.get(texture) !== frame) {
			_videoTextures.set(texture, frame);
			texture.update();
		}
	}
	function verifyColorSpace(texture, image) {
		const encoding = texture.encoding;
		const format = texture.format;
		const type = texture.type;
		if (texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat) return image;
		if (encoding !== LinearEncoding) {
			// sRGB

			if (encoding === sRGBEncoding) {
				if (isWebGL2 === false) {
					// in WebGL 1, try to use EXT_sRGB extension and unsized formats

					if (extensions.has('EXT_sRGB') === true && format === RGBAFormat) {
						texture.format = _SRGBAFormat;

						// it's not possible to generate mips in WebGL 1 with this extension

						texture.minFilter = LinearFilter;
						texture.generateMipmaps = false;
					} else {
						// slow fallback (CPU decode)

						image = ImageUtils.sRGBToLinear(image);
					}
				} else {
					// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format

					if (format !== RGBAFormat || type !== UnsignedByteType) {
						console.warn('THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.');
					}
				}
			} else {
				console.error('THREE.WebGLTextures: Unsupported texture encoding:', encoding);
			}
		}
		return image;
	}

	//

	this.allocateTextureUnit = allocateTextureUnit;
	this.resetTextureUnits = resetTextureUnits;
	this.setTexture2D = setTexture2D;
	this.setTexture2DArray = setTexture2DArray;
	this.setTexture3D = setTexture3D;
	this.setTextureCube = setTextureCube;
	this.rebindTextures = rebindTextures;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
	this.setupDepthRenderbuffer = setupDepthRenderbuffer;
	this.setupFrameBufferTexture = setupFrameBufferTexture;
	this.useMultisampledRTT = useMultisampledRTT;
}

function WebGLUtils(gl, extensions, capabilities) {
	const isWebGL2 = capabilities.isWebGL2;
	function convert(p, encoding = null) {
		let extension;
		if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
		if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
		if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
		if (p === ByteType) return gl.BYTE;
		if (p === ShortType) return gl.SHORT;
		if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
		if (p === IntType) return gl.INT;
		if (p === UnsignedIntType) return gl.UNSIGNED_INT;
		if (p === FloatType) return gl.FLOAT;
		if (p === HalfFloatType) {
			if (isWebGL2) return gl.HALF_FLOAT;
			extension = extensions.get('OES_texture_half_float');
			if (extension !== null) {
				return extension.HALF_FLOAT_OES;
			} else {
				return null;
			}
		}
		if (p === AlphaFormat) return gl.ALPHA;
		if (p === RGBAFormat) return gl.RGBA;
		if (p === LuminanceFormat) return gl.LUMINANCE;
		if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
		if (p === DepthFormat) return gl.DEPTH_COMPONENT;
		if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
		if (p === RedFormat) return gl.RED;

		// @deprecated since r137

		if (p === RGBFormat) {
			console.warn('THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228');
			return gl.RGBA;
		}

		// WebGL 1 sRGB fallback

		if (p === _SRGBAFormat) {
			extension = extensions.get('EXT_sRGB');
			if (extension !== null) {
				return extension.SRGB_ALPHA_EXT;
			} else {
				return null;
			}
		}

		// WebGL2 formats.

		if (p === RedIntegerFormat) return gl.RED_INTEGER;
		if (p === RGFormat) return gl.RG;
		if (p === RGIntegerFormat) return gl.RG_INTEGER;
		if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;

		// S3TC

		if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
			if (encoding === sRGBEncoding) {
				extension = extensions.get('WEBGL_compressed_texture_s3tc_srgb');
				if (extension !== null) {
					if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
					if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
				} else {
					return null;
				}
			} else {
				extension = extensions.get('WEBGL_compressed_texture_s3tc');
				if (extension !== null) {
					if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
				} else {
					return null;
				}
			}
		}

		// PVRTC

		if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
			extension = extensions.get('WEBGL_compressed_texture_pvrtc');
			if (extension !== null) {
				if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
			} else {
				return null;
			}
		}

		// ETC1

		if (p === RGB_ETC1_Format) {
			extension = extensions.get('WEBGL_compressed_texture_etc1');
			if (extension !== null) {
				return extension.COMPRESSED_RGB_ETC1_WEBGL;
			} else {
				return null;
			}
		}

		// ETC2

		if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
			extension = extensions.get('WEBGL_compressed_texture_etc');
			if (extension !== null) {
				if (p === RGB_ETC2_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
				if (p === RGBA_ETC2_EAC_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
			} else {
				return null;
			}
		}

		// ASTC

		if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
			extension = extensions.get('WEBGL_compressed_texture_astc');
			if (extension !== null) {
				if (p === RGBA_ASTC_4x4_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
				if (p === RGBA_ASTC_5x4_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
				if (p === RGBA_ASTC_5x5_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
				if (p === RGBA_ASTC_6x5_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
				if (p === RGBA_ASTC_6x6_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
				if (p === RGBA_ASTC_8x5_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
				if (p === RGBA_ASTC_8x6_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
				if (p === RGBA_ASTC_8x8_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
				if (p === RGBA_ASTC_10x5_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
				if (p === RGBA_ASTC_10x6_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
				if (p === RGBA_ASTC_10x8_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
				if (p === RGBA_ASTC_10x10_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
				if (p === RGBA_ASTC_12x10_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
				if (p === RGBA_ASTC_12x12_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
			} else {
				return null;
			}
		}

		// BPTC

		if (p === RGBA_BPTC_Format) {
			extension = extensions.get('EXT_texture_compression_bptc');
			if (extension !== null) {
				if (p === RGBA_BPTC_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
			} else {
				return null;
			}
		}

		//

		if (p === UnsignedInt248Type) {
			if (isWebGL2) return gl.UNSIGNED_INT_24_8;
			extension = extensions.get('WEBGL_depth_texture');
			if (extension !== null) {
				return extension.UNSIGNED_INT_24_8_WEBGL;
			} else {
				return null;
			}
		}

		// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

		return gl[p] !== undefined ? gl[p] : null;
	}
	return {
		convert: convert
	};
}

class ArrayCamera extends PerspectiveCamera {
	constructor(array = []) {
		super();
		this.isArrayCamera = true;
		this.cameras = array;
	}
}

class Group extends Object3D {
	constructor() {
		super();
		this.isGroup = true;
		this.type = 'Group';
	}
}

const _moveEvent = {
	type: 'move'
};
class WebXRController {
	constructor() {
		this._targetRay = null;
		this._grip = null;
		this._hand = null;
	}
	getHandSpace() {
		if (this._hand === null) {
			this._hand = new Group();
			this._hand.matrixAutoUpdate = false;
			this._hand.visible = false;
			this._hand.joints = {};
			this._hand.inputState = {
				pinching: false
			};
		}
		return this._hand;
	}
	getTargetRaySpace() {
		if (this._targetRay === null) {
			this._targetRay = new Group();
			this._targetRay.matrixAutoUpdate = false;
			this._targetRay.visible = false;
			this._targetRay.hasLinearVelocity = false;
			this._targetRay.linearVelocity = new Vector3();
			this._targetRay.hasAngularVelocity = false;
			this._targetRay.angularVelocity = new Vector3();
		}
		return this._targetRay;
	}
	getGripSpace() {
		if (this._grip === null) {
			this._grip = new Group();
			this._grip.matrixAutoUpdate = false;
			this._grip.visible = false;
			this._grip.hasLinearVelocity = false;
			this._grip.linearVelocity = new Vector3();
			this._grip.hasAngularVelocity = false;
			this._grip.angularVelocity = new Vector3();
		}
		return this._grip;
	}
	dispatchEvent(event) {
		if (this._targetRay !== null) {
			this._targetRay.dispatchEvent(event);
		}
		if (this._grip !== null) {
			this._grip.dispatchEvent(event);
		}
		if (this._hand !== null) {
			this._hand.dispatchEvent(event);
		}
		return this;
	}
	disconnect(inputSource) {
		this.dispatchEvent({
			type: 'disconnected',
			data: inputSource
		});
		if (this._targetRay !== null) {
			this._targetRay.visible = false;
		}
		if (this._grip !== null) {
			this._grip.visible = false;
		}
		if (this._hand !== null) {
			this._hand.visible = false;
		}
		return this;
	}
	update(inputSource, frame, referenceSpace) {
		let inputPose = null;
		let gripPose = null;
		let handPose = null;
		const targetRay = this._targetRay;
		const grip = this._grip;
		const hand = this._hand;
		if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
			if (hand && inputSource.hand) {
				handPose = true;
				for (const inputjoint of inputSource.hand.values()) {
					// Update the joints groups with the XRJoint poses
					const jointPose = frame.getJointPose(inputjoint, referenceSpace);
					if (hand.joints[inputjoint.jointName] === undefined) {
						// The transform of this joint will be updated with the joint pose on each frame
						const joint = new Group();
						joint.matrixAutoUpdate = false;
						joint.visible = false;
						hand.joints[inputjoint.jointName] = joint;
						// ??
						hand.add(joint);
					}
					const joint = hand.joints[inputjoint.jointName];
					if (jointPose !== null) {
						joint.matrix.fromArray(jointPose.transform.matrix);
						joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
						joint.jointRadius = jointPose.radius;
					}
					joint.visible = jointPose !== null;
				}

				// Custom events

				// Check pinchz
				const indexTip = hand.joints['index-finger-tip'];
				const thumbTip = hand.joints['thumb-tip'];
				const distance = indexTip.position.distanceTo(thumbTip.position);
				const distanceToPinch = 0.02;
				const threshold = 0.005;
				if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
					hand.inputState.pinching = false;
					this.dispatchEvent({
						type: 'pinchend',
						handedness: inputSource.handedness,
						target: this
					});
				} else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
					hand.inputState.pinching = true;
					this.dispatchEvent({
						type: 'pinchstart',
						handedness: inputSource.handedness,
						target: this
					});
				}
			} else {
				if (grip !== null && inputSource.gripSpace) {
					gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
					if (gripPose !== null) {
						grip.matrix.fromArray(gripPose.transform.matrix);
						grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
						if (gripPose.linearVelocity) {
							grip.hasLinearVelocity = true;
							grip.linearVelocity.copy(gripPose.linearVelocity);
						} else {
							grip.hasLinearVelocity = false;
						}
						if (gripPose.angularVelocity) {
							grip.hasAngularVelocity = true;
							grip.angularVelocity.copy(gripPose.angularVelocity);
						} else {
							grip.hasAngularVelocity = false;
						}
					}
				}
			}
			if (targetRay !== null) {
				inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);

				// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
				if (inputPose === null && gripPose !== null) {
					inputPose = gripPose;
				}
				if (inputPose !== null) {
					targetRay.matrix.fromArray(inputPose.transform.matrix);
					targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
					if (inputPose.linearVelocity) {
						targetRay.hasLinearVelocity = true;
						targetRay.linearVelocity.copy(inputPose.linearVelocity);
					} else {
						targetRay.hasLinearVelocity = false;
					}
					if (inputPose.angularVelocity) {
						targetRay.hasAngularVelocity = true;
						targetRay.angularVelocity.copy(inputPose.angularVelocity);
					} else {
						targetRay.hasAngularVelocity = false;
					}
					this.dispatchEvent(_moveEvent);
				}
			}
		}
		if (targetRay !== null) {
			targetRay.visible = inputPose !== null;
		}
		if (grip !== null) {
			grip.visible = gripPose !== null;
		}
		if (hand !== null) {
			hand.visible = handPose !== null;
		}
		return this;
	}
}

class DepthTexture extends Texture {
	constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
		format = format !== undefined ? format : DepthFormat;
		if (format !== DepthFormat && format !== DepthStencilFormat) {
			throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
		}
		if (type === undefined && format === DepthFormat) type = UnsignedIntType;
		if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
		super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
		this.isDepthTexture = true;
		this.image = {
			width: width,
			height: height
		};
		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
		this.flipY = false;
		this.generateMipmaps = false;
	}
}

class WebXRManager extends EventDispatcher {
	constructor(renderer, gl) {
		super();
		const scope = this;
		let session = null;
		let framebufferScaleFactor = 1.0;
		let referenceSpace = null;
		let referenceSpaceType = 'local-floor';
		let customReferenceSpace = null;
		let pose = null;
		let glBinding = null;
		let glProjLayer = null;
		let glBaseLayer = null;
		let xrFrame = null;
		const attributes = gl.getContextAttributes();
		let initialRenderTarget = null;
		let newRenderTarget = null;
		const controllers = [];
		const controllerInputSources = [];

		//

		const cameraL = new PerspectiveCamera();
		cameraL.layers.enable(1);
		cameraL.viewport = new Vector4();
		const cameraR = new PerspectiveCamera();
		cameraR.layers.enable(2);
		cameraR.viewport = new Vector4();
		const cameras = [cameraL, cameraR];
		const cameraVR = new ArrayCamera();
		cameraVR.layers.enable(1);
		cameraVR.layers.enable(2);
		let _currentDepthNear = null;
		let _currentDepthFar = null;

		//

		this.cameraAutoUpdate = true;
		this.enabled = false;
		this.isPresenting = false;
		this.getController = function (index) {
			let controller = controllers[index];
			if (controller === undefined) {
				controller = new WebXRController();
				controllers[index] = controller;
			}
			return controller.getTargetRaySpace();
		};
		this.getControllerGrip = function (index) {
			let controller = controllers[index];
			if (controller === undefined) {
				controller = new WebXRController();
				controllers[index] = controller;
			}
			return controller.getGripSpace();
		};
		this.getHand = function (index) {
			let controller = controllers[index];
			if (controller === undefined) {
				controller = new WebXRController();
				controllers[index] = controller;
			}
			return controller.getHandSpace();
		};

		//

		function onSessionEvent(event) {
			const controllerIndex = controllerInputSources.indexOf(event.inputSource);
			if (controllerIndex === -1) {
				return;
			}
			const controller = controllers[controllerIndex];
			if (controller !== undefined) {
				controller.dispatchEvent({
					type: event.type,
					data: event.inputSource
				});
			}
		}
		function onSessionEnd() {
			session.removeEventListener('select', onSessionEvent);
			session.removeEventListener('selectstart', onSessionEvent);
			session.removeEventListener('selectend', onSessionEvent);
			session.removeEventListener('squeeze', onSessionEvent);
			session.removeEventListener('squeezestart', onSessionEvent);
			session.removeEventListener('squeezeend', onSessionEvent);
			session.removeEventListener('end', onSessionEnd);
			session.removeEventListener('inputsourceschange', onInputSourcesChange);
			for (let i = 0; i < controllers.length; i++) {
				const inputSource = controllerInputSources[i];
				if (inputSource === null) continue;
				controllerInputSources[i] = null;
				controllers[i].disconnect(inputSource);
			}
			_currentDepthNear = null;
			_currentDepthFar = null;

			// restore framebuffer/rendering state

			renderer.setRenderTarget(initialRenderTarget);
			glBaseLayer = null;
			glProjLayer = null;
			glBinding = null;
			session = null;
			newRenderTarget = null;

			//

			animation.stop();
			scope.isPresenting = false;
			scope.dispatchEvent({
				type: 'sessionend'
			});
		}
		this.setFramebufferScaleFactor = function (value) {
			framebufferScaleFactor = value;
			if (scope.isPresenting === true) {
				console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
			}
		};
		this.setReferenceSpaceType = function (value) {
			referenceSpaceType = value;
			if (scope.isPresenting === true) {
				console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
			}
		};
		this.getReferenceSpace = function () {
			return customReferenceSpace || referenceSpace;
		};
		this.setReferenceSpace = function (space) {
			customReferenceSpace = space;
		};
		this.getBaseLayer = function () {
			return glProjLayer !== null ? glProjLayer : glBaseLayer;
		};
		this.getBinding = function () {
			return glBinding;
		};
		this.getFrame = function () {
			return xrFrame;
		};
		this.getSession = function () {
			return session;
		};
		this.setSession = async function (value) {
			session = value;
			if (session !== null) {
				initialRenderTarget = renderer.getRenderTarget();
				session.addEventListener('select', onSessionEvent);
				session.addEventListener('selectstart', onSessionEvent);
				session.addEventListener('selectend', onSessionEvent);
				session.addEventListener('squeeze', onSessionEvent);
				session.addEventListener('squeezestart', onSessionEvent);
				session.addEventListener('squeezeend', onSessionEvent);
				session.addEventListener('end', onSessionEnd);
				session.addEventListener('inputsourceschange', onInputSourcesChange);
				if (attributes.xrCompatible !== true) {
					await gl.makeXRCompatible();
				}
				if (session.renderState.layers === undefined || renderer.capabilities.isWebGL2 === false) {
					const layerInit = {
						antialias: session.renderState.layers === undefined ? attributes.antialias : true,
						alpha: attributes.alpha,
						depth: attributes.depth,
						stencil: attributes.stencil,
						framebufferScaleFactor: framebufferScaleFactor
					};
					glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
					session.updateRenderState({
						baseLayer: glBaseLayer
					});
					newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {
						format: RGBAFormat,
						type: UnsignedByteType,
						encoding: renderer.outputEncoding,
						stencilBuffer: attributes.stencil
					});
				} else {
					let depthFormat = null;
					let depthType = null;
					let glDepthFormat = null;
					if (attributes.depth) {
						glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
						depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
						depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
					}
					const projectionlayerInit = {
						colorFormat: gl.RGBA8,
						depthFormat: glDepthFormat,
						scaleFactor: framebufferScaleFactor
					};
					glBinding = new XRWebGLBinding(session, gl);
					glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
					session.updateRenderState({
						layers: [glProjLayer]
					});
					newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
						format: RGBAFormat,
						type: UnsignedByteType,
						depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat),
						stencilBuffer: attributes.stencil,
						encoding: renderer.outputEncoding,
						samples: attributes.antialias ? 4 : 0
					});
					const renderTargetProperties = renderer.properties.get(newRenderTarget);
					renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;
				}
				newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278

				// Set foveation to maximum.
				this.setFoveation(1.0);
				customReferenceSpace = null;
				referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
				animation.setContext(session);
				animation.start();
				scope.isPresenting = true;
				scope.dispatchEvent({
					type: 'sessionstart'
				});
			}
		};
		function onInputSourcesChange(event) {
			// Notify disconnected

			for (let i = 0; i < event.removed.length; i++) {
				const inputSource = event.removed[i];
				const index = controllerInputSources.indexOf(inputSource);
				if (index >= 0) {
					controllerInputSources[index] = null;
					controllers[index].dispatchEvent({
						type: 'disconnected',
						data: inputSource
					});
				}
			}

			// Notify connected

			for (let i = 0; i < event.added.length; i++) {
				const inputSource = event.added[i];
				let controllerIndex = controllerInputSources.indexOf(inputSource);
				if (controllerIndex === -1) {
					// Assign input source a controller that currently has no input source

					for (let i = 0; i < controllers.length; i++) {
						if (i >= controllerInputSources.length) {
							controllerInputSources.push(inputSource);
							controllerIndex = i;
							break;
						} else if (controllerInputSources[i] === null) {
							controllerInputSources[i] = inputSource;
							controllerIndex = i;
							break;
						}
					}

					// If all controllers do currently receive input we ignore new ones

					if (controllerIndex === -1) break;
				}
				const controller = controllers[controllerIndex];
				if (controller) {
					controller.dispatchEvent({
						type: 'connected',
						data: inputSource
					});
				}
			}
		}

		//

		const cameraLPos = new Vector3();
		const cameraRPos = new Vector3();

		/**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 */
		function setProjectionFromUnion(camera, cameraL, cameraR) {
			cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
			cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
			const ipd = cameraLPos.distanceTo(cameraRPos);
			const projL = cameraL.projectionMatrix.elements;
			const projR = cameraR.projectionMatrix.elements;

			// VR systems will have identical far and near planes, and
			// most likely identical top and bottom frustum extents.
			// Use the left camera for these values.
			const near = projL[14] / (projL[10] - 1);
			const far = projL[14] / (projL[10] + 1);
			const topFov = (projL[9] + 1) / projL[5];
			const bottomFov = (projL[9] - 1) / projL[5];
			const leftFov = (projL[8] - 1) / projL[0];
			const rightFov = (projR[8] + 1) / projR[0];
			const left = near * leftFov;
			const right = near * rightFov;

			// Calculate the new camera's position offset from the
			// left camera. xOffset should be roughly half `ipd`.
			const zOffset = ipd / (-leftFov + rightFov);
			const xOffset = zOffset * -leftFov;

			// TODO: Better way to apply this offset?
			cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
			camera.translateX(xOffset);
			camera.translateZ(zOffset);
			camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
			camera.matrixWorldInverse.copy(camera.matrixWorld).invert();

			// Find the union of the frustum values of the cameras and scale
			// the values so that the near plane's position does not change in world space,
			// although must now be relative to the new union camera.
			const near2 = near + zOffset;
			const far2 = far + zOffset;
			const left2 = left - xOffset;
			const right2 = right + (ipd - xOffset);
			const top2 = topFov * far / far2 * near2;
			const bottom2 = bottomFov * far / far2 * near2;
			camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
		}
		function updateCamera(camera, parent) {
			if (parent === null) {
				camera.matrixWorld.copy(camera.matrix);
			} else {
				camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
			}
			camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
		}
		this.updateCamera = function (camera) {
			if (session === null) return;
			cameraVR.near = cameraR.near = cameraL.near = camera.near;
			cameraVR.far = cameraR.far = cameraL.far = camera.far;
			if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
				// Note that the new renderState won't apply until the next frame. See #18320

				session.updateRenderState({
					depthNear: cameraVR.near,
					depthFar: cameraVR.far
				});
				_currentDepthNear = cameraVR.near;
				_currentDepthFar = cameraVR.far;
			}
			const parent = camera.parent;
			const cameras = cameraVR.cameras;
			updateCamera(cameraVR, parent);
			for (let i = 0; i < cameras.length; i++) {
				updateCamera(cameras[i], parent);
			}
			cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);

			// update user camera and its children

			camera.matrix.copy(cameraVR.matrix);
			camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
			const children = camera.children;
			for (let i = 0, l = children.length; i < l; i++) {
				children[i].updateMatrixWorld(true);
			}

			// update projection matrix for proper view frustum culling

			if (cameras.length === 2) {
				setProjectionFromUnion(cameraVR, cameraL, cameraR);
			} else {
				// assume single camera setup (AR)

				cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
			}
		};
		this.getCamera = function () {
			return cameraVR;
		};
		this.getFoveation = function () {
			if (glProjLayer !== null) {
				return glProjLayer.fixedFoveation;
			}
			if (glBaseLayer !== null) {
				return glBaseLayer.fixedFoveation;
			}
			return undefined;
		};
		this.setFoveation = function (foveation) {
			// 0 = no foveation = full resolution
			// 1 = maximum foveation = the edges render at lower resolution

			if (glProjLayer !== null) {
				glProjLayer.fixedFoveation = foveation;
			}
			if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {
				glBaseLayer.fixedFoveation = foveation;
			}
		};

		// Animation Loop

		let onAnimationFrameCallback = null;
		function onAnimationFrame(time, frame) {
			pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
			xrFrame = frame;
			if (pose !== null) {
				const views = pose.views;
				if (glBaseLayer !== null) {
					renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
					renderer.setRenderTarget(newRenderTarget);
				}
				let cameraVRNeedsUpdate = false;

				// check if it's necessary to rebuild cameraVR's camera list

				if (views.length !== cameraVR.cameras.length) {
					cameraVR.cameras.length = 0;
					cameraVRNeedsUpdate = true;
				}
				for (let i = 0; i < views.length; i++) {
					const view = views[i];
					let viewport = null;
					if (glBaseLayer !== null) {
						viewport = glBaseLayer.getViewport(view);
					} else {
						const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
						viewport = glSubImage.viewport;

						// For side-by-side projection, we only produce a single texture for both eyes.
						if (i === 0) {
							renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture);
							renderer.setRenderTarget(newRenderTarget);
						}
					}
					let camera = cameras[i];
					if (camera === undefined) {
						camera = new PerspectiveCamera();
						camera.layers.enable(i);
						camera.viewport = new Vector4();
						cameras[i] = camera;
					}
					camera.matrix.fromArray(view.transform.matrix);
					camera.projectionMatrix.fromArray(view.projectionMatrix);
					camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
					if (i === 0) {
						cameraVR.matrix.copy(camera.matrix);
					}
					if (cameraVRNeedsUpdate === true) {
						cameraVR.cameras.push(camera);
					}
				}
			}

			//

			for (let i = 0; i < controllers.length; i++) {
				const inputSource = controllerInputSources[i];
				const controller = controllers[i];
				if (inputSource !== null && controller !== undefined) {
					controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
				}
			}
			if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
			xrFrame = null;
		}
		const animation = new WebGLAnimation();
		animation.setAnimationLoop(onAnimationFrame);
		this.setAnimationLoop = function (callback) {
			onAnimationFrameCallback = callback;
		};
		this.dispose = function () {};
	}
}

function WebGLMaterials(renderer, properties) {
	function refreshFogUniforms(uniforms, fog) {
		uniforms.fogColor.value.copy(fog.color);
		if (fog.isFog) {
			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;
		} else if (fog.isFogExp2) {
			uniforms.fogDensity.value = fog.density;
		}
	}
	function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
		if (material.isMeshBasicMaterial) {
			refreshUniformsCommon(uniforms, material);
		} else if (material.isMeshLambertMaterial) {
			refreshUniformsCommon(uniforms, material);
		} else if (material.isMeshToonMaterial) {
			refreshUniformsCommon(uniforms, material);
			refreshUniformsToon(uniforms, material);
		} else if (material.isMeshPhongMaterial) {
			refreshUniformsCommon(uniforms, material);
			refreshUniformsPhong(uniforms, material);
		} else if (material.isMeshStandardMaterial) {
			refreshUniformsCommon(uniforms, material);
			refreshUniformsStandard(uniforms, material);
			if (material.isMeshPhysicalMaterial) {
				refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
			}
		} else if (material.isMeshMatcapMaterial) {
			refreshUniformsCommon(uniforms, material);
			refreshUniformsMatcap(uniforms, material);
		} else if (material.isMeshDepthMaterial) {
			refreshUniformsCommon(uniforms, material);
		} else if (material.isMeshDistanceMaterial) {
			refreshUniformsCommon(uniforms, material);
			refreshUniformsDistance(uniforms, material);
		} else if (material.isMeshNormalMaterial) {
			refreshUniformsCommon(uniforms, material);
		} else if (material.isLineBasicMaterial) {
			refreshUniformsLine(uniforms, material);
			if (material.isLineDashedMaterial) {
				refreshUniformsDash(uniforms, material);
			}
		} else if (material.isPointsMaterial) {
			refreshUniformsPoints(uniforms, material, pixelRatio, height);
		} else if (material.isSpriteMaterial) {
			refreshUniformsSprites(uniforms, material);
		} else if (material.isShadowMaterial) {
			uniforms.color.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
		} else if (material.isShaderMaterial) {
			material.uniformsNeedUpdate = false; // #15581
		}
	}

	function refreshUniformsCommon(uniforms, material) {
		uniforms.opacity.value = material.opacity;
		if (material.color) {
			uniforms.diffuse.value.copy(material.color);
		}
		if (material.emissive) {
			uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
		}
		if (material.map) {
			uniforms.map.value = material.map;
		}
		if (material.alphaMap) {
			uniforms.alphaMap.value = material.alphaMap;
		}
		if (material.bumpMap) {
			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if (material.side === BackSide) uniforms.bumpScale.value *= -1;
		}
		if (material.displacementMap) {
			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;
		}
		if (material.emissiveMap) {
			uniforms.emissiveMap.value = material.emissiveMap;
		}
		if (material.normalMap) {
			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy(material.normalScale);
			if (material.side === BackSide) uniforms.normalScale.value.negate();
		}
		if (material.specularMap) {
			uniforms.specularMap.value = material.specularMap;
		}
		if (material.alphaTest > 0) {
			uniforms.alphaTest.value = material.alphaTest;
		}
		const envMap = properties.get(material).envMap;
		if (envMap) {
			uniforms.envMap.value = envMap;
			uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
			uniforms.reflectivity.value = material.reflectivity;
			uniforms.ior.value = material.ior;
			uniforms.refractionRatio.value = material.refractionRatio;
		}
		if (material.lightMap) {
			uniforms.lightMap.value = material.lightMap;

			// artist-friendly light intensity scaling factor
			const scaleFactor = renderer.physicallyCorrectLights !== true ? Math.PI : 1;
			uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;
		}
		if (material.aoMap) {
			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;
		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. displacementMap map
		// 4. normal map
		// 5. bump map
		// 6. roughnessMap map
		// 7. metalnessMap map
		// 8. alphaMap map
		// 9. emissiveMap map
		// 10. clearcoat map
		// 11. clearcoat normal map
		// 12. clearcoat roughnessMap map
		// 13. iridescence map
		// 14. iridescence thickness map
		// 15. specular intensity map
		// 16. specular tint map
		// 17. transmission map
		// 18. thickness map

		let uvScaleMap;
		if (material.map) {
			uvScaleMap = material.map;
		} else if (material.specularMap) {
			uvScaleMap = material.specularMap;
		} else if (material.displacementMap) {
			uvScaleMap = material.displacementMap;
		} else if (material.normalMap) {
			uvScaleMap = material.normalMap;
		} else if (material.bumpMap) {
			uvScaleMap = material.bumpMap;
		} else if (material.roughnessMap) {
			uvScaleMap = material.roughnessMap;
		} else if (material.metalnessMap) {
			uvScaleMap = material.metalnessMap;
		} else if (material.alphaMap) {
			uvScaleMap = material.alphaMap;
		} else if (material.emissiveMap) {
			uvScaleMap = material.emissiveMap;
		} else if (material.clearcoatMap) {
			uvScaleMap = material.clearcoatMap;
		} else if (material.clearcoatNormalMap) {
			uvScaleMap = material.clearcoatNormalMap;
		} else if (material.clearcoatRoughnessMap) {
			uvScaleMap = material.clearcoatRoughnessMap;
		} else if (material.iridescenceMap) {
			uvScaleMap = material.iridescenceMap;
		} else if (material.iridescenceThicknessMap) {
			uvScaleMap = material.iridescenceThicknessMap;
		} else if (material.specularIntensityMap) {
			uvScaleMap = material.specularIntensityMap;
		} else if (material.specularColorMap) {
			uvScaleMap = material.specularColorMap;
		} else if (material.transmissionMap) {
			uvScaleMap = material.transmissionMap;
		} else if (material.thicknessMap) {
			uvScaleMap = material.thicknessMap;
		} else if (material.sheenColorMap) {
			uvScaleMap = material.sheenColorMap;
		} else if (material.sheenRoughnessMap) {
			uvScaleMap = material.sheenRoughnessMap;
		}
		if (uvScaleMap !== undefined) {
			// backwards compatibility
			if (uvScaleMap.isWebGLRenderTarget) {
				uvScaleMap = uvScaleMap.texture;
			}
			if (uvScaleMap.matrixAutoUpdate === true) {
				uvScaleMap.updateMatrix();
			}
			uniforms.uvTransform.value.copy(uvScaleMap.matrix);
		}

		// uv repeat and offset setting priorities for uv2
		// 1. ao map
		// 2. light map

		let uv2ScaleMap;
		if (material.aoMap) {
			uv2ScaleMap = material.aoMap;
		} else if (material.lightMap) {
			uv2ScaleMap = material.lightMap;
		}
		if (uv2ScaleMap !== undefined) {
			// backwards compatibility
			if (uv2ScaleMap.isWebGLRenderTarget) {
				uv2ScaleMap = uv2ScaleMap.texture;
			}
			if (uv2ScaleMap.matrixAutoUpdate === true) {
				uv2ScaleMap.updateMatrix();
			}
			uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
		}
	}
	function refreshUniformsLine(uniforms, material) {
		uniforms.diffuse.value.copy(material.color);
		uniforms.opacity.value = material.opacity;
	}
	function refreshUniformsDash(uniforms, material) {
		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;
	}
	function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
		uniforms.diffuse.value.copy(material.color);
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * pixelRatio;
		uniforms.scale.value = height * 0.5;
		if (material.map) {
			uniforms.map.value = material.map;
		}
		if (material.alphaMap) {
			uniforms.alphaMap.value = material.alphaMap;
		}
		if (material.alphaTest > 0) {
			uniforms.alphaTest.value = material.alphaTest;
		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		let uvScaleMap;
		if (material.map) {
			uvScaleMap = material.map;
		} else if (material.alphaMap) {
			uvScaleMap = material.alphaMap;
		}
		if (uvScaleMap !== undefined) {
			if (uvScaleMap.matrixAutoUpdate === true) {
				uvScaleMap.updateMatrix();
			}
			uniforms.uvTransform.value.copy(uvScaleMap.matrix);
		}
	}
	function refreshUniformsSprites(uniforms, material) {
		uniforms.diffuse.value.copy(material.color);
		uniforms.opacity.value = material.opacity;
		uniforms.rotation.value = material.rotation;
		if (material.map) {
			uniforms.map.value = material.map;
		}
		if (material.alphaMap) {
			uniforms.alphaMap.value = material.alphaMap;
		}
		if (material.alphaTest > 0) {
			uniforms.alphaTest.value = material.alphaTest;
		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		let uvScaleMap;
		if (material.map) {
			uvScaleMap = material.map;
		} else if (material.alphaMap) {
			uvScaleMap = material.alphaMap;
		}
		if (uvScaleMap !== undefined) {
			if (uvScaleMap.matrixAutoUpdate === true) {
				uvScaleMap.updateMatrix();
			}
			uniforms.uvTransform.value.copy(uvScaleMap.matrix);
		}
	}
	function refreshUniformsPhong(uniforms, material) {
		uniforms.specular.value.copy(material.specular);
		uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )
	}

	function refreshUniformsToon(uniforms, material) {
		if (material.gradientMap) {
			uniforms.gradientMap.value = material.gradientMap;
		}
	}
	function refreshUniformsStandard(uniforms, material) {
		uniforms.roughness.value = material.roughness;
		uniforms.metalness.value = material.metalness;
		if (material.roughnessMap) {
			uniforms.roughnessMap.value = material.roughnessMap;
		}
		if (material.metalnessMap) {
			uniforms.metalnessMap.value = material.metalnessMap;
		}
		const envMap = properties.get(material).envMap;
		if (envMap) {
			//uniforms.envMap.value = material.envMap; // part of uniforms common
			uniforms.envMapIntensity.value = material.envMapIntensity;
		}
	}
	function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
		uniforms.ior.value = material.ior; // also part of uniforms common

		if (material.sheen > 0) {
			uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
			uniforms.sheenRoughness.value = material.sheenRoughness;
			if (material.sheenColorMap) {
				uniforms.sheenColorMap.value = material.sheenColorMap;
			}
			if (material.sheenRoughnessMap) {
				uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
			}
		}
		if (material.clearcoat > 0) {
			uniforms.clearcoat.value = material.clearcoat;
			uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
			if (material.clearcoatMap) {
				uniforms.clearcoatMap.value = material.clearcoatMap;
			}
			if (material.clearcoatRoughnessMap) {
				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
			}
			if (material.clearcoatNormalMap) {
				uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
				if (material.side === BackSide) {
					uniforms.clearcoatNormalScale.value.negate();
				}
			}
		}
		if (material.iridescence > 0) {
			uniforms.iridescence.value = material.iridescence;
			uniforms.iridescenceIOR.value = material.iridescenceIOR;
			uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
			uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
			if (material.iridescenceMap) {
				uniforms.iridescenceMap.value = material.iridescenceMap;
			}
			if (material.iridescenceThicknessMap) {
				uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
			}
		}
		if (material.transmission > 0) {
			uniforms.transmission.value = material.transmission;
			uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
			uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
			if (material.transmissionMap) {
				uniforms.transmissionMap.value = material.transmissionMap;
			}
			uniforms.thickness.value = material.thickness;
			if (material.thicknessMap) {
				uniforms.thicknessMap.value = material.thicknessMap;
			}
			uniforms.attenuationDistance.value = material.attenuationDistance;
			uniforms.attenuationColor.value.copy(material.attenuationColor);
		}
		uniforms.specularIntensity.value = material.specularIntensity;
		uniforms.specularColor.value.copy(material.specularColor);
		if (material.specularIntensityMap) {
			uniforms.specularIntensityMap.value = material.specularIntensityMap;
		}
		if (material.specularColorMap) {
			uniforms.specularColorMap.value = material.specularColorMap;
		}
	}
	function refreshUniformsMatcap(uniforms, material) {
		if (material.matcap) {
			uniforms.matcap.value = material.matcap;
		}
	}
	function refreshUniformsDistance(uniforms, material) {
		uniforms.referencePosition.value.copy(material.referencePosition);
		uniforms.nearDistance.value = material.nearDistance;
		uniforms.farDistance.value = material.farDistance;
	}
	return {
		refreshFogUniforms: refreshFogUniforms,
		refreshMaterialUniforms: refreshMaterialUniforms
	};
}

function WebGLUniformsGroups(gl, info, capabilities, state) {
	let buffers = {};
	let updateList = {};
	let allocatedBindingPoints = [];
	const maxBindingPoints = capabilities.isWebGL2 ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0; // binding points are global whereas block indices are per shader program

	function bind(uniformsGroup, program) {
		const webglProgram = program.program;
		state.uniformBlockBinding(uniformsGroup, webglProgram);
	}
	function update(uniformsGroup, program) {
		let buffer = buffers[uniformsGroup.id];
		if (buffer === undefined) {
			prepareUniformsGroup(uniformsGroup);
			buffer = createBuffer(uniformsGroup);
			buffers[uniformsGroup.id] = buffer;
			uniformsGroup.addEventListener('dispose', onUniformsGroupsDispose);
		}

		// ensure to update the binding points/block indices mapping for this program

		const webglProgram = program.program;
		state.updateUBOMapping(uniformsGroup, webglProgram);

		// update UBO once per frame

		const frame = info.render.frame;
		if (updateList[uniformsGroup.id] !== frame) {
			updateBufferData(uniformsGroup);
			updateList[uniformsGroup.id] = frame;
		}
	}
	function createBuffer(uniformsGroup) {
		// the setup of an UBO is independent of a particular shader program but global

		const bindingPointIndex = allocateBindingPointIndex();
		uniformsGroup.__bindingPointIndex = bindingPointIndex;
		const buffer = gl.createBuffer();
		const size = uniformsGroup.__size;
		const usage = uniformsGroup.usage;
		gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
		gl.bufferData(gl.UNIFORM_BUFFER, size, usage);
		gl.bindBuffer(gl.UNIFORM_BUFFER, null);
		gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer);
		return buffer;
	}
	function allocateBindingPointIndex() {
		for (let i = 0; i < maxBindingPoints; i++) {
			if (allocatedBindingPoints.indexOf(i) === -1) {
				allocatedBindingPoints.push(i);
				return i;
			}
		}
		console.error('THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.');
		return 0;
	}
	function updateBufferData(uniformsGroup) {
		const buffer = buffers[uniformsGroup.id];
		const uniforms = uniformsGroup.uniforms;
		const cache = uniformsGroup.__cache;
		gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
		for (let i = 0, il = uniforms.length; i < il; i++) {
			const uniform = uniforms[i];

			// partly update the buffer if necessary

			if (hasUniformChanged(uniform, i, cache) === true) {
				const value = uniform.value;
				const offset = uniform.__offset;
				if (typeof value === 'number') {
					uniform.__data[0] = value;
					gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data);
				} else {
					if (uniform.value.isMatrix3) {
						// manually converting 3x3 to 3x4

						uniform.__data[0] = uniform.value.elements[0];
						uniform.__data[1] = uniform.value.elements[1];
						uniform.__data[2] = uniform.value.elements[2];
						uniform.__data[3] = uniform.value.elements[0];
						uniform.__data[4] = uniform.value.elements[3];
						uniform.__data[5] = uniform.value.elements[4];
						uniform.__data[6] = uniform.value.elements[5];
						uniform.__data[7] = uniform.value.elements[0];
						uniform.__data[8] = uniform.value.elements[6];
						uniform.__data[9] = uniform.value.elements[7];
						uniform.__data[10] = uniform.value.elements[8];
						uniform.__data[11] = uniform.value.elements[0];
					} else {
						value.toArray(uniform.__data);
					}
					gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data);
				}
			}
		}
		gl.bindBuffer(gl.UNIFORM_BUFFER, null);
	}
	function hasUniformChanged(uniform, index, cache) {
		const value = uniform.value;
		if (cache[index] === undefined) {
			// cache entry does not exist so far

			if (typeof value === 'number') {
				cache[index] = value;
			} else {
				cache[index] = value.clone();
			}
			return true;
		} else {
			// compare current value with cached entry

			if (typeof value === 'number') {
				if (cache[index] !== value) {
					cache[index] = value;
					return true;
				}
			} else {
				const cachedObject = cache[index];
				if (cachedObject.equals(value) === false) {
					cachedObject.copy(value);
					return true;
				}
			}
		}
		return false;
	}
	function prepareUniformsGroup(uniformsGroup) {
		// determine total buffer size according to the STD140 layout
		// Hint: STD140 is the only supported layout in WebGL 2

		const uniforms = uniformsGroup.uniforms;
		let offset = 0; // global buffer offset in bytes
		const chunkSize = 16; // size of a chunk in bytes
		let chunkOffset = 0; // offset within a single chunk in bytes

		for (let i = 0, l = uniforms.length; i < l; i++) {
			const uniform = uniforms[i];
			const info = getUniformSize(uniform);

			// the following two properties will be used for partial buffer updates

			uniform.__data = new Float32Array(info.storage / Float32Array.BYTES_PER_ELEMENT);
			uniform.__offset = offset;

			//

			if (i > 0) {
				chunkOffset = offset % chunkSize;
				const remainingSizeInChunk = chunkSize - chunkOffset;

				// check for chunk overflow

				if (chunkOffset !== 0 && remainingSizeInChunk - info.boundary < 0) {
					// add padding and adjust offset

					offset += chunkSize - chunkOffset;
					uniform.__offset = offset;
				}
			}
			offset += info.storage;
		}

		// ensure correct final padding

		chunkOffset = offset % chunkSize;
		if (chunkOffset > 0) offset += chunkSize - chunkOffset;

		//

		uniformsGroup.__size = offset;
		uniformsGroup.__cache = {};
		return this;
	}
	function getUniformSize(uniform) {
		const value = uniform.value;
		const info = {
			boundary: 0,
			// bytes
			storage: 0 // bytes
		};

		// determine sizes according to STD140

		if (typeof value === 'number') {
			// float/int

			info.boundary = 4;
			info.storage = 4;
		} else if (value.isVector2) {
			// vec2

			info.boundary = 8;
			info.storage = 8;
		} else if (value.isVector3 || value.isColor) {
			// vec3

			info.boundary = 16;
			info.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes
		} else if (value.isVector4) {
			// vec4

			info.boundary = 16;
			info.storage = 16;
		} else if (value.isMatrix3) {
			// mat3 (in STD140 a 3x3 matrix is represented as 3x4)

			info.boundary = 48;
			info.storage = 48;
		} else if (value.isMatrix4) {
			// mat4

			info.boundary = 64;
			info.storage = 64;
		} else if (value.isTexture) {
			console.warn('THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.');
		} else {
			console.warn('THREE.WebGLRenderer: Unsupported uniform value type.', value);
		}
		return info;
	}
	function onUniformsGroupsDispose(event) {
		const uniformsGroup = event.target;
		uniformsGroup.removeEventListener('dispose', onUniformsGroupsDispose);
		const index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
		allocatedBindingPoints.splice(index, 1);
		gl.deleteBuffer(buffers[uniformsGroup.id]);
		delete buffers[uniformsGroup.id];
		delete updateList[uniformsGroup.id];
	}
	function dispose() {
		for (const id in buffers) {
			gl.deleteBuffer(buffers[id]);
		}
		allocatedBindingPoints = [];
		buffers = {};
		updateList = {};
	}
	return {
		bind: bind,
		update: update,
		dispose: dispose
	};
}

function createCanvasElement() {
	const canvas = createElementNS('canvas');
	canvas.style.display = 'block';
	return canvas;
}
function WebGLRenderer(parameters = {}) {
	this.isWebGLRenderer = true;
	const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
		_context = parameters.context !== undefined ? parameters.context : null,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
		_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
		_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;
	let _alpha;
	if (_context !== null) {
		_alpha = _context.getContextAttributes().alpha;
	} else {
		_alpha = parameters.alpha !== undefined ? parameters.alpha : false;
	}
	let currentRenderList = null;
	let currentRenderState = null;

	// render() can be called from within a callback triggered by another render.
	// We track this so that the nested render call gets its list and state isolated from the parent render call.

	const renderListStack = [];
	const renderStateStack = [];

	// public properties

	this.domElement = _canvas;

	// Debug configuration container
	this.debug = {
		/**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */
		checkShaderErrors: true
	};

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// user-defined clipping

	this.clippingPlanes = [];
	this.localClippingEnabled = false;

	// physically based shading

	this.outputEncoding = LinearEncoding;

	// physical lights

	this.physicallyCorrectLights = false;

	// tone mapping

	this.toneMapping = NoToneMapping;
	this.toneMappingExposure = 1.0;

	//

	Object.defineProperties(this, {
		// @deprecated since r136, 0e21088102b4de7e0a0a33140620b7a3424b9e6d

		gammaFactor: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .gammaFactor has been removed.');
				return 2;
			},
			set: function () {
				console.warn('THREE.WebGLRenderer: .gammaFactor has been removed.');
			}
		}
	});

	// internal properties

	const _this = this;
	let _isContextLost = false;

	// internal state cache

	let _currentActiveCubeFace = 0;
	let _currentActiveMipmapLevel = 0;
	let _currentRenderTarget = null;
	let _currentMaterialId = -1;
	let _currentCamera = null;
	const _currentViewport = new Vector4();
	const _currentScissor = new Vector4();
	let _currentScissorTest = null;

	//

	let _width = _canvas.width;
	let _height = _canvas.height;
	let _pixelRatio = 1;
	let _opaqueSort = null;
	let _transparentSort = null;
	const _viewport = new Vector4(0, 0, _width, _height);
	const _scissor = new Vector4(0, 0, _width, _height);
	let _scissorTest = false;

	// frustum

	const _frustum = new Frustum();

	// clipping

	let _clippingEnabled = false;
	let _localClippingEnabled = false;

	// transmission

	let _transmissionRenderTarget = null;

	// camera matrices cache

	const _projScreenMatrix = new Matrix4();
	const _vector2 = new Vector2();
	const _vector3 = new Vector3();
	const _emptyScene = {
		background: null,
		fog: null,
		environment: null,
		overrideMaterial: null,
		isScene: true
	};
	function getTargetPixelRatio() {
		return _currentRenderTarget === null ? _pixelRatio : 1;
	}

	// initialize

	let _gl = _context;
	function getContext(contextNames, contextAttributes) {
		for (let i = 0; i < contextNames.length; i++) {
			const contextName = contextNames[i];
			const context = _canvas.getContext(contextName, contextAttributes);
			if (context !== null) return context;
		}
		return null;
	}
	try {
		const contextAttributes = {
			alpha: true,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer,
			powerPreference: _powerPreference,
			failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
		};

		// OffscreenCanvas does not have setAttribute, see #22811
		if ('setAttribute' in _canvas) _canvas.setAttribute('data-engine', `three.js r${REVISION}`);

		// event listeners must be registered before WebGL context is created, see #12753
		_canvas.addEventListener('webglcontextlost', onContextLost, false);
		_canvas.addEventListener('webglcontextrestored', onContextRestore, false);
		_canvas.addEventListener('webglcontextcreationerror', onContextCreationError, false);
		if (_gl === null) {
			const contextNames = ['webgl2', 'webgl', 'experimental-webgl'];
			if (_this.isWebGL1Renderer === true) {
				contextNames.shift();
			}
			_gl = getContext(contextNames, contextAttributes);
			if (_gl === null) {
				if (getContext(contextNames)) {
					throw new Error('Error creating WebGL context with your selected attributes.');
				} else {
					throw new Error('Error creating WebGL context.');
				}
			}
		}

		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

		if (_gl.getShaderPrecisionFormat === undefined) {
			_gl.getShaderPrecisionFormat = function () {
				return {
					'rangeMin': 1,
					'rangeMax': 1,
					'precision': 1
				};
			};
		}
	} catch (error) {
		console.error('THREE.WebGLRenderer: ' + error.message);
		throw error;
	}
	let extensions, capabilities, state, info;
	let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
	let programCache, materials, renderLists, renderStates, clipping, shadowMap;
	let background, morphtargets, bufferRenderer, indexedBufferRenderer;
	let utils, bindingStates, uniformsGroups;
	function initGLContext() {
		extensions = new WebGLExtensions(_gl);
		capabilities = new WebGLCapabilities(_gl, extensions, parameters);
		extensions.init(capabilities);
		utils = new WebGLUtils(_gl, extensions, capabilities);
		state = new WebGLState(_gl, extensions, capabilities);
		info = new WebGLInfo(_gl);
		properties = new WebGLProperties();
		textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
		cubemaps = new WebGLCubeMaps(_this);
		cubeuvmaps = new WebGLCubeUVMaps(_this);
		attributes = new WebGLAttributes(_gl, capabilities);
		bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
		geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
		objects = new WebGLObjects(_gl, geometries, attributes, info);
		morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
		clipping = new WebGLClipping(properties);
		programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
		materials = new WebGLMaterials(_this, properties);
		renderLists = new WebGLRenderLists();
		renderStates = new WebGLRenderStates(extensions, capabilities);
		background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, _premultipliedAlpha);
		shadowMap = new WebGLShadowMap(_this, objects, capabilities);
		uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
		bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
		indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
		info.programs = programCache.programs;
		_this.capabilities = capabilities;
		_this.extensions = extensions;
		_this.properties = properties;
		_this.renderLists = renderLists;
		_this.shadowMap = shadowMap;
		_this.state = state;
		_this.info = info;
	}
	initGLContext();

	// xr

	const xr = new WebXRManager(_this, _gl);
	this.xr = xr;

	// API

	this.getContext = function () {
		return _gl;
	};
	this.getContextAttributes = function () {
		return _gl.getContextAttributes();
	};
	this.forceContextLoss = function () {
		const extension = extensions.get('WEBGL_lose_context');
		if (extension) extension.loseContext();
	};
	this.forceContextRestore = function () {
		const extension = extensions.get('WEBGL_lose_context');
		if (extension) extension.restoreContext();
	};
	this.getPixelRatio = function () {
		return _pixelRatio;
	};
	this.setPixelRatio = function (value) {
		if (value === undefined) return;
		_pixelRatio = value;
		this.setSize(_width, _height, false);
	};
	this.getSize = function (target) {
		return target.set(_width, _height);
	};
	this.setSize = function (width, height, updateStyle) {
		if (xr.isPresenting) {
			console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
			return;
		}
		_width = width;
		_height = height;
		_canvas.width = Math.floor(width * _pixelRatio);
		_canvas.height = Math.floor(height * _pixelRatio);
		if (updateStyle !== false) {
			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';
		}
		this.setViewport(0, 0, width, height);
	};
	this.getDrawingBufferSize = function (target) {
		return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
	};
	this.setDrawingBufferSize = function (width, height, pixelRatio) {
		_width = width;
		_height = height;
		_pixelRatio = pixelRatio;
		_canvas.width = Math.floor(width * pixelRatio);
		_canvas.height = Math.floor(height * pixelRatio);
		this.setViewport(0, 0, width, height);
	};
	this.getCurrentViewport = function (target) {
		return target.copy(_currentViewport);
	};
	this.getViewport = function (target) {
		return target.copy(_viewport);
	};
	this.setViewport = function (x, y, width, height) {
		if (x.isVector4) {
			_viewport.set(x.x, x.y, x.z, x.w);
		} else {
			_viewport.set(x, y, width, height);
		}
		state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
	};
	this.getScissor = function (target) {
		return target.copy(_scissor);
	};
	this.setScissor = function (x, y, width, height) {
		if (x.isVector4) {
			_scissor.set(x.x, x.y, x.z, x.w);
		} else {
			_scissor.set(x, y, width, height);
		}
		state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
	};
	this.getScissorTest = function () {
		return _scissorTest;
	};
	this.setScissorTest = function (boolean) {
		state.setScissorTest(_scissorTest = boolean);
	};
	this.setOpaqueSort = function (method) {
		_opaqueSort = method;
	};
	this.setTransparentSort = function (method) {
		_transparentSort = method;
	};

	// Clearing

	this.getClearColor = function (target) {
		return target.copy(background.getClearColor());
	};
	this.setClearColor = function () {
		background.setClearColor.apply(background, arguments);
	};
	this.getClearAlpha = function () {
		return background.getClearAlpha();
	};
	this.setClearAlpha = function () {
		background.setClearAlpha.apply(background, arguments);
	};
	this.clear = function (color = true, depth = true, stencil = true) {
		let bits = 0;
		if (color) bits |= _gl.COLOR_BUFFER_BIT;
		if (depth) bits |= _gl.DEPTH_BUFFER_BIT;
		if (stencil) bits |= _gl.STENCIL_BUFFER_BIT;
		_gl.clear(bits);
	};
	this.clearColor = function () {
		this.clear(true, false, false);
	};
	this.clearDepth = function () {
		this.clear(false, true, false);
	};
	this.clearStencil = function () {
		this.clear(false, false, true);
	};

	//

	this.dispose = function () {
		_canvas.removeEventListener('webglcontextlost', onContextLost, false);
		_canvas.removeEventListener('webglcontextrestored', onContextRestore, false);
		_canvas.removeEventListener('webglcontextcreationerror', onContextCreationError, false);
		renderLists.dispose();
		renderStates.dispose();
		properties.dispose();
		cubemaps.dispose();
		cubeuvmaps.dispose();
		objects.dispose();
		bindingStates.dispose();
		uniformsGroups.dispose();
		programCache.dispose();
		xr.dispose();
		xr.removeEventListener('sessionstart', onXRSessionStart);
		xr.removeEventListener('sessionend', onXRSessionEnd);
		if (_transmissionRenderTarget) {
			_transmissionRenderTarget.dispose();
			_transmissionRenderTarget = null;
		}
		animation.stop();
	};

	// Events

	function onContextLost(event) {
		event.preventDefault();
		console.log('THREE.WebGLRenderer: Context Lost.');
		_isContextLost = true;
	}
	function /* event */
	onContextRestore() {
		console.log('THREE.WebGLRenderer: Context Restored.');
		_isContextLost = false;
		const infoAutoReset = info.autoReset;
		const shadowMapEnabled = shadowMap.enabled;
		const shadowMapAutoUpdate = shadowMap.autoUpdate;
		const shadowMapNeedsUpdate = shadowMap.needsUpdate;
		const shadowMapType = shadowMap.type;
		initGLContext();
		info.autoReset = infoAutoReset;
		shadowMap.enabled = shadowMapEnabled;
		shadowMap.autoUpdate = shadowMapAutoUpdate;
		shadowMap.needsUpdate = shadowMapNeedsUpdate;
		shadowMap.type = shadowMapType;
	}
	function onContextCreationError(event) {
		console.error('THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage);
	}
	function onMaterialDispose(event) {
		const material = event.target;
		material.removeEventListener('dispose', onMaterialDispose);
		deallocateMaterial(material);
	}

	// Buffer deallocation

	function deallocateMaterial(material) {
		releaseMaterialProgramReferences(material);
		properties.remove(material);
	}
	function releaseMaterialProgramReferences(material) {
		const programs = properties.get(material).programs;
		if (programs !== undefined) {
			programs.forEach(function (program) {
				programCache.releaseProgram(program);
			});
			if (material.isShaderMaterial) {
				programCache.releaseShaderCache(material);
			}
		}
	}

	// Buffer rendering

	this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {
		if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

		const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
		const program = setProgram(camera, scene, geometry, material, object);
		state.setMaterial(material, frontFaceCW);

		//

		let index = geometry.index;
		const position = geometry.attributes.position;

		//

		if (index === null) {
			if (position === undefined || position.count === 0) return;
		} else if (index.count === 0) {
			return;
		}

		//

		let rangeFactor = 1;
		if (material.wireframe === true) {
			index = geometries.getWireframeAttribute(geometry);
			rangeFactor = 2;
		}
		bindingStates.setup(object, material, program, geometry, index);
		let attribute;
		let renderer = bufferRenderer;
		if (index !== null) {
			attribute = attributes.get(index);
			renderer = indexedBufferRenderer;
			renderer.setIndex(attribute);
		}

		//

		const dataCount = index !== null ? index.count : position.count;
		const rangeStart = geometry.drawRange.start * rangeFactor;
		const rangeCount = geometry.drawRange.count * rangeFactor;
		const groupStart = group !== null ? group.start * rangeFactor : 0;
		const groupCount = group !== null ? group.count * rangeFactor : Infinity;
		const drawStart = Math.max(rangeStart, groupStart);
		const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
		const drawCount = Math.max(0, drawEnd - drawStart + 1);
		if (drawCount === 0) return;

		//

		if (object.isMesh) {
			if (material.wireframe === true) {
				state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
				renderer.setMode(_gl.LINES);
			} else {
				renderer.setMode(_gl.TRIANGLES);
			}
		} else if (object.isLine) {
			let lineWidth = material.linewidth;
			if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

			state.setLineWidth(lineWidth * getTargetPixelRatio());
			if (object.isLineSegments) {
				renderer.setMode(_gl.LINES);
			} else if (object.isLineLoop) {
				renderer.setMode(_gl.LINE_LOOP);
			} else {
				renderer.setMode(_gl.LINE_STRIP);
			}
		} else if (object.isPoints) {
			renderer.setMode(_gl.POINTS);
		} else if (object.isSprite) {
			renderer.setMode(_gl.TRIANGLES);
		}
		if (object.isInstancedMesh) {
			renderer.renderInstances(drawStart, drawCount, object.count);
		} else if (geometry.isInstancedBufferGeometry) {
			const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
			renderer.renderInstances(drawStart, drawCount, instanceCount);
		} else {
			renderer.render(drawStart, drawCount);
		}
	};

	// Compile

	this.compile = function (scene, camera) {
		function prepare(material, scene, object) {
			if (material.transparent === true && material.side === DoubleSide) {
				material.side = BackSide;
				material.needsUpdate = true;
				getProgram(material, scene, object);
				material.side = FrontSide;
				material.needsUpdate = true;
				getProgram(material, scene, object);
				material.side = DoubleSide;
			} else {
				getProgram(material, scene, object);
			}
		}
		currentRenderState = renderStates.get(scene);
		currentRenderState.init();
		renderStateStack.push(currentRenderState);
		scene.traverseVisible(function (object) {
			if (object.isLight && object.layers.test(camera.layers)) {
				currentRenderState.pushLight(object);
				if (object.castShadow) {
					currentRenderState.pushShadow(object);
				}
			}
		});
		currentRenderState.setupLights(_this.physicallyCorrectLights);
		scene.traverse(function (object) {
			const material = object.material;
			if (material) {
				if (Array.isArray(material)) {
					for (let i = 0; i < material.length; i++) {
						const material2 = material[i];
						prepare(material2, scene, object);
					}
				} else {
					prepare(material, scene, object);
				}
			}
		});
		renderStateStack.pop();
		currentRenderState = null;
	};

	// Animation Loop

	let onAnimationFrameCallback = null;
	function onAnimationFrame(time) {
		if (onAnimationFrameCallback) onAnimationFrameCallback(time);
	}
	function onXRSessionStart() {
		animation.stop();
	}
	function onXRSessionEnd() {
		animation.start();
	}
	const animation = new WebGLAnimation();
	animation.setAnimationLoop(onAnimationFrame);
	if (typeof self !== 'undefined') animation.setContext(self);
	this.setAnimationLoop = function (callback) {
		onAnimationFrameCallback = callback;
		xr.setAnimationLoop(callback);
		callback === null ? animation.stop() : animation.start();
	};
	xr.addEventListener('sessionstart', onXRSessionStart);
	xr.addEventListener('sessionend', onXRSessionEnd);

	// Rendering

	this.render = function (scene, camera) {
		if (camera !== undefined && camera.isCamera !== true) {
			console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
			return;
		}
		if (_isContextLost === true) return;

		// update scene graph

		if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
		if (xr.enabled === true && xr.isPresenting === true) {
			if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
			camera = xr.getCamera(); // use XR camera for rendering
		}

		//
		if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
		currentRenderState = renderStates.get(scene, renderStateStack.length);
		currentRenderState.init();
		renderStateStack.push(currentRenderState);
		_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
		_frustum.setFromProjectionMatrix(_projScreenMatrix);
		_localClippingEnabled = this.localClippingEnabled;
		_clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
		currentRenderList = renderLists.get(scene, renderListStack.length);
		currentRenderList.init();
		renderListStack.push(currentRenderList);
		projectObject(scene, camera, 0, _this.sortObjects);
		currentRenderList.finish();
		if (_this.sortObjects === true) {
			currentRenderList.sort(_opaqueSort, _transparentSort);
		}

		//

		if (_clippingEnabled === true) clipping.beginShadows();
		const shadowsArray = currentRenderState.state.shadowsArray;
		shadowMap.render(shadowsArray, scene, camera);
		if (_clippingEnabled === true) clipping.endShadows();

		//

		if (this.info.autoReset === true) this.info.reset();

		//

		background.render(currentRenderList, scene);

		// render scene

		currentRenderState.setupLights(_this.physicallyCorrectLights);
		if (camera.isArrayCamera) {
			const cameras = camera.cameras;
			for (let i = 0, l = cameras.length; i < l; i++) {
				const camera2 = cameras[i];
				renderScene(currentRenderList, scene, camera2, camera2.viewport);
			}
		} else {
			renderScene(currentRenderList, scene, camera);
		}

		//

		if (_currentRenderTarget !== null) {
			// resolve multisample renderbuffers to a single-sample texture if necessary

			textures.updateMultisampleRenderTarget(_currentRenderTarget);

			// Generate mipmap if we're using any kind of mipmap filtering

			textures.updateRenderTargetMipmap(_currentRenderTarget);
		}

		//

		if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);

		// _gl.finish();

		bindingStates.resetDefaultState();
		_currentMaterialId = -1;
		_currentCamera = null;
		renderStateStack.pop();
		if (renderStateStack.length > 0) {
			currentRenderState = renderStateStack[renderStateStack.length - 1];
		} else {
			currentRenderState = null;
		}
		renderListStack.pop();
		if (renderListStack.length > 0) {
			currentRenderList = renderListStack[renderListStack.length - 1];
		} else {
			currentRenderList = null;
		}
	};
	function projectObject(object, camera, groupOrder, sortObjects) {
		if (object.visible === false) return;
		const visible = object.layers.test(camera.layers);
		if (visible) {
			if (object.isGroup) {
				groupOrder = object.renderOrder;
			} else if (object.isLOD) {
				if (object.autoUpdate === true) object.update(camera);
			} else if (object.isLight) {
				currentRenderState.pushLight(object);
				if (object.castShadow) {
					currentRenderState.pushShadow(object);
				}
			} else if (object.isSprite) {
				if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
					if (sortObjects) {
						_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
					}
					const geometry = objects.update(object);
					const material = object.material;
					if (material.visible) {
						currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
					}
				}
			} else if (object.isMesh || object.isLine || object.isPoints) {
				if (object.isSkinnedMesh) {
					// update skeleton only once in a frame

					if (object.skeleton.frame !== info.render.frame) {
						object.skeleton.update();
						object.skeleton.frame = info.render.frame;
					}
				}
				if (!object.frustumCulled || _frustum.intersectsObject(object)) {
					if (sortObjects) {
						_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
					}
					const geometry = objects.update(object);
					const material = object.material;
					if (Array.isArray(material)) {
						const groups = geometry.groups;
						for (let i = 0, l = groups.length; i < l; i++) {
							const group = groups[i];
							const groupMaterial = material[group.materialIndex];
							if (groupMaterial && groupMaterial.visible) {
								currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
							}
						}
					} else if (material.visible) {
						currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
					}
				}
			}
		}
		const children = object.children;
		for (let i = 0, l = children.length; i < l; i++) {
			projectObject(children[i], camera, groupOrder, sortObjects);
		}
	}
	function renderScene(currentRenderList, scene, camera, viewport) {
		const opaqueObjects = currentRenderList.opaque;
		const transmissiveObjects = currentRenderList.transmissive;
		const transparentObjects = currentRenderList.transparent;
		currentRenderState.setupLightsView(camera);
		if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, scene, camera);
		if (viewport) state.viewport(_currentViewport.copy(viewport));
		if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
		if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);
		if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.buffers.depth.setTest(true);
		state.buffers.depth.setMask(true);
		state.buffers.color.setMask(true);
		state.setPolygonOffset(false);
	}
	function renderTransmissionPass(opaqueObjects, scene, camera) {
		const isWebGL2 = capabilities.isWebGL2;
		if (_transmissionRenderTarget === null) {
			_transmissionRenderTarget = new WebGLRenderTarget(1, 1, {
				generateMipmaps: true,
				type: extensions.has('EXT_color_buffer_half_float') ? HalfFloatType : UnsignedByteType,
				minFilter: LinearMipmapLinearFilter,
				samples: isWebGL2 && _antialias === true ? 4 : 0
			});
		}
		_this.getDrawingBufferSize(_vector2);
		if (isWebGL2) {
			_transmissionRenderTarget.setSize(_vector2.x, _vector2.y);
		} else {
			_transmissionRenderTarget.setSize(floorPowerOfTwo(_vector2.x), floorPowerOfTwo(_vector2.y));
		}

		//

		const currentRenderTarget = _this.getRenderTarget();
		_this.setRenderTarget(_transmissionRenderTarget);
		_this.clear();

		// Turn off the features which can affect the frag color for opaque objects pass.
		// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
		const currentToneMapping = _this.toneMapping;
		_this.toneMapping = NoToneMapping;
		renderObjects(opaqueObjects, scene, camera);
		_this.toneMapping = currentToneMapping;
		textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
		textures.updateRenderTargetMipmap(_transmissionRenderTarget);
		_this.setRenderTarget(currentRenderTarget);
	}
	function renderObjects(renderList, scene, camera) {
		const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
		for (let i = 0, l = renderList.length; i < l; i++) {
			const renderItem = renderList[i];
			const object = renderItem.object;
			const geometry = renderItem.geometry;
			const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
			const group = renderItem.group;
			if (object.layers.test(camera.layers)) {
				renderObject(object, scene, camera, geometry, material, group);
			}
		}
	}
	function renderObject(object, scene, camera, geometry, material, group) {
		object.onBeforeRender(_this, scene, camera, geometry, material, group);
		object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
		object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
		material.onBeforeRender(_this, scene, camera, geometry, object, group);
		if (material.transparent === true && material.side === DoubleSide) {
			material.side = BackSide;
			material.needsUpdate = true;
			_this.renderBufferDirect(camera, scene, geometry, material, object, group);
			material.side = FrontSide;
			material.needsUpdate = true;
			_this.renderBufferDirect(camera, scene, geometry, material, object, group);
			material.side = DoubleSide;
		} else {
			_this.renderBufferDirect(camera, scene, geometry, material, object, group);
		}
		object.onAfterRender(_this, scene, camera, geometry, material, group);
	}
	function getProgram(material, scene, object) {
		if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		const materialProperties = properties.get(material);
		const lights = currentRenderState.state.lights;
		const shadowsArray = currentRenderState.state.shadowsArray;
		const lightsStateVersion = lights.state.version;
		const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
		const programCacheKey = programCache.getProgramCacheKey(parameters);
		let programs = materialProperties.programs;

		// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

		materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
		materialProperties.fog = scene.fog;
		materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
		if (programs === undefined) {
			// new material

			material.addEventListener('dispose', onMaterialDispose);
			programs = new Map();
			materialProperties.programs = programs;
		}
		let program = programs.get(programCacheKey);
		if (program !== undefined) {
			// early out if program and light state is identical

			if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
				updateCommonMaterialProperties(material, parameters);
				return program;
			}
		} else {
			parameters.uniforms = programCache.getUniforms(material);
			material.onBuild(object, parameters, _this);
			material.onBeforeCompile(parameters, _this);
			program = programCache.acquireProgram(parameters, programCacheKey);
			programs.set(programCacheKey, program);
			materialProperties.uniforms = parameters.uniforms;
		}
		const uniforms = materialProperties.uniforms;
		if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
			uniforms.clippingPlanes = clipping.uniform;
		}
		updateCommonMaterialProperties(material, parameters);

		// store the light setup it was created for

		materialProperties.needsLights = materialNeedsLights(material);
		materialProperties.lightsStateVersion = lightsStateVersion;
		if (materialProperties.needsLights) {
			// wire up the material to this renderer's lighting state

			uniforms.ambientLightColor.value = lights.state.ambient;
			uniforms.lightProbe.value = lights.state.probe;
			uniforms.directionalLights.value = lights.state.directional;
			uniforms.directionalLightShadows.value = lights.state.directionalShadow;
			uniforms.spotLights.value = lights.state.spot;
			uniforms.spotLightShadows.value = lights.state.spotShadow;
			uniforms.rectAreaLights.value = lights.state.rectArea;
			uniforms.ltc_1.value = lights.state.rectAreaLTC1;
			uniforms.ltc_2.value = lights.state.rectAreaLTC2;
			uniforms.pointLights.value = lights.state.point;
			uniforms.pointLightShadows.value = lights.state.pointShadow;
			uniforms.hemisphereLights.value = lights.state.hemi;
			uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
			uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
			uniforms.spotShadowMap.value = lights.state.spotShadowMap;
			uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
			uniforms.spotLightMap.value = lights.state.spotLightMap;
			uniforms.pointShadowMap.value = lights.state.pointShadowMap;
			uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
			// TODO (abelnation): add area lights shadow info to uniforms
		}

		const progUniforms = program.getUniforms();
		const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
		materialProperties.currentProgram = program;
		materialProperties.uniformsList = uniformsList;
		return program;
	}
	function updateCommonMaterialProperties(material, parameters) {
		const materialProperties = properties.get(material);
		materialProperties.outputEncoding = parameters.outputEncoding;
		materialProperties.instancing = parameters.instancing;
		materialProperties.skinning = parameters.skinning;
		materialProperties.morphTargets = parameters.morphTargets;
		materialProperties.morphNormals = parameters.morphNormals;
		materialProperties.morphColors = parameters.morphColors;
		materialProperties.morphTargetsCount = parameters.morphTargetsCount;
		materialProperties.numClippingPlanes = parameters.numClippingPlanes;
		materialProperties.numIntersection = parameters.numClipIntersection;
		materialProperties.vertexAlphas = parameters.vertexAlphas;
		materialProperties.vertexTangents = parameters.vertexTangents;
		materialProperties.toneMapping = parameters.toneMapping;
	}
	function setProgram(camera, scene, geometry, material, object) {
		if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		textures.resetTextureUnits();
		const fog = scene.fog;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;
		const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding;
		const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
		const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
		const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
		const morphTargets = !!geometry.morphAttributes.position;
		const morphNormals = !!geometry.morphAttributes.normal;
		const morphColors = !!geometry.morphAttributes.color;
		const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;
		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
		const materialProperties = properties.get(material);
		const lights = currentRenderState.state.lights;
		if (_clippingEnabled === true) {
			if (_localClippingEnabled === true || camera !== _currentCamera) {
				const useCache = camera === _currentCamera && material.id === _currentMaterialId;

				// we might want to call this function with some ClippingGroup
				// object instead of the material, once it becomes feasible
				// (#8465, #8379)
				clipping.setState(material, camera, useCache);
			}
		}

		//

		let needsProgramChange = false;
		if (material.version === materialProperties.__version) {
			if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
				needsProgramChange = true;
			} else if (materialProperties.outputEncoding !== encoding) {
				needsProgramChange = true;
			} else if (object.isInstancedMesh && materialProperties.instancing === false) {
				needsProgramChange = true;
			} else if (!object.isInstancedMesh && materialProperties.instancing === true) {
				needsProgramChange = true;
			} else if (object.isSkinnedMesh && materialProperties.skinning === false) {
				needsProgramChange = true;
			} else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
				needsProgramChange = true;
			} else if (materialProperties.envMap !== envMap) {
				needsProgramChange = true;
			} else if (material.fog === true && materialProperties.fog !== fog) {
				needsProgramChange = true;
			} else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
				needsProgramChange = true;
			} else if (materialProperties.vertexAlphas !== vertexAlphas) {
				needsProgramChange = true;
			} else if (materialProperties.vertexTangents !== vertexTangents) {
				needsProgramChange = true;
			} else if (materialProperties.morphTargets !== morphTargets) {
				needsProgramChange = true;
			} else if (materialProperties.morphNormals !== morphNormals) {
				needsProgramChange = true;
			} else if (materialProperties.morphColors !== morphColors) {
				needsProgramChange = true;
			} else if (materialProperties.toneMapping !== toneMapping) {
				needsProgramChange = true;
			} else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
				needsProgramChange = true;
			}
		} else {
			needsProgramChange = true;
			materialProperties.__version = material.version;
		}

		//

		let program = materialProperties.currentProgram;
		if (needsProgramChange === true) {
			program = getProgram(material, scene, object);
		}
		let refreshProgram = false;
		let refreshMaterial = false;
		let refreshLights = false;
		const p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.uniforms;
		if (state.useProgram(program.program)) {
			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;
		}
		if (material.id !== _currentMaterialId) {
			_currentMaterialId = material.id;
			refreshMaterial = true;
		}
		if (refreshProgram || _currentCamera !== camera) {
			p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);
			if (capabilities.logarithmicDepthBuffer) {
				p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
			}
			if (_currentCamera !== camera) {
				_currentCamera = camera;

				// lighting uniforms depend on the camera so enforce an update
				// now, in case this material supports lights - or later, when
				// the next material that does gets activated:

				refreshMaterial = true; // set to true on material change
				refreshLights = true; // remains set until update done
			}

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
				const uCamPos = p_uniforms.map.cameraPosition;
				if (uCamPos !== undefined) {
					uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
				}
			}
			if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
				p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
			}
			if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
				p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
			}
		}

		// skinning and morph target uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone and morph texture must go before other textures
		// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures

		if (object.isSkinnedMesh) {
			p_uniforms.setOptional(_gl, object, 'bindMatrix');
			p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
			const skeleton = object.skeleton;
			if (skeleton) {
				if (capabilities.floatVertexTextures) {
					if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
					p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
					p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
				} else {
					console.warn('THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.');
				}
			}
		}
		const morphAttributes = geometry.morphAttributes;
		if (morphAttributes.position !== undefined || morphAttributes.normal !== undefined || morphAttributes.color !== undefined && capabilities.isWebGL2 === true) {
			morphtargets.update(object, geometry, material, program);
		}
		if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
			materialProperties.receiveShadow = object.receiveShadow;
			p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
		}

		// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512

		if (material.isMeshGouraudMaterial && material.envMap !== null) {
			m_uniforms.envMap.value = envMap;
			m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
		}
		if (refreshMaterial) {
			p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
			if (materialProperties.needsLights) {
				// the current material requires lighting info

				// note: all lighting uniforms are always set correctly
				// they simply reference the renderer's state for their
				// values
				//
				// use the current material's .needsUpdate flags to set
				// the GL state when required

				markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
			}

			// refresh uniforms common to several materials

			if (fog && material.fog === true) {
				materials.refreshFogUniforms(m_uniforms, fog);
			}
			materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
			WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
		}
		if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
			WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
			material.uniformsNeedUpdate = false;
		}
		if (material.isSpriteMaterial) {
			p_uniforms.setValue(_gl, 'center', object.center);
		}

		// common matrices

		p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
		p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
		p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);

		// UBOs

		if (material.isShaderMaterial || material.isRawShaderMaterial) {
			const groups = material.uniformsGroups;
			for (let i = 0, l = groups.length; i < l; i++) {
				if (capabilities.isWebGL2) {
					const group = groups[i];
					uniformsGroups.update(group, program);
					uniformsGroups.bind(group, program);
				} else {
					console.warn('THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.');
				}
			}
		}
		return program;
	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate(uniforms, value) {
		uniforms.ambientLightColor.needsUpdate = value;
		uniforms.lightProbe.needsUpdate = value;
		uniforms.directionalLights.needsUpdate = value;
		uniforms.directionalLightShadows.needsUpdate = value;
		uniforms.pointLights.needsUpdate = value;
		uniforms.pointLightShadows.needsUpdate = value;
		uniforms.spotLights.needsUpdate = value;
		uniforms.spotLightShadows.needsUpdate = value;
		uniforms.rectAreaLights.needsUpdate = value;
		uniforms.hemisphereLights.needsUpdate = value;
	}
	function materialNeedsLights(material) {
		return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
	}
	this.getActiveCubeFace = function () {
		return _currentActiveCubeFace;
	};
	this.getActiveMipmapLevel = function () {
		return _currentActiveMipmapLevel;
	};
	this.getRenderTarget = function () {
		return _currentRenderTarget;
	};
	this.setRenderTargetTextures = function (renderTarget, colorTexture, depthTexture) {
		properties.get(renderTarget.texture).__webglTexture = colorTexture;
		properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
		const renderTargetProperties = properties.get(renderTarget);
		renderTargetProperties.__hasExternalTextures = true;
		if (renderTargetProperties.__hasExternalTextures) {
			renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;
			if (!renderTargetProperties.__autoAllocateDepthBuffer) {
				// The multisample_render_to_texture extension doesn't work properly if there
				// are midframe flushes and an external depth buffer. Disable use of the extension.
				if (extensions.has('WEBGL_multisampled_render_to_texture') === true) {
					console.warn('THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided');
					renderTargetProperties.__useRenderToTexture = false;
				}
			}
		}
	};
	this.setRenderTargetFramebuffer = function (renderTarget, defaultFramebuffer) {
		const renderTargetProperties = properties.get(renderTarget);
		renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
		renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;
	};
	this.setRenderTarget = function (renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
		_currentRenderTarget = renderTarget;
		_currentActiveCubeFace = activeCubeFace;
		_currentActiveMipmapLevel = activeMipmapLevel;
		let useDefaultFramebuffer = true;
		let framebuffer = null;
		let isCube = false;
		let isRenderTarget3D = false;
		if (renderTarget) {
			const renderTargetProperties = properties.get(renderTarget);
			if (renderTargetProperties.__useDefaultFramebuffer !== undefined) {
				// We need to make sure to rebind the framebuffer.
				state.bindFramebuffer(_gl.FRAMEBUFFER, null);
				useDefaultFramebuffer = false;
			} else if (renderTargetProperties.__webglFramebuffer === undefined) {
				textures.setupRenderTarget(renderTarget);
			} else if (renderTargetProperties.__hasExternalTextures) {
				// Color and depth texture must be rebound in order for the swapchain to update.
				textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
			}
			const texture = renderTarget.texture;
			if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
				isRenderTarget3D = true;
			}
			const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
			if (renderTarget.isWebGLCubeRenderTarget) {
				framebuffer = __webglFramebuffer[activeCubeFace];
				isCube = true;
			} else if (capabilities.isWebGL2 && renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
				framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
			} else {
				framebuffer = __webglFramebuffer;
			}
			_currentViewport.copy(renderTarget.viewport);
			_currentScissor.copy(renderTarget.scissor);
			_currentScissorTest = renderTarget.scissorTest;
		} else {
			_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
			_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
			_currentScissorTest = _scissorTest;
		}
		const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
		if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
			state.drawBuffers(renderTarget, framebuffer);
		}
		state.viewport(_currentViewport);
		state.scissor(_currentScissor);
		state.setScissorTest(_currentScissorTest);
		if (isCube) {
			const textureProperties = properties.get(renderTarget.texture);
			_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
		} else if (isRenderTarget3D) {
			const textureProperties = properties.get(renderTarget.texture);
			const layer = activeCubeFace || 0;
			_gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
		}
		_currentMaterialId = -1; // reset current material to ensure correct uniform bindings
	};

	this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
		if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
			console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
			return;
		}
		let framebuffer = properties.get(renderTarget).__webglFramebuffer;
		if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
			framebuffer = framebuffer[activeCubeFaceIndex];
		}
		if (framebuffer) {
			state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
			try {
				const texture = renderTarget.texture;
				const textureFormat = texture.format;
				const textureType = texture.type;
				if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
					console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
					return;
				}
				const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));
				if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) &&
				// Edge and Chrome Mac < 52 (#9513)
				!(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) &&
				// Chrome Mac >= 52 and Firefox
				!halfFloatSupportedByExt) {
					console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
					return;
				}

				// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

				if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
					_gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
				}
			} finally {
				// restore framebuffer of current render target if necessary

				const framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
				state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
			}
		}
	};
	this.copyFramebufferToTexture = function (position, texture, level = 0) {
		const levelScale = Math.pow(2, -level);
		const width = Math.floor(texture.image.width * levelScale);
		const height = Math.floor(texture.image.height * levelScale);
		textures.setTexture2D(texture, 0);
		_gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height);
		state.unbindTexture();
	};
	this.copyTextureToTexture = function (position, srcTexture, dstTexture, level = 0) {
		const width = srcTexture.image.width;
		const height = srcTexture.image.height;
		const glFormat = utils.convert(dstTexture.format);
		const glType = utils.convert(dstTexture.type);
		textures.setTexture2D(dstTexture, 0);

		// As another texture upload may have changed pixelStorei
		// parameters, make sure they are correct for the dstTexture
		_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
		_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
		_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
		if (srcTexture.isDataTexture) {
			_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
		} else {
			if (srcTexture.isCompressedTexture) {
				_gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
			} else {
				_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);
			}
		}

		// Generate mipmaps only when copying level 0
		if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);
		state.unbindTexture();
	};
	this.copyTextureToTexture3D = function (sourceBox, position, srcTexture, dstTexture, level = 0) {
		if (_this.isWebGL1Renderer) {
			console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');
			return;
		}
		const width = sourceBox.max.x - sourceBox.min.x + 1;
		const height = sourceBox.max.y - sourceBox.min.y + 1;
		const depth = sourceBox.max.z - sourceBox.min.z + 1;
		const glFormat = utils.convert(dstTexture.format);
		const glType = utils.convert(dstTexture.type);
		let glTarget;
		if (dstTexture.isData3DTexture) {
			textures.setTexture3D(dstTexture, 0);
			glTarget = _gl.TEXTURE_3D;
		} else if (dstTexture.isDataArrayTexture) {
			textures.setTexture2DArray(dstTexture, 0);
			glTarget = _gl.TEXTURE_2D_ARRAY;
		} else {
			console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');
			return;
		}
		_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
		_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
		_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
		const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
		const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
		const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
		const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
		const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
		const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
		_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
		_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
		_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);
		_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);
		_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);
		if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
			_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
		} else {
			if (srcTexture.isCompressedArrayTexture) {
				console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.');
				_gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
			} else {
				_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
			}
		}
		_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);
		_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);
		_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);
		_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);
		_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages);

		// Generate mipmaps only when copying level 0
		if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
		state.unbindTexture();
	};
	this.initTexture = function (texture) {
		if (texture.isCubeTexture) {
			textures.setTextureCube(texture, 0);
		} else if (texture.isData3DTexture) {
			textures.setTexture3D(texture, 0);
		} else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
			textures.setTexture2DArray(texture, 0);
		} else {
			textures.setTexture2D(texture, 0);
		}
		state.unbindTexture();
	};
	this.resetState = function () {
		_currentActiveCubeFace = 0;
		_currentActiveMipmapLevel = 0;
		_currentRenderTarget = null;
		state.reset();
		bindingStates.reset();
	};
	if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
		__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
			detail: this
		}));
	}
}

class Fog {
	constructor(color, near = 1, far = 1000) {
		this.isFog = true;
		this.name = '';
		this.color = new Color$1(color);
		this.near = near;
		this.far = far;
	}
	clone() {
		return new Fog(this.color, this.near, this.far);
	}
	toJSON( /* meta */
	) {
		return {
			type: 'Fog',
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};
	}
}

class Scene extends Object3D {
	constructor() {
		super();
		this.isScene = true;
		this.type = 'Scene';
		this.background = null;
		this.environment = null;
		this.fog = null;
		this.backgroundBlurriness = 0;
		this.overrideMaterial = null;
		if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
			__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
				detail: this
			}));
		}
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		if (source.background !== null) this.background = source.background.clone();
		if (source.environment !== null) this.environment = source.environment.clone();
		if (source.fog !== null) this.fog = source.fog.clone();
		this.backgroundBlurriness = source.backgroundBlurriness;
		if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
		this.matrixAutoUpdate = source.matrixAutoUpdate;
		return this;
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		if (this.fog !== null) data.object.fog = this.fog.toJSON();
		if (this.backgroundBlurriness > 0) data.backgroundBlurriness = this.backgroundBlurriness;
		return data;
	}

	// @deprecated

	get autoUpdate() {
		console.warn('THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.');
		return this.matrixWorldAutoUpdate;
	}
	set autoUpdate(value) {
		console.warn('THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.');
		this.matrixWorldAutoUpdate = value;
	}
}

class LineBasicMaterial extends Material {
	constructor(parameters) {
		super();
		this.isLineBasicMaterial = true;
		this.type = 'LineBasicMaterial';
		this.color = new Color$1(0xffffff);
		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;
		this.fog = source.fog;
		return this;
	}
}

const _start$1 = /*@__PURE__*/new Vector3();
const _end$1 = /*@__PURE__*/new Vector3();
const _inverseMatrix$1 = /*@__PURE__*/new Matrix4();
const _ray$1 = /*@__PURE__*/new Ray();
const _sphere$1 = /*@__PURE__*/new Sphere();
class Line extends Object3D {
	constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
		super();
		this.isLine = true;
		this.type = 'Line';
		this.geometry = geometry;
		this.material = material;
		this.updateMorphTargets();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.material = source.material;
		this.geometry = source.geometry;
		return this;
	}
	computeLineDistances() {
		const geometry = this.geometry;

		// we assume non-indexed geometry

		if (geometry.index === null) {
			const positionAttribute = geometry.attributes.position;
			const lineDistances = [0];
			for (let i = 1, l = positionAttribute.count; i < l; i++) {
				_start$1.fromBufferAttribute(positionAttribute, i - 1);
				_end$1.fromBufferAttribute(positionAttribute, i);
				lineDistances[i] = lineDistances[i - 1];
				lineDistances[i] += _start$1.distanceTo(_end$1);
			}
			geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
		} else {
			console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
		}
		return this;
	}
	raycast(raycaster, intersects) {
		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Line.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
		_sphere$1.copy(geometry.boundingSphere);
		_sphere$1.applyMatrix4(matrixWorld);
		_sphere$1.radius += threshold;
		if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;

		//

		_inverseMatrix$1.copy(matrixWorld).invert();
		_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
		const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
		const localThresholdSq = localThreshold * localThreshold;
		const vStart = new Vector3();
		const vEnd = new Vector3();
		const interSegment = new Vector3();
		const interRay = new Vector3();
		const step = this.isLineSegments ? 2 : 1;
		const index = geometry.index;
		const attributes = geometry.attributes;
		const positionAttribute = attributes.position;
		if (index !== null) {
			const start = Math.max(0, drawRange.start);
			const end = Math.min(index.count, drawRange.start + drawRange.count);
			for (let i = start, l = end - 1; i < l; i += step) {
				const a = index.getX(i);
				const b = index.getX(i + 1);
				vStart.fromBufferAttribute(positionAttribute, a);
				vEnd.fromBufferAttribute(positionAttribute, b);
				const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
				if (distSq > localThresholdSq) continue;
				interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

				const distance = raycaster.ray.origin.distanceTo(interRay);
				if (distance < raycaster.near || distance > raycaster.far) continue;
				intersects.push({
					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4(this.matrixWorld),
					index: i,
					face: null,
					faceIndex: null,
					object: this
				});
			}
		} else {
			const start = Math.max(0, drawRange.start);
			const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
			for (let i = start, l = end - 1; i < l; i += step) {
				vStart.fromBufferAttribute(positionAttribute, i);
				vEnd.fromBufferAttribute(positionAttribute, i + 1);
				const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
				if (distSq > localThresholdSq) continue;
				interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

				const distance = raycaster.ray.origin.distanceTo(interRay);
				if (distance < raycaster.near || distance > raycaster.far) continue;
				intersects.push({
					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4(this.matrixWorld),
					index: i,
					face: null,
					faceIndex: null,
					object: this
				});
			}
		}
	}
	updateMorphTargets() {
		const geometry = this.geometry;
		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys(morphAttributes);
		if (keys.length > 0) {
			const morphAttribute = morphAttributes[keys[0]];
			if (morphAttribute !== undefined) {
				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};
				for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
					const name = morphAttribute[m].name || String(m);
					this.morphTargetInfluences.push(0);
					this.morphTargetDictionary[name] = m;
				}
			}
		}
	}
}

const _start = /*@__PURE__*/new Vector3();
const _end = /*@__PURE__*/new Vector3();
class LineSegments extends Line {
	constructor(geometry, material) {
		super(geometry, material);
		this.isLineSegments = true;
		this.type = 'LineSegments';
	}
	computeLineDistances() {
		const geometry = this.geometry;

		// we assume non-indexed geometry

		if (geometry.index === null) {
			const positionAttribute = geometry.attributes.position;
			const lineDistances = [];
			for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
				_start.fromBufferAttribute(positionAttribute, i);
				_end.fromBufferAttribute(positionAttribute, i + 1);
				lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
				lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
			}
			geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
		} else {
			console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
		}
		return this;
	}
}

class PointsMaterial extends Material {
	constructor(parameters) {
		super();
		this.isPointsMaterial = true;
		this.type = 'PointsMaterial';
		this.color = new Color$1(0xffffff);
		this.map = null;
		this.alphaMap = null;
		this.size = 1;
		this.sizeAttenuation = true;
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.map = source.map;
		this.alphaMap = source.alphaMap;
		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;
		this.fog = source.fog;
		return this;
	}
}

const _inverseMatrix = /*@__PURE__*/new Matrix4();
const _ray = /*@__PURE__*/new Ray();
const _sphere = /*@__PURE__*/new Sphere();
const _position = /*@__PURE__*/new Vector3();
class Points extends Object3D {
	constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
		super();
		this.isPoints = true;
		this.type = 'Points';
		this.geometry = geometry;
		this.material = material;
		this.updateMorphTargets();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.material = source.material;
		this.geometry = source.geometry;
		return this;
	}
	raycast(raycaster, intersects) {
		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Points.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
		_sphere.copy(geometry.boundingSphere);
		_sphere.applyMatrix4(matrixWorld);
		_sphere.radius += threshold;
		if (raycaster.ray.intersectsSphere(_sphere) === false) return;

		//

		_inverseMatrix.copy(matrixWorld).invert();
		_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
		const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
		const localThresholdSq = localThreshold * localThreshold;
		const index = geometry.index;
		const attributes = geometry.attributes;
		const positionAttribute = attributes.position;
		if (index !== null) {
			const start = Math.max(0, drawRange.start);
			const end = Math.min(index.count, drawRange.start + drawRange.count);
			for (let i = start, il = end; i < il; i++) {
				const a = index.getX(i);
				_position.fromBufferAttribute(positionAttribute, a);
				testPoint(_position, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
			}
		} else {
			const start = Math.max(0, drawRange.start);
			const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
			for (let i = start, l = end; i < l; i++) {
				_position.fromBufferAttribute(positionAttribute, i);
				testPoint(_position, i, localThresholdSq, matrixWorld, raycaster, intersects, this);
			}
		}
	}
	updateMorphTargets() {
		const geometry = this.geometry;
		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys(morphAttributes);
		if (keys.length > 0) {
			const morphAttribute = morphAttributes[keys[0]];
			if (morphAttribute !== undefined) {
				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};
				for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
					const name = morphAttribute[m].name || String(m);
					this.morphTargetInfluences.push(0);
					this.morphTargetDictionary[name] = m;
				}
			}
		}
	}
}
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
	const rayPointDistanceSq = _ray.distanceSqToPoint(point);
	if (rayPointDistanceSq < localThresholdSq) {
		const intersectPoint = new Vector3();
		_ray.closestPointToPoint(point, intersectPoint);
		intersectPoint.applyMatrix4(matrixWorld);
		const distance = raycaster.ray.origin.distanceTo(intersectPoint);
		if (distance < raycaster.near || distance > raycaster.far) return;
		intersects.push({
			distance: distance,
			distanceToRay: Math.sqrt(rayPointDistanceSq),
			point: intersectPoint,
			index: index,
			face: null,
			object: object
		});
	}
}

class DataTexture extends Texture {
	constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
		super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
		this.isDataTexture = true;
		this.image = {
			data: data,
			width: width,
			height: height
		};
		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;
	}
}

class CanvasTexture extends Texture {
	constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
		super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
		this.isCanvasTexture = true;
		this.needsUpdate = true;
	}
}

/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

class Curve {
	constructor() {
		this.type = 'Curve';
		this.arcLengthDivisions = 200;
	}

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint( /* t, optionalTarget */
	) {
		console.warn('THREE.Curve: .getPoint() not implemented.');
		return null;
	}

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt(u, optionalTarget) {
		const t = this.getUtoTmapping(u);
		return this.getPoint(t, optionalTarget);
	}

	// Get sequence of points using getPoint( t )

	getPoints(divisions = 5) {
		const points = [];
		for (let d = 0; d <= divisions; d++) {
			points.push(this.getPoint(d / divisions));
		}
		return points;
	}

	// Get sequence of points using getPointAt( u )

	getSpacedPoints(divisions = 5) {
		const points = [];
		for (let d = 0; d <= divisions; d++) {
			points.push(this.getPointAt(d / divisions));
		}
		return points;
	}

	// Get total curve arc length

	getLength() {
		const lengths = this.getLengths();
		return lengths[lengths.length - 1];
	}

	// Get list of cumulative segment lengths

	getLengths(divisions = this.arcLengthDivisions) {
		if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
			return this.cacheArcLengths;
		}
		this.needsUpdate = false;
		const cache = [];
		let current,
			last = this.getPoint(0);
		let sum = 0;
		cache.push(0);
		for (let p = 1; p <= divisions; p++) {
			current = this.getPoint(p / divisions);
			sum += current.distanceTo(last);
			cache.push(sum);
			last = current;
		}
		this.cacheArcLengths = cache;
		return cache; // { sums: cache, sum: sum }; Sum is in the last element.
	}

	updateArcLengths() {
		this.needsUpdate = true;
		this.getLengths();
	}

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping(u, distance) {
		const arcLengths = this.getLengths();
		let i = 0;
		const il = arcLengths.length;
		let targetArcLength; // The targeted u distance value to get

		if (distance) {
			targetArcLength = distance;
		} else {
			targetArcLength = u * arcLengths[il - 1];
		}

		// binary search for the index with largest value smaller than target u distance

		let low = 0,
			high = il - 1,
			comparison;
		while (low <= high) {
			i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[i] - targetArcLength;
			if (comparison < 0) {
				low = i + 1;
			} else if (comparison > 0) {
				high = i - 1;
			} else {
				high = i;
				break;

				// DONE
			}
		}

		i = high;
		if (arcLengths[i] === targetArcLength) {
			return i / (il - 1);
		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		const lengthBefore = arcLengths[i];
		const lengthAfter = arcLengths[i + 1];
		const segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;

		// add that fractional amount to t

		const t = (i + segmentFraction) / (il - 1);
		return t;
	}

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent(t, optionalTarget) {
		const delta = 0.0001;
		let t1 = t - delta;
		let t2 = t + delta;

		// Capping in case of danger

		if (t1 < 0) t1 = 0;
		if (t2 > 1) t2 = 1;
		const pt1 = this.getPoint(t1);
		const pt2 = this.getPoint(t2);
		const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
		tangent.copy(pt2).sub(pt1).normalize();
		return tangent;
	}
	getTangentAt(u, optionalTarget) {
		const t = this.getUtoTmapping(u);
		return this.getTangent(t, optionalTarget);
	}
	computeFrenetFrames(segments, closed) {
		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

		const normal = new Vector3();
		const tangents = [];
		const normals = [];
		const binormals = [];
		const vec = new Vector3();
		const mat = new Matrix4();

		// compute the tangent vectors for each segment on the curve

		for (let i = 0; i <= segments; i++) {
			const u = i / segments;
			tangents[i] = this.getTangentAt(u, new Vector3());
		}

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the minimum tangent xyz component

		normals[0] = new Vector3();
		binormals[0] = new Vector3();
		let min = Number.MAX_VALUE;
		const tx = Math.abs(tangents[0].x);
		const ty = Math.abs(tangents[0].y);
		const tz = Math.abs(tangents[0].z);
		if (tx <= min) {
			min = tx;
			normal.set(1, 0, 0);
		}
		if (ty <= min) {
			min = ty;
			normal.set(0, 1, 0);
		}
		if (tz <= min) {
			normal.set(0, 0, 1);
		}
		vec.crossVectors(tangents[0], normal).normalize();
		normals[0].crossVectors(tangents[0], vec);
		binormals[0].crossVectors(tangents[0], normals[0]);

		// compute the slowly-varying normal and binormal vectors for each segment on the curve

		for (let i = 1; i <= segments; i++) {
			normals[i] = normals[i - 1].clone();
			binormals[i] = binormals[i - 1].clone();
			vec.crossVectors(tangents[i - 1], tangents[i]);
			if (vec.length() > Number.EPSILON) {
				vec.normalize();
				const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors

				normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
			}
			binormals[i].crossVectors(tangents[i], normals[i]);
		}

		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if (closed === true) {
			let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
			theta /= segments;
			if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
				theta = -theta;
			}
			for (let i = 1; i <= segments; i++) {
				// twist a little...
				normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
				binormals[i].crossVectors(tangents[i], normals[i]);
			}
		}
		return {
			tangents: tangents,
			normals: normals,
			binormals: binormals
		};
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(source) {
		this.arcLengthDivisions = source.arcLengthDivisions;
		return this;
	}
	toJSON() {
		const data = {
			metadata: {
				version: 4.5,
				type: 'Curve',
				generator: 'Curve.toJSON'
			}
		};
		data.arcLengthDivisions = this.arcLengthDivisions;
		data.type = this.type;
		return data;
	}
	fromJSON(json) {
		this.arcLengthDivisions = json.arcLengthDivisions;
		return this;
	}
}

class EllipseCurve extends Curve {
	constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
		super();
		this.isEllipseCurve = true;
		this.type = 'EllipseCurve';
		this.aX = aX;
		this.aY = aY;
		this.xRadius = xRadius;
		this.yRadius = yRadius;
		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;
		this.aClockwise = aClockwise;
		this.aRotation = aRotation;
	}
	getPoint(t, optionalTarget) {
		const point = optionalTarget || new Vector2();
		const twoPi = Math.PI * 2;
		let deltaAngle = this.aEndAngle - this.aStartAngle;
		const samePoints = Math.abs(deltaAngle) < Number.EPSILON;

		// ensures that deltaAngle is 0 .. 2 PI
		while (deltaAngle < 0) deltaAngle += twoPi;
		while (deltaAngle > twoPi) deltaAngle -= twoPi;
		if (deltaAngle < Number.EPSILON) {
			if (samePoints) {
				deltaAngle = 0;
			} else {
				deltaAngle = twoPi;
			}
		}
		if (this.aClockwise === true && !samePoints) {
			if (deltaAngle === twoPi) {
				deltaAngle = -twoPi;
			} else {
				deltaAngle = deltaAngle - twoPi;
			}
		}
		const angle = this.aStartAngle + t * deltaAngle;
		let x = this.aX + this.xRadius * Math.cos(angle);
		let y = this.aY + this.yRadius * Math.sin(angle);
		if (this.aRotation !== 0) {
			const cos = Math.cos(this.aRotation);
			const sin = Math.sin(this.aRotation);
			const tx = x - this.aX;
			const ty = y - this.aY;

			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;
		}
		return point.set(x, y);
	}
	copy(source) {
		super.copy(source);
		this.aX = source.aX;
		this.aY = source.aY;
		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;
		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;
		this.aClockwise = source.aClockwise;
		this.aRotation = source.aRotation;
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.aX = this.aX;
		data.aY = this.aY;
		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;
		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;
		data.aClockwise = this.aClockwise;
		data.aRotation = this.aRotation;
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.aX = json.aX;
		this.aY = json.aY;
		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;
		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;
		this.aClockwise = json.aClockwise;
		this.aRotation = json.aRotation;
		return this;
	}
}

class ArcCurve extends EllipseCurve {
	constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
		super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
		this.isArcCurve = true;
		this.type = 'ArcCurve';
	}
}

/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {
	let c0 = 0,
		c1 = 0,
		c2 = 0,
		c3 = 0;

	/*
	 * Compute coefficients for a cubic polynomial
	 *	 p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *	 p(0) = x0, p(1) = x1
	 *	and
	 *	 p'(0) = t0, p'(1) = t1.
	 */
	function init(x0, x1, t0, t1) {
		c0 = x0;
		c1 = t0;
		c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
		c3 = 2 * x0 - 2 * x1 + t0 + t1;
	}
	return {
		initCatmullRom: function (x0, x1, x2, x3, tension) {
			init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
		},
		initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
			// compute tangents when parameterized in [t1,t2]
			let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
			let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;
			init(x1, x2, t1, t2);
		},
		calc: function (t) {
			const t2 = t * t;
			const t3 = t2 * t;
			return c0 + c1 * t + c2 * t2 + c3 * t3;
		}
	};
}

//

const tmp = /*@__PURE__*/new Vector3();
const px = /*@__PURE__*/new CubicPoly();
const py = /*@__PURE__*/new CubicPoly();
const pz = /*@__PURE__*/new CubicPoly();
class CatmullRomCurve3 extends Curve {
	constructor(points = [], closed = false, curveType = 'centripetal', tension = 0.5) {
		super();
		this.isCatmullRomCurve3 = true;
		this.type = 'CatmullRomCurve3';
		this.points = points;
		this.closed = closed;
		this.curveType = curveType;
		this.tension = tension;
	}
	getPoint(t, optionalTarget = new Vector3()) {
		const point = optionalTarget;
		const points = this.points;
		const l = points.length;
		const p = (l - (this.closed ? 0 : 1)) * t;
		let intPoint = Math.floor(p);
		let weight = p - intPoint;
		if (this.closed) {
			intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
		} else if (weight === 0 && intPoint === l - 1) {
			intPoint = l - 2;
			weight = 1;
		}
		let p0, p3; // 4 points (p1 & p2 defined below)

		if (this.closed || intPoint > 0) {
			p0 = points[(intPoint - 1) % l];
		} else {
			// extrapolate first point
			tmp.subVectors(points[0], points[1]).add(points[0]);
			p0 = tmp;
		}
		const p1 = points[intPoint % l];
		const p2 = points[(intPoint + 1) % l];
		if (this.closed || intPoint + 2 < l) {
			p3 = points[(intPoint + 2) % l];
		} else {
			// extrapolate last point
			tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
			p3 = tmp;
		}
		if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
			// init Centripetal / Chordal Catmull-Rom
			const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
			let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
			let dt2 = Math.pow(p2.distanceToSquared(p3), pow);

			// safety check for repeated points
			if (dt1 < 1e-4) dt1 = 1.0;
			if (dt0 < 1e-4) dt0 = dt1;
			if (dt2 < 1e-4) dt2 = dt1;
			px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
			py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
			pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
		} else if (this.curveType === 'catmullrom') {
			px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
			py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
			pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
		}
		point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
		return point;
	}
	copy(source) {
		super.copy(source);
		this.points = [];
		for (let i = 0, l = source.points.length; i < l; i++) {
			const point = source.points[i];
			this.points.push(point.clone());
		}
		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.points = [];
		for (let i = 0, l = this.points.length; i < l; i++) {
			const point = this.points[i];
			data.points.push(point.toArray());
		}
		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.points = [];
		for (let i = 0, l = json.points.length; i < l; i++) {
			const point = json.points[i];
			this.points.push(new Vector3().fromArray(point));
		}
		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;
		return this;
	}
}

/**
 * Bezier Curves formulas obtained from
 * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
 */

function CatmullRom(t, p0, p1, p2, p3) {
	const v0 = (p2 - p0) * 0.5;
	const v1 = (p3 - p1) * 0.5;
	const t2 = t * t;
	const t3 = t * t2;
	return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}

//

function QuadraticBezierP0(t, p) {
	const k = 1 - t;
	return k * k * p;
}
function QuadraticBezierP1(t, p) {
	return 2 * (1 - t) * t * p;
}
function QuadraticBezierP2(t, p) {
	return t * t * p;
}
function QuadraticBezier(t, p0, p1, p2) {
	return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
}

//

function CubicBezierP0(t, p) {
	const k = 1 - t;
	return k * k * k * p;
}
function CubicBezierP1(t, p) {
	const k = 1 - t;
	return 3 * k * k * t * p;
}
function CubicBezierP2(t, p) {
	return 3 * (1 - t) * t * t * p;
}
function CubicBezierP3(t, p) {
	return t * t * t * p;
}
function CubicBezier(t, p0, p1, p2, p3) {
	return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}

class CubicBezierCurve extends Curve {
	constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
		super();
		this.isCubicBezierCurve = true;
		this.type = 'CubicBezierCurve';
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;
	}
	getPoint(t, optionalTarget = new Vector2()) {
		const point = optionalTarget;
		const v0 = this.v0,
			v1 = this.v1,
			v2 = this.v2,
			v3 = this.v3;
		point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
		return point;
	}
	copy(source) {
		super.copy(source);
		this.v0.copy(source.v0);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);
		this.v3.copy(source.v3);
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.v0.fromArray(json.v0);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);
		this.v3.fromArray(json.v3);
		return this;
	}
}

class CubicBezierCurve3 extends Curve {
	constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
		super();
		this.isCubicBezierCurve3 = true;
		this.type = 'CubicBezierCurve3';
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;
	}
	getPoint(t, optionalTarget = new Vector3()) {
		const point = optionalTarget;
		const v0 = this.v0,
			v1 = this.v1,
			v2 = this.v2,
			v3 = this.v3;
		point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
		return point;
	}
	copy(source) {
		super.copy(source);
		this.v0.copy(source.v0);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);
		this.v3.copy(source.v3);
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.v0.fromArray(json.v0);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);
		this.v3.fromArray(json.v3);
		return this;
	}
}

class LineCurve extends Curve {
	constructor(v1 = new Vector2(), v2 = new Vector2()) {
		super();
		this.isLineCurve = true;
		this.type = 'LineCurve';
		this.v1 = v1;
		this.v2 = v2;
	}
	getPoint(t, optionalTarget = new Vector2()) {
		const point = optionalTarget;
		if (t === 1) {
			point.copy(this.v2);
		} else {
			point.copy(this.v2).sub(this.v1);
			point.multiplyScalar(t).add(this.v1);
		}
		return point;
	}

	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt(u, optionalTarget) {
		return this.getPoint(u, optionalTarget);
	}
	getTangent(t, optionalTarget) {
		const tangent = optionalTarget || new Vector2();
		tangent.copy(this.v2).sub(this.v1).normalize();
		return tangent;
	}
	copy(source) {
		super.copy(source);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);
		return this;
	}
}

class LineCurve3 extends Curve {
	constructor(v1 = new Vector3(), v2 = new Vector3()) {
		super();
		this.isLineCurve3 = true;
		this.type = 'LineCurve3';
		this.v1 = v1;
		this.v2 = v2;
	}
	getPoint(t, optionalTarget = new Vector3()) {
		const point = optionalTarget;
		if (t === 1) {
			point.copy(this.v2);
		} else {
			point.copy(this.v2).sub(this.v1);
			point.multiplyScalar(t).add(this.v1);
		}
		return point;
	}
	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt(u, optionalTarget) {
		return this.getPoint(u, optionalTarget);
	}
	copy(source) {
		super.copy(source);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);
		return this;
	}
}

class QuadraticBezierCurve extends Curve {
	constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
		super();
		this.isQuadraticBezierCurve = true;
		this.type = 'QuadraticBezierCurve';
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
	}
	getPoint(t, optionalTarget = new Vector2()) {
		const point = optionalTarget;
		const v0 = this.v0,
			v1 = this.v1,
			v2 = this.v2;
		point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
		return point;
	}
	copy(source) {
		super.copy(source);
		this.v0.copy(source.v0);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.v0.fromArray(json.v0);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);
		return this;
	}
}

class QuadraticBezierCurve3 extends Curve {
	constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
		super();
		this.isQuadraticBezierCurve3 = true;
		this.type = 'QuadraticBezierCurve3';
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
	}
	getPoint(t, optionalTarget = new Vector3()) {
		const point = optionalTarget;
		const v0 = this.v0,
			v1 = this.v1,
			v2 = this.v2;
		point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
		return point;
	}
	copy(source) {
		super.copy(source);
		this.v0.copy(source.v0);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.v0.fromArray(json.v0);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);
		return this;
	}
}

class SplineCurve extends Curve {
	constructor(points = []) {
		super();
		this.isSplineCurve = true;
		this.type = 'SplineCurve';
		this.points = points;
	}
	getPoint(t, optionalTarget = new Vector2()) {
		const point = optionalTarget;
		const points = this.points;
		const p = (points.length - 1) * t;
		const intPoint = Math.floor(p);
		const weight = p - intPoint;
		const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
		const p1 = points[intPoint];
		const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
		const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
		point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
		return point;
	}
	copy(source) {
		super.copy(source);
		this.points = [];
		for (let i = 0, l = source.points.length; i < l; i++) {
			const point = source.points[i];
			this.points.push(point.clone());
		}
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.points = [];
		for (let i = 0, l = this.points.length; i < l; i++) {
			const point = this.points[i];
			data.points.push(point.toArray());
		}
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.points = [];
		for (let i = 0, l = json.points.length; i < l; i++) {
			const point = json.points[i];
			this.points.push(new Vector2().fromArray(point));
		}
		return this;
	}
}

var Curves = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ArcCurve: ArcCurve,
	CatmullRomCurve3: CatmullRomCurve3,
	CubicBezierCurve: CubicBezierCurve,
	CubicBezierCurve3: CubicBezierCurve3,
	EllipseCurve: EllipseCurve,
	LineCurve: LineCurve,
	LineCurve3: LineCurve3,
	QuadraticBezierCurve: QuadraticBezierCurve,
	QuadraticBezierCurve3: QuadraticBezierCurve3,
	SplineCurve: SplineCurve
});

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *	curves, but retains the api of a curve
 **************************************************************/

class CurvePath extends Curve {
	constructor() {
		super();
		this.type = 'CurvePath';
		this.curves = [];
		this.autoClose = false; // Automatically closes the path
	}

	add(curve) {
		this.curves.push(curve);
	}
	closePath() {
		// Add a line curve if start and end of lines are not connected
		const startPoint = this.curves[0].getPoint(0);
		const endPoint = this.curves[this.curves.length - 1].getPoint(1);
		if (!startPoint.equals(endPoint)) {
			this.curves.push(new LineCurve(endPoint, startPoint));
		}
	}

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	getPoint(t, optionalTarget) {
		const d = t * this.getLength();
		const curveLengths = this.getCurveLengths();
		let i = 0;

		// To think about boundaries points.

		while (i < curveLengths.length) {
			if (curveLengths[i] >= d) {
				const diff = curveLengths[i] - d;
				const curve = this.curves[i];
				const segmentLength = curve.getLength();
				const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
				return curve.getPointAt(u, optionalTarget);
			}
			i++;
		}
		return null;

		// loop where sum != 0, sum > d , sum+1 <d
	}

	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	getLength() {
		const lens = this.getCurveLengths();
		return lens[lens.length - 1];
	}

	// cacheLengths must be recalculated.
	updateArcLengths() {
		this.needsUpdate = true;
		this.cacheLengths = null;
		this.getCurveLengths();
	}

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	getCurveLengths() {
		// We use cache values if curves and cache array are same length

		if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
			return this.cacheLengths;
		}

		// Get length of sub-curve
		// Push sums into cached array

		const lengths = [];
		let sums = 0;
		for (let i = 0, l = this.curves.length; i < l; i++) {
			sums += this.curves[i].getLength();
			lengths.push(sums);
		}
		this.cacheLengths = lengths;
		return lengths;
	}
	getSpacedPoints(divisions = 40) {
		const points = [];
		for (let i = 0; i <= divisions; i++) {
			points.push(this.getPoint(i / divisions));
		}
		if (this.autoClose) {
			points.push(points[0]);
		}
		return points;
	}
	getPoints(divisions = 12) {
		const points = [];
		let last;
		for (let i = 0, curves = this.curves; i < curves.length; i++) {
			const curve = curves[i];
			const resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
			const pts = curve.getPoints(resolution);
			for (let j = 0; j < pts.length; j++) {
				const point = pts[j];
				if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

				points.push(point);
				last = point;
			}
		}
		if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
			points.push(points[0]);
		}
		return points;
	}
	copy(source) {
		super.copy(source);
		this.curves = [];
		for (let i = 0, l = source.curves.length; i < l; i++) {
			const curve = source.curves[i];
			this.curves.push(curve.clone());
		}
		this.autoClose = source.autoClose;
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.autoClose = this.autoClose;
		data.curves = [];
		for (let i = 0, l = this.curves.length; i < l; i++) {
			const curve = this.curves[i];
			data.curves.push(curve.toJSON());
		}
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.autoClose = json.autoClose;
		this.curves = [];
		for (let i = 0, l = json.curves.length; i < l; i++) {
			const curve = json.curves[i];
			this.curves.push(new Curves[curve.type]().fromJSON(curve));
		}
		return this;
	}
}

class Path extends CurvePath {
	constructor(points) {
		super();
		this.type = 'Path';
		this.currentPoint = new Vector2();
		if (points) {
			this.setFromPoints(points);
		}
	}
	setFromPoints(points) {
		this.moveTo(points[0].x, points[0].y);
		for (let i = 1, l = points.length; i < l; i++) {
			this.lineTo(points[i].x, points[i].y);
		}
		return this;
	}
	moveTo(x, y) {
		this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?

		return this;
	}
	lineTo(x, y) {
		const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
		this.curves.push(curve);
		this.currentPoint.set(x, y);
		return this;
	}
	quadraticCurveTo(aCPx, aCPy, aX, aY) {
		const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
		this.curves.push(curve);
		this.currentPoint.set(aX, aY);
		return this;
	}
	bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
		const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
		this.curves.push(curve);
		this.currentPoint.set(aX, aY);
		return this;
	}
	splineThru(pts /*Array of Vector*/) {
		const npts = [this.currentPoint.clone()].concat(pts);
		const curve = new SplineCurve(npts);
		this.curves.push(curve);
		this.currentPoint.copy(pts[pts.length - 1]);
		return this;
	}
	arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;
		this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
		return this;
	}
	absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
		this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
		return this;
	}
	ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;
		this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
		return this;
	}
	absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
		const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
		if (this.curves.length > 0) {
			// if a previous curve is present, attempt to join
			const firstPoint = curve.getPoint(0);
			if (!firstPoint.equals(this.currentPoint)) {
				this.lineTo(firstPoint.x, firstPoint.y);
			}
		}
		this.curves.push(curve);
		const lastPoint = curve.getPoint(1);
		this.currentPoint.copy(lastPoint);
		return this;
	}
	copy(source) {
		super.copy(source);
		this.currentPoint.copy(source.currentPoint);
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.currentPoint = this.currentPoint.toArray();
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.currentPoint.fromArray(json.currentPoint);
		return this;
	}
}

class CircleGeometry extends BufferGeometry {
	constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
		super();
		this.type = 'CircleGeometry';
		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
		segments = Math.max(3, segments);

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const uv = new Vector2();

		// center point

		vertices.push(0, 0, 0);
		normals.push(0, 0, 1);
		uvs.push(0.5, 0.5);
		for (let s = 0, i = 3; s <= segments; s++, i += 3) {
			const segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos(segment);
			vertex.y = radius * Math.sin(segment);
			vertices.push(vertex.x, vertex.y, vertex.z);

			// normal

			normals.push(0, 0, 1);

			// uvs

			uv.x = (vertices[i] / radius + 1) / 2;
			uv.y = (vertices[i + 1] / radius + 1) / 2;
			uvs.push(uv.x, uv.y);
		}

		// indices

		for (let i = 1; i <= segments; i++) {
			indices.push(i, i + 1, 0);
		}

		// build geometry

		this.setIndex(indices);
		this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
	}
	static fromJSON(data) {
		return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
	}
}

class CylinderGeometry extends BufferGeometry {
	constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
		super();
		this.type = 'CylinderGeometry';
		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
		const scope = this;
		radialSegments = Math.floor(radialSegments);
		heightSegments = Math.floor(heightSegments);

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let index = 0;
		const indexArray = [];
		const halfHeight = height / 2;
		let groupStart = 0;

		// generate geometry

		generateTorso();
		if (openEnded === false) {
			if (radiusTop > 0) generateCap(true);
			if (radiusBottom > 0) generateCap(false);
		}

		// build geometry

		this.setIndex(indices);
		this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		function generateTorso() {
			const normal = new Vector3();
			const vertex = new Vector3();
			let groupCount = 0;

			// this will be used to calculate the normal
			const slope = (radiusBottom - radiusTop) / height;

			// generate vertices, normals and uvs

			for (let y = 0; y <= heightSegments; y++) {
				const indexRow = [];
				const v = y / heightSegments;

				// calculate the radius of the current row

				const radius = v * (radiusBottom - radiusTop) + radiusTop;
				for (let x = 0; x <= radialSegments; x++) {
					const u = x / radialSegments;
					const theta = u * thetaLength + thetaStart;
					const sinTheta = Math.sin(theta);
					const cosTheta = Math.cos(theta);

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = -v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push(vertex.x, vertex.y, vertex.z);

					// normal

					normal.set(sinTheta, slope, cosTheta).normalize();
					normals.push(normal.x, normal.y, normal.z);

					// uv

					uvs.push(u, 1 - v);

					// save index of vertex in respective row

					indexRow.push(index++);
				}

				// now save vertices of the row in our index array

				indexArray.push(indexRow);
			}

			// generate indices

			for (let x = 0; x < radialSegments; x++) {
				for (let y = 0; y < heightSegments; y++) {
					// we use the index array to access the correct indices

					const a = indexArray[y][x];
					const b = indexArray[y + 1][x];
					const c = indexArray[y + 1][x + 1];
					const d = indexArray[y][x + 1];

					// faces

					indices.push(a, b, d);
					indices.push(b, c, d);

					// update group counter

					groupCount += 6;
				}
			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup(groupStart, groupCount, 0);

			// calculate new start value for groups

			groupStart += groupCount;
		}
		function generateCap(top) {
			// save the index of the first center vertex
			const centerIndexStart = index;
			const uv = new Vector2();
			const vertex = new Vector3();
			let groupCount = 0;
			const radius = top === true ? radiusTop : radiusBottom;
			const sign = top === true ? 1 : -1;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for (let x = 1; x <= radialSegments; x++) {
				// vertex

				vertices.push(0, halfHeight * sign, 0);

				// normal

				normals.push(0, sign, 0);

				// uv

				uvs.push(0.5, 0.5);

				// increase index

				index++;
			}

			// save the index of the last center vertex
			const centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for (let x = 0; x <= radialSegments; x++) {
				const u = x / radialSegments;
				const theta = u * thetaLength + thetaStart;
				const cosTheta = Math.cos(theta);
				const sinTheta = Math.sin(theta);

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push(vertex.x, vertex.y, vertex.z);

				// normal

				normals.push(0, sign, 0);

				// uv

				uv.x = cosTheta * 0.5 + 0.5;
				uv.y = sinTheta * 0.5 * sign + 0.5;
				uvs.push(uv.x, uv.y);

				// increase index

				index++;
			}

			// generate indices

			for (let x = 0; x < radialSegments; x++) {
				const c = centerIndexStart + x;
				const i = centerIndexEnd + x;
				if (top === true) {
					// face top

					indices.push(i, i + 1, c);
				} else {
					// face bottom

					indices.push(i + 1, i, c);
				}
				groupCount += 3;
			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);

			// calculate new start value for groups

			groupStart += groupCount;
		}
	}
	static fromJSON(data) {
		return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
	}
}

class PolyhedronGeometry extends BufferGeometry {
	constructor(vertices = [], indices = [], radius = 1, detail = 0) {
		super();
		this.type = 'PolyhedronGeometry';
		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		// default buffer data

		const vertexBuffer = [];
		const uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide(detail);

		// all vertices should lie on a conceptual sphere with a given radius

		applyRadius(radius);

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
		this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));
		if (detail === 0) {
			this.computeVertexNormals(); // flat normals
		} else {
			this.normalizeNormals(); // smooth normals
		}

		// helper functions

		function subdivide(detail) {
			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			// iterate over all faces and apply a subdivison with the given detail value

			for (let i = 0; i < indices.length; i += 3) {
				// get the vertices of the face

				getVertexByIndex(indices[i + 0], a);
				getVertexByIndex(indices[i + 1], b);
				getVertexByIndex(indices[i + 2], c);

				// perform subdivision

				subdivideFace(a, b, c, detail);
			}
		}
		function subdivideFace(a, b, c, detail) {
			const cols = detail + 1;

			// we use this multidimensional array as a data structure for creating the subdivision

			const v = [];

			// construct all of the vertices for this subdivision

			for (let i = 0; i <= cols; i++) {
				v[i] = [];
				const aj = a.clone().lerp(c, i / cols);
				const bj = b.clone().lerp(c, i / cols);
				const rows = cols - i;
				for (let j = 0; j <= rows; j++) {
					if (j === 0 && i === cols) {
						v[i][j] = aj;
					} else {
						v[i][j] = aj.clone().lerp(bj, j / rows);
					}
				}
			}

			// construct all of the faces

			for (let i = 0; i < cols; i++) {
				for (let j = 0; j < 2 * (cols - i) - 1; j++) {
					const k = Math.floor(j / 2);
					if (j % 2 === 0) {
						pushVertex(v[i][k + 1]);
						pushVertex(v[i + 1][k]);
						pushVertex(v[i][k]);
					} else {
						pushVertex(v[i][k + 1]);
						pushVertex(v[i + 1][k + 1]);
						pushVertex(v[i + 1][k]);
					}
				}
			}
		}
		function applyRadius(radius) {
			const vertex = new Vector3();

			// iterate over the entire buffer and apply the radius to each vertex

			for (let i = 0; i < vertexBuffer.length; i += 3) {
				vertex.x = vertexBuffer[i + 0];
				vertex.y = vertexBuffer[i + 1];
				vertex.z = vertexBuffer[i + 2];
				vertex.normalize().multiplyScalar(radius);
				vertexBuffer[i + 0] = vertex.x;
				vertexBuffer[i + 1] = vertex.y;
				vertexBuffer[i + 2] = vertex.z;
			}
		}
		function generateUVs() {
			const vertex = new Vector3();
			for (let i = 0; i < vertexBuffer.length; i += 3) {
				vertex.x = vertexBuffer[i + 0];
				vertex.y = vertexBuffer[i + 1];
				vertex.z = vertexBuffer[i + 2];
				const u = azimuth(vertex) / 2 / Math.PI + 0.5;
				const v = inclination(vertex) / Math.PI + 0.5;
				uvBuffer.push(u, 1 - v);
			}
			correctUVs();
			correctSeam();
		}
		function correctSeam() {
			// handle case when face straddles the seam, see #3269

			for (let i = 0; i < uvBuffer.length; i += 6) {
				// uv data of a single face

				const x0 = uvBuffer[i + 0];
				const x1 = uvBuffer[i + 2];
				const x2 = uvBuffer[i + 4];
				const max = Math.max(x0, x1, x2);
				const min = Math.min(x0, x1, x2);

				// 0.9 is somewhat arbitrary

				if (max > 0.9 && min < 0.1) {
					if (x0 < 0.2) uvBuffer[i + 0] += 1;
					if (x1 < 0.2) uvBuffer[i + 2] += 1;
					if (x2 < 0.2) uvBuffer[i + 4] += 1;
				}
			}
		}
		function pushVertex(vertex) {
			vertexBuffer.push(vertex.x, vertex.y, vertex.z);
		}
		function getVertexByIndex(index, vertex) {
			const stride = index * 3;
			vertex.x = vertices[stride + 0];
			vertex.y = vertices[stride + 1];
			vertex.z = vertices[stride + 2];
		}
		function correctUVs() {
			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();
			const centroid = new Vector3();
			const uvA = new Vector2();
			const uvB = new Vector2();
			const uvC = new Vector2();
			for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
				a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
				b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
				c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
				uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
				uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
				uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
				centroid.copy(a).add(b).add(c).divideScalar(3);
				const azi = azimuth(centroid);
				correctUV(uvA, j + 0, a, azi);
				correctUV(uvB, j + 2, b, azi);
				correctUV(uvC, j + 4, c, azi);
			}
		}
		function correctUV(uv, stride, vector, azimuth) {
			if (azimuth < 0 && uv.x === 1) {
				uvBuffer[stride] = uv.x - 1;
			}
			if (vector.x === 0 && vector.z === 0) {
				uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
			}
		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth(vector) {
			return Math.atan2(vector.z, -vector.x);
		}

		// Angle above the XZ plane.

		function inclination(vector) {
			return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
		}
	}
	static fromJSON(data) {
		return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
	}
}

class Shape extends Path {
	constructor(points) {
		super(points);
		this.uuid = generateUUID();
		this.type = 'Shape';
		this.holes = [];
	}
	getPointsHoles(divisions) {
		const holesPts = [];
		for (let i = 0, l = this.holes.length; i < l; i++) {
			holesPts[i] = this.holes[i].getPoints(divisions);
		}
		return holesPts;
	}

	// get points of shape and holes (keypoints based on segments parameter)

	extractPoints(divisions) {
		return {
			shape: this.getPoints(divisions),
			holes: this.getPointsHoles(divisions)
		};
	}
	copy(source) {
		super.copy(source);
		this.holes = [];
		for (let i = 0, l = source.holes.length; i < l; i++) {
			const hole = source.holes[i];
			this.holes.push(hole.clone());
		}
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.uuid = this.uuid;
		data.holes = [];
		for (let i = 0, l = this.holes.length; i < l; i++) {
			const hole = this.holes[i];
			data.holes.push(hole.toJSON());
		}
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.uuid = json.uuid;
		this.holes = [];
		for (let i = 0, l = json.holes.length; i < l; i++) {
			const hole = json.holes[i];
			this.holes.push(new Path().fromJSON(hole));
		}
		return this;
	}
}

/**
 * Port from https://github.com/mapbox/earcut (v2.2.4)
 */

const Earcut = {
	triangulate: function (data, holeIndices, dim = 2) {
		const hasHoles = holeIndices && holeIndices.length;
		const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
		let outerNode = linkedList(data, 0, outerLen, dim, true);
		const triangles = [];
		if (!outerNode || outerNode.next === outerNode.prev) return triangles;
		let minX, minY, maxX, maxY, x, y, invSize;
		if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

		// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
		if (data.length > 80 * dim) {
			minX = maxX = data[0];
			minY = maxY = data[1];
			for (let i = dim; i < outerLen; i += dim) {
				x = data[i];
				y = data[i + 1];
				if (x < minX) minX = x;
				if (y < minY) minY = y;
				if (x > maxX) maxX = x;
				if (y > maxY) maxY = y;
			}

			// minX, minY and invSize are later used to transform coords into integers for z-order calculation
			invSize = Math.max(maxX - minX, maxY - minY);
			invSize = invSize !== 0 ? 32767 / invSize : 0;
		}
		earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
		return triangles;
	}
};

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
	let i, last;
	if (clockwise === signedArea(data, start, end, dim) > 0) {
		for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
	} else {
		for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
	}
	if (last && equals(last, last.next)) {
		removeNode(last);
		last = last.next;
	}
	return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
	if (!start) return start;
	if (!end) end = start;
	let p = start,
		again;
	do {
		again = false;
		if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
			removeNode(p);
			p = end = p.prev;
			if (p === p.next) break;
			again = true;
		} else {
			p = p.next;
		}
	} while (again || p !== end);
	return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
	if (!ear) return;

	// interlink polygon nodes in z-order
	if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
	let stop = ear,
		prev,
		next;

	// iterate through ears, slicing them one by one
	while (ear.prev !== ear.next) {
		prev = ear.prev;
		next = ear.next;
		if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
			// cut off the triangle
			triangles.push(prev.i / dim | 0);
			triangles.push(ear.i / dim | 0);
			triangles.push(next.i / dim | 0);
			removeNode(ear);

			// skipping the next vertex leads to less sliver triangles
			ear = next.next;
			stop = next.next;
			continue;
		}
		ear = next;

		// if we looped through the whole remaining polygon and can't find any more ears
		if (ear === stop) {
			// try filtering points and slicing again
			if (!pass) {
				earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

				// if this didn't work, try curing all small self-intersections locally
			} else if (pass === 1) {
				ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
				earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

				// as a last resort, try splitting the remaining polygon into two
			} else if (pass === 2) {
				splitEarcut(ear, triangles, dim, minX, minY, invSize);
			}
			break;
		}
	}
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
	const a = ear.prev,
		b = ear,
		c = ear.next;
	if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

	// now make sure we don't have other points inside the potential ear
	const ax = a.x,
		bx = b.x,
		cx = c.x,
		ay = a.y,
		by = b.y,
		cy = c.y;

	// triangle bbox; min & max are calculated like this for speed
	const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,
		y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,
		x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,
		y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
	let p = c.next;
	while (p !== a) {
		if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
		p = p.next;
	}
	return true;
}
function isEarHashed(ear, minX, minY, invSize) {
	const a = ear.prev,
		b = ear,
		c = ear.next;
	if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

	const ax = a.x,
		bx = b.x,
		cx = c.x,
		ay = a.y,
		by = b.y,
		cy = c.y;

	// triangle bbox; min & max are calculated like this for speed
	const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,
		y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,
		x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,
		y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;

	// z-order range for the current triangle bbox;
	const minZ = zOrder(x0, y0, minX, minY, invSize),
		maxZ = zOrder(x1, y1, minX, minY, invSize);
	let p = ear.prevZ,
		n = ear.nextZ;

	// look for points inside the triangle in both directions
	while (p && p.z >= minZ && n && n.z <= maxZ) {
		if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
		p = p.prevZ;
		if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
		n = n.nextZ;
	}

	// look for remaining points in decreasing z-order
	while (p && p.z >= minZ) {
		if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
		p = p.prevZ;
	}

	// look for remaining points in increasing z-order
	while (n && n.z <= maxZ) {
		if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
		n = n.nextZ;
	}
	return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
	let p = start;
	do {
		const a = p.prev,
			b = p.next.next;
		if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
			triangles.push(a.i / dim | 0);
			triangles.push(p.i / dim | 0);
			triangles.push(b.i / dim | 0);

			// remove two nodes involved
			removeNode(p);
			removeNode(p.next);
			p = start = b;
		}
		p = p.next;
	} while (p !== start);
	return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
	// look for a valid diagonal that divides the polygon into two
	let a = start;
	do {
		let b = a.next.next;
		while (b !== a.prev) {
			if (a.i !== b.i && isValidDiagonal(a, b)) {
				// split the polygon in two by the diagonal
				let c = splitPolygon(a, b);

				// filter colinear points around the cuts
				a = filterPoints(a, a.next);
				c = filterPoints(c, c.next);

				// run earcut on each half
				earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
				earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
				return;
			}
			b = b.next;
		}
		a = a.next;
	} while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
	const queue = [];
	let i, len, start, end, list;
	for (i = 0, len = holeIndices.length; i < len; i++) {
		start = holeIndices[i] * dim;
		end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
		list = linkedList(data, start, end, dim, false);
		if (list === list.next) list.steiner = true;
		queue.push(getLeftmost(list));
	}
	queue.sort(compareX);

	// process holes from left to right
	for (i = 0; i < queue.length; i++) {
		outerNode = eliminateHole(queue[i], outerNode);
	}
	return outerNode;
}
function compareX(a, b) {
	return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and link it
function eliminateHole(hole, outerNode) {
	const bridge = findHoleBridge(hole, outerNode);
	if (!bridge) {
		return outerNode;
	}
	const bridgeReverse = splitPolygon(bridge, hole);

	// filter collinear points around the cuts
	filterPoints(bridgeReverse, bridgeReverse.next);
	return filterPoints(bridge, bridge.next);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
	let p = outerNode,
		qx = -Infinity,
		m;
	const hx = hole.x,
		hy = hole.y;

	// find a segment intersected by a ray from the hole's leftmost point to the left;
	// segment's endpoint with lesser x will be potential connection point
	do {
		if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
			const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
			if (x <= hx && x > qx) {
				qx = x;
				m = p.x < p.next.x ? p : p.next;
				if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
			}
		}

		p = p.next;
	} while (p !== outerNode);
	if (!m) return null;

	// look for points inside the triangle of hole point, segment intersection and endpoint;
	// if there are no points found, we have a valid connection;
	// otherwise choose the point of the minimum angle with the ray as connection point

	const stop = m,
		mx = m.x,
		my = m.y;
	let tanMin = Infinity,
		tan;
	p = m;
	do {
		if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
			tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

			if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
				m = p;
				tanMin = tan;
			}
		}
		p = p.next;
	} while (p !== stop);
	return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
	return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
	let p = start;
	do {
		if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
		p.prevZ = p.prev;
		p.nextZ = p.next;
		p = p.next;
	} while (p !== start);
	p.prevZ.nextZ = null;
	p.prevZ = null;
	sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
	let i,
		p,
		q,
		e,
		tail,
		numMerges,
		pSize,
		qSize,
		inSize = 1;
	do {
		p = list;
		list = null;
		tail = null;
		numMerges = 0;
		while (p) {
			numMerges++;
			q = p;
			pSize = 0;
			for (i = 0; i < inSize; i++) {
				pSize++;
				q = q.nextZ;
				if (!q) break;
			}
			qSize = inSize;
			while (pSize > 0 || qSize > 0 && q) {
				if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
					e = p;
					p = p.nextZ;
					pSize--;
				} else {
					e = q;
					q = q.nextZ;
					qSize--;
				}
				if (tail) tail.nextZ = e;else list = e;
				e.prevZ = tail;
				tail = e;
			}
			p = q;
		}
		tail.nextZ = null;
		inSize *= 2;
	} while (numMerges > 1);
	return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
	// coords are transformed into non-negative 15-bit integer range
	x = (x - minX) * invSize | 0;
	y = (y - minY) * invSize | 0;
	x = (x | x << 8) & 0x00FF00FF;
	x = (x | x << 4) & 0x0F0F0F0F;
	x = (x | x << 2) & 0x33333333;
	x = (x | x << 1) & 0x55555555;
	y = (y | y << 8) & 0x00FF00FF;
	y = (y | y << 4) & 0x0F0F0F0F;
	y = (y | y << 2) & 0x33333333;
	y = (y | y << 1) & 0x55555555;
	return x | y << 1;
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
	let p = start,
		leftmost = start;
	do {
		if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
		p = p.next;
	} while (p !== start);
	return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
	return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
	return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (
	// dones't intersect other edges
	locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (
	// locally visible
	area(a.prev, a, b.prev) || area(a, b.prev, b)) ||
	// does not create opposite-facing sectors
	equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
	return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
	return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
	const o1 = sign(area(p1, q1, p2));
	const o2 = sign(area(p1, q1, q2));
	const o3 = sign(area(p2, q2, p1));
	const o4 = sign(area(p2, q2, q1));
	if (o1 !== o2 && o3 !== o4) return true; // general case

	if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
	if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
	if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
	if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

	return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
	return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
	return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
	let p = a;
	do {
		if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
		p = p.next;
	} while (p !== a);
	return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
	return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
	let p = a,
		inside = false;
	const px = (a.x + b.x) / 2,
		py = (a.y + b.y) / 2;
	do {
		if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
		p = p.next;
	} while (p !== a);
	return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
	const a2 = new Node$1(a.i, a.x, a.y),
		b2 = new Node$1(b.i, b.x, b.y),
		an = a.next,
		bp = b.prev;
	a.next = b;
	b.prev = a;
	a2.next = an;
	an.prev = a2;
	b2.next = a2;
	a2.prev = b2;
	bp.next = b2;
	b2.prev = bp;
	return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
	const p = new Node$1(i, x, y);
	if (!last) {
		p.prev = p;
		p.next = p;
	} else {
		p.next = last.next;
		p.prev = last;
		last.next.prev = p;
		last.next = p;
	}
	return p;
}
function removeNode(p) {
	p.next.prev = p.prev;
	p.prev.next = p.next;
	if (p.prevZ) p.prevZ.nextZ = p.nextZ;
	if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node$1(i, x, y) {
	// vertex index in coordinates array
	this.i = i;

	// vertex coordinates
	this.x = x;
	this.y = y;

	// previous and next vertex nodes in a polygon ring
	this.prev = null;
	this.next = null;

	// z-order curve value
	this.z = 0;

	// previous and next nodes in z-order
	this.prevZ = null;
	this.nextZ = null;

	// indicates whether this is a steiner point
	this.steiner = false;
}
function signedArea(data, start, end, dim) {
	let sum = 0;
	for (let i = start, j = end - dim; i < end; i += dim) {
		sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
		j = i;
	}
	return sum;
}

class ShapeUtils {
	// calculate area of the contour polygon

	static area(contour) {
		const n = contour.length;
		let a = 0.0;
		for (let p = n - 1, q = 0; q < n; p = q++) {
			a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
		}
		return a * 0.5;
	}
	static isClockWise(pts) {
		return ShapeUtils.area(pts) < 0;
	}
	static triangulateShape(contour, holes) {
		const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
		const holeIndices = []; // array of hole indices
		const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

		removeDupEndPts(contour);
		addContour(vertices, contour);

		//

		let holeIndex = contour.length;
		holes.forEach(removeDupEndPts);
		for (let i = 0; i < holes.length; i++) {
			holeIndices.push(holeIndex);
			holeIndex += holes[i].length;
			addContour(vertices, holes[i]);
		}

		//

		const triangles = Earcut.triangulate(vertices, holeIndices);

		//

		for (let i = 0; i < triangles.length; i += 3) {
			faces.push(triangles.slice(i, i + 3));
		}
		return faces;
	}
}
function removeDupEndPts(points) {
	const l = points.length;
	if (l > 2 && points[l - 1].equals(points[0])) {
		points.pop();
	}
}
function addContour(vertices, contour) {
	for (let i = 0; i < contour.length; i++) {
		vertices.push(contour[i].x);
		vertices.push(contour[i].y);
	}
}

/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves
 *	steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *	depth: <float>, // Depth to extrude the shape
 *
 *	bevelEnabled: <bool>, // turn on bevel
 *	bevelThickness: <float>, // how deep into the original shape bevel goes
 *	bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *	bevelOffset: <float>, // how far from shape outline does bevel start
 *	bevelSegments: <int>, // number of bevel layers
 *
 *	extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *	UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */
class ExtrudeGeometry extends BufferGeometry {
	constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
		super();
		this.type = 'ExtrudeGeometry';
		this.parameters = {
			shapes: shapes,
			options: options
		};
		shapes = Array.isArray(shapes) ? shapes : [shapes];
		const scope = this;
		const verticesArray = [];
		const uvArray = [];
		for (let i = 0, l = shapes.length; i < l; i++) {
			const shape = shapes[i];
			addShape(shape);
		}

		// build geometry

		this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
		this.computeVertexNormals();

		// functions

		function addShape(shape) {
			const placeholder = [];

			// options

			const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			const steps = options.steps !== undefined ? options.steps : 1;
			const depth = options.depth !== undefined ? options.depth : 1;
			let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
			let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
			let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
			let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
			const extrudePath = options.extrudePath;
			const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

			//

			let extrudePts,
				extrudeByPath = false;
			let splineTube, binormal, normal, position2;
			if (extrudePath) {
				extrudePts = extrudePath.getSpacedPoints(steps);
				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion

				// SETUP TNB variables

				// TODO1 - have a .isClosed in spline?

				splineTube = extrudePath.computeFrenetFrames(steps, false);

				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();
			}

			// Safeguards if bevels are not enabled

			if (!bevelEnabled) {
				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;
				bevelOffset = 0;
			}

			// Variables initialization

			const shapePoints = shape.extractPoints(curveSegments);
			let vertices = shapePoints.shape;
			const holes = shapePoints.holes;
			const reverse = !ShapeUtils.isClockWise(vertices);
			if (reverse) {
				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

				for (let h = 0, hl = holes.length; h < hl; h++) {
					const ahole = holes[h];
					if (ShapeUtils.isClockWise(ahole)) {
						holes[h] = ahole.reverse();
					}
				}
			}
			const faces = ShapeUtils.triangulateShape(vertices, holes);

			/* Vertices */

			const contour = vertices; // vertices has all points but contour has only points of circumference

			for (let h = 0, hl = holes.length; h < hl; h++) {
				const ahole = holes[h];
				vertices = vertices.concat(ahole);
			}
			function scalePt2(pt, vec, size) {
				if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
				return vec.clone().multiplyScalar(size).add(pt);
			}
			const vlen = vertices.length,
				flen = faces.length;

			// Find directions for point movement

			function getBevelVec(inPt, inPrev, inNext) {
				// computes for inPt the corresponding point inPt' on a new contour
				//	 shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//	adjacent edges of inPt at a distance of 1 unit on the left side.

				let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html

				const v_prev_x = inPt.x - inPrev.x,
					v_prev_y = inPt.y - inPrev.y;
				const v_next_x = inNext.x - inPt.x,
					v_next_y = inNext.y - inPt.y;
				const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;

				// check for collinear edges
				const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
				if (Math.abs(collinear0) > Number.EPSILON) {
					// not collinear

					// length of vectors for normalizing

					const v_prev_len = Math.sqrt(v_prev_lensq);
					const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);

					// shift adjacent points by unit vectors to the left

					const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
					const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
					const ptNextShift_x = inNext.x - v_next_y / v_next_len;
					const ptNextShift_y = inNext.y + v_next_x / v_next_len;

					// scaling factor for v_prev to intersection point

					const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);

					// vector from inPt to intersection point

					v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
					v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;

					// Don't normalize!, otherwise sharp corners become ugly
					//	but prevent crazy spikes
					const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
					if (v_trans_lensq <= 2) {
						return new Vector2(v_trans_x, v_trans_y);
					} else {
						shrink_by = Math.sqrt(v_trans_lensq / 2);
					}
				} else {
					// handle special case of collinear edges

					let direction_eq = false; // assumes: opposite

					if (v_prev_x > Number.EPSILON) {
						if (v_next_x > Number.EPSILON) {
							direction_eq = true;
						}
					} else {
						if (v_prev_x < -Number.EPSILON) {
							if (v_next_x < -Number.EPSILON) {
								direction_eq = true;
							}
						} else {
							if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
								direction_eq = true;
							}
						}
					}
					if (direction_eq) {
						// console.log("Warning: lines are a straight sequence");
						v_trans_x = -v_prev_y;
						v_trans_y = v_prev_x;
						shrink_by = Math.sqrt(v_prev_lensq);
					} else {
						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt(v_prev_lensq / 2);
					}
				}
				return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
			}
			const contourMovements = [];
			for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
				if (j === il) j = 0;
				if (k === il) k = 0;

				//	(j)---(i)---(k)
				// console.log('i,j,k', i, j , k)

				contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
			}
			const holesMovements = [];
			let oneHoleMovements,
				verticesMovements = contourMovements.concat();
			for (let h = 0, hl = holes.length; h < hl; h++) {
				const ahole = holes[h];
				oneHoleMovements = [];
				for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
					if (j === il) j = 0;
					if (k === il) k = 0;

					//	(j)---(i)---(k)
					oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
				}
				holesMovements.push(oneHoleMovements);
				verticesMovements = verticesMovements.concat(oneHoleMovements);
			}

			// Loop bevelSegments, 1 for the front, 1 for the back

			for (let b = 0; b < bevelSegments; b++) {
				//for ( b = bevelSegments; b > 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos(t * Math.PI / 2);
				const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;

				// contract shape

				for (let i = 0, il = contour.length; i < il; i++) {
					const vert = scalePt2(contour[i], contourMovements[i], bs);
					v(vert.x, vert.y, -z);
				}

				// expand holes

				for (let h = 0, hl = holes.length; h < hl; h++) {
					const ahole = holes[h];
					oneHoleMovements = holesMovements[h];
					for (let i = 0, il = ahole.length; i < il; i++) {
						const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
						v(vert.x, vert.y, -z);
					}
				}
			}
			const bs = bevelSize + bevelOffset;

			// Back facing vertices

			for (let i = 0; i < vlen; i++) {
				const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
				if (!extrudeByPath) {
					v(vert.x, vert.y, 0);
				} else {
					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
					binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
					position2.copy(extrudePts[0]).add(normal).add(binormal);
					v(position2.x, position2.y, position2.z);
				}
			}

			// Add stepped vertices...
			// Including front facing vertices

			for (let s = 1; s <= steps; s++) {
				for (let i = 0; i < vlen; i++) {
					const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
					if (!extrudeByPath) {
						v(vert.x, vert.y, depth / steps * s);
					} else {
						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
						binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
						position2.copy(extrudePts[s]).add(normal).add(binormal);
						v(position2.x, position2.y, position2.z);
					}
				}
			}

			// Add bevel segments planes

			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for (let b = bevelSegments - 1; b >= 0; b--) {
				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos(t * Math.PI / 2);
				const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;

				// contract shape

				for (let i = 0, il = contour.length; i < il; i++) {
					const vert = scalePt2(contour[i], contourMovements[i], bs);
					v(vert.x, vert.y, depth + z);
				}

				// expand holes

				for (let h = 0, hl = holes.length; h < hl; h++) {
					const ahole = holes[h];
					oneHoleMovements = holesMovements[h];
					for (let i = 0, il = ahole.length; i < il; i++) {
						const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
						if (!extrudeByPath) {
							v(vert.x, vert.y, depth + z);
						} else {
							v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
						}
					}
				}
			}

			/* Faces */

			// Top and bottom faces

			buildLidFaces();

			// Sides faces

			buildSideFaces();

			/////	Internal functions

			function buildLidFaces() {
				const start = verticesArray.length / 3;
				if (bevelEnabled) {
					let layer = 0; // steps + 1
					let offset = vlen * layer;

					// Bottom faces

					for (let i = 0; i < flen; i++) {
						const face = faces[i];
						f3(face[2] + offset, face[1] + offset, face[0] + offset);
					}
					layer = steps + bevelSegments * 2;
					offset = vlen * layer;

					// Top faces

					for (let i = 0; i < flen; i++) {
						const face = faces[i];
						f3(face[0] + offset, face[1] + offset, face[2] + offset);
					}
				} else {
					// Bottom faces

					for (let i = 0; i < flen; i++) {
						const face = faces[i];
						f3(face[2], face[1], face[0]);
					}

					// Top faces

					for (let i = 0; i < flen; i++) {
						const face = faces[i];
						f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
					}
				}
				scope.addGroup(start, verticesArray.length / 3 - start, 0);
			}

			// Create faces for the z-sides of the shape

			function buildSideFaces() {
				const start = verticesArray.length / 3;
				let layeroffset = 0;
				sidewalls(contour, layeroffset);
				layeroffset += contour.length;
				for (let h = 0, hl = holes.length; h < hl; h++) {
					const ahole = holes[h];
					sidewalls(ahole, layeroffset);

					//, true
					layeroffset += ahole.length;
				}
				scope.addGroup(start, verticesArray.length / 3 - start, 1);
			}
			function sidewalls(contour, layeroffset) {
				let i = contour.length;
				while (--i >= 0) {
					const j = i;
					let k = i - 1;
					if (k < 0) k = contour.length - 1;

					//console.log('b', i,j, i-1, k,vertices.length);

					for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
						const slen1 = vlen * s;
						const slen2 = vlen * (s + 1);
						const a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;
						f4(a, b, c, d);
					}
				}
			}
			function v(x, y, z) {
				placeholder.push(x);
				placeholder.push(y);
				placeholder.push(z);
			}
			function f3(a, b, c) {
				addVertex(a);
				addVertex(b);
				addVertex(c);
				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
				addUV(uvs[0]);
				addUV(uvs[1]);
				addUV(uvs[2]);
			}
			function f4(a, b, c, d) {
				addVertex(a);
				addVertex(b);
				addVertex(d);
				addVertex(b);
				addVertex(c);
				addVertex(d);
				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
				addUV(uvs[0]);
				addUV(uvs[1]);
				addUV(uvs[3]);
				addUV(uvs[1]);
				addUV(uvs[2]);
				addUV(uvs[3]);
			}
			function addVertex(index) {
				verticesArray.push(placeholder[index * 3 + 0]);
				verticesArray.push(placeholder[index * 3 + 1]);
				verticesArray.push(placeholder[index * 3 + 2]);
			}
			function addUV(vector2) {
				uvArray.push(vector2.x);
				uvArray.push(vector2.y);
			}
		}
	}
	toJSON() {
		const data = super.toJSON();
		const shapes = this.parameters.shapes;
		const options = this.parameters.options;
		return toJSON$1(shapes, options, data);
	}
	static fromJSON(data, shapes) {
		const geometryShapes = [];
		for (let j = 0, jl = data.shapes.length; j < jl; j++) {
			const shape = shapes[data.shapes[j]];
			geometryShapes.push(shape);
		}
		const extrudePath = data.options.extrudePath;
		if (extrudePath !== undefined) {
			data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
		}
		return new ExtrudeGeometry(geometryShapes, data.options);
	}
}
const WorldUVGenerator = {
	generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
		const a_x = vertices[indexA * 3];
		const a_y = vertices[indexA * 3 + 1];
		const b_x = vertices[indexB * 3];
		const b_y = vertices[indexB * 3 + 1];
		const c_x = vertices[indexC * 3];
		const c_y = vertices[indexC * 3 + 1];
		return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
	},
	generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
		const a_x = vertices[indexA * 3];
		const a_y = vertices[indexA * 3 + 1];
		const a_z = vertices[indexA * 3 + 2];
		const b_x = vertices[indexB * 3];
		const b_y = vertices[indexB * 3 + 1];
		const b_z = vertices[indexB * 3 + 2];
		const c_x = vertices[indexC * 3];
		const c_y = vertices[indexC * 3 + 1];
		const c_z = vertices[indexC * 3 + 2];
		const d_x = vertices[indexD * 3];
		const d_y = vertices[indexD * 3 + 1];
		const d_z = vertices[indexD * 3 + 2];
		if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
			return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
		} else {
			return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
		}
	}
};
function toJSON$1(shapes, options, data) {
	data.shapes = [];
	if (Array.isArray(shapes)) {
		for (let i = 0, l = shapes.length; i < l; i++) {
			const shape = shapes[i];
			data.shapes.push(shape.uuid);
		}
	} else {
		data.shapes.push(shapes.uuid);
	}
	data.options = Object.assign({}, options);
	if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
	return data;
}

class OctahedronGeometry extends PolyhedronGeometry {
	constructor(radius = 1, detail = 0) {
		const vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
		const indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
		super(vertices, indices, radius, detail);
		this.type = 'OctahedronGeometry';
		this.parameters = {
			radius: radius,
			detail: detail
		};
	}
	static fromJSON(data) {
		return new OctahedronGeometry(data.radius, data.detail);
	}
}

class SphereGeometry extends BufferGeometry {
	constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
		super();
		this.type = 'SphereGeometry';
		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
		widthSegments = Math.max(3, Math.floor(widthSegments));
		heightSegments = Math.max(2, Math.floor(heightSegments));
		const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
		let index = 0;
		const grid = [];
		const vertex = new Vector3();
		const normal = new Vector3();

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// generate vertices, normals and uvs

		for (let iy = 0; iy <= heightSegments; iy++) {
			const verticesRow = [];
			const v = iy / heightSegments;

			// special case for the poles

			let uOffset = 0;
			if (iy == 0 && thetaStart == 0) {
				uOffset = 0.5 / widthSegments;
			} else if (iy == heightSegments && thetaEnd == Math.PI) {
				uOffset = -0.5 / widthSegments;
			}
			for (let ix = 0; ix <= widthSegments; ix++) {
				const u = ix / widthSegments;

				// vertex

				vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
				vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
				vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
				vertices.push(vertex.x, vertex.y, vertex.z);

				// normal

				normal.copy(vertex).normalize();
				normals.push(normal.x, normal.y, normal.z);

				// uv

				uvs.push(u + uOffset, 1 - v);
				verticesRow.push(index++);
			}
			grid.push(verticesRow);
		}

		// indices

		for (let iy = 0; iy < heightSegments; iy++) {
			for (let ix = 0; ix < widthSegments; ix++) {
				const a = grid[iy][ix + 1];
				const b = grid[iy][ix];
				const c = grid[iy + 1][ix];
				const d = grid[iy + 1][ix + 1];
				if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
				if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
			}
		}

		// build geometry

		this.setIndex(indices);
		this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
	}
	static fromJSON(data) {
		return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
	}
}

class TorusGeometry extends BufferGeometry {
	constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
		super();
		this.type = 'TorusGeometry';
		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};
		radialSegments = Math.floor(radialSegments);
		tubularSegments = Math.floor(tubularSegments);

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const center = new Vector3();
		const vertex = new Vector3();
		const normal = new Vector3();

		// generate vertices, normals and uvs

		for (let j = 0; j <= radialSegments; j++) {
			for (let i = 0; i <= tubularSegments; i++) {
				const u = i / tubularSegments * arc;
				const v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
				vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
				vertex.z = tube * Math.sin(v);
				vertices.push(vertex.x, vertex.y, vertex.z);

				// normal

				center.x = radius * Math.cos(u);
				center.y = radius * Math.sin(u);
				normal.subVectors(vertex, center).normalize();
				normals.push(normal.x, normal.y, normal.z);

				// uv

				uvs.push(i / tubularSegments);
				uvs.push(j / radialSegments);
			}
		}

		// generate indices

		for (let j = 1; j <= radialSegments; j++) {
			for (let i = 1; i <= tubularSegments; i++) {
				// indices

				const a = (tubularSegments + 1) * j + i - 1;
				const b = (tubularSegments + 1) * (j - 1) + i - 1;
				const c = (tubularSegments + 1) * (j - 1) + i;
				const d = (tubularSegments + 1) * j + i;

				// faces

				indices.push(a, b, d);
				indices.push(b, c, d);
			}
		}

		// build geometry

		this.setIndex(indices);
		this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
	}
	static fromJSON(data) {
		return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
	}
}

class WireframeGeometry extends BufferGeometry {
	constructor(geometry = null) {
		super();
		this.type = 'WireframeGeometry';
		this.parameters = {
			geometry: geometry
		};
		if (geometry !== null) {
			// buffer

			const vertices = [];
			const edges = new Set();

			// helper variables

			const start = new Vector3();
			const end = new Vector3();
			if (geometry.index !== null) {
				// indexed BufferGeometry

				const position = geometry.attributes.position;
				const indices = geometry.index;
				let groups = geometry.groups;
				if (groups.length === 0) {
					groups = [{
						start: 0,
						count: indices.count,
						materialIndex: 0
					}];
				}

				// create a data structure that contains all edges without duplicates

				for (let o = 0, ol = groups.length; o < ol; ++o) {
					const group = groups[o];
					const groupStart = group.start;
					const groupCount = group.count;
					for (let i = groupStart, l = groupStart + groupCount; i < l; i += 3) {
						for (let j = 0; j < 3; j++) {
							const index1 = indices.getX(i + j);
							const index2 = indices.getX(i + (j + 1) % 3);
							start.fromBufferAttribute(position, index1);
							end.fromBufferAttribute(position, index2);
							if (isUniqueEdge(start, end, edges) === true) {
								vertices.push(start.x, start.y, start.z);
								vertices.push(end.x, end.y, end.z);
							}
						}
					}
				}
			} else {
				// non-indexed BufferGeometry

				const position = geometry.attributes.position;
				for (let i = 0, l = position.count / 3; i < l; i++) {
					for (let j = 0; j < 3; j++) {
						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

						const index1 = 3 * i + j;
						const index2 = 3 * i + (j + 1) % 3;
						start.fromBufferAttribute(position, index1);
						end.fromBufferAttribute(position, index2);
						if (isUniqueEdge(start, end, edges) === true) {
							vertices.push(start.x, start.y, start.z);
							vertices.push(end.x, end.y, end.z);
						}
					}
				}
			}

			// build geometry

			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		}
	}
}
function isUniqueEdge(start, end, edges) {
	const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
	const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge

	if (edges.has(hash1) === true || edges.has(hash2) === true) {
		return false;
	} else {
		edges.add(hash1);
		edges.add(hash2);
		return true;
	}
}

class MeshNormalMaterial extends Material {
	constructor(parameters) {
		super();
		this.isMeshNormalMaterial = true;
		this.type = 'MeshNormalMaterial';
		this.bumpMap = null;
		this.bumpScale = 1;
		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2(1, 1);
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.flatShading = false;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.flatShading = source.flatShading;
		return this;
	}
}

class MeshLambertMaterial extends Material {
	constructor(parameters) {
		super();
		this.isMeshLambertMaterial = true;
		this.type = 'MeshLambertMaterial';
		this.color = new Color$1(0xffffff); // diffuse

		this.map = null;
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
		this.emissive = new Color$1(0x000000);
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
		this.bumpMap = null;
		this.bumpScale = 1;
		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2(1, 1);
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.specularMap = null;
		this.alphaMap = null;
		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
		this.flatShading = false;
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.map = source.map;
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
		this.emissive.copy(source.emissive);
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.specularMap = source.specularMap;
		this.alphaMap = source.alphaMap;
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
		this.flatShading = source.flatShading;
		this.fog = source.fog;
		return this;
	}
}

class LineDashedMaterial extends LineBasicMaterial {
	constructor(parameters) {
		super();
		this.isLineDashedMaterial = true;
		this.type = 'LineDashedMaterial';
		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;
		return this;
	}
}

const Cache = {
	enabled: false,
	files: {},
	add: function (key, file) {
		if (this.enabled === false) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[key] = file;
	},
	get: function (key) {
		if (this.enabled === false) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[key];
	},
	remove: function (key) {
		delete this.files[key];
	},
	clear: function () {
		this.files = {};
	}
};

class LoadingManager {
	constructor(onLoad, onProgress, onError) {
		const scope = this;
		let isLoading = false;
		let itemsLoaded = 0;
		let itemsTotal = 0;
		let urlModifier = undefined;
		const handlers = [];

		// Refer to #5689 for the reason why we don't set .onStart
		// in the constructor

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;
		this.itemStart = function (url) {
			itemsTotal++;
			if (isLoading === false) {
				if (scope.onStart !== undefined) {
					scope.onStart(url, itemsLoaded, itemsTotal);
				}
			}
			isLoading = true;
		};
		this.itemEnd = function (url) {
			itemsLoaded++;
			if (scope.onProgress !== undefined) {
				scope.onProgress(url, itemsLoaded, itemsTotal);
			}
			if (itemsLoaded === itemsTotal) {
				isLoading = false;
				if (scope.onLoad !== undefined) {
					scope.onLoad();
				}
			}
		};
		this.itemError = function (url) {
			if (scope.onError !== undefined) {
				scope.onError(url);
			}
		};
		this.resolveURL = function (url) {
			if (urlModifier) {
				return urlModifier(url);
			}
			return url;
		};
		this.setURLModifier = function (transform) {
			urlModifier = transform;
			return this;
		};
		this.addHandler = function (regex, loader) {
			handlers.push(regex, loader);
			return this;
		};
		this.removeHandler = function (regex) {
			const index = handlers.indexOf(regex);
			if (index !== -1) {
				handlers.splice(index, 2);
			}
			return this;
		};
		this.getHandler = function (file) {
			for (let i = 0, l = handlers.length; i < l; i += 2) {
				const regex = handlers[i];
				const loader = handlers[i + 1];
				if (regex.global) regex.lastIndex = 0; // see #17920

				if (regex.test(file)) {
					return loader;
				}
			}
			return null;
		};
	}
}
const DefaultLoadingManager = /*@__PURE__*/new LoadingManager();

class Loader {
	constructor(manager) {
		this.manager = manager !== undefined ? manager : DefaultLoadingManager;
		this.crossOrigin = 'anonymous';
		this.withCredentials = false;
		this.path = '';
		this.resourcePath = '';
		this.requestHeader = {};
	}
	load( /* url, onLoad, onProgress, onError */) {}
	loadAsync(url, onProgress) {
		const scope = this;
		return new Promise(function (resolve, reject) {
			scope.load(url, resolve, onProgress, reject);
		});
	}
	parse( /* data */) {}
	setCrossOrigin(crossOrigin) {
		this.crossOrigin = crossOrigin;
		return this;
	}
	setWithCredentials(value) {
		this.withCredentials = value;
		return this;
	}
	setPath(path) {
		this.path = path;
		return this;
	}
	setResourcePath(resourcePath) {
		this.resourcePath = resourcePath;
		return this;
	}
	setRequestHeader(requestHeader) {
		this.requestHeader = requestHeader;
		return this;
	}
}

class ImageLoader extends Loader {
	constructor(manager) {
		super(manager);
	}
	load(url, onLoad, onProgress, onError) {
		if (this.path !== undefined) url = this.path + url;
		url = this.manager.resolveURL(url);
		const scope = this;
		const cached = Cache.get(url);
		if (cached !== undefined) {
			scope.manager.itemStart(url);
			setTimeout(function () {
				if (onLoad) onLoad(cached);
				scope.manager.itemEnd(url);
			}, 0);
			return cached;
		}
		const image = createElementNS('img');
		function onImageLoad() {
			removeEventListeners();
			Cache.add(url, this);
			if (onLoad) onLoad(this);
			scope.manager.itemEnd(url);
		}
		function onImageError(event) {
			removeEventListeners();
			if (onError) onError(event);
			scope.manager.itemError(url);
			scope.manager.itemEnd(url);
		}
		function removeEventListeners() {
			image.removeEventListener('load', onImageLoad, false);
			image.removeEventListener('error', onImageError, false);
		}
		image.addEventListener('load', onImageLoad, false);
		image.addEventListener('error', onImageError, false);
		if (url.slice(0, 5) !== 'data:') {
			if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
		}
		scope.manager.itemStart(url);
		image.src = url;
		return image;
	}
}

class TextureLoader extends Loader {
	constructor(manager) {
		super(manager);
	}
	load(url, onLoad, onProgress, onError) {
		const texture = new Texture();
		const loader = new ImageLoader(this.manager);
		loader.setCrossOrigin(this.crossOrigin);
		loader.setPath(this.path);
		loader.load(url, function (image) {
			texture.image = image;
			texture.needsUpdate = true;
			if (onLoad !== undefined) {
				onLoad(texture);
			}
		}, onProgress, onError);
		return texture;
	}
}

class Light extends Object3D {
	constructor(color, intensity = 1) {
		super();
		this.isLight = true;
		this.type = 'Light';
		this.color = new Color$1(color);
		this.intensity = intensity;
	}
	dispose() {

		// Empty here in base class; some subclasses override.
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.color.copy(source.color);
		this.intensity = source.intensity;
		return this;
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;
		if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
		if (this.distance !== undefined) data.object.distance = this.distance;
		if (this.angle !== undefined) data.object.angle = this.angle;
		if (this.decay !== undefined) data.object.decay = this.decay;
		if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
		if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
		return data;
	}
}

class HemisphereLight extends Light {
	constructor(skyColor, groundColor, intensity) {
		super(skyColor, intensity);
		this.isHemisphereLight = true;
		this.type = 'HemisphereLight';
		this.position.copy(Object3D.DefaultUp);
		this.updateMatrix();
		this.groundColor = new Color$1(groundColor);
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.groundColor.copy(source.groundColor);
		return this;
	}
}

const _projScreenMatrix$1 = /*@__PURE__*/new Matrix4();
const _lightPositionWorld$1 = /*@__PURE__*/new Vector3();
const _lookTarget$1 = /*@__PURE__*/new Vector3();
class LightShadow {
	constructor(camera) {
		this.camera = camera;
		this.bias = 0;
		this.normalBias = 0;
		this.radius = 1;
		this.blurSamples = 8;
		this.mapSize = new Vector2(512, 512);
		this.map = null;
		this.mapPass = null;
		this.matrix = new Matrix4();
		this.autoUpdate = true;
		this.needsUpdate = false;
		this._frustum = new Frustum();
		this._frameExtents = new Vector2(1, 1);
		this._viewportCount = 1;
		this._viewports = [new Vector4(0, 0, 1, 1)];
	}
	getViewportCount() {
		return this._viewportCount;
	}
	getFrustum() {
		return this._frustum;
	}
	updateMatrices(light) {
		const shadowCamera = this.camera;
		const shadowMatrix = this.matrix;
		_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
		shadowCamera.position.copy(_lightPositionWorld$1);
		_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
		shadowCamera.lookAt(_lookTarget$1);
		shadowCamera.updateMatrixWorld();
		_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
		this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
		shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
		shadowMatrix.multiply(_projScreenMatrix$1);
	}
	getViewport(viewportIndex) {
		return this._viewports[viewportIndex];
	}
	getFrameExtents() {
		return this._frameExtents;
	}
	dispose() {
		if (this.map) {
			this.map.dispose();
		}
		if (this.mapPass) {
			this.mapPass.dispose();
		}
	}
	copy(source) {
		this.camera = source.camera.clone();
		this.bias = source.bias;
		this.radius = source.radius;
		this.mapSize.copy(source.mapSize);
		return this;
	}
	clone() {
		return new this.constructor().copy(this);
	}
	toJSON() {
		const object = {};
		if (this.bias !== 0) object.bias = this.bias;
		if (this.normalBias !== 0) object.normalBias = this.normalBias;
		if (this.radius !== 1) object.radius = this.radius;
		if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
		object.camera = this.camera.toJSON(false).object;
		delete object.camera.matrix;
		return object;
	}
}

const _projScreenMatrix = /*@__PURE__*/new Matrix4();
const _lightPositionWorld = /*@__PURE__*/new Vector3();
const _lookTarget = /*@__PURE__*/new Vector3();
class PointLightShadow extends LightShadow {
	constructor() {
		super(new PerspectiveCamera(90, 1, 0.5, 500));
		this.isPointLightShadow = true;
		this._frameExtents = new Vector2(4, 2);
		this._viewportCount = 6;
		this._viewports = [
		// These viewports map a cube-map onto a 2D texture with the
		// following orientation:
		//
		//	xzXZ
		//	 y Y
		//
		// X - Positive x direction
		// x - Negative x direction
		// Y - Positive y direction
		// y - Negative y direction
		// Z - Positive z direction
		// z - Negative z direction

		// positive X
		new Vector4(2, 1, 1, 1),
		// negative X
		new Vector4(0, 1, 1, 1),
		// positive Z
		new Vector4(3, 1, 1, 1),
		// negative Z
		new Vector4(1, 1, 1, 1),
		// positive Y
		new Vector4(3, 0, 1, 1),
		// negative Y
		new Vector4(1, 0, 1, 1)];
		this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
		this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
	}
	updateMatrices(light, viewportIndex = 0) {
		const camera = this.camera;
		const shadowMatrix = this.matrix;
		const far = light.distance || camera.far;
		if (far !== camera.far) {
			camera.far = far;
			camera.updateProjectionMatrix();
		}
		_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
		camera.position.copy(_lightPositionWorld);
		_lookTarget.copy(camera.position);
		_lookTarget.add(this._cubeDirections[viewportIndex]);
		camera.up.copy(this._cubeUps[viewportIndex]);
		camera.lookAt(_lookTarget);
		camera.updateMatrixWorld();
		shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
		_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
		this._frustum.setFromProjectionMatrix(_projScreenMatrix);
	}
}

class PointLight extends Light {
	constructor(color, intensity, distance = 0, decay = 1) {
		super(color, intensity);
		this.isPointLight = true;
		this.type = 'PointLight';
		this.distance = distance;
		this.decay = decay; // for physically correct lights, should be 2.

		this.shadow = new PointLightShadow();
	}
	get power() {
		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)
		return this.intensity * 4 * Math.PI;
	}
	set power(power) {
		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / (4 * Math.PI);
	}
	dispose() {
		this.shadow.dispose();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.distance = source.distance;
		this.decay = source.decay;
		this.shadow = source.shadow.clone();
		return this;
	}
}

class AmbientLight extends Light {
	constructor(color, intensity) {
		super(color, intensity);
		this.isAmbientLight = true;
		this.type = 'AmbientLight';
	}
}

class Raycaster {
	constructor(origin, direction, near = 0, far = Infinity) {
		this.ray = new Ray(origin, direction);
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near;
		this.far = far;
		this.camera = null;
		this.layers = new Layers();
		this.params = {
			Mesh: {},
			Line: {
				threshold: 1
			},
			LOD: {},
			Points: {
				threshold: 1
			},
			Sprite: {}
		};
	}
	set(origin, direction) {
		// direction is assumed to be normalized (for accurate distance calculations)

		this.ray.set(origin, direction);
	}
	setFromCamera(coords, camera) {
		if (camera.isPerspectiveCamera) {
			this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
			this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
			this.camera = camera;
		} else if (camera.isOrthographicCamera) {
			this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
			this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
			this.camera = camera;
		} else {
			console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
		}
	}
	intersectObject(object, recursive = true, intersects = []) {
		intersectObject(object, this, intersects, recursive);
		intersects.sort(ascSort);
		return intersects;
	}
	intersectObjects(objects, recursive = true, intersects = []) {
		for (let i = 0, l = objects.length; i < l; i++) {
			intersectObject(objects[i], this, intersects, recursive);
		}
		intersects.sort(ascSort);
		return intersects;
	}
}
function ascSort(a, b) {
	return a.distance - b.distance;
}
function intersectObject(object, raycaster, intersects, recursive) {
	if (object.layers.test(raycaster.layers)) {
		object.raycast(raycaster, intersects);
	}
	if (recursive === true) {
		const children = object.children;
		for (let i = 0, l = children.length; i < l; i++) {
			intersectObject(children[i], raycaster, intersects, true);
		}
	}
}

class Clock {
	constructor(autoStart = true) {
		this.autoStart = autoStart;
		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;
		this.running = false;
	}
	start() {
		this.startTime = now();
		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;
	}
	stop() {
		this.getElapsedTime();
		this.running = false;
		this.autoStart = false;
	}
	getElapsedTime() {
		this.getDelta();
		return this.elapsedTime;
	}
	getDelta() {
		let diff = 0;
		if (this.autoStart && !this.running) {
			this.start();
			return 0;
		}
		if (this.running) {
			const newTime = now();
			diff = (newTime - this.oldTime) / 1000;
			this.oldTime = newTime;
			this.elapsedTime += diff;
		}
		return diff;
	}
}
function now() {
	return (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
}

/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */
class Spherical {
	constructor(radius = 1, phi = 0, theta = 0) {
		this.radius = radius;
		this.phi = phi; // polar angle
		this.theta = theta; // azimuthal angle

		return this;
	}
	set(radius, phi, theta) {
		this.radius = radius;
		this.phi = phi;
		this.theta = theta;
		return this;
	}
	copy(other) {
		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;
		return this;
	}

	// restrict phi to be between EPS and PI-EPS
	makeSafe() {
		const EPS = 0.000001;
		this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
		return this;
	}
	setFromVector3(v) {
		return this.setFromCartesianCoords(v.x, v.y, v.z);
	}
	setFromCartesianCoords(x, y, z) {
		this.radius = Math.sqrt(x * x + y * y + z * z);
		if (this.radius === 0) {
			this.theta = 0;
			this.phi = 0;
		} else {
			this.theta = Math.atan2(x, z);
			this.phi = Math.acos(clamp(y / this.radius, -1, 1));
		}
		return this;
	}
	clone() {
		return new this.constructor().copy(this);
	}
}

const _vector$4 = /*@__PURE__*/new Vector2();
class Box2 {
	constructor(min = new Vector2(+Infinity, +Infinity), max = new Vector2(-Infinity, -Infinity)) {
		this.isBox2 = true;
		this.min = min;
		this.max = max;
	}
	set(min, max) {
		this.min.copy(min);
		this.max.copy(max);
		return this;
	}
	setFromPoints(points) {
		this.makeEmpty();
		for (let i = 0, il = points.length; i < il; i++) {
			this.expandByPoint(points[i]);
		}
		return this;
	}
	setFromCenterAndSize(center, size) {
		const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
		this.min.copy(center).sub(halfSize);
		this.max.copy(center).add(halfSize);
		return this;
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(box) {
		this.min.copy(box.min);
		this.max.copy(box.max);
		return this;
	}
	makeEmpty() {
		this.min.x = this.min.y = +Infinity;
		this.max.x = this.max.y = -Infinity;
		return this;
	}
	isEmpty() {
		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return this.max.x < this.min.x || this.max.y < this.min.y;
	}
	getCenter(target) {
		return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
	}
	getSize(target) {
		return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
	}
	expandByPoint(point) {
		this.min.min(point);
		this.max.max(point);
		return this;
	}
	expandByVector(vector) {
		this.min.sub(vector);
		this.max.add(vector);
		return this;
	}
	expandByScalar(scalar) {
		this.min.addScalar(-scalar);
		this.max.addScalar(scalar);
		return this;
	}
	containsPoint(point) {
		return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
	}
	containsBox(box) {
		return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
	}
	getParameter(point, target) {
		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
	}
	intersectsBox(box) {
		// using 4 splitting planes to rule out intersections

		return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
	}
	clampPoint(point, target) {
		return target.copy(point).clamp(this.min, this.max);
	}
	distanceToPoint(point) {
		const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);
		return clampedPoint.sub(point).length();
	}
	intersect(box) {
		this.min.max(box.min);
		this.max.min(box.max);
		return this;
	}
	union(box) {
		this.min.min(box.min);
		this.max.max(box.max);
		return this;
	}
	translate(offset) {
		this.min.add(offset);
		this.max.add(offset);
		return this;
	}
	equals(box) {
		return box.min.equals(this.min) && box.max.equals(this.max);
	}
}

const _startP = /*@__PURE__*/new Vector3();
const _startEnd = /*@__PURE__*/new Vector3();
class Line3 {
	constructor(start = new Vector3(), end = new Vector3()) {
		this.start = start;
		this.end = end;
	}
	set(start, end) {
		this.start.copy(start);
		this.end.copy(end);
		return this;
	}
	copy(line) {
		this.start.copy(line.start);
		this.end.copy(line.end);
		return this;
	}
	getCenter(target) {
		return target.addVectors(this.start, this.end).multiplyScalar(0.5);
	}
	delta(target) {
		return target.subVectors(this.end, this.start);
	}
	distanceSq() {
		return this.start.distanceToSquared(this.end);
	}
	distance() {
		return this.start.distanceTo(this.end);
	}
	at(t, target) {
		return this.delta(target).multiplyScalar(t).add(this.start);
	}
	closestPointToPointParameter(point, clampToLine) {
		_startP.subVectors(point, this.start);
		_startEnd.subVectors(this.end, this.start);
		const startEnd2 = _startEnd.dot(_startEnd);
		const startEnd_startP = _startEnd.dot(_startP);
		let t = startEnd_startP / startEnd2;
		if (clampToLine) {
			t = clamp(t, 0, 1);
		}
		return t;
	}
	closestPointToPoint(point, clampToLine, target) {
		const t = this.closestPointToPointParameter(point, clampToLine);
		return this.delta(target).multiplyScalar(t).add(this.start);
	}
	applyMatrix4(matrix) {
		this.start.applyMatrix4(matrix);
		this.end.applyMatrix4(matrix);
		return this;
	}
	equals(line) {
		return line.start.equals(this.start) && line.end.equals(this.end);
	}
	clone() {
		return new this.constructor().copy(this);
	}
}

class GridHelper extends LineSegments {
	constructor(size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888) {
		color1 = new Color$1(color1);
		color2 = new Color$1(color2);
		const center = divisions / 2;
		const step = size / divisions;
		const halfSize = size / 2;
		const vertices = [],
			colors = [];
		for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
			vertices.push(-halfSize, 0, k, halfSize, 0, k);
			vertices.push(k, 0, -halfSize, k, 0, halfSize);
			const color = i === center ? color1 : color2;
			color.toArray(colors, j);
			j += 3;
			color.toArray(colors, j);
			j += 3;
			color.toArray(colors, j);
			j += 3;
			color.toArray(colors, j);
			j += 3;
		}
		const geometry = new BufferGeometry();
		geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
		const material = new LineBasicMaterial({
			vertexColors: true,
			toneMapped: false
		});
		super(geometry, material);
		this.type = 'GridHelper';
	}
	dispose() {
		this.geometry.dispose();
		this.material.dispose();
	}
}

const _box = /*@__PURE__*/new Box3();
class BoxHelper extends LineSegments {
	constructor(object, color = 0xffff00) {
		const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
		const positions = new Float32Array(8 * 3);
		const geometry = new BufferGeometry();
		geometry.setIndex(new BufferAttribute(indices, 1));
		geometry.setAttribute('position', new BufferAttribute(positions, 3));
		super(geometry, new LineBasicMaterial({
			color: color,
			toneMapped: false
		}));
		this.object = object;
		this.type = 'BoxHelper';
		this.matrixAutoUpdate = false;
		this.update();
	}
	update(object) {
		if (object !== undefined) {
			console.warn('THREE.BoxHelper: .update() has no longer arguments.');
		}
		if (this.object !== undefined) {
			_box.setFromObject(this.object);
		}
		if (_box.isEmpty()) return;
		const min = _box.min;
		const max = _box.max;

		/*
			5____4
		1/___0/|
		| 6__|_7
		2/___3/
			0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		const position = this.geometry.attributes.position;
		const array = position.array;
		array[0] = max.x;
		array[1] = max.y;
		array[2] = max.z;
		array[3] = min.x;
		array[4] = max.y;
		array[5] = max.z;
		array[6] = min.x;
		array[7] = min.y;
		array[8] = max.z;
		array[9] = max.x;
		array[10] = min.y;
		array[11] = max.z;
		array[12] = max.x;
		array[13] = max.y;
		array[14] = min.z;
		array[15] = min.x;
		array[16] = max.y;
		array[17] = min.z;
		array[18] = min.x;
		array[19] = min.y;
		array[20] = min.z;
		array[21] = max.x;
		array[22] = min.y;
		array[23] = min.z;
		position.needsUpdate = true;
		this.geometry.computeBoundingSphere();
	}
	setFromObject(object) {
		this.object = object;
		this.update();
		return this;
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.object = source.object;
		return this;
	}
	dispose() {
		this.geometry.dispose();
		this.material.dispose();
	}
}

class AxesHelper extends LineSegments {
	constructor(size = 1) {
		const vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
		const colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
		const geometry = new BufferGeometry();
		geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
		const material = new LineBasicMaterial({
			vertexColors: true,
			toneMapped: false
		});
		super(geometry, material);
		this.type = 'AxesHelper';
	}
	setColors(xAxisColor, yAxisColor, zAxisColor) {
		const color = new Color$1();
		const array = this.geometry.attributes.color.array;
		color.set(xAxisColor);
		color.toArray(array, 0);
		color.toArray(array, 3);
		color.set(yAxisColor);
		color.toArray(array, 6);
		color.toArray(array, 9);
		color.set(zAxisColor);
		color.toArray(array, 12);
		color.toArray(array, 15);
		this.geometry.attributes.color.needsUpdate = true;
		return this;
	}
	dispose() {
		this.geometry.dispose();
		this.material.dispose();
	}
}

class ShapePath {
	constructor() {
		this.type = 'ShapePath';
		this.color = new Color$1();
		this.subPaths = [];
		this.currentPath = null;
	}
	moveTo(x, y) {
		this.currentPath = new Path();
		this.subPaths.push(this.currentPath);
		this.currentPath.moveTo(x, y);
		return this;
	}
	lineTo(x, y) {
		this.currentPath.lineTo(x, y);
		return this;
	}
	quadraticCurveTo(aCPx, aCPy, aX, aY) {
		this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
		return this;
	}
	bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
		this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
		return this;
	}
	splineThru(pts) {
		this.currentPath.splineThru(pts);
		return this;
	}
	toShapes(isCCW) {
		function toShapesNoHoles(inSubpaths) {
			const shapes = [];
			for (let i = 0, l = inSubpaths.length; i < l; i++) {
				const tmpPath = inSubpaths[i];
				const tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push(tmpShape);
			}
			return shapes;
		}
		function isPointInsidePolygon(inPt, inPolygon) {
			const polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success		or
			// toggling of inside/outside at every single! intersection point of an edge
			//	with the horizontal line through inPt, left of inPt
			//	not counting lowerY endpoints of edges and whole edges on that line
			let inside = false;
			for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
				let edgeLowPt = inPolygon[p];
				let edgeHighPt = inPolygon[q];
				let edgeDx = edgeHighPt.x - edgeLowPt.x;
				let edgeDy = edgeHighPt.y - edgeLowPt.y;
				if (Math.abs(edgeDy) > Number.EPSILON) {
					// not parallel
					if (edgeDy < 0) {
						edgeLowPt = inPolygon[q];
						edgeDx = -edgeDx;
						edgeHighPt = inPolygon[p];
						edgeDy = -edgeDy;
					}
					if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
					if (inPt.y === edgeLowPt.y) {
						if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!
					} else {
						const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
						if (perpEdge === 0) return true; // inPt is on contour ?
						if (perpEdge < 0) continue;
						inside = !inside; // true intersection left of inPt
					}
				} else {
					// parallel or collinear
					if (inPt.y !== edgeLowPt.y) continue; // parallel
					// edge lies on the same horizontal line as inPt
					if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
					// continue;
				}
			}

			return inside;
		}
		const isClockWise = ShapeUtils.isClockWise;
		const subPaths = this.subPaths;
		if (subPaths.length === 0) return [];
		let solid, tmpPath, tmpShape;
		const shapes = [];
		if (subPaths.length === 1) {
			tmpPath = subPaths[0];
			tmpShape = new Shape();
			tmpShape.curves = tmpPath.curves;
			shapes.push(tmpShape);
			return shapes;
		}
		let holesFirst = !isClockWise(subPaths[0].getPoints());
		holesFirst = isCCW ? !holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		const betterShapeHoles = [];
		const newShapes = [];
		let newShapeHoles = [];
		let mainIdx = 0;
		let tmpPoints;
		newShapes[mainIdx] = undefined;
		newShapeHoles[mainIdx] = [];
		for (let i = 0, l = subPaths.length; i < l; i++) {
			tmpPath = subPaths[i];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise(tmpPoints);
			solid = isCCW ? !solid : solid;
			if (solid) {
				if (!holesFirst && newShapes[mainIdx]) mainIdx++;
				newShapes[mainIdx] = {
					s: new Shape(),
					p: tmpPoints
				};
				newShapes[mainIdx].s.curves = tmpPath.curves;
				if (holesFirst) mainIdx++;
				newShapeHoles[mainIdx] = [];

				//console.log('cw', i);
			} else {
				newShapeHoles[mainIdx].push({
					h: tmpPath,
					p: tmpPoints[0]
				});

				//console.log('ccw', i);
			}
		}

		// only Holes? -> probably all Shapes with wrong orientation
		if (!newShapes[0]) return toShapesNoHoles(subPaths);
		if (newShapes.length > 1) {
			let ambiguous = false;
			let toChange = 0;
			for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
				betterShapeHoles[sIdx] = [];
			}
			for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
				const sho = newShapeHoles[sIdx];
				for (let hIdx = 0; hIdx < sho.length; hIdx++) {
					const ho = sho[hIdx];
					let hole_unassigned = true;
					for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
						if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
							if (sIdx !== s2Idx) toChange++;
							if (hole_unassigned) {
								hole_unassigned = false;
								betterShapeHoles[s2Idx].push(ho);
							} else {
								ambiguous = true;
							}
						}
					}
					if (hole_unassigned) {
						betterShapeHoles[sIdx].push(ho);
					}
				}
			}
			if (toChange > 0 && ambiguous === false) {
				newShapeHoles = betterShapeHoles;
			}
		}
		let tmpHoles;
		for (let i = 0, il = newShapes.length; i < il; i++) {
			tmpShape = newShapes[i].s;
			shapes.push(tmpShape);
			tmpHoles = newShapeHoles[i];
			for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
				tmpShape.holes.push(tmpHoles[j].h);
			}
		}

		//console.log("shape", shapes);

		return shapes;
	}
}

/**
 * Text = 3D Text
 *
 * parameters = {
 *	font: <THREE.Font>, // font
 *
 *	size: <float>, // size of the text
 *	height: <float>, // thickness to extrude text
 *	curveSegments: <int>, // number of points on the curves
 *
 *	bevelEnabled: <bool>, // turn on bevel
 *	bevelThickness: <float>, // how deep into text bevel goes
 *	bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *	bevelOffset: <float> // how far from text outline does bevel start
 * }
 */
class TextGeometry extends ExtrudeGeometry {
	constructor(text, parameters = {}) {
		const font = parameters.font;
		if (font === undefined) {
			super(); // generate default extrude geometry
		} else {
			const shapes = font.generateShapes(text, parameters.size);

			// translate parameters to ExtrudeGeometry API

			parameters.depth = parameters.height !== undefined ? parameters.height : 50;

			// defaults

			if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
			if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
			if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
			super(shapes, parameters);
		}
		this.type = 'TextGeometry';
	}
}

var glyphs={"0":{x_min:73,x_max:715,ha:792,o:"m 394 -29 q 153 129 242 -29 q 73 479 73 272 q 152 829 73 687 q 394 989 241 989 q 634 829 545 989 q 715 479 715 684 q 635 129 715 270 q 394 -29 546 -29 m 394 89 q 546 211 489 89 q 598 479 598 322 q 548 748 598 640 q 394 871 491 871 q 241 748 298 871 q 190 479 190 637 q 239 211 190 319 q 394 89 296 89 "},"1":{x_min:215.671875,x_max:574,ha:792,o:"m 574 0 l 442 0 l 442 697 l 215 697 l 215 796 q 386 833 330 796 q 475 986 447 875 l 574 986 l 574 0 "},"2":{x_min:59,x_max:731,ha:792,o:"m 731 0 l 59 0 q 197 314 59 188 q 457 487 199 315 q 598 691 598 580 q 543 819 598 772 q 411 867 488 867 q 272 811 328 867 q 209 630 209 747 l 81 630 q 182 901 81 805 q 408 986 271 986 q 629 909 536 986 q 731 694 731 826 q 613 449 731 541 q 378 316 495 383 q 201 122 235 234 l 731 122 l 731 0 "},"3":{x_min:54,x_max:737,ha:792,o:"m 737 284 q 635 55 737 141 q 399 -25 541 -25 q 156 52 248 -25 q 54 308 54 140 l 185 308 q 245 147 185 202 q 395 96 302 96 q 539 140 484 96 q 602 280 602 190 q 510 429 602 390 q 324 454 451 454 l 324 565 q 487 584 441 565 q 565 719 565 617 q 515 835 565 791 q 395 879 466 879 q 255 824 307 879 q 203 661 203 769 l 78 661 q 166 909 78 822 q 387 992 250 992 q 603 921 513 992 q 701 723 701 844 q 669 607 701 656 q 578 524 637 558 q 696 434 655 499 q 737 284 737 369 "},"4":{x_min:48,x_max:742.453125,ha:792,o:"m 742 243 l 602 243 l 602 0 l 476 0 l 476 243 l 48 243 l 48 368 l 476 958 l 602 958 l 602 354 l 742 354 l 742 243 m 476 354 l 476 792 l 162 354 l 476 354 "},"5":{x_min:54.171875,x_max:738,ha:792,o:"m 738 314 q 626 60 738 153 q 382 -23 526 -23 q 155 47 248 -23 q 54 256 54 125 l 183 256 q 259 132 204 174 q 382 91 314 91 q 533 149 471 91 q 602 314 602 213 q 538 469 602 411 q 386 528 475 528 q 284 506 332 528 q 197 439 237 484 l 81 439 l 159 958 l 684 958 l 684 840 l 254 840 l 214 579 q 306 627 258 612 q 407 643 354 643 q 636 552 540 643 q 738 314 738 457 "},"6":{x_min:53,x_max:739,ha:792,o:"m 739 312 q 633 62 739 162 q 400 -31 534 -31 q 162 78 257 -31 q 53 439 53 206 q 178 859 53 712 q 441 986 284 986 q 643 912 559 986 q 732 713 732 833 l 601 713 q 544 830 594 786 q 426 875 494 875 q 268 793 331 875 q 193 517 193 697 q 301 597 240 570 q 427 624 362 624 q 643 540 552 624 q 739 312 739 451 m 603 298 q 540 461 603 400 q 404 516 484 516 q 268 461 323 516 q 207 300 207 401 q 269 137 207 198 q 405 83 325 83 q 541 137 486 83 q 603 298 603 197 "},"7":{x_min:58.71875,x_max:730.953125,ha:792,o:"m 730 839 q 469 448 560 641 q 335 0 378 255 l 192 0 q 328 441 235 252 q 593 830 421 630 l 58 830 l 58 958 l 730 958 l 730 839 "},"8":{x_min:55,x_max:736,ha:792,o:"m 571 527 q 694 424 652 491 q 736 280 736 358 q 648 71 736 158 q 395 -26 551 -26 q 142 69 238 -26 q 55 279 55 157 q 96 425 55 359 q 220 527 138 491 q 120 615 153 562 q 88 726 88 668 q 171 904 88 827 q 395 986 261 986 q 618 905 529 986 q 702 727 702 830 q 670 616 702 667 q 571 527 638 565 m 394 565 q 519 610 475 565 q 563 717 563 655 q 521 823 563 781 q 392 872 474 872 q 265 824 312 872 q 224 720 224 783 q 265 613 224 656 q 394 565 312 565 m 395 91 q 545 150 488 91 q 597 280 597 204 q 546 408 597 355 q 395 465 492 465 q 244 408 299 465 q 194 280 194 356 q 244 150 194 203 q 395 91 299 91 "},"9":{x_min:53,x_max:739,ha:792,o:"m 739 524 q 619 94 739 241 q 362 -32 516 -32 q 150 47 242 -32 q 59 244 59 126 l 191 244 q 246 129 191 176 q 373 82 301 82 q 526 161 466 82 q 597 440 597 255 q 363 334 501 334 q 130 432 216 334 q 53 650 53 521 q 134 880 53 786 q 383 986 226 986 q 659 841 566 986 q 739 524 739 719 m 388 449 q 535 514 480 449 q 585 658 585 573 q 535 805 585 744 q 388 873 480 873 q 242 809 294 873 q 191 658 191 745 q 239 514 191 572 q 388 449 292 449 "},"ο":{x_min:0,x_max:712,ha:815,o:"m 356 -25 q 96 88 192 -25 q 0 368 0 201 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 "},S:{x_min:0,x_max:788,ha:890,o:"m 788 291 q 662 54 788 144 q 397 -26 550 -26 q 116 68 226 -26 q 0 337 0 168 l 131 337 q 200 152 131 220 q 384 85 269 85 q 557 129 479 85 q 650 270 650 183 q 490 429 650 379 q 194 513 341 470 q 33 739 33 584 q 142 964 33 881 q 388 1041 242 1041 q 644 957 543 1041 q 756 716 756 867 l 625 716 q 561 874 625 816 q 395 933 497 933 q 243 891 309 933 q 164 759 164 841 q 325 609 164 656 q 625 526 475 568 q 788 291 788 454 "},"¦":{x_min:343,x_max:449,ha:792,o:"m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 "},"/":{x_min:183.25,x_max:608.328125,ha:792,o:"m 608 1041 l 266 -129 l 183 -129 l 520 1041 l 608 1041 "},"Τ":{x_min:-0.4375,x_max:777.453125,ha:839,o:"m 777 893 l 458 893 l 458 0 l 319 0 l 319 892 l 0 892 l 0 1013 l 777 1013 l 777 893 "},y:{x_min:0,x_max:684.78125,ha:771,o:"m 684 738 l 388 -83 q 311 -216 356 -167 q 173 -279 252 -279 q 97 -266 133 -279 l 97 -149 q 132 -155 109 -151 q 168 -160 155 -160 q 240 -114 213 -160 q 274 -26 248 -98 l 0 738 l 137 737 l 341 139 l 548 737 l 684 738 "},"Π":{x_min:0,x_max:803,ha:917,o:"m 803 0 l 667 0 l 667 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 803 1012 l 803 0 "},"ΐ":{x_min:-111,x_max:339,ha:361,o:"m 339 800 l 229 800 l 229 925 l 339 925 l 339 800 m -1 800 l -111 800 l -111 925 l -1 925 l -1 800 m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 m 302 1040 l 113 819 l 30 819 l 165 1040 l 302 1040 "},g:{x_min:0,x_max:686,ha:838,o:"m 686 34 q 586 -213 686 -121 q 331 -306 487 -306 q 131 -252 216 -306 q 31 -84 31 -190 l 155 -84 q 228 -174 166 -138 q 345 -207 284 -207 q 514 -109 454 -207 q 564 89 564 -27 q 461 6 521 36 q 335 -23 401 -23 q 88 100 184 -23 q 0 370 0 215 q 87 634 0 522 q 330 758 183 758 q 457 728 398 758 q 564 644 515 699 l 564 737 l 686 737 l 686 34 m 582 367 q 529 560 582 481 q 358 652 468 652 q 189 561 250 652 q 135 369 135 482 q 189 176 135 255 q 361 85 251 85 q 529 176 468 85 q 582 367 582 255 "},"²":{x_min:0,x_max:442,ha:539,o:"m 442 383 l 0 383 q 91 566 0 492 q 260 668 176 617 q 354 798 354 727 q 315 875 354 845 q 227 905 277 905 q 136 869 173 905 q 99 761 99 833 l 14 761 q 82 922 14 864 q 232 974 141 974 q 379 926 316 974 q 442 797 442 878 q 351 635 442 704 q 183 539 321 611 q 92 455 92 491 l 442 455 l 442 383 "},"–":{x_min:0,x_max:705.5625,ha:803,o:"m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 "},"Κ":{x_min:0,x_max:819.5625,ha:893,o:"m 819 0 l 650 0 l 294 509 l 139 356 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 "},"ƒ":{x_min:-46.265625,x_max:392,ha:513,o:"m 392 651 l 259 651 l 79 -279 l -46 -278 l 134 651 l 14 651 l 14 751 l 135 751 q 151 948 135 900 q 304 1041 185 1041 q 334 1040 319 1041 q 392 1034 348 1039 l 392 922 q 337 931 360 931 q 271 883 287 931 q 260 793 260 853 l 260 751 l 392 751 l 392 651 "},e:{x_min:0,x_max:714,ha:813,o:"m 714 326 l 140 326 q 200 157 140 227 q 359 87 260 87 q 488 130 431 87 q 561 245 545 174 l 697 245 q 577 48 670 123 q 358 -26 484 -26 q 97 85 195 -26 q 0 363 0 197 q 94 642 0 529 q 358 765 195 765 q 626 627 529 765 q 714 326 714 503 m 576 429 q 507 583 564 522 q 355 650 445 650 q 206 583 266 650 q 140 429 152 522 l 576 429 "},"ό":{x_min:0,x_max:712,ha:815,o:"m 356 -25 q 94 91 194 -25 q 0 368 0 202 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 m 576 1040 l 387 819 l 303 819 l 438 1040 l 576 1040 "},J:{x_min:0,x_max:588,ha:699,o:"m 588 279 q 287 -26 588 -26 q 58 73 126 -26 q 0 327 0 158 l 133 327 q 160 172 133 227 q 288 96 198 96 q 426 171 391 96 q 449 336 449 219 l 449 1013 l 588 1013 l 588 279 "},"»":{x_min:-1,x_max:503,ha:601,o:"m 503 302 l 280 136 l 281 256 l 429 373 l 281 486 l 280 608 l 503 440 l 503 302 m 221 302 l 0 136 l 0 255 l 145 372 l 0 486 l -1 608 l 221 440 l 221 302 "},"©":{x_min:-3,x_max:1008,ha:1106,o:"m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 741 394 q 661 246 731 302 q 496 190 591 190 q 294 285 369 190 q 228 497 228 370 q 295 714 228 625 q 499 813 370 813 q 656 762 588 813 q 733 625 724 711 l 634 625 q 589 704 629 673 q 498 735 550 735 q 377 666 421 735 q 334 504 334 597 q 374 340 334 408 q 490 272 415 272 q 589 304 549 272 q 638 394 628 337 l 741 394 "},"ώ":{x_min:0,x_max:922,ha:1030,o:"m 687 1040 l 498 819 l 415 819 l 549 1040 l 687 1040 m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 338 0 202 q 45 551 0 444 q 161 737 84 643 l 302 737 q 175 552 219 647 q 124 336 124 446 q 155 179 124 248 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 341 797 257 q 745 555 797 450 q 619 737 705 637 l 760 737 q 874 551 835 640 q 922 339 922 444 "},"^":{x_min:193.0625,x_max:598.609375,ha:792,o:"m 598 772 l 515 772 l 395 931 l 277 772 l 193 772 l 326 1013 l 462 1013 l 598 772 "},"«":{x_min:0,x_max:507.203125,ha:604,o:"m 506 136 l 284 302 l 284 440 l 506 608 l 507 485 l 360 371 l 506 255 l 506 136 m 222 136 l 0 302 l 0 440 l 222 608 l 221 486 l 73 373 l 222 256 l 222 136 "},D:{x_min:0,x_max:828,ha:935,o:"m 389 1013 q 714 867 593 1013 q 828 521 828 729 q 712 161 828 309 q 382 0 587 0 l 0 0 l 0 1013 l 389 1013 m 376 124 q 607 247 523 124 q 681 510 681 355 q 607 771 681 662 q 376 896 522 896 l 139 896 l 139 124 l 376 124 "},"∙":{x_min:0,x_max:142,ha:239,o:"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 "},"ÿ":{x_min:0,x_max:47,ha:125,o:"m 47 3 q 37 -7 47 -7 q 28 0 30 -7 q 39 -4 32 -4 q 45 3 45 -1 l 37 0 q 28 9 28 0 q 39 19 28 19 l 47 16 l 47 19 l 47 3 m 37 1 q 44 8 44 1 q 37 16 44 16 q 30 8 30 16 q 37 1 30 1 m 26 1 l 23 22 l 14 0 l 3 22 l 3 3 l 0 25 l 13 1 l 22 25 l 26 1 "},w:{x_min:0,x_max:1009.71875,ha:1100,o:"m 1009 738 l 783 0 l 658 0 l 501 567 l 345 0 l 222 0 l 0 738 l 130 738 l 284 174 l 432 737 l 576 738 l 721 173 l 881 737 l 1009 738 "},$:{x_min:0,x_max:700,ha:793,o:"m 664 717 l 542 717 q 490 825 531 785 q 381 872 450 865 l 381 551 q 620 446 540 522 q 700 241 700 370 q 618 45 700 116 q 381 -25 536 -25 l 381 -152 l 307 -152 l 307 -25 q 81 62 162 -25 q 0 297 0 149 l 124 297 q 169 146 124 204 q 307 81 215 89 l 307 441 q 80 536 148 469 q 13 725 13 603 q 96 910 13 839 q 307 982 180 982 l 307 1077 l 381 1077 l 381 982 q 574 917 494 982 q 664 717 664 845 m 307 565 l 307 872 q 187 831 233 872 q 142 724 142 791 q 180 618 142 656 q 307 565 218 580 m 381 76 q 562 237 562 96 q 517 361 562 313 q 381 423 472 409 l 381 76 "},"\\":{x_min:-0.015625,x_max:425.0625,ha:522,o:"m 425 -129 l 337 -129 l 0 1041 l 83 1041 l 425 -129 "},"µ":{x_min:0,x_max:697.21875,ha:747,o:"m 697 -4 q 629 -14 658 -14 q 498 97 513 -14 q 422 9 470 41 q 313 -23 374 -23 q 207 4 258 -23 q 119 81 156 32 l 119 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 173 124 246 q 308 83 216 83 q 452 178 402 83 q 493 359 493 255 l 493 738 l 617 738 l 617 214 q 623 136 617 160 q 673 92 637 92 q 697 96 684 92 l 697 -4 "},"Ι":{x_min:42,x_max:181,ha:297,o:"m 181 0 l 42 0 l 42 1013 l 181 1013 l 181 0 "},"Ύ":{x_min:0,x_max:1144.5,ha:1214,o:"m 1144 1012 l 807 416 l 807 0 l 667 0 l 667 416 l 325 1012 l 465 1012 l 736 533 l 1004 1012 l 1144 1012 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"’":{x_min:0,x_max:139,ha:236,o:"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 "},"Ν":{x_min:0,x_max:801,ha:915,o:"m 801 0 l 651 0 l 131 822 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 191 l 670 1013 l 801 1013 l 801 0 "},"-":{x_min:8.71875,x_max:350.390625,ha:478,o:"m 350 317 l 8 317 l 8 428 l 350 428 l 350 317 "},Q:{x_min:0,x_max:968,ha:1072,o:"m 954 5 l 887 -79 l 744 35 q 622 -11 687 2 q 483 -26 556 -26 q 127 130 262 -26 q 0 504 0 279 q 127 880 0 728 q 484 1041 262 1041 q 841 884 708 1041 q 968 507 968 735 q 933 293 968 398 q 832 104 899 188 l 954 5 m 723 191 q 802 330 777 248 q 828 499 828 412 q 744 790 828 673 q 483 922 650 922 q 228 791 322 922 q 142 505 142 673 q 227 221 142 337 q 487 91 323 91 q 632 123 566 91 l 520 215 l 587 301 l 723 191 "},"ς":{x_min:1,x_max:676.28125,ha:740,o:"m 676 460 l 551 460 q 498 595 542 546 q 365 651 448 651 q 199 578 263 651 q 136 401 136 505 q 266 178 136 241 q 508 106 387 142 q 640 -50 640 62 q 625 -158 640 -105 q 583 -278 611 -211 l 465 -278 q 498 -182 490 -211 q 515 -80 515 -126 q 381 12 515 -15 q 134 91 197 51 q 1 388 1 179 q 100 651 1 542 q 354 761 199 761 q 587 680 498 761 q 676 460 676 599 "},M:{x_min:0,x_max:954,ha:1067,o:"m 954 0 l 819 0 l 819 869 l 537 0 l 405 0 l 128 866 l 128 0 l 0 0 l 0 1013 l 200 1013 l 472 160 l 757 1013 l 954 1013 l 954 0 "},"Ψ":{x_min:0,x_max:1006,ha:1094,o:"m 1006 678 q 914 319 1006 429 q 571 200 814 200 l 571 0 l 433 0 l 433 200 q 92 319 194 200 q 0 678 0 429 l 0 1013 l 139 1013 l 139 679 q 191 417 139 492 q 433 326 255 326 l 433 1013 l 571 1013 l 571 326 l 580 326 q 813 423 747 326 q 868 679 868 502 l 868 1013 l 1006 1013 l 1006 678 "},C:{x_min:0,x_max:886,ha:944,o:"m 886 379 q 760 87 886 201 q 455 -26 634 -26 q 112 136 236 -26 q 0 509 0 283 q 118 882 0 737 q 469 1041 245 1041 q 748 955 630 1041 q 879 708 879 859 l 745 708 q 649 862 724 805 q 473 920 573 920 q 219 791 312 920 q 136 509 136 675 q 217 229 136 344 q 470 99 311 99 q 672 179 591 99 q 753 379 753 259 l 886 379 "},"!":{x_min:0,x_max:138,ha:236,o:"m 138 684 q 116 409 138 629 q 105 244 105 299 l 33 244 q 16 465 33 313 q 0 684 0 616 l 0 1013 l 138 1013 l 138 684 m 138 0 l 0 0 l 0 151 l 138 151 l 138 0 "},"{":{x_min:0,x_max:480.5625,ha:578,o:"m 480 -286 q 237 -213 303 -286 q 187 -45 187 -159 q 194 48 187 -15 q 201 141 201 112 q 164 264 201 225 q 0 314 118 314 l 0 417 q 164 471 119 417 q 201 605 201 514 q 199 665 201 644 q 193 772 193 769 q 241 941 193 887 q 480 1015 308 1015 l 480 915 q 336 866 375 915 q 306 742 306 828 q 310 662 306 717 q 314 577 314 606 q 288 452 314 500 q 176 365 256 391 q 289 275 257 337 q 314 143 314 226 q 313 84 314 107 q 310 -11 310 -5 q 339 -131 310 -94 q 480 -182 377 -182 l 480 -286 "},X:{x_min:-0.015625,x_max:854.15625,ha:940,o:"m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 428 637 l 675 1013 l 836 1013 l 504 520 l 854 0 "},"#":{x_min:0,x_max:963.890625,ha:1061,o:"m 963 690 l 927 590 l 719 590 l 655 410 l 876 410 l 840 310 l 618 310 l 508 -3 l 393 -2 l 506 309 l 329 310 l 215 -2 l 102 -3 l 212 310 l 0 310 l 36 410 l 248 409 l 312 590 l 86 590 l 120 690 l 347 690 l 459 1006 l 573 1006 l 462 690 l 640 690 l 751 1006 l 865 1006 l 754 690 l 963 690 m 606 590 l 425 590 l 362 410 l 543 410 l 606 590 "},"ι":{x_min:42,x_max:284,ha:361,o:"m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 738 l 167 738 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 "},"Ά":{x_min:0,x_max:906.953125,ha:982,o:"m 283 1040 l 88 799 l 5 799 l 145 1040 l 283 1040 m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1012 l 529 1012 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 "},")":{x_min:0,x_max:318,ha:415,o:"m 318 365 q 257 25 318 191 q 87 -290 197 -141 l 0 -290 q 140 21 93 -128 q 193 360 193 189 q 141 704 193 537 q 0 1024 97 850 l 87 1024 q 257 706 197 871 q 318 365 318 542 "},"ε":{x_min:0,x_max:634.71875,ha:714,o:"m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 314 0 265 q 128 390 67 353 q 56 460 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 "},"Δ":{x_min:0,x_max:952.78125,ha:1028,o:"m 952 0 l 0 0 l 400 1013 l 551 1013 l 952 0 m 762 124 l 476 867 l 187 124 l 762 124 "},"}":{x_min:0,x_max:481,ha:578,o:"m 481 314 q 318 262 364 314 q 282 136 282 222 q 284 65 282 97 q 293 -58 293 -48 q 241 -217 293 -166 q 0 -286 174 -286 l 0 -182 q 143 -130 105 -182 q 171 -2 171 -93 q 168 81 171 22 q 165 144 165 140 q 188 275 165 229 q 306 365 220 339 q 191 455 224 391 q 165 588 165 505 q 168 681 165 624 q 171 742 171 737 q 141 865 171 827 q 0 915 102 915 l 0 1015 q 243 942 176 1015 q 293 773 293 888 q 287 675 293 741 q 282 590 282 608 q 318 466 282 505 q 481 417 364 417 l 481 314 "},"‰":{x_min:-3,x_max:1672,ha:1821,o:"m 846 0 q 664 76 732 0 q 603 244 603 145 q 662 412 603 344 q 846 489 729 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 846 0 962 0 m 845 103 q 945 143 910 103 q 981 243 981 184 q 947 340 981 301 q 845 385 910 385 q 745 342 782 385 q 709 243 709 300 q 742 147 709 186 q 845 103 781 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 m 1428 0 q 1246 76 1314 0 q 1185 244 1185 145 q 1244 412 1185 344 q 1428 489 1311 489 q 1610 412 1542 489 q 1672 244 1672 343 q 1612 76 1672 144 q 1428 0 1545 0 m 1427 103 q 1528 143 1492 103 q 1564 243 1564 184 q 1530 340 1564 301 q 1427 385 1492 385 q 1327 342 1364 385 q 1291 243 1291 300 q 1324 147 1291 186 q 1427 103 1363 103 "},a:{x_min:0,x_max:698.609375,ha:794,o:"m 698 0 q 661 -12 679 -7 q 615 -17 643 -17 q 536 12 564 -17 q 500 96 508 41 q 384 6 456 37 q 236 -25 312 -25 q 65 31 130 -25 q 0 194 0 88 q 118 390 0 334 q 328 435 180 420 q 488 483 476 451 q 495 523 495 504 q 442 619 495 584 q 325 654 389 654 q 209 617 257 654 q 152 513 161 580 l 33 513 q 123 705 33 633 q 332 772 207 772 q 528 712 448 772 q 617 531 617 645 l 617 163 q 624 108 617 126 q 664 90 632 90 l 698 94 l 698 0 m 491 262 l 491 372 q 272 329 350 347 q 128 201 128 294 q 166 113 128 144 q 264 83 205 83 q 414 130 346 83 q 491 262 491 183 "},"—":{x_min:0,x_max:941.671875,ha:1039,o:"m 941 334 l 0 334 l 0 410 l 941 410 l 941 334 "},"=":{x_min:8.71875,x_max:780.953125,ha:792,o:"m 780 510 l 8 510 l 8 606 l 780 606 l 780 510 m 780 235 l 8 235 l 8 332 l 780 332 l 780 235 "},N:{x_min:0,x_max:801,ha:914,o:"m 801 0 l 651 0 l 131 823 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 193 l 670 1013 l 801 1013 l 801 0 "},"ρ":{x_min:0,x_max:712,ha:797,o:"m 712 369 q 620 94 712 207 q 362 -26 521 -26 q 230 2 292 -26 q 119 83 167 30 l 119 -278 l 0 -278 l 0 362 q 91 643 0 531 q 355 764 190 764 q 617 647 517 764 q 712 369 712 536 m 583 366 q 530 559 583 480 q 359 651 469 651 q 190 562 252 651 q 135 370 135 483 q 189 176 135 257 q 359 85 250 85 q 528 175 466 85 q 583 366 583 254 "},"¯":{x_min:0,x_max:941.671875,ha:938,o:"m 941 1033 l 0 1033 l 0 1109 l 941 1109 l 941 1033 "},Z:{x_min:0,x_max:779,ha:849,o:"m 779 0 l 0 0 l 0 113 l 621 896 l 40 896 l 40 1013 l 779 1013 l 778 887 l 171 124 l 779 124 l 779 0 "},u:{x_min:0,x_max:617,ha:729,o:"m 617 0 l 499 0 l 499 110 q 391 10 460 45 q 246 -25 322 -25 q 61 58 127 -25 q 0 258 0 136 l 0 738 l 125 738 l 125 284 q 156 148 125 202 q 273 82 197 82 q 433 165 369 82 q 493 340 493 243 l 493 738 l 617 738 l 617 0 "},k:{x_min:0,x_max:612.484375,ha:697,o:"m 612 738 l 338 465 l 608 0 l 469 0 l 251 382 l 121 251 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 402 l 456 738 l 612 738 "},"Η":{x_min:0,x_max:803,ha:917,o:"m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 "},"Α":{x_min:0,x_max:906.953125,ha:985,o:"m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 "},s:{x_min:0,x_max:604,ha:697,o:"m 604 217 q 501 36 604 104 q 292 -23 411 -23 q 86 43 166 -23 q 0 238 0 114 l 121 237 q 175 122 121 164 q 300 85 223 85 q 415 112 363 85 q 479 207 479 147 q 361 309 479 276 q 140 372 141 370 q 21 544 21 426 q 111 708 21 647 q 298 761 190 761 q 492 705 413 761 q 583 531 583 643 l 462 531 q 412 625 462 594 q 298 657 363 657 q 199 636 242 657 q 143 558 143 608 q 262 454 143 486 q 484 394 479 397 q 604 217 604 341 "},B:{x_min:0,x_max:778,ha:876,o:"m 580 546 q 724 469 670 535 q 778 311 778 403 q 673 83 778 171 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 892 q 691 633 732 693 q 580 546 650 572 m 393 899 l 139 899 l 139 588 l 379 588 q 521 624 462 588 q 592 744 592 667 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 303 635 219 q 559 436 635 389 q 402 477 494 477 l 139 477 l 139 124 l 419 124 "},"…":{x_min:0,x_max:614,ha:708,o:"m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 m 378 0 l 236 0 l 236 151 l 378 151 l 378 0 m 614 0 l 472 0 l 472 151 l 614 151 l 614 0 "},"?":{x_min:0,x_max:607,ha:704,o:"m 607 777 q 543 599 607 674 q 422 474 482 537 q 357 272 357 391 l 236 272 q 297 487 236 395 q 411 619 298 490 q 474 762 474 691 q 422 885 474 838 q 301 933 371 933 q 179 880 228 933 q 124 706 124 819 l 0 706 q 94 963 0 872 q 302 1044 177 1044 q 511 973 423 1044 q 607 777 607 895 m 370 0 l 230 0 l 230 151 l 370 151 l 370 0 "},H:{x_min:0,x_max:803,ha:915,o:"m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 "},"ν":{x_min:0,x_max:675,ha:761,o:"m 675 738 l 404 0 l 272 0 l 0 738 l 133 738 l 340 147 l 541 738 l 675 738 "},c:{x_min:1,x_max:701.390625,ha:775,o:"m 701 264 q 584 53 681 133 q 353 -26 487 -26 q 91 91 188 -26 q 1 370 1 201 q 92 645 1 537 q 353 761 190 761 q 572 688 479 761 q 690 493 666 615 l 556 493 q 487 606 545 562 q 356 650 428 650 q 186 563 246 650 q 134 372 134 487 q 188 179 134 258 q 359 88 250 88 q 492 136 437 88 q 566 264 548 185 l 701 264 "},"¶":{x_min:0,x_max:566.671875,ha:678,o:"m 21 892 l 52 892 l 98 761 l 145 892 l 176 892 l 178 741 l 157 741 l 157 867 l 108 741 l 88 741 l 40 871 l 40 741 l 21 741 l 21 892 m 308 854 l 308 731 q 252 691 308 691 q 227 691 240 691 q 207 696 213 695 l 207 712 l 253 706 q 288 733 288 706 l 288 763 q 244 741 279 741 q 193 797 193 741 q 261 860 193 860 q 287 860 273 860 q 308 854 302 855 m 288 842 l 263 843 q 213 796 213 843 q 248 756 213 756 q 288 796 288 756 l 288 842 m 566 988 l 502 988 l 502 -1 l 439 -1 l 439 988 l 317 988 l 317 -1 l 252 -1 l 252 602 q 81 653 155 602 q 0 805 0 711 q 101 989 0 918 q 309 1053 194 1053 l 566 1053 l 566 988 "},"β":{x_min:0,x_max:660,ha:745,o:"m 471 550 q 610 450 561 522 q 660 280 660 378 q 578 64 660 151 q 367 -22 497 -22 q 239 5 299 -22 q 126 82 178 32 l 126 -278 l 0 -278 l 0 593 q 54 903 0 801 q 318 1042 127 1042 q 519 964 436 1042 q 603 771 603 887 q 567 644 603 701 q 471 550 532 586 m 337 79 q 476 138 418 79 q 535 279 535 198 q 427 437 535 386 q 226 477 344 477 l 226 583 q 398 620 329 583 q 486 762 486 668 q 435 884 486 833 q 312 935 384 935 q 169 861 219 935 q 126 698 126 797 l 126 362 q 170 169 126 242 q 337 79 224 79 "},"Μ":{x_min:0,x_max:954,ha:1068,o:"m 954 0 l 819 0 l 819 868 l 537 0 l 405 0 l 128 865 l 128 0 l 0 0 l 0 1013 l 199 1013 l 472 158 l 758 1013 l 954 1013 l 954 0 "},"Ό":{x_min:0.109375,x_max:1120,ha:1217,o:"m 1120 505 q 994 132 1120 282 q 642 -29 861 -29 q 290 130 422 -29 q 167 505 167 280 q 294 883 167 730 q 650 1046 430 1046 q 999 882 868 1046 q 1120 505 1120 730 m 977 504 q 896 784 977 669 q 644 915 804 915 q 391 785 484 915 q 307 504 307 669 q 391 224 307 339 q 644 95 486 95 q 894 224 803 95 q 977 504 977 339 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"Ή":{x_min:0,x_max:1158,ha:1275,o:"m 1158 0 l 1022 0 l 1022 475 l 496 475 l 496 0 l 356 0 l 356 1012 l 496 1012 l 496 599 l 1022 599 l 1022 1012 l 1158 1012 l 1158 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"•":{x_min:0,x_max:663.890625,ha:775,o:"m 663 529 q 566 293 663 391 q 331 196 469 196 q 97 294 194 196 q 0 529 0 393 q 96 763 0 665 q 331 861 193 861 q 566 763 469 861 q 663 529 663 665 "},"¥":{x_min:0.1875,x_max:819.546875,ha:886,o:"m 563 561 l 697 561 l 696 487 l 520 487 l 482 416 l 482 380 l 697 380 l 695 308 l 482 308 l 482 0 l 342 0 l 342 308 l 125 308 l 125 380 l 342 380 l 342 417 l 303 487 l 125 487 l 125 561 l 258 561 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 l 563 561 "},"(":{x_min:0,x_max:318.0625,ha:415,o:"m 318 -290 l 230 -290 q 61 23 122 -142 q 0 365 0 190 q 62 712 0 540 q 230 1024 119 869 l 318 1024 q 175 705 219 853 q 125 360 125 542 q 176 22 125 187 q 318 -290 223 -127 "},U:{x_min:0,x_max:796,ha:904,o:"m 796 393 q 681 93 796 212 q 386 -25 566 -25 q 101 95 208 -25 q 0 393 0 211 l 0 1013 l 138 1013 l 138 391 q 204 191 138 270 q 394 107 276 107 q 586 191 512 107 q 656 391 656 270 l 656 1013 l 796 1013 l 796 393 "},"γ":{x_min:0.5,x_max:744.953125,ha:822,o:"m 744 737 l 463 54 l 463 -278 l 338 -278 l 338 54 l 154 495 q 104 597 124 569 q 13 651 67 651 l 0 651 l 0 751 l 39 753 q 168 711 121 753 q 242 594 207 676 l 403 208 l 617 737 l 744 737 "},"α":{x_min:0,x_max:765.5625,ha:809,o:"m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 728 407 760 q 563 637 524 696 l 563 739 l 685 739 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 96 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 "},F:{x_min:0,x_max:683.328125,ha:717,o:"m 683 888 l 140 888 l 140 583 l 613 583 l 613 458 l 140 458 l 140 0 l 0 0 l 0 1013 l 683 1013 l 683 888 "},"­":{x_min:0,x_max:705.5625,ha:803,o:"m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 "},":":{x_min:0,x_max:142,ha:239,o:"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 "},"Χ":{x_min:0,x_max:854.171875,ha:935,o:"m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 427 637 l 675 1013 l 836 1013 l 504 521 l 854 0 "},"*":{x_min:116,x_max:674,ha:792,o:"m 674 768 l 475 713 l 610 544 l 517 477 l 394 652 l 272 478 l 178 544 l 314 713 l 116 766 l 153 876 l 341 812 l 342 1013 l 446 1013 l 446 811 l 635 874 l 674 768 "},"†":{x_min:0,x_max:777,ha:835,o:"m 458 804 l 777 804 l 777 683 l 458 683 l 458 0 l 319 0 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 "},"°":{x_min:0,x_max:347,ha:444,o:"m 173 802 q 43 856 91 802 q 0 977 0 905 q 45 1101 0 1049 q 173 1153 90 1153 q 303 1098 255 1153 q 347 977 347 1049 q 303 856 347 905 q 173 802 256 802 m 173 884 q 238 910 214 884 q 262 973 262 937 q 239 1038 262 1012 q 173 1064 217 1064 q 108 1037 132 1064 q 85 973 85 1010 q 108 910 85 937 q 173 884 132 884 "},V:{x_min:0,x_max:862.71875,ha:940,o:"m 862 1013 l 505 0 l 361 0 l 0 1013 l 143 1013 l 434 165 l 718 1012 l 862 1013 "},"Ξ":{x_min:0,x_max:734.71875,ha:763,o:"m 723 889 l 9 889 l 9 1013 l 723 1013 l 723 889 m 673 463 l 61 463 l 61 589 l 673 589 l 673 463 m 734 0 l 0 0 l 0 124 l 734 124 l 734 0 "}," ":{x_min:0,x_max:0,ha:853},"Ϋ":{x_min:0.328125,x_max:819.515625,ha:889,o:"m 588 1046 l 460 1046 l 460 1189 l 588 1189 l 588 1046 m 360 1046 l 232 1046 l 232 1189 l 360 1189 l 360 1046 m 819 1012 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1012 l 140 1012 l 411 533 l 679 1012 l 819 1012 "},"”":{x_min:0,x_max:347,ha:454,o:"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 m 347 851 q 310 737 347 784 q 208 669 273 690 l 208 734 q 267 787 250 741 q 280 873 280 821 l 208 873 l 208 1013 l 347 1013 l 347 851 "},"@":{x_min:0,x_max:1260,ha:1357,o:"m 1098 -45 q 877 -160 1001 -117 q 633 -203 752 -203 q 155 -29 327 -203 q 0 360 0 127 q 176 802 0 616 q 687 1008 372 1008 q 1123 854 969 1008 q 1260 517 1260 718 q 1155 216 1260 341 q 868 82 1044 82 q 772 106 801 82 q 737 202 737 135 q 647 113 700 144 q 527 82 594 82 q 367 147 420 82 q 314 312 314 212 q 401 565 314 452 q 639 690 498 690 q 810 588 760 690 l 849 668 l 938 668 q 877 441 900 532 q 833 226 833 268 q 853 182 833 198 q 902 167 873 167 q 1088 272 1012 167 q 1159 512 1159 372 q 1051 793 1159 681 q 687 925 925 925 q 248 747 415 925 q 97 361 97 586 q 226 26 97 159 q 627 -122 370 -122 q 856 -87 737 -122 q 1061 8 976 -53 l 1098 -45 m 786 488 q 738 580 777 545 q 643 615 700 615 q 483 517 548 615 q 425 322 425 430 q 457 203 425 250 q 552 156 490 156 q 722 273 665 156 q 786 488 738 309 "},"Ί":{x_min:0,x_max:499,ha:613,o:"m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 m 499 0 l 360 0 l 360 1012 l 499 1012 l 499 0 "},i:{x_min:14,x_max:136,ha:275,o:"m 136 873 l 14 873 l 14 1013 l 136 1013 l 136 873 m 136 0 l 14 0 l 14 737 l 136 737 l 136 0 "},"Β":{x_min:0,x_max:778,ha:877,o:"m 580 545 q 724 468 671 534 q 778 310 778 402 q 673 83 778 170 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 891 q 691 632 732 692 q 580 545 650 571 m 393 899 l 139 899 l 139 587 l 379 587 q 521 623 462 587 q 592 744 592 666 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 302 635 219 q 559 435 635 388 q 402 476 494 476 l 139 476 l 139 124 l 419 124 "},"υ":{x_min:0,x_max:617,ha:725,o:"m 617 352 q 540 94 617 199 q 308 -24 455 -24 q 76 94 161 -24 q 0 352 0 199 l 0 739 l 126 739 l 126 355 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 355 492 257 l 492 739 l 617 739 l 617 352 "},"]":{x_min:0,x_max:275,ha:372,o:"m 275 -281 l 0 -281 l 0 -187 l 151 -187 l 151 920 l 0 920 l 0 1013 l 275 1013 l 275 -281 "},m:{x_min:0,x_max:1019,ha:1128,o:"m 1019 0 l 897 0 l 897 454 q 860 591 897 536 q 739 660 816 660 q 613 586 659 660 q 573 436 573 522 l 573 0 l 447 0 l 447 455 q 412 591 447 535 q 294 657 372 657 q 165 586 213 657 q 122 437 122 521 l 122 0 l 0 0 l 0 738 l 117 738 l 117 640 q 202 730 150 697 q 316 763 254 763 q 437 730 381 763 q 525 642 494 697 q 621 731 559 700 q 753 763 682 763 q 943 694 867 763 q 1019 512 1019 625 l 1019 0 "},"χ":{x_min:8.328125,x_max:780.5625,ha:815,o:"m 780 -278 q 715 -294 747 -294 q 616 -257 663 -294 q 548 -175 576 -227 l 379 133 l 143 -277 l 9 -277 l 313 254 l 163 522 q 127 586 131 580 q 36 640 91 640 q 8 637 27 640 l 8 752 l 52 757 q 162 719 113 757 q 236 627 200 690 l 383 372 l 594 737 l 726 737 l 448 250 l 625 -69 q 670 -153 647 -110 q 743 -188 695 -188 q 780 -184 759 -188 l 780 -278 "},"ί":{x_min:42,x_max:326.71875,ha:361,o:"m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 102 239 101 q 284 112 257 104 l 284 3 m 326 1040 l 137 819 l 54 819 l 189 1040 l 326 1040 "},"Ζ":{x_min:0,x_max:779.171875,ha:850,o:"m 779 0 l 0 0 l 0 113 l 620 896 l 40 896 l 40 1013 l 779 1013 l 779 887 l 170 124 l 779 124 l 779 0 "},R:{x_min:0,x_max:781.953125,ha:907,o:"m 781 0 l 623 0 q 587 242 590 52 q 407 433 585 433 l 138 433 l 138 0 l 0 0 l 0 1013 l 396 1013 q 636 946 539 1013 q 749 731 749 868 q 711 597 749 659 q 608 502 674 534 q 718 370 696 474 q 729 207 722 352 q 781 26 736 62 l 781 0 m 373 551 q 533 594 465 551 q 614 731 614 645 q 532 859 614 815 q 373 896 465 896 l 138 896 l 138 551 l 373 551 "},o:{x_min:0,x_max:713,ha:821,o:"m 357 -25 q 94 91 194 -25 q 0 368 0 202 q 93 642 0 533 q 357 761 193 761 q 618 644 518 761 q 713 368 713 533 q 619 91 713 201 q 357 -25 521 -25 m 357 85 q 528 175 465 85 q 584 369 584 255 q 529 562 584 484 q 357 651 467 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 357 85 250 85 "},K:{x_min:0,x_max:819.46875,ha:906,o:"m 819 0 l 649 0 l 294 509 l 139 355 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 "},",":{x_min:0,x_max:142,ha:239,o:"m 142 -12 q 105 -132 142 -82 q 0 -205 68 -182 l 0 -138 q 57 -82 40 -124 q 70 0 70 -51 l 0 0 l 0 151 l 142 151 l 142 -12 "},d:{x_min:0,x_max:683,ha:796,o:"m 683 0 l 564 0 l 564 93 q 456 6 516 38 q 327 -25 395 -25 q 87 100 181 -25 q 0 365 0 215 q 90 639 0 525 q 343 763 187 763 q 564 647 486 763 l 564 1013 l 683 1013 l 683 0 m 582 373 q 529 562 582 484 q 361 653 468 653 q 190 561 253 653 q 135 365 135 479 q 189 175 135 254 q 358 85 251 85 q 529 178 468 85 q 582 373 582 258 "},"¨":{x_min:-109,x_max:247,ha:232,o:"m 247 1046 l 119 1046 l 119 1189 l 247 1189 l 247 1046 m 19 1046 l -109 1046 l -109 1189 l 19 1189 l 19 1046 "},E:{x_min:0,x_max:736.109375,ha:789,o:"m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 "},Y:{x_min:0,x_max:820,ha:886,o:"m 820 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 534 l 679 1012 l 820 1013 "},"\"":{x_min:0,x_max:299,ha:396,o:"m 299 606 l 203 606 l 203 988 l 299 988 l 299 606 m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 "},"‹":{x_min:17.984375,x_max:773.609375,ha:792,o:"m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 "},"„":{x_min:0,x_max:364,ha:467,o:"m 141 -12 q 104 -132 141 -82 q 0 -205 67 -182 l 0 -138 q 56 -82 40 -124 q 69 0 69 -51 l 0 0 l 0 151 l 141 151 l 141 -12 m 364 -12 q 327 -132 364 -82 q 222 -205 290 -182 l 222 -138 q 279 -82 262 -124 q 292 0 292 -51 l 222 0 l 222 151 l 364 151 l 364 -12 "},"δ":{x_min:1,x_max:710,ha:810,o:"m 710 360 q 616 87 710 196 q 356 -28 518 -28 q 99 82 197 -28 q 1 356 1 192 q 100 606 1 509 q 355 703 199 703 q 180 829 288 754 q 70 903 124 866 l 70 1012 l 643 1012 l 643 901 l 258 901 q 462 763 422 794 q 636 592 577 677 q 710 360 710 485 m 584 365 q 552 501 584 447 q 451 602 521 555 q 372 611 411 611 q 197 541 258 611 q 136 355 136 472 q 190 171 136 245 q 358 85 252 85 q 528 173 465 85 q 584 365 584 252 "},"έ":{x_min:0,x_max:634.71875,ha:714,o:"m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 313 0 265 q 128 390 67 352 q 56 459 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 m 520 1040 l 331 819 l 248 819 l 383 1040 l 520 1040 "},"ω":{x_min:0,x_max:922,ha:1031,o:"m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 339 0 203 q 45 551 0 444 q 161 738 84 643 l 302 738 q 175 553 219 647 q 124 336 124 446 q 155 179 124 249 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 342 797 257 q 745 556 797 450 q 619 738 705 638 l 760 738 q 874 551 835 640 q 922 339 922 444 "},"´":{x_min:0,x_max:96,ha:251,o:"m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 "},"±":{x_min:11,x_max:781,ha:792,o:"m 781 490 l 446 490 l 446 255 l 349 255 l 349 490 l 11 490 l 11 586 l 349 586 l 349 819 l 446 819 l 446 586 l 781 586 l 781 490 m 781 21 l 11 21 l 11 115 l 781 115 l 781 21 "},"|":{x_min:343,x_max:449,ha:792,o:"m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 "},"ϋ":{x_min:0,x_max:617,ha:725,o:"m 482 800 l 372 800 l 372 925 l 482 925 l 482 800 m 239 800 l 129 800 l 129 925 l 239 925 l 239 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 "},"§":{x_min:0,x_max:593,ha:690,o:"m 593 425 q 554 312 593 369 q 467 233 516 254 q 537 83 537 172 q 459 -74 537 -12 q 288 -133 387 -133 q 115 -69 184 -133 q 47 96 47 -6 l 166 96 q 199 7 166 40 q 288 -26 232 -26 q 371 -5 332 -26 q 420 60 420 21 q 311 201 420 139 q 108 309 210 255 q 0 490 0 383 q 33 602 0 551 q 124 687 66 654 q 75 743 93 712 q 58 812 58 773 q 133 984 58 920 q 300 1043 201 1043 q 458 987 394 1043 q 529 814 529 925 l 411 814 q 370 908 404 877 q 289 939 336 939 q 213 911 246 939 q 180 841 180 883 q 286 720 180 779 q 484 612 480 615 q 593 425 593 534 m 467 409 q 355 544 467 473 q 196 630 228 612 q 146 587 162 609 q 124 525 124 558 q 239 387 124 462 q 398 298 369 315 q 448 345 429 316 q 467 409 467 375 "},b:{x_min:0,x_max:685,ha:783,o:"m 685 372 q 597 99 685 213 q 347 -25 501 -25 q 219 5 277 -25 q 121 93 161 36 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 634 q 214 723 157 692 q 341 754 272 754 q 591 637 493 754 q 685 372 685 526 m 554 356 q 499 550 554 470 q 328 644 437 644 q 162 556 223 644 q 108 369 108 478 q 160 176 108 256 q 330 83 221 83 q 498 169 435 83 q 554 356 554 245 "},q:{x_min:0,x_max:683,ha:876,o:"m 683 -278 l 564 -278 l 564 97 q 474 8 533 39 q 345 -23 415 -23 q 91 93 188 -23 q 0 364 0 203 q 87 635 0 522 q 337 760 184 760 q 466 727 408 760 q 564 637 523 695 l 564 737 l 683 737 l 683 -278 m 582 375 q 527 564 582 488 q 358 652 466 652 q 190 565 253 652 q 135 377 135 488 q 189 179 135 261 q 361 84 251 84 q 530 179 469 84 q 582 375 582 260 "},"Ω":{x_min:-0.171875,x_max:969.5625,ha:1068,o:"m 969 0 l 555 0 l 555 123 q 744 308 675 194 q 814 558 814 423 q 726 812 814 709 q 484 922 633 922 q 244 820 334 922 q 154 567 154 719 q 223 316 154 433 q 412 123 292 199 l 412 0 l 0 0 l 0 124 l 217 124 q 68 327 122 210 q 15 572 15 444 q 144 911 15 781 q 484 1041 274 1041 q 822 909 691 1041 q 953 569 953 777 q 899 326 953 443 q 750 124 846 210 l 969 124 l 969 0 "},"ύ":{x_min:0,x_max:617,ha:725,o:"m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 535 1040 l 346 819 l 262 819 l 397 1040 l 535 1040 "},z:{x_min:-0.015625,x_max:613.890625,ha:697,o:"m 613 0 l 0 0 l 0 100 l 433 630 l 20 630 l 20 738 l 594 738 l 593 636 l 163 110 l 613 110 l 613 0 "},"™":{x_min:0,x_max:894,ha:1000,o:"m 389 951 l 229 951 l 229 503 l 160 503 l 160 951 l 0 951 l 0 1011 l 389 1011 l 389 951 m 894 503 l 827 503 l 827 939 l 685 503 l 620 503 l 481 937 l 481 503 l 417 503 l 417 1011 l 517 1011 l 653 580 l 796 1010 l 894 1011 l 894 503 "},"ή":{x_min:0.78125,x_max:697,ha:810,o:"m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 721 124 755 q 200 630 193 687 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 m 479 1040 l 290 819 l 207 819 l 341 1040 l 479 1040 "},"Θ":{x_min:0,x_max:960,ha:1056,o:"m 960 507 q 833 129 960 280 q 476 -32 698 -32 q 123 129 255 -32 q 0 507 0 280 q 123 883 0 732 q 476 1045 255 1045 q 832 883 696 1045 q 960 507 960 732 m 817 500 q 733 789 817 669 q 476 924 639 924 q 223 792 317 924 q 142 507 142 675 q 222 222 142 339 q 476 89 315 89 q 730 218 636 89 q 817 500 817 334 m 716 449 l 243 449 l 243 571 l 716 571 l 716 449 "},"®":{x_min:-3,x_max:1008,ha:1106,o:"m 503 532 q 614 562 566 532 q 672 658 672 598 q 614 747 672 716 q 503 772 569 772 l 338 772 l 338 532 l 503 532 m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 788 146 l 678 146 q 653 316 655 183 q 527 449 652 449 l 338 449 l 338 146 l 241 146 l 241 854 l 518 854 q 688 808 621 854 q 766 658 766 755 q 739 563 766 607 q 668 497 713 519 q 751 331 747 472 q 788 164 756 190 l 788 146 "},"~":{x_min:0,x_max:833,ha:931,o:"m 833 958 q 778 753 833 831 q 594 665 716 665 q 402 761 502 665 q 240 857 302 857 q 131 795 166 857 q 104 665 104 745 l 0 665 q 54 867 0 789 q 237 958 116 958 q 429 861 331 958 q 594 765 527 765 q 704 827 670 765 q 729 958 729 874 l 833 958 "},"Ε":{x_min:0,x_max:736.21875,ha:778,o:"m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 "},"³":{x_min:0,x_max:450,ha:547,o:"m 450 552 q 379 413 450 464 q 220 366 313 366 q 69 414 130 366 q 0 567 0 470 l 85 567 q 126 470 85 504 q 225 437 168 437 q 320 467 280 437 q 360 552 360 498 q 318 632 360 608 q 213 657 276 657 q 195 657 203 657 q 176 657 181 657 l 176 722 q 279 733 249 722 q 334 815 334 752 q 300 881 334 856 q 220 907 267 907 q 133 875 169 907 q 97 781 97 844 l 15 781 q 78 926 15 875 q 220 972 135 972 q 364 930 303 972 q 426 817 426 888 q 344 697 426 733 q 421 642 392 681 q 450 552 450 603 "},"[":{x_min:0,x_max:273.609375,ha:371,o:"m 273 -281 l 0 -281 l 0 1013 l 273 1013 l 273 920 l 124 920 l 124 -187 l 273 -187 l 273 -281 "},L:{x_min:0,x_max:645.828125,ha:696,o:"m 645 0 l 0 0 l 0 1013 l 140 1013 l 140 126 l 645 126 l 645 0 "},"σ":{x_min:0,x_max:803.390625,ha:894,o:"m 803 628 l 633 628 q 713 368 713 512 q 618 93 713 204 q 357 -25 518 -25 q 94 91 194 -25 q 0 368 0 201 q 94 644 0 533 q 356 761 194 761 q 481 750 398 761 q 608 739 564 739 l 803 739 l 803 628 m 360 85 q 529 180 467 85 q 584 374 584 262 q 527 566 584 490 q 352 651 463 651 q 187 559 247 651 q 135 368 135 478 q 189 175 135 254 q 360 85 251 85 "},"ζ":{x_min:0,x_max:573,ha:642,o:"m 573 -40 q 553 -162 573 -97 q 510 -278 543 -193 l 400 -278 q 441 -187 428 -219 q 462 -90 462 -132 q 378 -14 462 -14 q 108 45 197 -14 q 0 290 0 117 q 108 631 0 462 q 353 901 194 767 l 55 901 l 55 1012 l 561 1012 l 561 924 q 261 669 382 831 q 128 301 128 489 q 243 117 128 149 q 458 98 350 108 q 573 -40 573 80 "},"θ":{x_min:0,x_max:674,ha:778,o:"m 674 496 q 601 160 674 304 q 336 -26 508 -26 q 73 153 165 -26 q 0 485 0 296 q 72 840 0 683 q 343 1045 166 1045 q 605 844 516 1045 q 674 496 674 692 m 546 579 q 498 798 546 691 q 336 935 437 935 q 178 798 237 935 q 126 579 137 701 l 546 579 m 546 475 l 126 475 q 170 233 126 348 q 338 80 230 80 q 504 233 447 80 q 546 475 546 346 "},"Ο":{x_min:0,x_max:958,ha:1054,o:"m 485 1042 q 834 883 703 1042 q 958 511 958 735 q 834 136 958 287 q 481 -26 701 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 729 q 485 1042 263 1042 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 670 q 480 913 640 913 q 226 785 321 913 q 142 504 142 671 q 226 224 142 339 q 480 98 319 98 "},"Γ":{x_min:0,x_max:705.28125,ha:749,o:"m 705 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 705 1012 l 705 886 "}," ":{x_min:0,x_max:0,ha:375},"%":{x_min:-3,x_max:1089,ha:1186,o:"m 845 0 q 663 76 731 0 q 602 244 602 145 q 661 412 602 344 q 845 489 728 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 845 0 962 0 m 844 103 q 945 143 909 103 q 981 243 981 184 q 947 340 981 301 q 844 385 909 385 q 744 342 781 385 q 708 243 708 300 q 741 147 708 186 q 844 103 780 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 "},P:{x_min:0,x_max:726,ha:806,o:"m 424 1013 q 640 931 555 1013 q 726 719 726 850 q 637 506 726 587 q 413 426 548 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 379 889 l 140 889 l 140 548 l 372 548 q 522 589 459 548 q 593 720 593 637 q 528 845 593 801 q 379 889 463 889 "},"Έ":{x_min:0,x_max:1078.21875,ha:1118,o:"m 1078 0 l 342 0 l 342 1013 l 1067 1013 l 1067 889 l 481 889 l 481 585 l 1019 585 l 1019 467 l 481 467 l 481 125 l 1078 125 l 1078 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"Ώ":{x_min:0.125,x_max:1136.546875,ha:1235,o:"m 1136 0 l 722 0 l 722 123 q 911 309 842 194 q 981 558 981 423 q 893 813 981 710 q 651 923 800 923 q 411 821 501 923 q 321 568 321 720 q 390 316 321 433 q 579 123 459 200 l 579 0 l 166 0 l 166 124 l 384 124 q 235 327 289 210 q 182 572 182 444 q 311 912 182 782 q 651 1042 441 1042 q 989 910 858 1042 q 1120 569 1120 778 q 1066 326 1120 443 q 917 124 1013 210 l 1136 124 l 1136 0 m 277 1040 l 83 800 l 0 800 l 140 1041 l 277 1040 "},_:{x_min:0,x_max:705.5625,ha:803,o:"m 705 -334 l 0 -334 l 0 -234 l 705 -234 l 705 -334 "},"Ϊ":{x_min:-110,x_max:246,ha:275,o:"m 246 1046 l 118 1046 l 118 1189 l 246 1189 l 246 1046 m 18 1046 l -110 1046 l -110 1189 l 18 1189 l 18 1046 m 136 0 l 0 0 l 0 1012 l 136 1012 l 136 0 "},"+":{x_min:23,x_max:768,ha:792,o:"m 768 372 l 444 372 l 444 0 l 347 0 l 347 372 l 23 372 l 23 468 l 347 468 l 347 840 l 444 840 l 444 468 l 768 468 l 768 372 "},"½":{x_min:0,x_max:1050,ha:1149,o:"m 1050 0 l 625 0 q 712 178 625 108 q 878 277 722 187 q 967 385 967 328 q 932 456 967 429 q 850 484 897 484 q 759 450 798 484 q 721 352 721 416 l 640 352 q 706 502 640 448 q 851 551 766 551 q 987 509 931 551 q 1050 385 1050 462 q 976 251 1050 301 q 829 179 902 215 q 717 68 740 133 l 1050 68 l 1050 0 m 834 985 l 215 -28 l 130 -28 l 750 984 l 834 985 m 224 422 l 142 422 l 142 811 l 0 811 l 0 867 q 104 889 62 867 q 164 973 157 916 l 224 973 l 224 422 "},"Ρ":{x_min:0,x_max:720,ha:783,o:"m 424 1013 q 637 933 554 1013 q 720 723 720 853 q 633 508 720 591 q 413 426 546 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 378 889 l 140 889 l 140 548 l 371 548 q 521 589 458 548 q 592 720 592 637 q 527 845 592 801 q 378 889 463 889 "},"'":{x_min:0,x_max:139,ha:236,o:"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 "},"ª":{x_min:0,x_max:350,ha:397,o:"m 350 625 q 307 616 328 616 q 266 631 281 616 q 247 673 251 645 q 190 628 225 644 q 116 613 156 613 q 32 641 64 613 q 0 722 0 669 q 72 826 0 800 q 247 866 159 846 l 247 887 q 220 934 247 916 q 162 953 194 953 q 104 934 129 953 q 76 882 80 915 l 16 882 q 60 976 16 941 q 166 1011 104 1011 q 266 979 224 1011 q 308 891 308 948 l 308 706 q 311 679 308 688 q 331 670 315 670 l 350 672 l 350 625 m 247 757 l 247 811 q 136 790 175 798 q 64 726 64 773 q 83 682 64 697 q 132 667 103 667 q 207 690 174 667 q 247 757 247 718 "},"΅":{x_min:0,x_max:450,ha:553,o:"m 450 800 l 340 800 l 340 925 l 450 925 l 450 800 m 406 1040 l 212 800 l 129 800 l 269 1040 l 406 1040 m 110 800 l 0 800 l 0 925 l 110 925 l 110 800 "},T:{x_min:0,x_max:777,ha:835,o:"m 777 894 l 458 894 l 458 0 l 319 0 l 319 894 l 0 894 l 0 1013 l 777 1013 l 777 894 "},"Φ":{x_min:0,x_max:915,ha:997,o:"m 527 0 l 389 0 l 389 122 q 110 231 220 122 q 0 509 0 340 q 110 785 0 677 q 389 893 220 893 l 389 1013 l 527 1013 l 527 893 q 804 786 693 893 q 915 509 915 679 q 805 231 915 341 q 527 122 696 122 l 527 0 m 527 226 q 712 310 641 226 q 779 507 779 389 q 712 705 779 627 q 527 787 641 787 l 527 226 m 389 226 l 389 787 q 205 698 275 775 q 136 505 136 620 q 206 308 136 391 q 389 226 276 226 "},"⁋":{x_min:0,x_max:0,ha:694},j:{x_min:-77.78125,x_max:167,ha:349,o:"m 167 871 l 42 871 l 42 1013 l 167 1013 l 167 871 m 167 -80 q 121 -231 167 -184 q -26 -278 76 -278 l -77 -278 l -77 -164 l -41 -164 q 26 -143 11 -164 q 42 -65 42 -122 l 42 737 l 167 737 l 167 -80 "},"Σ":{x_min:0,x_max:756.953125,ha:819,o:"m 756 0 l 0 0 l 0 107 l 395 523 l 22 904 l 22 1013 l 745 1013 l 745 889 l 209 889 l 566 523 l 187 125 l 756 125 l 756 0 "},"›":{x_min:18.0625,x_max:774,ha:792,o:"m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 "},"<":{x_min:17.984375,x_max:773.609375,ha:792,o:"m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 "},"£":{x_min:0,x_max:704.484375,ha:801,o:"m 704 41 q 623 -10 664 5 q 543 -26 583 -26 q 359 15 501 -26 q 243 36 288 36 q 158 23 197 36 q 73 -21 119 10 l 6 76 q 125 195 90 150 q 175 331 175 262 q 147 443 175 383 l 0 443 l 0 512 l 108 512 q 43 734 43 623 q 120 929 43 854 q 358 1010 204 1010 q 579 936 487 1010 q 678 729 678 857 l 678 684 l 552 684 q 504 838 552 780 q 362 896 457 896 q 216 852 263 896 q 176 747 176 815 q 199 627 176 697 q 248 512 217 574 l 468 512 l 468 443 l 279 443 q 297 356 297 398 q 230 194 297 279 q 153 107 211 170 q 227 133 190 125 q 293 142 264 142 q 410 119 339 142 q 516 96 482 96 q 579 105 550 96 q 648 142 608 115 l 704 41 "},t:{x_min:0,x_max:367,ha:458,o:"m 367 0 q 312 -5 339 -2 q 262 -8 284 -8 q 145 28 183 -8 q 108 143 108 64 l 108 638 l 0 638 l 0 738 l 108 738 l 108 944 l 232 944 l 232 738 l 367 738 l 367 638 l 232 638 l 232 185 q 248 121 232 140 q 307 102 264 102 q 345 104 330 102 q 367 107 360 107 l 367 0 "},"¬":{x_min:0,x_max:706,ha:803,o:"m 706 411 l 706 158 l 630 158 l 630 335 l 0 335 l 0 411 l 706 411 "},"λ":{x_min:0,x_max:750,ha:803,o:"m 750 -7 q 679 -15 716 -15 q 538 59 591 -15 q 466 214 512 97 l 336 551 l 126 0 l 0 0 l 270 705 q 223 837 247 770 q 116 899 190 899 q 90 898 100 899 l 90 1004 q 152 1011 125 1011 q 298 938 244 1011 q 373 783 326 901 l 605 192 q 649 115 629 136 q 716 95 669 95 l 736 95 q 750 97 745 97 l 750 -7 "},W:{x_min:0,x_max:1263.890625,ha:1351,o:"m 1263 1013 l 995 0 l 859 0 l 627 837 l 405 0 l 265 0 l 0 1013 l 136 1013 l 342 202 l 556 1013 l 701 1013 l 921 207 l 1133 1012 l 1263 1013 "},">":{x_min:18.0625,x_max:774,ha:792,o:"m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 "},v:{x_min:0,x_max:675.15625,ha:761,o:"m 675 738 l 404 0 l 272 0 l 0 738 l 133 737 l 340 147 l 541 737 l 675 738 "},"τ":{x_min:0.28125,x_max:644.5,ha:703,o:"m 644 628 l 382 628 l 382 179 q 388 120 382 137 q 436 91 401 91 q 474 94 447 91 q 504 97 501 97 l 504 0 q 454 -9 482 -5 q 401 -14 426 -14 q 278 67 308 -14 q 260 233 260 118 l 260 628 l 0 628 l 0 739 l 644 739 l 644 628 "},"ξ":{x_min:0,x_max:624.9375,ha:699,o:"m 624 -37 q 608 -153 624 -96 q 563 -278 593 -211 l 454 -278 q 491 -183 486 -200 q 511 -83 511 -126 q 484 -23 511 -44 q 370 1 452 1 q 323 0 354 1 q 283 -1 293 -1 q 84 76 169 -1 q 0 266 0 154 q 56 431 0 358 q 197 538 108 498 q 94 613 134 562 q 54 730 54 665 q 77 823 54 780 q 143 901 101 867 l 27 901 l 27 1012 l 576 1012 l 576 901 l 380 901 q 244 863 303 901 q 178 745 178 820 q 312 600 178 636 q 532 582 380 582 l 532 479 q 276 455 361 479 q 118 281 118 410 q 165 173 118 217 q 274 120 208 133 q 494 101 384 110 q 624 -37 624 76 "},"&":{x_min:-3,x_max:894.25,ha:992,o:"m 894 0 l 725 0 l 624 123 q 471 0 553 40 q 306 -41 390 -41 q 168 -7 231 -41 q 62 92 105 26 q 14 187 31 139 q -3 276 -3 235 q 55 433 -3 358 q 248 581 114 508 q 170 689 196 640 q 137 817 137 751 q 214 985 137 922 q 384 1041 284 1041 q 548 988 483 1041 q 622 824 622 928 q 563 666 622 739 q 431 556 516 608 l 621 326 q 649 407 639 361 q 663 493 653 426 l 781 493 q 703 229 781 352 l 894 0 m 504 818 q 468 908 504 877 q 384 940 433 940 q 293 907 331 940 q 255 818 255 875 q 289 714 255 767 q 363 628 313 678 q 477 729 446 682 q 504 818 504 771 m 556 209 l 314 499 q 179 395 223 449 q 135 283 135 341 q 146 222 135 253 q 183 158 158 192 q 333 80 241 80 q 556 209 448 80 "},"Λ":{x_min:0,x_max:862.5,ha:942,o:"m 862 0 l 719 0 l 426 847 l 143 0 l 0 0 l 356 1013 l 501 1013 l 862 0 "},I:{x_min:41,x_max:180,ha:293,o:"m 180 0 l 41 0 l 41 1013 l 180 1013 l 180 0 "},G:{x_min:0,x_max:921,ha:1011,o:"m 921 0 l 832 0 l 801 136 q 655 15 741 58 q 470 -28 568 -28 q 126 133 259 -28 q 0 499 0 284 q 125 881 0 731 q 486 1043 259 1043 q 763 957 647 1043 q 905 709 890 864 l 772 709 q 668 866 747 807 q 486 926 589 926 q 228 795 322 926 q 142 507 142 677 q 228 224 142 342 q 483 94 323 94 q 712 195 625 94 q 796 435 796 291 l 477 435 l 477 549 l 921 549 l 921 0 "},"ΰ":{x_min:0,x_max:617,ha:725,o:"m 524 800 l 414 800 l 414 925 l 524 925 l 524 800 m 183 800 l 73 800 l 73 925 l 183 925 l 183 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 489 1040 l 300 819 l 216 819 l 351 1040 l 489 1040 "},"`":{x_min:0,x_max:138.890625,ha:236,o:"m 138 699 l 0 699 l 0 861 q 36 974 0 929 q 138 1041 72 1020 l 138 977 q 82 931 95 969 q 69 839 69 893 l 138 839 l 138 699 "},"·":{x_min:0,x_max:142,ha:239,o:"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 "},"Υ":{x_min:0.328125,x_max:819.515625,ha:889,o:"m 819 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 "},r:{x_min:0,x_max:355.5625,ha:432,o:"m 355 621 l 343 621 q 179 569 236 621 q 122 411 122 518 l 122 0 l 0 0 l 0 737 l 117 737 l 117 604 q 204 719 146 686 q 355 753 262 753 l 355 621 "},x:{x_min:0,x_max:675,ha:764,o:"m 675 0 l 525 0 l 331 286 l 144 0 l 0 0 l 256 379 l 12 738 l 157 737 l 336 473 l 516 738 l 661 738 l 412 380 l 675 0 "},"μ":{x_min:0,x_max:696.609375,ha:747,o:"m 696 -4 q 628 -14 657 -14 q 498 97 513 -14 q 422 8 470 41 q 313 -24 374 -24 q 207 3 258 -24 q 120 80 157 31 l 120 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 172 124 246 q 308 82 216 82 q 451 177 402 82 q 492 358 492 254 l 492 738 l 616 738 l 616 214 q 623 136 616 160 q 673 92 636 92 q 696 95 684 92 l 696 -4 "},h:{x_min:0,x_max:615,ha:724,o:"m 615 472 l 615 0 l 490 0 l 490 454 q 456 590 490 535 q 338 654 416 654 q 186 588 251 654 q 122 436 122 522 l 122 0 l 0 0 l 0 1013 l 122 1013 l 122 633 q 218 727 149 694 q 362 760 287 760 q 552 676 484 760 q 615 472 615 600 "},".":{x_min:0,x_max:142,ha:239,o:"m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 "},"φ":{x_min:-2,x_max:878,ha:974,o:"m 496 -279 l 378 -279 l 378 -17 q 101 88 204 -17 q -2 367 -2 194 q 68 626 -2 510 q 283 758 151 758 l 283 646 q 167 537 209 626 q 133 373 133 462 q 192 177 133 254 q 378 93 259 93 l 378 758 q 445 764 426 763 q 476 765 464 765 q 765 659 653 765 q 878 377 878 553 q 771 96 878 209 q 496 -17 665 -17 l 496 -279 m 496 93 l 514 93 q 687 183 623 93 q 746 380 746 265 q 691 569 746 491 q 522 658 629 658 l 496 656 l 496 93 "},";":{x_min:0,x_max:142,ha:239,o:"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 -12 q 105 -132 142 -82 q 0 -206 68 -182 l 0 -138 q 58 -82 43 -123 q 68 0 68 -56 l 0 0 l 0 151 l 142 151 l 142 -12 "},f:{x_min:0,x_max:378,ha:472,o:"m 378 638 l 246 638 l 246 0 l 121 0 l 121 638 l 0 638 l 0 738 l 121 738 q 137 935 121 887 q 290 1028 171 1028 q 320 1027 305 1028 q 378 1021 334 1026 l 378 908 q 323 918 346 918 q 257 870 273 918 q 246 780 246 840 l 246 738 l 378 738 l 378 638 "},"“":{x_min:1,x_max:348.21875,ha:454,o:"m 140 670 l 1 670 l 1 830 q 37 943 1 897 q 140 1011 74 990 l 140 947 q 82 900 97 940 q 68 810 68 861 l 140 810 l 140 670 m 348 670 l 209 670 l 209 830 q 245 943 209 897 q 348 1011 282 990 l 348 947 q 290 900 305 940 q 276 810 276 861 l 348 810 l 348 670 "},A:{x_min:0.03125,x_max:906.953125,ha:1008,o:"m 906 0 l 756 0 l 648 303 l 251 303 l 142 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 610 421 l 452 867 l 293 421 l 610 421 "},"‘":{x_min:1,x_max:139.890625,ha:236,o:"m 139 670 l 1 670 l 1 830 q 37 943 1 897 q 139 1011 74 990 l 139 947 q 82 900 97 940 q 68 810 68 861 l 139 810 l 139 670 "},"ϊ":{x_min:-70,x_max:283,ha:361,o:"m 283 800 l 173 800 l 173 925 l 283 925 l 283 800 m 40 800 l -70 800 l -70 925 l 40 925 l 40 800 m 283 3 q 232 -10 257 -5 q 181 -15 206 -15 q 84 26 118 -15 q 41 200 41 79 l 41 737 l 166 737 l 167 215 q 171 141 167 157 q 225 101 182 101 q 247 103 238 101 q 283 112 256 104 l 283 3 "},"π":{x_min:-0.21875,x_max:773.21875,ha:857,o:"m 773 -7 l 707 -11 q 575 40 607 -11 q 552 174 552 77 l 552 226 l 552 626 l 222 626 l 222 0 l 97 0 l 97 626 l 0 626 l 0 737 l 773 737 l 773 626 l 676 626 l 676 171 q 695 103 676 117 q 773 90 714 90 l 773 -7 "},"ά":{x_min:0,x_max:765.5625,ha:809,o:"m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 727 407 760 q 563 637 524 695 l 563 738 l 685 738 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 95 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 m 604 1040 l 415 819 l 332 819 l 466 1040 l 604 1040 "},O:{x_min:0,x_max:958,ha:1057,o:"m 485 1041 q 834 882 702 1041 q 958 512 958 734 q 834 136 958 287 q 481 -26 702 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 728 q 485 1041 263 1041 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 669 q 480 912 640 912 q 226 784 321 912 q 142 504 142 670 q 226 224 142 339 q 480 98 319 98 "},n:{x_min:0,x_max:615,ha:724,o:"m 615 463 l 615 0 l 490 0 l 490 454 q 453 592 490 537 q 331 656 410 656 q 178 585 240 656 q 117 421 117 514 l 117 0 l 0 0 l 0 738 l 117 738 l 117 630 q 218 728 150 693 q 359 764 286 764 q 552 675 484 764 q 615 463 615 593 "},l:{x_min:41,x_max:166,ha:279,o:"m 166 0 l 41 0 l 41 1013 l 166 1013 l 166 0 "},"¤":{x_min:40.09375,x_max:728.796875,ha:825,o:"m 728 304 l 649 224 l 512 363 q 383 331 458 331 q 256 363 310 331 l 119 224 l 40 304 l 177 441 q 150 553 150 493 q 184 673 150 621 l 40 818 l 119 898 l 267 749 q 321 766 291 759 q 384 773 351 773 q 447 766 417 773 q 501 749 477 759 l 649 898 l 728 818 l 585 675 q 612 618 604 648 q 621 553 621 587 q 591 441 621 491 l 728 304 m 384 682 q 280 643 318 682 q 243 551 243 604 q 279 461 243 499 q 383 423 316 423 q 487 461 449 423 q 525 553 525 500 q 490 641 525 605 q 384 682 451 682 "},"κ":{x_min:0,x_max:632.328125,ha:679,o:"m 632 0 l 482 0 l 225 384 l 124 288 l 124 0 l 0 0 l 0 738 l 124 738 l 124 446 l 433 738 l 596 738 l 312 466 l 632 0 "},p:{x_min:0,x_max:685,ha:786,o:"m 685 364 q 598 96 685 205 q 350 -23 504 -23 q 121 89 205 -23 l 121 -278 l 0 -278 l 0 738 l 121 738 l 121 633 q 220 726 159 691 q 351 761 280 761 q 598 636 504 761 q 685 364 685 522 m 557 371 q 501 560 557 481 q 330 651 437 651 q 162 559 223 651 q 108 366 108 479 q 162 177 108 254 q 333 87 224 87 q 502 178 441 87 q 557 371 557 258 "},"‡":{x_min:0,x_max:777,ha:835,o:"m 458 238 l 458 0 l 319 0 l 319 238 l 0 238 l 0 360 l 319 360 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 l 777 804 l 777 683 l 458 683 l 458 360 l 777 360 l 777 238 l 458 238 "},"ψ":{x_min:0,x_max:808,ha:907,o:"m 465 -278 l 341 -278 l 341 -15 q 87 102 180 -15 q 0 378 0 210 l 0 739 l 133 739 l 133 379 q 182 195 133 275 q 341 98 242 98 l 341 922 l 465 922 l 465 98 q 623 195 563 98 q 675 382 675 278 l 675 742 l 808 742 l 808 381 q 720 104 808 213 q 466 -13 627 -13 l 465 -278 "},"η":{x_min:0.78125,x_max:697,ha:810,o:"m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 720 124 755 q 200 630 193 686 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 "}};var cssFontWeight="normal";var ascender=1189;var underlinePosition=-100;var cssFontStyle="normal";var boundingBox={yMin:-334,xMin:-111,yMax:1189,xMax:1672};var resolution=1000;var original_font_information={postscript_name:"Helvetiker-Regular",version_string:"Version 1.00 2004 initial release",vendor_url:"http://www.magenta.gr/",full_font_name:"Helvetiker",font_family_name:"Helvetiker",copyright:"Copyright (c) Μagenta ltd, 2004",description:"",trademark:"",designer:"",designer_url:"",unique_font_identifier:"Μagenta ltd:Helvetiker:22-10-104",license_url:"http://www.ellak.gr/fonts/MgOpen/license.html",license_description:"Copyright (c) 2004 by MAGENTA Ltd. All Rights Reserved.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of the fonts accompanying this license (\"Fonts\") and associated documentation files (the \"Font Software\"), to reproduce and distribute the Font Software, including without limitation the rights to use, copy, merge, publish, distribute, and/or sell copies of the Font Software, and to permit persons to whom the Font Software is furnished to do so, subject to the following conditions: \r\n\r\nThe above copyright and this permission notice shall be included in all copies of one or more of the Font Software typefaces.\r\n\r\nThe Font Software may be modified, altered, or added to, and in particular the designs of glyphs or characters in the Fonts may be modified and additional glyphs or characters may be added to the Fonts, only if the fonts are renamed to names not containing the word \"MgOpen\", or if the modifications are accepted for inclusion in the Font Software itself by the each appointed Administrator.\r\n\r\nThis License becomes null and void to the extent applicable to Fonts or Font Software that has been modified and is distributed under the \"MgOpen\" name.\r\n\r\nThe Font Software may be sold as part of a larger software package but no copy of one or more of the Font Software typefaces may be sold by itself. \r\n\r\nTHE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL MAGENTA OR PERSONS OR BODIES IN CHARGE OF ADMINISTRATION AND MAINTENANCE OF THE FONT SOFTWARE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.",manufacturer_name:"Μagenta ltd",font_sub_family_name:"Regular"};var descender=-334;var familyName="Helvetiker";var lineHeight=1522;var underlineThickness=50;var helvetiker_regular_typeface = {glyphs:glyphs,cssFontWeight:cssFontWeight,ascender:ascender,underlinePosition:underlinePosition,cssFontStyle:cssFontStyle,boundingBox:boundingBox,resolution:resolution,original_font_information:original_font_information,descender:descender,familyName:familyName,lineHeight:lineHeight,underlineThickness:underlineThickness};

var json1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	glyphs: glyphs,
	cssFontWeight: cssFontWeight,
	ascender: ascender,
	underlinePosition: underlinePosition,
	cssFontStyle: cssFontStyle,
	boundingBox: boundingBox,
	resolution: resolution,
	original_font_information: original_font_information,
	descender: descender,
	familyName: familyName,
	lineHeight: lineHeight,
	underlineThickness: underlineThickness,
	'default': helvetiker_regular_typeface
});

//

class Font {
	constructor(data) {
		this.isFont = true;
		this.type = 'Font';
		this.data = data;
	}
	generateShapes(text, size = 100) {
		const shapes = [];
		const paths = createPaths(text, size, this.data);
		for (let p = 0, pl = paths.length; p < pl; p++) {
			shapes.push(...paths[p].toShapes());
		}
		return shapes;
	}
}
function createPaths(text, size, data) {
	const chars = Array.from(text);
	const scale = size / data.resolution;
	const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
	const paths = [];
	let offsetX = 0,
		offsetY = 0;
	for (let i = 0; i < chars.length; i++) {
		const char = chars[i];
		if (char === '\n') {
			offsetX = 0;
			offsetY -= line_height;
		} else {
			const ret = createPath(char, scale, offsetX, offsetY, data);
			offsetX += ret.offsetX;
			paths.push(ret.path);
		}
	}
	return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
	const glyph = data.glyphs[char] || data.glyphs['?'];
	if (!glyph) {
		console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
		return;
	}
	const path = new ShapePath();
	let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
	if (glyph.o) {
		const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
		for (let i = 0, l = outline.length; i < l;) {
			const action = outline[i++];
			switch (action) {
				case 'm':
					// moveTo

					x = outline[i++] * scale + offsetX;
					y = outline[i++] * scale + offsetY;
					path.moveTo(x, y);
					break;
				case 'l':
					// lineTo

					x = outline[i++] * scale + offsetX;
					y = outline[i++] * scale + offsetY;
					path.lineTo(x, y);
					break;
				case 'q':
					// quadraticCurveTo

					cpx = outline[i++] * scale + offsetX;
					cpy = outline[i++] * scale + offsetY;
					cpx1 = outline[i++] * scale + offsetX;
					cpy1 = outline[i++] * scale + offsetY;
					path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
					break;
				case 'b':
					// bezierCurveTo

					cpx = outline[i++] * scale + offsetX;
					cpy = outline[i++] * scale + offsetY;
					cpx1 = outline[i++] * scale + offsetX;
					cpy1 = outline[i++] * scale + offsetY;
					cpx2 = outline[i++] * scale + offsetX;
					cpy2 = outline[i++] * scale + offsetY;
					path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
					break;
			}
		}
	}
	return {
		offsetX: glyph.ha * scale,
		path: path
	};
}

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//		Orbit - left mouse / touch: one-finger move
//		Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//		Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

const _changeEvent$1 = {
	type: 'change'
};
const _startEvent = {
	type: 'start'
};
const _endEvent = {
	type: 'end'
};
class OrbitControls extends EventDispatcher {
	constructor(object, domElement) {
		super();
		this.object = object;
		this.domElement = domElement;
		this.domElement.style.touchAction = 'none'; // disable touch scroll

		// Set to false to disable this control
		this.enabled = true;

		// "target" sets the location of focus, where the object orbits around
		this.target = new Vector3();

		// How far you can dolly in and out ( PerspectiveCamera only )
		this.minDistance = 0;
		this.maxDistance = Infinity;

		// How far you can zoom in and out ( OrthographicCamera only )
		this.minZoom = 0;
		this.maxZoom = Infinity;

		// How far you can orbit vertically, upper and lower limits.
		// Range is 0 to Math.PI radians.
		this.minPolarAngle = 0; // radians
		this.maxPolarAngle = Math.PI; // radians

		// How far you can orbit horizontally, upper and lower limits.
		// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
		this.minAzimuthAngle = -Infinity; // radians
		this.maxAzimuthAngle = Infinity; // radians

		// Set to true to enable damping (inertia)
		// If damping is enabled, you must call controls.update() in your animation loop
		this.enableDamping = false;
		this.dampingFactor = 0.05;

		// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
		// Set to false to disable zooming
		this.enableZoom = true;
		this.zoomSpeed = 1.0;

		// Set to false to disable rotating
		this.enableRotate = true;
		this.rotateSpeed = 1.0;

		// Set to false to disable panning
		this.enablePan = true;
		this.panSpeed = 1.0;
		this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
		this.keyPanSpeed = 7.0; // pixels moved per arrow key push

		// Set to true to automatically rotate around the target
		// If auto-rotate is enabled, you must call controls.update() in your animation loop
		this.autoRotate = false;
		this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60

		// The four arrow keys
		this.keys = {
			LEFT: 'ArrowLeft',
			UP: 'ArrowUp',
			RIGHT: 'ArrowRight',
			BOTTOM: 'ArrowDown'
		};

		// Mouse buttons
		this.mouseButtons = {
			LEFT: MOUSE.ROTATE,
			MIDDLE: MOUSE.DOLLY,
			RIGHT: MOUSE.PAN
		};

		// Touch fingers
		this.touches = {
			ONE: TOUCH.ROTATE,
			TWO: TOUCH.DOLLY_PAN
		};

		// for reset
		this.target0 = this.target.clone();
		this.position0 = this.object.position.clone();
		this.zoom0 = this.object.zoom;

		// the target DOM element for key events
		this._domElementKeyEvents = null;

		//
		// public methods
		//

		this.getPolarAngle = function () {
			return spherical.phi;
		};
		this.getAzimuthalAngle = function () {
			return spherical.theta;
		};
		this.getDistance = function () {
			return this.object.position.distanceTo(this.target);
		};
		this.listenToKeyEvents = function (domElement) {
			domElement.addEventListener('keydown', onKeyDown);
			this._domElementKeyEvents = domElement;
		};
		this.saveState = function () {
			scope.target0.copy(scope.target);
			scope.position0.copy(scope.object.position);
			scope.zoom0 = scope.object.zoom;
		};
		this.reset = function () {
			scope.target.copy(scope.target0);
			scope.object.position.copy(scope.position0);
			scope.object.zoom = scope.zoom0;
			scope.object.updateProjectionMatrix();
			scope.dispatchEvent(_changeEvent$1);
			scope.update();
			state = STATE.NONE;
		};
		this.resetOrthoPanZoom = function () {
			panOffset.set(0, 0, 0);
			scope.object.zoom = 1;
			scope.object.updateProjectionMatrix();
			zoomChanged = true;
		};

		// this method is exposed, but perhaps it would be better if we can make it private...
		this.update = function () {
			const offset = new Vector3();

			// so camera.up is the orbit axis
			const quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
			const quatInverse = quat.clone().invert();
			const lastPosition = new Vector3();
			const lastQuaternion = new Quaternion();
			const twoPI = 2 * Math.PI;
			return function update() {
				const position = scope.object.position;
				offset.copy(position).sub(scope.target);

				// rotate offset to "y-axis-is-up" space
				offset.applyQuaternion(quat);

				// angle from z-axis around y-axis
				spherical.setFromVector3(offset);
				if (scope.autoRotate && state === STATE.NONE) {
					rotateLeft(getAutoRotationAngle());
				}
				if (scope.enableDamping) {
					spherical.theta += sphericalDelta.theta * scope.dampingFactor;
					spherical.phi += sphericalDelta.phi * scope.dampingFactor;
				} else {
					spherical.theta += sphericalDelta.theta;
					spherical.phi += sphericalDelta.phi;
				}

				// restrict theta to be between desired limits

				let min = scope.minAzimuthAngle;
				let max = scope.maxAzimuthAngle;
				if (isFinite(min) && isFinite(max)) {
					if (min < -Math.PI) min += twoPI;else if (min > Math.PI) min -= twoPI;
					if (max < -Math.PI) max += twoPI;else if (max > Math.PI) max -= twoPI;
					if (min <= max) {
						spherical.theta = Math.max(min, Math.min(max, spherical.theta));
					} else {
						spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
					}
				}

				// restrict phi to be between desired limits
				spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
				spherical.makeSafe();
				spherical.radius *= scale;

				// restrict radius to be between desired limits
				spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));

				// move target to panned location

				if (scope.enableDamping === true) {
					scope.target.addScaledVector(panOffset, scope.dampingFactor);
				} else {
					scope.target.add(panOffset);
				}
				offset.setFromSpherical(spherical);

				// rotate offset back to "camera-up-vector-is-up" space
				offset.applyQuaternion(quatInverse);
				position.copy(scope.target).add(offset);
				scope.object.lookAt(scope.target);
				if (scope.enableDamping === true) {
					sphericalDelta.theta *= 1 - scope.dampingFactor;
					sphericalDelta.phi *= 1 - scope.dampingFactor;
					panOffset.multiplyScalar(1 - scope.dampingFactor);
				} else {
					sphericalDelta.set(0, 0, 0);
					panOffset.set(0, 0, 0);
				}
				scale = 1;

				// update condition is:
				// min(camera displacement, camera rotation in radians)^2 > EPS
				// using small-angle approximation cos(x/2) = 1 - x^2 / 8

				if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
					scope.dispatchEvent(_changeEvent$1);
					lastPosition.copy(scope.object.position);
					lastQuaternion.copy(scope.object.quaternion);
					zoomChanged = false;
					return true;
				}
				return false;
			};
		}();
		this.dispose = function () {
			scope.domElement.removeEventListener('contextmenu', onContextMenu);
			scope.domElement.removeEventListener('pointerdown', onPointerDown);
			scope.domElement.removeEventListener('pointercancel', onPointerCancel);
			scope.domElement.removeEventListener('wheel', onMouseWheel);
			scope.domElement.removeEventListener('pointermove', onPointerMove);
			scope.domElement.removeEventListener('pointerup', onPointerUp);
			if (scope._domElementKeyEvents !== null) {
				scope._domElementKeyEvents.removeEventListener('keydown', onKeyDown);
			}

			//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
		};

		//
		// internals
		//

		const scope = this;
		const STATE = {
			NONE: -1,
			ROTATE: 0,
			DOLLY: 1,
			PAN: 2,
			TOUCH_ROTATE: 3,
			TOUCH_PAN: 4,
			TOUCH_DOLLY_PAN: 5,
			TOUCH_DOLLY_ROTATE: 6
		};
		let state = STATE.NONE;
		const EPS = 0.000001;

		// current position in spherical coordinates
		const spherical = new Spherical();
		const sphericalDelta = new Spherical();
		let scale = 1;
		const panOffset = new Vector3();
		let zoomChanged = false;
		const rotateStart = new Vector2();
		const rotateEnd = new Vector2();
		const rotateDelta = new Vector2();
		const panStart = new Vector2();
		const panEnd = new Vector2();
		const panDelta = new Vector2();
		const dollyStart = new Vector2();
		const dollyEnd = new Vector2();
		const dollyDelta = new Vector2();
		const pointers = [];
		const pointerPositions = {};
		function getAutoRotationAngle() {
			return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
		}
		function getZoomScale() {
			return Math.pow(0.95, scope.zoomSpeed);
		}
		function rotateLeft(angle) {
			sphericalDelta.theta -= angle;
		}
		function rotateUp(angle) {
			sphericalDelta.phi -= angle;
		}
		const panLeft = function () {
			const v = new Vector3();
			return function panLeft(distance, objectMatrix) {
				v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
				v.multiplyScalar(-distance);
				panOffset.add(v);
			};
		}();
		const panUp = function () {
			const v = new Vector3();
			return function panUp(distance, objectMatrix) {
				if (scope.screenSpacePanning === true) {
					v.setFromMatrixColumn(objectMatrix, 1);
				} else {
					v.setFromMatrixColumn(objectMatrix, 0);
					v.crossVectors(scope.object.up, v);
				}
				v.multiplyScalar(distance);
				panOffset.add(v);
			};
		}();

		// deltaX and deltaY are in pixels; right and down are positive
		const pan = function () {
			const offset = new Vector3();
			return function pan(deltaX, deltaY) {
				const element = scope.domElement;
				if (scope.object.isPerspectiveCamera) {
					// perspective
					const position = scope.object.position;
					offset.copy(position).sub(scope.target);
					let targetDistance = offset.length();

					// half of the fov is center to top of screen
					targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);

					// we use only clientHeight here so aspect ratio does not distort speed
					panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
					panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
				} else if (scope.object.isOrthographicCamera) {
					// orthographic
					panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
					panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
				} else {
					// camera neither orthographic nor perspective
					console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
					scope.enablePan = false;
				}
			};
		}();
		function dollyOut(dollyScale) {
			if (scope.object.isPerspectiveCamera) {
				scale /= dollyScale;
			} else if (scope.object.isOrthographicCamera) {
				scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
				scope.object.updateProjectionMatrix();
				zoomChanged = true;
			} else {
				console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
				scope.enableZoom = false;
			}
		}
		function dollyIn(dollyScale) {
			if (scope.object.isPerspectiveCamera) {
				scale *= dollyScale;
			} else if (scope.object.isOrthographicCamera) {
				scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
				scope.object.updateProjectionMatrix();
				zoomChanged = true;
			} else {
				console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
				scope.enableZoom = false;
			}
		}

		//
		// event callbacks - update the object state
		//

		function handleMouseDownRotate(event) {
			rotateStart.set(event.clientX, event.clientY);
		}
		function handleMouseDownDolly(event) {
			dollyStart.set(event.clientX, event.clientY);
		}
		function handleMouseDownPan(event) {
			panStart.set(event.clientX, event.clientY);
		}
		function handleMouseMoveRotate(event) {
			rotateEnd.set(event.clientX, event.clientY);
			rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
			const element = scope.domElement;
			rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

			rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
			rotateStart.copy(rotateEnd);
			scope.update();
		}
		function handleMouseMoveDolly(event) {
			dollyEnd.set(event.clientX, event.clientY);
			dollyDelta.subVectors(dollyEnd, dollyStart);
			if (dollyDelta.y > 0) {
				dollyOut(getZoomScale());
			} else if (dollyDelta.y < 0) {
				dollyIn(getZoomScale());
			}
			dollyStart.copy(dollyEnd);
			scope.update();
		}
		function handleMouseMovePan(event) {
			panEnd.set(event.clientX, event.clientY);
			panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
			pan(panDelta.x, panDelta.y);
			panStart.copy(panEnd);
			scope.update();
		}
		function handleMouseWheel(event) {
			if (event.deltaY < 0) {
				dollyIn(getZoomScale());
			} else if (event.deltaY > 0) {
				dollyOut(getZoomScale());
			}
			scope.update();
		}
		function handleKeyDown(event) {
			let needsUpdate = false;
			switch (event.code) {
				case scope.keys.UP:
					pan(0, scope.keyPanSpeed);
					needsUpdate = true;
					break;
				case scope.keys.BOTTOM:
					pan(0, -scope.keyPanSpeed);
					needsUpdate = true;
					break;
				case scope.keys.LEFT:
					pan(scope.keyPanSpeed, 0);
					needsUpdate = true;
					break;
				case scope.keys.RIGHT:
					pan(-scope.keyPanSpeed, 0);
					needsUpdate = true;
					break;
			}
			if (needsUpdate) {
				// prevent the browser from scrolling on cursor keys
				event.preventDefault();
				scope.update();
			}
		}
		function handleTouchStartRotate() {
			if (pointers.length === 1) {
				rotateStart.set(pointers[0].pageX, pointers[0].pageY);
			} else {
				const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
				const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
				rotateStart.set(x, y);
			}
		}
		function handleTouchStartPan() {
			if (pointers.length === 1) {
				panStart.set(pointers[0].pageX, pointers[0].pageY);
			} else {
				const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
				const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
				panStart.set(x, y);
			}
		}
		function handleTouchStartDolly() {
			const dx = pointers[0].pageX - pointers[1].pageX;
			const dy = pointers[0].pageY - pointers[1].pageY;
			const distance = Math.sqrt(dx * dx + dy * dy);
			dollyStart.set(0, distance);
		}
		function handleTouchStartDollyPan() {
			if (scope.enableZoom) handleTouchStartDolly();
			if (scope.enablePan) handleTouchStartPan();
		}
		function handleTouchStartDollyRotate() {
			if (scope.enableZoom) handleTouchStartDolly();
			if (scope.enableRotate) handleTouchStartRotate();
		}
		function handleTouchMoveRotate(event) {
			if (pointers.length == 1) {
				rotateEnd.set(event.pageX, event.pageY);
			} else {
				const position = getSecondPointerPosition(event);
				const x = 0.5 * (event.pageX + position.x);
				const y = 0.5 * (event.pageY + position.y);
				rotateEnd.set(x, y);
			}
			rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
			const element = scope.domElement;
			rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

			rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
			rotateStart.copy(rotateEnd);
		}
		function handleTouchMovePan(event) {
			if (pointers.length === 1) {
				panEnd.set(event.pageX, event.pageY);
			} else {
				const position = getSecondPointerPosition(event);
				const x = 0.5 * (event.pageX + position.x);
				const y = 0.5 * (event.pageY + position.y);
				panEnd.set(x, y);
			}
			panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
			pan(panDelta.x, panDelta.y);
			panStart.copy(panEnd);
		}
		function handleTouchMoveDolly(event) {
			const position = getSecondPointerPosition(event);
			const dx = event.pageX - position.x;
			const dy = event.pageY - position.y;
			const distance = Math.sqrt(dx * dx + dy * dy);
			dollyEnd.set(0, distance);
			dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
			dollyOut(dollyDelta.y);
			dollyStart.copy(dollyEnd);
		}
		function handleTouchMoveDollyPan(event) {
			if (scope.enableZoom) handleTouchMoveDolly(event);
			if (scope.enablePan) handleTouchMovePan(event);
		}
		function handleTouchMoveDollyRotate(event) {
			if (scope.enableZoom) handleTouchMoveDolly(event);
			if (scope.enableRotate) handleTouchMoveRotate(event);
		}

		//
		// event handlers - FSM: listen for events and reset state
		//

		function onPointerDown(event) {
			if (scope.enabled === false) return;
			if (pointers.length === 0) {
				scope.domElement.setPointerCapture(event.pointerId);
				scope.domElement.addEventListener('pointermove', onPointerMove);
				scope.domElement.addEventListener('pointerup', onPointerUp);
			}

			//

			addPointer(event);
			if (event.pointerType === 'touch') {
				onTouchStart(event);
			} else {
				onMouseDown(event);
			}
		}
		function onPointerMove(event) {
			if (scope.enabled === false) return;
			if (event.pointerType === 'touch') {
				onTouchMove(event);
			} else {
				onMouseMove(event);
			}
		}
		function onPointerUp(event) {
			removePointer(event);
			if (pointers.length === 0) {
				scope.domElement.releasePointerCapture(event.pointerId);
				scope.domElement.removeEventListener('pointermove', onPointerMove);
				scope.domElement.removeEventListener('pointerup', onPointerUp);
			}
			scope.dispatchEvent(_endEvent);
			state = STATE.NONE;
		}
		function onPointerCancel(event) {
			removePointer(event);
		}
		function onMouseDown(event) {
			let mouseAction;
			switch (event.button) {
				case 0:
					mouseAction = scope.mouseButtons.LEFT;
					break;
				case 1:
					mouseAction = scope.mouseButtons.MIDDLE;
					break;
				case 2:
					mouseAction = scope.mouseButtons.RIGHT;
					break;
				default:
					mouseAction = -1;
			}
			switch (mouseAction) {
				case MOUSE.DOLLY:
					if (scope.enableZoom === false) return;
					handleMouseDownDolly(event);
					state = STATE.DOLLY;
					break;
				case MOUSE.ROTATE:
					if (event.ctrlKey || event.metaKey || event.shiftKey) {
						if (scope.enablePan === false) return;
						handleMouseDownPan(event);
						state = STATE.PAN;
					} else {
						if (scope.enableRotate === false) return;
						handleMouseDownRotate(event);
						state = STATE.ROTATE;
					}
					break;
				case MOUSE.PAN:
					if (event.ctrlKey || event.metaKey || event.shiftKey) {
						if (scope.enableRotate === false) return;
						handleMouseDownRotate(event);
						state = STATE.ROTATE;
					} else {
						if (scope.enablePan === false) return;
						handleMouseDownPan(event);
						state = STATE.PAN;
					}
					break;
				default:
					state = STATE.NONE;
			}
			if (state !== STATE.NONE) {
				scope.dispatchEvent(_startEvent);
			}
		}
		function onMouseMove(event) {
			switch (state) {
				case STATE.ROTATE:
					if (scope.enableRotate === false) return;
					handleMouseMoveRotate(event);
					break;
				case STATE.DOLLY:
					if (scope.enableZoom === false) return;
					handleMouseMoveDolly(event);
					break;
				case STATE.PAN:
					if (scope.enablePan === false) return;
					handleMouseMovePan(event);
					break;
			}
		}
		function onMouseWheel(event) {
			if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE) return;
			event.preventDefault();
			scope.dispatchEvent(_startEvent);
			handleMouseWheel(event);
			scope.dispatchEvent(_endEvent);
		}
		function onKeyDown(event) {
			if (scope.enabled === false || scope.enablePan === false) return;
			handleKeyDown(event);
		}
		function onTouchStart(event) {
			trackPointer(event);
			switch (pointers.length) {
				case 1:
					switch (scope.touches.ONE) {
						case TOUCH.ROTATE:
							if (scope.enableRotate === false) return;
							handleTouchStartRotate();
							state = STATE.TOUCH_ROTATE;
							break;
						case TOUCH.PAN:
							if (scope.enablePan === false) return;
							handleTouchStartPan();
							state = STATE.TOUCH_PAN;
							break;
						default:
							state = STATE.NONE;
					}
					break;
				case 2:
					switch (scope.touches.TWO) {
						case TOUCH.DOLLY_PAN:
							if (scope.enableZoom === false && scope.enablePan === false) return;
							handleTouchStartDollyPan();
							state = STATE.TOUCH_DOLLY_PAN;
							break;
						case TOUCH.DOLLY_ROTATE:
							if (scope.enableZoom === false && scope.enableRotate === false) return;
							handleTouchStartDollyRotate();
							state = STATE.TOUCH_DOLLY_ROTATE;
							break;
						default:
							state = STATE.NONE;
					}
					break;
				default:
					state = STATE.NONE;
			}
			if (state !== STATE.NONE) {
				scope.dispatchEvent(_startEvent);
			}
		}
		function onTouchMove(event) {
			trackPointer(event);
			switch (state) {
				case STATE.TOUCH_ROTATE:
					if (scope.enableRotate === false) return;
					handleTouchMoveRotate(event);
					scope.update();
					break;
				case STATE.TOUCH_PAN:
					if (scope.enablePan === false) return;
					handleTouchMovePan(event);
					scope.update();
					break;
				case STATE.TOUCH_DOLLY_PAN:
					if (scope.enableZoom === false && scope.enablePan === false) return;
					handleTouchMoveDollyPan(event);
					scope.update();
					break;
				case STATE.TOUCH_DOLLY_ROTATE:
					if (scope.enableZoom === false && scope.enableRotate === false) return;
					handleTouchMoveDollyRotate(event);
					scope.update();
					break;
				default:
					state = STATE.NONE;
			}
		}
		function onContextMenu(event) {
			if (scope.enabled === false) return;
			event.preventDefault();
		}
		function addPointer(event) {
			pointers.push(event);
		}
		function removePointer(event) {
			delete pointerPositions[event.pointerId];
			for (let i = 0; i < pointers.length; i++) {
				if (pointers[i].pointerId == event.pointerId) {
					pointers.splice(i, 1);
					return;
				}
			}
		}
		function trackPointer(event) {
			let position = pointerPositions[event.pointerId];
			if (position === undefined) {
				position = new Vector2();
				pointerPositions[event.pointerId] = position;
			}
			position.set(event.pageX, event.pageY);
		}
		function getSecondPointerPosition(event) {
			const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
			return pointerPositions[pointer.pointerId];
		}

		//

		scope.domElement.addEventListener('contextmenu', onContextMenu);
		scope.domElement.addEventListener('pointerdown', onPointerDown);
		scope.domElement.addEventListener('pointercancel', onPointerCancel);
		scope.domElement.addEventListener('wheel', onMouseWheel, {
			passive: false
		});

		// force an update at start

		this.update();
	}
}

const _raycaster = new Raycaster();
const _tempVector = new Vector3();
const _tempVector2 = new Vector3();
const _tempQuaternion = new Quaternion();
const _unit = {
	X: new Vector3(1, 0, 0),
	Y: new Vector3(0, 1, 0),
	Z: new Vector3(0, 0, 1)
};
const _changeEvent = {
	type: 'change'
};
const _mouseDownEvent = {
	type: 'mouseDown'
};
const _mouseUpEvent = {
	type: 'mouseUp',
	mode: null
};
const _objectChangeEvent = {
	type: 'objectChange'
};
class TransformControls extends Object3D {
	constructor(camera, domElement) {
		super();
		if (domElement === undefined) {
			console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.');
			domElement = document;
		}
		this.isTransformControls = true;
		this.visible = false;
		this.domElement = domElement;
		this.domElement.style.touchAction = 'none'; // disable touch scroll

		const _gizmo = new TransformControlsGizmo();
		this._gizmo = _gizmo;
		this.add(_gizmo);
		const _plane = new TransformControlsPlane();
		this._plane = _plane;
		this.add(_plane);
		const scope = this;

		// Defined getter, setter and store for a property
		function defineProperty(propName, defaultValue) {
			let propValue = defaultValue;
			Object.defineProperty(scope, propName, {
				get: function () {
					return propValue !== undefined ? propValue : defaultValue;
				},
				set: function (value) {
					if (propValue !== value) {
						propValue = value;
						_plane[propName] = value;
						_gizmo[propName] = value;
						scope.dispatchEvent({
							type: propName + '-changed',
							value: value
						});
						scope.dispatchEvent(_changeEvent);
					}
				}
			});
			scope[propName] = defaultValue;
			_plane[propName] = defaultValue;
			_gizmo[propName] = defaultValue;
		}

		// Define properties with getters/setter
		// Setting the defined property will automatically trigger change event
		// Defined properties are passed down to gizmo and plane

		defineProperty('camera', camera);
		defineProperty('object', undefined);
		defineProperty('enabled', true);
		defineProperty('axis', null);
		defineProperty('mode', 'translate');
		defineProperty('translationSnap', null);
		defineProperty('rotationSnap', null);
		defineProperty('scaleSnap', null);
		defineProperty('space', 'world');
		defineProperty('size', 1);
		defineProperty('dragging', false);
		defineProperty('showX', true);
		defineProperty('showY', true);
		defineProperty('showZ', true);

		// Reusable utility variables

		const worldPosition = new Vector3();
		const worldPositionStart = new Vector3();
		const worldQuaternion = new Quaternion();
		const worldQuaternionStart = new Quaternion();
		const cameraPosition = new Vector3();
		const cameraQuaternion = new Quaternion();
		const pointStart = new Vector3();
		const pointEnd = new Vector3();
		const rotationAxis = new Vector3();
		const rotationAngle = 0;
		const eye = new Vector3();

		// TODO: remove properties unused in plane and gizmo

		defineProperty('worldPosition', worldPosition);
		defineProperty('worldPositionStart', worldPositionStart);
		defineProperty('worldQuaternion', worldQuaternion);
		defineProperty('worldQuaternionStart', worldQuaternionStart);
		defineProperty('cameraPosition', cameraPosition);
		defineProperty('cameraQuaternion', cameraQuaternion);
		defineProperty('pointStart', pointStart);
		defineProperty('pointEnd', pointEnd);
		defineProperty('rotationAxis', rotationAxis);
		defineProperty('rotationAngle', rotationAngle);
		defineProperty('eye', eye);
		this._offset = new Vector3();
		this._startNorm = new Vector3();
		this._endNorm = new Vector3();
		this._cameraScale = new Vector3();
		this._parentPosition = new Vector3();
		this._parentQuaternion = new Quaternion();
		this._parentQuaternionInv = new Quaternion();
		this._parentScale = new Vector3();
		this._worldScaleStart = new Vector3();
		this._worldQuaternionInv = new Quaternion();
		this._worldScale = new Vector3();
		this._positionStart = new Vector3();
		this._quaternionStart = new Quaternion();
		this._scaleStart = new Vector3();
		this._getPointer = getPointer.bind(this);
		this._onPointerDown = onPointerDown.bind(this);
		this._onPointerHover = onPointerHover.bind(this);
		this._onPointerMove = onPointerMove.bind(this);
		this._onPointerUp = onPointerUp.bind(this);
		this.domElement.addEventListener('pointerdown', this._onPointerDown);
		this.domElement.addEventListener('pointermove', this._onPointerHover);
		this.domElement.addEventListener('pointerup', this._onPointerUp);
	}

	// updateMatrixWorld	updates key transformation variables
	updateMatrixWorld() {
		if (this.object !== undefined) {
			this.object.updateMatrixWorld();
			if (this.object.parent === null) {
				console.error('TransformControls: The attached 3D object must be a part of the scene graph.');
			} else {
				this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale);
			}
			this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale);
			this._parentQuaternionInv.copy(this._parentQuaternion).invert();
			this._worldQuaternionInv.copy(this.worldQuaternion).invert();
		}
		this.camera.updateMatrixWorld();
		this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale);
		if (this.camera.isOrthographicCamera) {
			this.camera.getWorldDirection(this.eye).negate();
		} else {
			this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize();
		}
		super.updateMatrixWorld(this);
	}
	pointerHover(pointer) {
		if (this.object === undefined || this.dragging === true) return;
		_raycaster.setFromCamera(pointer, this.camera);
		const intersect = intersectObjectWithRay(this._gizmo.picker[this.mode], _raycaster);
		if (intersect) {
			this.axis = intersect.object.name;
		} else {
			this.axis = null;
		}
	}
	pointerDown(pointer) {
		if (this.object === undefined || this.dragging === true || pointer.button !== 0) return;
		if (this.axis !== null) {
			_raycaster.setFromCamera(pointer, this.camera);
			const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
			if (planeIntersect) {
				this.object.updateMatrixWorld();
				this.object.parent.updateMatrixWorld();
				this._positionStart.copy(this.object.position);
				this._quaternionStart.copy(this.object.quaternion);
				this._scaleStart.copy(this.object.scale);
				this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart);
				this.pointStart.copy(planeIntersect.point).sub(this.worldPositionStart);
			}
			this.dragging = true;
			_mouseDownEvent.mode = this.mode;
			this.dispatchEvent(_mouseDownEvent);
		}
	}
	pointerMove(pointer) {
		const axis = this.axis;
		const mode = this.mode;
		const object = this.object;
		let space = this.space;
		if (mode === 'scale') {
			space = 'local';
		} else if (axis === 'E' || axis === 'XYZE' || axis === 'XYZ') {
			space = 'world';
		}
		if (object === undefined || axis === null || this.dragging === false || pointer.button !== -1) return;
		_raycaster.setFromCamera(pointer, this.camera);
		const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
		if (!planeIntersect) return;
		this.pointEnd.copy(planeIntersect.point).sub(this.worldPositionStart);
		if (mode === 'translate') {
			// Apply translate

			this._offset.copy(this.pointEnd).sub(this.pointStart);
			if (space === 'local' && axis !== 'XYZ') {
				this._offset.applyQuaternion(this._worldQuaternionInv);
			}
			if (axis.indexOf('X') === -1) this._offset.x = 0;
			if (axis.indexOf('Y') === -1) this._offset.y = 0;
			if (axis.indexOf('Z') === -1) this._offset.z = 0;
			if (space === 'local' && axis !== 'XYZ') {
				this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale);
			} else {
				this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale);
			}
			object.position.copy(this._offset).add(this._positionStart);

			// Apply translation snap

			if (this.translationSnap) {
				if (space === 'local') {
					object.position.applyQuaternion(_tempQuaternion.copy(this._quaternionStart).invert());
					if (axis.search('X') !== -1) {
						object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
					}
					if (axis.search('Y') !== -1) {
						object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
					}
					if (axis.search('Z') !== -1) {
						object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
					}
					object.position.applyQuaternion(this._quaternionStart);
				}
				if (space === 'world') {
					if (object.parent) {
						object.position.add(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
					}
					if (axis.search('X') !== -1) {
						object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
					}
					if (axis.search('Y') !== -1) {
						object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
					}
					if (axis.search('Z') !== -1) {
						object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
					}
					if (object.parent) {
						object.position.sub(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
					}
				}
			}
		} else if (mode === 'scale') {
			if (axis.search('XYZ') !== -1) {
				let d = this.pointEnd.length() / this.pointStart.length();
				if (this.pointEnd.dot(this.pointStart) < 0) d *= -1;
				_tempVector2.set(d, d, d);
			} else {
				_tempVector.copy(this.pointStart);
				_tempVector2.copy(this.pointEnd);
				_tempVector.applyQuaternion(this._worldQuaternionInv);
				_tempVector2.applyQuaternion(this._worldQuaternionInv);
				_tempVector2.divide(_tempVector);
				if (axis.search('X') === -1) {
					_tempVector2.x = 1;
				}
				if (axis.search('Y') === -1) {
					_tempVector2.y = 1;
				}
				if (axis.search('Z') === -1) {
					_tempVector2.z = 1;
				}
			}

			// Apply scale

			object.scale.copy(this._scaleStart).multiply(_tempVector2);
			if (this.scaleSnap) {
				if (axis.search('X') !== -1) {
					object.scale.x = Math.round(object.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
				}
				if (axis.search('Y') !== -1) {
					object.scale.y = Math.round(object.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
				}
				if (axis.search('Z') !== -1) {
					object.scale.z = Math.round(object.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
				}
			}
		} else if (mode === 'rotate') {
			this._offset.copy(this.pointEnd).sub(this.pointStart);
			const ROTATION_SPEED = 20 / this.worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld));
			if (axis === 'E') {
				this.rotationAxis.copy(this.eye);
				this.rotationAngle = this.pointEnd.angleTo(this.pointStart);
				this._startNorm.copy(this.pointStart).normalize();
				this._endNorm.copy(this.pointEnd).normalize();
				this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1;
			} else if (axis === 'XYZE') {
				this.rotationAxis.copy(this._offset).cross(this.eye).normalize();
				this.rotationAngle = this._offset.dot(_tempVector.copy(this.rotationAxis).cross(this.eye)) * ROTATION_SPEED;
			} else if (axis === 'X' || axis === 'Y' || axis === 'Z') {
				this.rotationAxis.copy(_unit[axis]);
				_tempVector.copy(_unit[axis]);
				if (space === 'local') {
					_tempVector.applyQuaternion(this.worldQuaternion);
				}
				this.rotationAngle = this._offset.dot(_tempVector.cross(this.eye).normalize()) * ROTATION_SPEED;
			}

			// Apply rotation snap

			if (this.rotationSnap) this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap;

			// Apply rotate
			if (space === 'local' && axis !== 'E' && axis !== 'XYZE') {
				object.quaternion.copy(this._quaternionStart);
				object.quaternion.multiply(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize();
			} else {
				this.rotationAxis.applyQuaternion(this._parentQuaternionInv);
				object.quaternion.copy(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle));
				object.quaternion.multiply(this._quaternionStart).normalize();
			}
		}
		this.dispatchEvent(_changeEvent);
		this.dispatchEvent(_objectChangeEvent);
	}
	pointerUp(pointer) {
		if (pointer.button !== 0) return;
		if (this.dragging && this.axis !== null) {
			_mouseUpEvent.mode = this.mode;
			this.dispatchEvent(_mouseUpEvent);
		}
		this.dragging = false;
		this.axis = null;
	}
	dispose() {
		this.domElement.removeEventListener('pointerdown', this._onPointerDown);
		this.domElement.removeEventListener('pointermove', this._onPointerHover);
		this.domElement.removeEventListener('pointermove', this._onPointerMove);
		this.domElement.removeEventListener('pointerup', this._onPointerUp);
		this.traverse(function (child) {
			if (child.geometry) child.geometry.dispose();
			if (child.material) child.material.dispose();
		});
	}

	// Set current object
	attach(object) {
		this.object = object;
		this.visible = true;
		return this;
	}

	// Detach from object
	detach() {
		this.object = undefined;
		this.visible = false;
		this.axis = null;
		return this;
	}
	reset() {
		if (!this.enabled) return;
		if (this.dragging) {
			this.object.position.copy(this._positionStart);
			this.object.quaternion.copy(this._quaternionStart);
			this.object.scale.copy(this._scaleStart);
			this.dispatchEvent(_changeEvent);
			this.dispatchEvent(_objectChangeEvent);
			this.pointStart.copy(this.pointEnd);
		}
	}
	getRaycaster() {
		return _raycaster;
	}

	// TODO: deprecate

	getMode() {
		return this.mode;
	}
	setMode(mode) {
		this.mode = mode;
	}
	setTranslationSnap(translationSnap) {
		this.translationSnap = translationSnap;
	}
	setRotationSnap(rotationSnap) {
		this.rotationSnap = rotationSnap;
	}
	setScaleSnap(scaleSnap) {
		this.scaleSnap = scaleSnap;
	}
	setSize(size) {
		this.size = size;
	}
	setSpace(space) {
		this.space = space;
	}
}

// mouse / touch event handlers

function getPointer(event) {
	if (this.domElement.ownerDocument.pointerLockElement) {
		return {
			x: 0,
			y: 0,
			button: event.button
		};
	} else {
		const rect = this.domElement.getBoundingClientRect();
		return {
			x: (event.clientX - rect.left) / rect.width * 2 - 1,
			y: -(event.clientY - rect.top) / rect.height * 2 + 1,
			button: event.button
		};
	}
}
function onPointerHover(event) {
	if (!this.enabled) return;
	switch (event.pointerType) {
		case 'mouse':
		case 'pen':
			this.pointerHover(this._getPointer(event));
			break;
	}
}
function onPointerDown(event) {
	if (!this.enabled) return;
	if (!document.pointerLockElement) {
		this.domElement.setPointerCapture(event.pointerId);
	}
	this.domElement.addEventListener('pointermove', this._onPointerMove);
	this.pointerHover(this._getPointer(event));
	this.pointerDown(this._getPointer(event));
}
function onPointerMove(event) {
	if (!this.enabled) return;
	this.pointerMove(this._getPointer(event));
}
function onPointerUp(event) {
	if (!this.enabled) return;
	this.domElement.releasePointerCapture(event.pointerId);
	this.domElement.removeEventListener('pointermove', this._onPointerMove);
	this.pointerUp(this._getPointer(event));
}
function intersectObjectWithRay(object, raycaster, includeInvisible) {
	const allIntersections = raycaster.intersectObject(object, true);
	for (let i = 0; i < allIntersections.length; i++) {
		if (allIntersections[i].object.visible || includeInvisible) {
			return allIntersections[i];
		}
	}
	return false;
}

//

// Reusable utility variables

const _tempEuler = new Euler();
const _alignVector = new Vector3(0, 1, 0);
const _zeroVector = new Vector3(0, 0, 0);
const _lookAtMatrix = new Matrix4();
const _tempQuaternion2 = new Quaternion();
const _identityQuaternion = new Quaternion();
const _dirVector = new Vector3();
const _tempMatrix = new Matrix4();
const _unitX = new Vector3(1, 0, 0);
const _unitY = new Vector3(0, 1, 0);
const _unitZ = new Vector3(0, 0, 1);
const _v1 = new Vector3();
const _v2 = new Vector3();
const _v3 = new Vector3();
class TransformControlsGizmo extends Object3D {
	constructor() {
		super();
		this.isTransformControlsGizmo = true;
		this.type = 'TransformControlsGizmo';

		// shared materials

		const gizmoMaterial = new MeshBasicMaterial({
			depthTest: false,
			depthWrite: false,
			fog: false,
			toneMapped: false,
			transparent: true
		});
		const gizmoLineMaterial = new LineBasicMaterial({
			depthTest: false,
			depthWrite: false,
			fog: false,
			toneMapped: false,
			transparent: true
		});

		// Make unique material for each axis/color

		const matInvisible = gizmoMaterial.clone();
		matInvisible.opacity = 0.15;
		const matHelper = gizmoLineMaterial.clone();
		matHelper.opacity = 0.5;
		const matRed = gizmoMaterial.clone();
		matRed.color.setHex(0xff0000);
		const matGreen = gizmoMaterial.clone();
		matGreen.color.setHex(0x00ff00);
		const matBlue = gizmoMaterial.clone();
		matBlue.color.setHex(0x0000ff);
		const matRedTransparent = gizmoMaterial.clone();
		matRedTransparent.color.setHex(0xff0000);
		matRedTransparent.opacity = 0.5;
		const matGreenTransparent = gizmoMaterial.clone();
		matGreenTransparent.color.setHex(0x00ff00);
		matGreenTransparent.opacity = 0.5;
		const matBlueTransparent = gizmoMaterial.clone();
		matBlueTransparent.color.setHex(0x0000ff);
		matBlueTransparent.opacity = 0.5;
		const matWhiteTransparent = gizmoMaterial.clone();
		matWhiteTransparent.opacity = 0.25;
		const matYellowTransparent = gizmoMaterial.clone();
		matYellowTransparent.color.setHex(0xffff00);
		matYellowTransparent.opacity = 0.25;
		const matYellow = gizmoMaterial.clone();
		matYellow.color.setHex(0xffff00);
		const matGray = gizmoMaterial.clone();
		matGray.color.setHex(0x787878);

		// reusable geometry

		const arrowGeometry = new CylinderGeometry(0, 0.04, 0.1, 12);
		arrowGeometry.translate(0, 0.05, 0);
		const scaleHandleGeometry = new BoxGeometry(0.08, 0.08, 0.08);
		scaleHandleGeometry.translate(0, 0.04, 0);
		const lineGeometry = new BufferGeometry();
		lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
		const lineGeometry2 = new CylinderGeometry(0.0075, 0.0075, 0.5, 3);
		lineGeometry2.translate(0, 0.25, 0);
		function CircleGeometry(radius, arc) {
			const geometry = new TorusGeometry(radius, 0.0075, 3, 64, arc * Math.PI * 2);
			geometry.rotateY(Math.PI / 2);
			geometry.rotateX(Math.PI / 2);
			return geometry;
		}

		// Special geometry for transform helper. If scaled with position vector it spans from [0,0,0] to position

		function TranslateHelperGeometry() {
			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3));
			return geometry;
		}

		// Gizmo definitions - custom hierarchy definitions for setupGizmo() function

		const gizmoTranslate = {
			X: [[new Mesh(arrowGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new Mesh(arrowGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]], [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]]],
			Y: [[new Mesh(arrowGeometry, matGreen), [0, 0.5, 0]], [new Mesh(arrowGeometry, matGreen), [0, -0.5, 0], [Math.PI, 0, 0]], [new Mesh(lineGeometry2, matGreen)]],
			Z: [[new Mesh(arrowGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new Mesh(arrowGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]], [new Mesh(lineGeometry2, matBlue), null, [Math.PI / 2, 0, 0]]],
			XYZ: [[new Mesh(new OctahedronGeometry(0.1, 0), matWhiteTransparent.clone()), [0, 0, 0]]],
			XY: [[new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent.clone()), [0.15, 0.15, 0]]],
			YZ: [[new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]],
			XZ: [[new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]]
		};
		const pickerTranslate = {
			X: [[new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]], [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]],
			Y: [[new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]], [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]],
			Z: [[new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]], [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]],
			XYZ: [[new Mesh(new OctahedronGeometry(0.2, 0), matInvisible)]],
			XY: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]],
			YZ: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]],
			XZ: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]]
		};
		const helperTranslate = {
			START: [[new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, 'helper']],
			END: [[new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, 'helper']],
			DELTA: [[new Line(TranslateHelperGeometry(), matHelper), null, null, null, 'helper']],
			X: [[new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], 'helper']],
			Y: [[new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], 'helper']],
			Z: [[new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], 'helper']]
		};
		const gizmoRotate = {
			XYZE: [[new Mesh(CircleGeometry(0.5, 1), matGray), null, [0, Math.PI / 2, 0]]],
			X: [[new Mesh(CircleGeometry(0.5, 0.5), matRed)]],
			Y: [[new Mesh(CircleGeometry(0.5, 0.5), matGreen), null, [0, 0, -Math.PI / 2]]],
			Z: [[new Mesh(CircleGeometry(0.5, 0.5), matBlue), null, [0, Math.PI / 2, 0]]],
			E: [[new Mesh(CircleGeometry(0.75, 1), matYellowTransparent), null, [0, Math.PI / 2, 0]]]
		};
		const helperRotate = {
			AXIS: [[new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], 'helper']]
		};
		const pickerRotate = {
			XYZE: [[new Mesh(new SphereGeometry(0.25, 10, 8), matInvisible)]],
			X: [[new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],
			Y: [[new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [Math.PI / 2, 0, 0]]],
			Z: [[new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, 0, -Math.PI / 2]]],
			E: [[new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), matInvisible)]]
		};
		const gizmoScale = {
			X: [[new Mesh(scaleHandleGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]], [new Mesh(scaleHandleGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]]],
			Y: [[new Mesh(scaleHandleGeometry, matGreen), [0, 0.5, 0]], [new Mesh(lineGeometry2, matGreen)], [new Mesh(scaleHandleGeometry, matGreen), [0, -0.5, 0], [0, 0, Math.PI]]],
			Z: [[new Mesh(scaleHandleGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new Mesh(lineGeometry2, matBlue), [0, 0, 0], [Math.PI / 2, 0, 0]], [new Mesh(scaleHandleGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]],
			XY: [[new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent), [0.15, 0.15, 0]]],
			YZ: [[new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]],
			XZ: [[new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]],
			XYZ: [[new Mesh(new BoxGeometry(0.1, 0.1, 0.1), matWhiteTransparent.clone())]]
		};
		const pickerScale = {
			X: [[new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]], [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]],
			Y: [[new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]], [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]],
			Z: [[new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]], [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]],
			XY: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]],
			YZ: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]],
			XZ: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]],
			XYZ: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.2), matInvisible), [0, 0, 0]]]
		};
		const helperScale = {
			X: [[new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], 'helper']],
			Y: [[new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], 'helper']],
			Z: [[new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], 'helper']]
		};

		// Creates an Object3D with gizmos described in custom hierarchy definition.

		function setupGizmo(gizmoMap) {
			const gizmo = new Object3D();
			for (const name in gizmoMap) {
				for (let i = gizmoMap[name].length; i--;) {
					const object = gizmoMap[name][i][0].clone();
					const position = gizmoMap[name][i][1];
					const rotation = gizmoMap[name][i][2];
					const scale = gizmoMap[name][i][3];
					const tag = gizmoMap[name][i][4];

					// name and tag properties are essential for picking and updating logic.
					object.name = name;
					object.tag = tag;
					if (position) {
						object.position.set(position[0], position[1], position[2]);
					}
					if (rotation) {
						object.rotation.set(rotation[0], rotation[1], rotation[2]);
					}
					if (scale) {
						object.scale.set(scale[0], scale[1], scale[2]);
					}
					object.updateMatrix();
					const tempGeometry = object.geometry.clone();
					tempGeometry.applyMatrix4(object.matrix);
					object.geometry = tempGeometry;
					object.renderOrder = Infinity;
					object.position.set(0, 0, 0);
					object.rotation.set(0, 0, 0);
					object.scale.set(1, 1, 1);
					gizmo.add(object);
				}
			}
			return gizmo;
		}

		// Gizmo creation

		this.gizmo = {};
		this.picker = {};
		this.helper = {};
		this.add(this.gizmo['translate'] = setupGizmo(gizmoTranslate));
		this.add(this.gizmo['rotate'] = setupGizmo(gizmoRotate));
		this.add(this.gizmo['scale'] = setupGizmo(gizmoScale));
		this.add(this.picker['translate'] = setupGizmo(pickerTranslate));
		this.add(this.picker['rotate'] = setupGizmo(pickerRotate));
		this.add(this.picker['scale'] = setupGizmo(pickerScale));
		this.add(this.helper['translate'] = setupGizmo(helperTranslate));
		this.add(this.helper['rotate'] = setupGizmo(helperRotate));
		this.add(this.helper['scale'] = setupGizmo(helperScale));

		// Pickers should be hidden always

		this.picker['translate'].visible = false;
		this.picker['rotate'].visible = false;
		this.picker['scale'].visible = false;
	}

	// updateMatrixWorld will update transformations and appearance of individual handles

	updateMatrixWorld(force) {
		const space = this.mode === 'scale' ? 'local' : this.space; // scale always oriented to local rotation

		const quaternion = space === 'local' ? this.worldQuaternion : _identityQuaternion;

		// Show only gizmos for current transform mode

		this.gizmo['translate'].visible = this.mode === 'translate';
		this.gizmo['rotate'].visible = this.mode === 'rotate';
		this.gizmo['scale'].visible = this.mode === 'scale';
		this.helper['translate'].visible = this.mode === 'translate';
		this.helper['rotate'].visible = this.mode === 'rotate';
		this.helper['scale'].visible = this.mode === 'scale';
		let handles = [];
		handles = handles.concat(this.picker[this.mode].children);
		handles = handles.concat(this.gizmo[this.mode].children);
		handles = handles.concat(this.helper[this.mode].children);
		for (let i = 0; i < handles.length; i++) {
			const handle = handles[i];

			// hide aligned to camera

			handle.visible = true;
			handle.rotation.set(0, 0, 0);
			handle.position.copy(this.worldPosition);
			let factor;
			if (this.camera.isOrthographicCamera) {
				factor = (this.camera.top - this.camera.bottom) / this.camera.zoom;
			} else {
				factor = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7);
			}
			handle.scale.set(1, 1, 1).multiplyScalar(factor * this.size / 4);

			// TODO: simplify helpers and consider decoupling from gizmo

			if (handle.tag === 'helper') {
				handle.visible = false;
				if (handle.name === 'AXIS') {
					handle.position.copy(this.worldPositionStart);
					handle.visible = !!this.axis;
					if (this.axis === 'X') {
						_tempQuaternion.setFromEuler(_tempEuler.set(0, 0, 0));
						handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
						if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
							handle.visible = false;
						}
					}
					if (this.axis === 'Y') {
						_tempQuaternion.setFromEuler(_tempEuler.set(0, 0, Math.PI / 2));
						handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
						if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
							handle.visible = false;
						}
					}
					if (this.axis === 'Z') {
						_tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
						handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
						if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
							handle.visible = false;
						}
					}
					if (this.axis === 'XYZE') {
						_tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
						_alignVector.copy(this.rotationAxis);
						handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(_zeroVector, _alignVector, _unitY));
						handle.quaternion.multiply(_tempQuaternion);
						handle.visible = this.dragging;
					}
					if (this.axis === 'E') {
						handle.visible = false;
					}
				} else if (handle.name === 'START') {
					handle.position.copy(this.worldPositionStart);
					handle.visible = this.dragging;
				} else if (handle.name === 'END') {
					handle.position.copy(this.worldPosition);
					handle.visible = this.dragging;
				} else if (handle.name === 'DELTA') {
					handle.position.copy(this.worldPositionStart);
					handle.quaternion.copy(this.worldQuaternionStart);
					_tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1);
					_tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert());
					handle.scale.copy(_tempVector);
					handle.visible = this.dragging;
				} else {
					handle.quaternion.copy(quaternion);
					if (this.dragging) {
						handle.position.copy(this.worldPositionStart);
					} else {
						handle.position.copy(this.worldPosition);
					}
					if (this.axis) {
						handle.visible = this.axis.search(handle.name) !== -1;
					}
				}

				// If updating helper, skip rest of the loop
				continue;
			}

			// Align handles to current local or world rotation

			handle.quaternion.copy(quaternion);
			if (this.mode === 'translate' || this.mode === 'scale') {
				// Hide translate and scale axis facing the camera

				const AXIS_HIDE_THRESHOLD = 0.99;
				const PLANE_HIDE_THRESHOLD = 0.2;
				if (handle.name === 'X') {
					if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
						handle.scale.set(1e-10, 1e-10, 1e-10);
						handle.visible = false;
					}
				}
				if (handle.name === 'Y') {
					if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
						handle.scale.set(1e-10, 1e-10, 1e-10);
						handle.visible = false;
					}
				}
				if (handle.name === 'Z') {
					if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
						handle.scale.set(1e-10, 1e-10, 1e-10);
						handle.visible = false;
					}
				}
				if (handle.name === 'XY') {
					if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
						handle.scale.set(1e-10, 1e-10, 1e-10);
						handle.visible = false;
					}
				}
				if (handle.name === 'YZ') {
					if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
						handle.scale.set(1e-10, 1e-10, 1e-10);
						handle.visible = false;
					}
				}
				if (handle.name === 'XZ') {
					if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
						handle.scale.set(1e-10, 1e-10, 1e-10);
						handle.visible = false;
					}
				}
			} else if (this.mode === 'rotate') {
				// Align handles to current local or world rotation

				_tempQuaternion2.copy(quaternion);
				_alignVector.copy(this.eye).applyQuaternion(_tempQuaternion.copy(quaternion).invert());
				if (handle.name.search('E') !== -1) {
					handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(this.eye, _zeroVector, _unitY));
				}
				if (handle.name === 'X') {
					_tempQuaternion.setFromAxisAngle(_unitX, Math.atan2(-_alignVector.y, _alignVector.z));
					_tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
					handle.quaternion.copy(_tempQuaternion);
				}
				if (handle.name === 'Y') {
					_tempQuaternion.setFromAxisAngle(_unitY, Math.atan2(_alignVector.x, _alignVector.z));
					_tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
					handle.quaternion.copy(_tempQuaternion);
				}
				if (handle.name === 'Z') {
					_tempQuaternion.setFromAxisAngle(_unitZ, Math.atan2(_alignVector.y, _alignVector.x));
					_tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
					handle.quaternion.copy(_tempQuaternion);
				}
			}

			// Hide disabled axes
			handle.visible = handle.visible && (handle.name.indexOf('X') === -1 || this.showX);
			handle.visible = handle.visible && (handle.name.indexOf('Y') === -1 || this.showY);
			handle.visible = handle.visible && (handle.name.indexOf('Z') === -1 || this.showZ);
			handle.visible = handle.visible && (handle.name.indexOf('E') === -1 || this.showX && this.showY && this.showZ);

			// highlight selected axis

			handle.material._color = handle.material._color || handle.material.color.clone();
			handle.material._opacity = handle.material._opacity || handle.material.opacity;
			handle.material.color.copy(handle.material._color);
			handle.material.opacity = handle.material._opacity;
			if (this.enabled && this.axis) {
				if (handle.name === this.axis) {
					handle.material.color.setHex(0xffff00);
					handle.material.opacity = 1.0;
				} else if (this.axis.split('').some(function (a) {
					return handle.name === a;
				})) {
					handle.material.color.setHex(0xffff00);
					handle.material.opacity = 1.0;
				}
			}
		}
		super.updateMatrixWorld(force);
	}
}

//

class TransformControlsPlane extends Mesh {
	constructor() {
		super(new PlaneGeometry(100000, 100000, 2, 2), new MeshBasicMaterial({
			visible: false,
			wireframe: true,
			side: DoubleSide,
			transparent: true,
			opacity: 0.1,
			toneMapped: false
		}));
		this.isTransformControlsPlane = true;
		this.type = 'TransformControlsPlane';
	}
	updateMatrixWorld(force) {
		let space = this.space;
		this.position.copy(this.worldPosition);
		if (this.mode === 'scale') space = 'local'; // scale always oriented to local rotation

		_v1.copy(_unitX).applyQuaternion(space === 'local' ? this.worldQuaternion : _identityQuaternion);
		_v2.copy(_unitY).applyQuaternion(space === 'local' ? this.worldQuaternion : _identityQuaternion);
		_v3.copy(_unitZ).applyQuaternion(space === 'local' ? this.worldQuaternion : _identityQuaternion);

		// Align the plane for current transform mode, axis and space.

		_alignVector.copy(_v2);
		switch (this.mode) {
			case 'translate':
			case 'scale':
				switch (this.axis) {
					case 'X':
						_alignVector.copy(this.eye).cross(_v1);
						_dirVector.copy(_v1).cross(_alignVector);
						break;
					case 'Y':
						_alignVector.copy(this.eye).cross(_v2);
						_dirVector.copy(_v2).cross(_alignVector);
						break;
					case 'Z':
						_alignVector.copy(this.eye).cross(_v3);
						_dirVector.copy(_v3).cross(_alignVector);
						break;
					case 'XY':
						_dirVector.copy(_v3);
						break;
					case 'YZ':
						_dirVector.copy(_v1);
						break;
					case 'XZ':
						_alignVector.copy(_v3);
						_dirVector.copy(_v2);
						break;
					case 'XYZ':
					case 'E':
						_dirVector.set(0, 0, 0);
						break;
				}
				break;
			case 'rotate':
			default:
				// special case for rotate
				_dirVector.set(0, 0, 0);
		}
		if (_dirVector.length() === 0) {
			// If in rotate mode, make the plane parallel to camera
			this.quaternion.copy(this.cameraQuaternion);
		} else {
			_tempMatrix.lookAt(_tempVector.set(0, 0, 0), _dirVector, _alignVector);
			this.quaternion.setFromRotationMatrix(_tempMatrix);
		}
		super.updateMatrixWorld(force);
	}
}

/**
 * Full-screen textured quad shader
 */

const CopyShader = {
	uniforms: {
		'tDiffuse': {
			value: null
		},
		'opacity': {
			value: 1.0
		}
	},
	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
	fragmentShader: /* glsl */`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`
};

class Pass {
	constructor() {
		// if set to true, the pass is processed by the composer
		this.enabled = true;

		// if set to true, the pass indicates to swap read and write buffer after rendering
		this.needsSwap = true;

		// if set to true, the pass clears its buffer before rendering
		this.clear = false;

		// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
		this.renderToScreen = false;
	}
	setSize( /* width, height */) {}
	render( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */
	) {
		console.error('THREE.Pass: .render() must be implemented in derived pass.');
	}
	dispose() {}
}

// Helper for passes that need to fill the viewport with a single quad.

const _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);

// https://github.com/mrdoob/three.js/pull/21358

const _geometry$1 = new BufferGeometry();
_geometry$1.setAttribute('position', new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
_geometry$1.setAttribute('uv', new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
class FullScreenQuad {
	constructor(material) {
		this._mesh = new Mesh(_geometry$1, material);
	}
	dispose() {
		this._mesh.geometry.dispose();
	}
	render(renderer) {
		renderer.render(this._mesh, _camera);
	}
	get material() {
		return this._mesh.material;
	}
	set material(value) {
		this._mesh.material = value;
	}
}

class ShaderPass extends Pass {
	constructor(shader, textureID) {
		super();
		this.textureID = textureID !== undefined ? textureID : 'tDiffuse';
		if (shader instanceof ShaderMaterial) {
			this.uniforms = shader.uniforms;
			this.material = shader;
		} else if (shader) {
			this.uniforms = UniformsUtils.clone(shader.uniforms);
			this.material = new ShaderMaterial({
				defines: Object.assign({}, shader.defines),
				uniforms: this.uniforms,
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader
			});
		}
		this.fsQuad = new FullScreenQuad(this.material);
	}
	render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {
		if (this.uniforms[this.textureID]) {
			this.uniforms[this.textureID].value = readBuffer.texture;
		}
		this.fsQuad.material = this.material;
		if (this.renderToScreen) {
			renderer.setRenderTarget(null);
			this.fsQuad.render(renderer);
		} else {
			renderer.setRenderTarget(writeBuffer);
			// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
			if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
			this.fsQuad.render(renderer);
		}
	}
	dispose() {
		this.material.dispose();
		this.fsQuad.dispose();
	}
}

class MaskPass extends Pass {
	constructor(scene, camera) {
		super();
		this.scene = scene;
		this.camera = camera;
		this.clear = true;
		this.needsSwap = false;
		this.inverse = false;
	}
	render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {
		const context = renderer.getContext();
		const state = renderer.state;

		// don't update color or depth

		state.buffers.color.setMask(false);
		state.buffers.depth.setMask(false);

		// lock buffers

		state.buffers.color.setLocked(true);
		state.buffers.depth.setLocked(true);

		// set up stencil

		let writeValue, clearValue;
		if (this.inverse) {
			writeValue = 0;
			clearValue = 1;
		} else {
			writeValue = 1;
			clearValue = 0;
		}
		state.buffers.stencil.setTest(true);
		state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
		state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);
		state.buffers.stencil.setClear(clearValue);
		state.buffers.stencil.setLocked(true);

		// draw into the stencil buffer

		renderer.setRenderTarget(readBuffer);
		if (this.clear) renderer.clear();
		renderer.render(this.scene, this.camera);
		renderer.setRenderTarget(writeBuffer);
		if (this.clear) renderer.clear();
		renderer.render(this.scene, this.camera);

		// unlock color and depth buffer for subsequent rendering

		state.buffers.color.setLocked(false);
		state.buffers.depth.setLocked(false);

		// only render where stencil is set to 1

		state.buffers.stencil.setLocked(false);
		state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1
		state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
		state.buffers.stencil.setLocked(true);
	}
}
class ClearMaskPass extends Pass {
	constructor() {
		super();
		this.needsSwap = false;
	}
	render(renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */) {
		renderer.state.buffers.stencil.setLocked(false);
		renderer.state.buffers.stencil.setTest(false);
	}
}

class EffectComposer {
	constructor(renderer, renderTarget) {
		this.renderer = renderer;
		if (renderTarget === undefined) {
			const size = renderer.getSize(new Vector2());
			this._pixelRatio = renderer.getPixelRatio();
			this._width = size.width;
			this._height = size.height;
			renderTarget = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio);
			renderTarget.texture.name = 'EffectComposer.rt1';
		} else {
			this._pixelRatio = 1;
			this._width = renderTarget.width;
			this._height = renderTarget.height;
		}
		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();
		this.renderTarget2.texture.name = 'EffectComposer.rt2';
		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;
		this.renderToScreen = true;
		this.passes = [];

		// dependencies

		if (CopyShader === undefined) {
			console.error('THREE.EffectComposer relies on CopyShader');
		}
		if (ShaderPass === undefined) {
			console.error('THREE.EffectComposer relies on ShaderPass');
		}
		this.copyPass = new ShaderPass(CopyShader);
		this.clock = new Clock();
	}
	swapBuffers() {
		const tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;
	}
	addPass(pass) {
		this.passes.push(pass);
		pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
	}
	insertPass(pass, index) {
		this.passes.splice(index, 0, pass);
		pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
	}
	removePass(pass) {
		const index = this.passes.indexOf(pass);
		if (index !== -1) {
			this.passes.splice(index, 1);
		}
	}
	isLastEnabledPass(passIndex) {
		for (let i = passIndex + 1; i < this.passes.length; i++) {
			if (this.passes[i].enabled) {
				return false;
			}
		}
		return true;
	}
	render(deltaTime) {
		// deltaTime value is in seconds

		if (deltaTime === undefined) {
			deltaTime = this.clock.getDelta();
		}
		const currentRenderTarget = this.renderer.getRenderTarget();
		let maskActive = false;
		for (let i = 0, il = this.passes.length; i < il; i++) {
			const pass = this.passes[i];
			if (pass.enabled === false) continue;
			pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);
			pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);
			if (pass.needsSwap) {
				if (maskActive) {
					const context = this.renderer.getContext();
					const stencil = this.renderer.state.buffers.stencil;

					//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
					stencil.setFunc(context.NOTEQUAL, 1, 0xffffffff);
					this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);

					//context.stencilFunc( context.EQUAL, 1, 0xffffffff );
					stencil.setFunc(context.EQUAL, 1, 0xffffffff);
				}
				this.swapBuffers();
			}
			if (MaskPass !== undefined) {
				if (pass instanceof MaskPass) {
					maskActive = true;
				} else if (pass instanceof ClearMaskPass) {
					maskActive = false;
				}
			}
		}
		this.renderer.setRenderTarget(currentRenderTarget);
	}
	reset(renderTarget) {
		if (renderTarget === undefined) {
			const size = this.renderer.getSize(new Vector2());
			this._pixelRatio = this.renderer.getPixelRatio();
			this._width = size.width;
			this._height = size.height;
			renderTarget = this.renderTarget1.clone();
			renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
		}
		this.renderTarget1.dispose();
		this.renderTarget2.dispose();
		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();
		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;
	}
	setSize(width, height) {
		this._width = width;
		this._height = height;
		const effectiveWidth = this._width * this._pixelRatio;
		const effectiveHeight = this._height * this._pixelRatio;
		this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
		this.renderTarget2.setSize(effectiveWidth, effectiveHeight);
		for (let i = 0; i < this.passes.length; i++) {
			this.passes[i].setSize(effectiveWidth, effectiveHeight);
		}
	}
	setPixelRatio(pixelRatio) {
		this._pixelRatio = pixelRatio;
		this.setSize(this._width, this._height);
	}
	dispose() {
		this.renderTarget1.dispose();
		this.renderTarget2.dispose();
		this.copyPass.dispose();
	}
}

// Helper for passes that need to fill the viewport with a single quad.

new OrthographicCamera(-1, 1, 1, -1, 0, 1);

// https://github.com/mrdoob/three.js/pull/21358

const _geometry = new BufferGeometry();
_geometry.setAttribute('position', new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
_geometry.setAttribute('uv', new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));

class RenderPass extends Pass {
	constructor(scene, camera, overrideMaterial, clearColor, clearAlpha) {
		super();
		this.scene = scene;
		this.camera = camera;
		this.overrideMaterial = overrideMaterial;
		this.clearColor = clearColor;
		this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;
		this.clear = true;
		this.clearDepth = false;
		this.needsSwap = false;
		this._oldClearColor = new Color$1();
	}
	render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {
		const oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;
		let oldClearAlpha, oldOverrideMaterial;
		if (this.overrideMaterial !== undefined) {
			oldOverrideMaterial = this.scene.overrideMaterial;
			this.scene.overrideMaterial = this.overrideMaterial;
		}
		if (this.clearColor) {
			renderer.getClearColor(this._oldClearColor);
			oldClearAlpha = renderer.getClearAlpha();
			renderer.setClearColor(this.clearColor, this.clearAlpha);
		}
		if (this.clearDepth) {
			renderer.clearDepth();
		}
		renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);

		// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
		if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
		renderer.render(this.scene, this.camera);
		if (this.clearColor) {
			renderer.setClearColor(this._oldClearColor, oldClearAlpha);
		}
		if (this.overrideMaterial !== undefined) {
			this.scene.overrideMaterial = oldOverrideMaterial;
		}
		renderer.autoClear = oldAutoClear;
	}
}

/**
 * References:
 * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html
 * https://learnopengl.com/Advanced-Lighting/SSAO
 * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl
 */

const SSAOShader = {
	defines: {
		'PERSPECTIVE_CAMERA': 1,
		'KERNEL_SIZE': 32
	},
	uniforms: {
		'tDiffuse': {
			value: null
		},
		'tNormal': {
			value: null
		},
		'tDepth': {
			value: null
		},
		'tNoise': {
			value: null
		},
		'kernel': {
			value: null
		},
		'cameraNear': {
			value: null
		},
		'cameraFar': {
			value: null
		},
		'resolution': {
			value: new Vector2()
		},
		'cameraProjectionMatrix': {
			value: new Matrix4()
		},
		'cameraInverseProjectionMatrix': {
			value: new Matrix4()
		},
		'kernelRadius': {
			value: 8
		},
		'minDistance': {
			value: 0.005
		},
		'maxDistance': {
			value: 0.05
		}
	},
	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
	fragmentShader: /* glsl */`

		uniform sampler2D tDiffuse;
		uniform sampler2D tNormal;
		uniform sampler2D tDepth;
		uniform sampler2D tNoise;

		uniform vec3 kernel[ KERNEL_SIZE ];

		uniform vec2 resolution;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;

		uniform float kernelRadius;
		uniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference
		uniform float maxDistance; // avoid the influence of fragments which are too far away

		varying vec2 vUv;

		#include <packing>

		float getDepth( const in vec2 screenPosition ) {

			return texture2D( tDepth, screenPosition ).x;

		}

		float getLinearDepth( const in vec2 screenPosition ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, screenPosition ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, screenPosition ).x;

			#endif

		}

		float getViewZ( const in float depth ) {

			#if PERSPECTIVE_CAMERA == 1

				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );

			#else

				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );

			#endif

		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {

			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];

			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );

			clipPosition *= clipW; // unprojection.

			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;

		}

		vec3 getViewNormal( const in vec2 screenPosition ) {

			return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );

		}

		void main() {

			float depth = getDepth( vUv );
			float viewZ = getViewZ( depth );

			vec3 viewPosition = getViewPosition( vUv, depth, viewZ );
			vec3 viewNormal = getViewNormal( vUv );

			vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );
			vec3 random = vec3( texture2D( tNoise, vUv * noiseScale ).r );

			// compute matrix used to reorient a kernel vector

			vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );
			vec3 bitangent = cross( viewNormal, tangent );
			mat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );

		 float occlusion = 0.0;

		 for ( int i = 0; i < KERNEL_SIZE; i ++ ) {

				vec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space
				vec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point

				vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 ); // project point and calculate NDC
				samplePointNDC /= samplePointNDC.w;

				vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates

				float realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture
				float sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar ); // compute linear depth of the sample view Z value
				float delta = sampleDepth - realDepth;

				if ( delta > minDistance && delta < maxDistance ) { // if fragment is before sample point, increase occlusion

					occlusion += 1.0;

				}

			}

			occlusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );

			gl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );

		}`
};
const SSAODepthShader = {
	defines: {
		'PERSPECTIVE_CAMERA': 1
	},
	uniforms: {
		'tDepth': {
			value: null
		},
		'cameraNear': {
			value: null
		},
		'cameraFar': {
			value: null
		}
	},
	vertexShader: `varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
	fragmentShader: `uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;

		varying vec2 vUv;

		#include <packing>

		float getLinearDepth( const in vec2 screenPosition ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, screenPosition ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, screenPosition ).x;

			#endif

		}

		void main() {

			float depth = getLinearDepth( vUv );
			gl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );

		}`
};
const SSAOBlurShader = {
	uniforms: {
		'tDiffuse': {
			value: null
		},
		'resolution': {
			value: new Vector2()
		}
	},
	vertexShader: `varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
	fragmentShader: `uniform sampler2D tDiffuse;

		uniform vec2 resolution;

		varying vec2 vUv;

		void main() {

			vec2 texelSize = ( 1.0 / resolution );
			float result = 0.0;

			for ( int i = - 2; i <= 2; i ++ ) {

				for ( int j = - 2; j <= 2; j ++ ) {

					vec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;
					result += texture2D( tDiffuse, vUv + offset ).r;

				}

			}

			gl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );

		}`
};

// Ported from Stefan Gustavson's java implementation
// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf
// Read Stefan's excellent paper for details on how this code works.
//
// Sean McCullough banksean@gmail.com
//
// Added 4D noise

/**
 * You can pass in a random number generator object if you like.
 * It is assumed to have a random() method.
 */
class SimplexNoise {
	constructor(r = Math) {
		this.grad3 = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]];
		this.grad4 = [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]];
		this.p = [];
		for (let i = 0; i < 256; i++) {
			this.p[i] = Math.floor(r.random() * 256);
		}

		// To remove the need for index wrapping, double the permutation table length
		this.perm = [];
		for (let i = 0; i < 512; i++) {
			this.perm[i] = this.p[i & 255];
		}

		// A lookup table to traverse the simplex around a given point in 4D.
		// Details can be found where this table is used, in the 4D noise method.
		this.simplex = [[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0], [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0], [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0], [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]];
	}
	dot(g, x, y) {
		return g[0] * x + g[1] * y;
	}
	dot3(g, x, y, z) {
		return g[0] * x + g[1] * y + g[2] * z;
	}
	dot4(g, x, y, z, w) {
		return g[0] * x + g[1] * y + g[2] * z + g[3] * w;
	}
	noise(xin, yin) {
		let n0; // Noise contributions from the ../../../src/Three_jsroot.js corners
		let n1;
		let n2;
		// Skew the input space to determine which simplex cell we're in
		const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
		const s = (xin + yin) * F2; // Hairy factor for 2D
		const i = Math.floor(xin + s);
		const j = Math.floor(yin + s);
		const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
		const t = (i + j) * G2;
		const X0 = i - t; // Unskew the cell origin back to (x,y) space
		const Y0 = j - t;
		const x0 = xin - X0; // The x,y distances from the cell origin
		const y0 = yin - Y0;

		// For the 2D case, the simplex shape is an equilateral triangle.
		// Determine which simplex we are in.
		let i1; // Offsets for second (middle) corner of simplex in (i,j) coords

		let j1;
		if (x0 > y0) {
			i1 = 1;
			j1 = 0;

			// lower triangle, XY order: (0,0)->(1,0)->(1,1)
		} else {
			i1 = 0;
			j1 = 1;
		} // upper triangle, YX order: (0,0)->(0,1)->(1,1)

		// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
		// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
		// c = (3-sqrt(3))/6
		const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
		const y1 = y0 - j1 + G2;
		const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
		const y2 = y0 - 1.0 + 2.0 * G2;
		// Work out the hashed gradient indices of the three simplex corners
		const ii = i & 255;
		const jj = j & 255;
		const gi0 = this.perm[ii + this.perm[jj]] % 12;
		const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
		const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
		// Calculate the contribution from the three corners
		let t0 = 0.5 - x0 * x0 - y0 * y0;
		if (t0 < 0) n0 = 0.0;else {
			t0 *= t0;
			n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient
		}

		let t1 = 0.5 - x1 * x1 - y1 * y1;
		if (t1 < 0) n1 = 0.0;else {
			t1 *= t1;
			n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
		}
		let t2 = 0.5 - x2 * x2 - y2 * y2;
		if (t2 < 0) n2 = 0.0;else {
			t2 *= t2;
			n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
		}

		// Add contributions from each corner to get the final noise value.
		// The result is scaled to return values in the interval [-1,1].
		return 70.0 * (n0 + n1 + n2);
	}

	// 3D simplex noise
	noise3d(xin, yin, zin) {
		let n0; // Noise contributions from the four corners
		let n1;
		let n2;
		let n3;
		// Skew the input space to determine which simplex cell we're in
		const F3 = 1.0 / 3.0;
		const s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D
		const i = Math.floor(xin + s);
		const j = Math.floor(yin + s);
		const k = Math.floor(zin + s);
		const G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too
		const t = (i + j + k) * G3;
		const X0 = i - t; // Unskew the cell origin back to (x,y,z) space
		const Y0 = j - t;
		const Z0 = k - t;
		const x0 = xin - X0; // The x,y,z distances from the cell origin
		const y0 = yin - Y0;
		const z0 = zin - Z0;

		// For the 3D case, the simplex shape is a slightly irregular tetrahedron.
		// Determine which simplex we are in.
		let i1; // Offsets for second corner of simplex in (i,j,k) coords

		let j1;
		let k1;
		let i2; // Offsets for third corner of simplex in (i,j,k) coords
		let j2;
		let k2;
		if (x0 >= y0) {
			if (y0 >= z0) {
				i1 = 1;
				j1 = 0;
				k1 = 0;
				i2 = 1;
				j2 = 1;
				k2 = 0;

				// X Y Z order
			} else if (x0 >= z0) {
				i1 = 1;
				j1 = 0;
				k1 = 0;
				i2 = 1;
				j2 = 0;
				k2 = 1;

				// X Z Y order
			} else {
				i1 = 0;
				j1 = 0;
				k1 = 1;
				i2 = 1;
				j2 = 0;
				k2 = 1;
			} // Z X Y order
		} else {
			// x0<y0

			if (y0 < z0) {
				i1 = 0;
				j1 = 0;
				k1 = 1;
				i2 = 0;
				j2 = 1;
				k2 = 1;

				// Z Y X order
			} else if (x0 < z0) {
				i1 = 0;
				j1 = 1;
				k1 = 0;
				i2 = 0;
				j2 = 1;
				k2 = 1;

				// Y Z X order
			} else {
				i1 = 0;
				j1 = 1;
				k1 = 0;
				i2 = 1;
				j2 = 1;
				k2 = 0;
			} // Y X Z order
		}

		// A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
		// a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
		// a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
		// c = 1/6.
		const x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
		const y1 = y0 - j1 + G3;
		const z1 = z0 - k1 + G3;
		const x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
		const y2 = y0 - j2 + 2.0 * G3;
		const z2 = z0 - k2 + 2.0 * G3;
		const x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
		const y3 = y0 - 1.0 + 3.0 * G3;
		const z3 = z0 - 1.0 + 3.0 * G3;
		// Work out the hashed gradient indices of the four simplex corners
		const ii = i & 255;
		const jj = j & 255;
		const kk = k & 255;
		const gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;
		const gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;
		const gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;
		const gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;
		// Calculate the contribution from the four corners
		let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
		if (t0 < 0) n0 = 0.0;else {
			t0 *= t0;
			n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0);
		}
		let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
		if (t1 < 0) n1 = 0.0;else {
			t1 *= t1;
			n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1);
		}
		let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
		if (t2 < 0) n2 = 0.0;else {
			t2 *= t2;
			n2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2);
		}
		let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
		if (t3 < 0) n3 = 0.0;else {
			t3 *= t3;
			n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3);
		}

		// Add contributions from each corner to get the final noise value.
		// The result is scaled to stay just inside [-1,1]
		return 32.0 * (n0 + n1 + n2 + n3);
	}

	// 4D simplex noise
	noise4d(x, y, z, w) {
		// For faster and easier lookups
		const grad4 = this.grad4;
		const simplex = this.simplex;
		const perm = this.perm;

		// The skewing and unskewing factors are hairy again for the 4D case
		const F4 = (Math.sqrt(5.0) - 1.0) / 4.0;
		const G4 = (5.0 - Math.sqrt(5.0)) / 20.0;
		let n0; // Noise contributions from the five corners
		let n1;
		let n2;
		let n3;
		let n4;
		// Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
		const s = (x + y + z + w) * F4; // Factor for 4D skewing
		const i = Math.floor(x + s);
		const j = Math.floor(y + s);
		const k = Math.floor(z + s);
		const l = Math.floor(w + s);
		const t = (i + j + k + l) * G4; // Factor for 4D unskewing
		const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
		const Y0 = j - t;
		const Z0 = k - t;
		const W0 = l - t;
		const x0 = x - X0; // The x,y,z,w distances from the cell origin
		const y0 = y - Y0;
		const z0 = z - Z0;
		const w0 = w - W0;

		// For the 4D case, the simplex is a 4D shape I won't even try to describe.
		// To find out which of the 24 possible simplices we're in, we need to
		// determine the magnitude ordering of x0, y0, z0 and w0.
		// The method below is a good way of finding the ordering of x,y,z,w and
		// then find the correct traversal order for the simplex we’re in.
		// First, six pair-wise comparisons are performed between each possible pair
		// of the four coordinates, and the results are used to add up binary bits
		// for an integer index.
		const c1 = x0 > y0 ? 32 : 0;
		const c2 = x0 > z0 ? 16 : 0;
		const c3 = y0 > z0 ? 8 : 0;
		const c4 = x0 > w0 ? 4 : 0;
		const c5 = y0 > w0 ? 2 : 0;
		const c6 = z0 > w0 ? 1 : 0;
		const c = c1 + c2 + c3 + c4 + c5 + c6;

		// simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
		// Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
		// impossible. Only the 24 indices which have non-zero entries make any sense.
		// We use a thresholding to set the coordinates in turn from the largest magnitude.
		// The number 3 in the "simplex" array is at the position of the largest coordinate.
		const i1 = simplex[c][0] >= 3 ? 1 : 0;
		const j1 = simplex[c][1] >= 3 ? 1 : 0;
		const k1 = simplex[c][2] >= 3 ? 1 : 0;
		const l1 = simplex[c][3] >= 3 ? 1 : 0;
		// The number 2 in the "simplex" array is at the second largest coordinate.
		const i2 = simplex[c][0] >= 2 ? 1 : 0;
		const j2 = simplex[c][1] >= 2 ? 1 : 0;
		const k2 = simplex[c][2] >= 2 ? 1 : 0;
		const l2 = simplex[c][3] >= 2 ? 1 : 0;
		// The number 1 in the "simplex" array is at the second smallest coordinate.
		const i3 = simplex[c][0] >= 1 ? 1 : 0;
		const j3 = simplex[c][1] >= 1 ? 1 : 0;
		const k3 = simplex[c][2] >= 1 ? 1 : 0;
		const l3 = simplex[c][3] >= 1 ? 1 : 0;
		// The fifth corner has all coordinate offsets = 1, so no need to look that up.
		const x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
		const y1 = y0 - j1 + G4;
		const z1 = z0 - k1 + G4;
		const w1 = w0 - l1 + G4;
		const x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
		const y2 = y0 - j2 + 2.0 * G4;
		const z2 = z0 - k2 + 2.0 * G4;
		const w2 = w0 - l2 + 2.0 * G4;
		const x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
		const y3 = y0 - j3 + 3.0 * G4;
		const z3 = z0 - k3 + 3.0 * G4;
		const w3 = w0 - l3 + 3.0 * G4;
		const x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
		const y4 = y0 - 1.0 + 4.0 * G4;
		const z4 = z0 - 1.0 + 4.0 * G4;
		const w4 = w0 - 1.0 + 4.0 * G4;
		// Work out the hashed gradient indices of the five simplex corners
		const ii = i & 255;
		const jj = j & 255;
		const kk = k & 255;
		const ll = l & 255;
		const gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;
		const gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;
		const gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;
		const gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;
		const gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;
		// Calculate the contribution from the five corners
		let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
		if (t0 < 0) n0 = 0.0;else {
			t0 *= t0;
			n0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0);
		}
		let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
		if (t1 < 0) n1 = 0.0;else {
			t1 *= t1;
			n1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1);
		}
		let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
		if (t2 < 0) n2 = 0.0;else {
			t2 *= t2;
			n2 = t2 * t2 * this.dot4(grad4[gi2], x2, y2, z2, w2);
		}
		let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
		if (t3 < 0) n3 = 0.0;else {
			t3 *= t3;
			n3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3);
		}
		let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
		if (t4 < 0) n4 = 0.0;else {
			t4 *= t4;
			n4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4);
		}

		// Sum up and scale the result to cover the range [-1,1]
		return 27.0 * (n0 + n1 + n2 + n3 + n4);
	}
}

class SSAOPass extends Pass {
	constructor(scene, camera, width, height) {
		super();
		this.width = width !== undefined ? width : 512;
		this.height = height !== undefined ? height : 512;
		this.clear = true;
		this.camera = camera;
		this.scene = scene;
		this.kernelRadius = 8;
		this.kernelSize = 32;
		this.kernel = [];
		this.noiseTexture = null;
		this.output = 0;
		this.minDistance = 0.005;
		this.maxDistance = 0.1;
		this._visibilityCache = new Map();

		//

		this.generateSampleKernel();
		this.generateRandomKernelRotations();

		// beauty render target

		const depthTexture = new DepthTexture();
		depthTexture.format = DepthStencilFormat;
		depthTexture.type = UnsignedInt248Type;
		this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height);

		// normal render target with depth buffer

		this.normalRenderTarget = new WebGLRenderTarget(this.width, this.height, {
			minFilter: NearestFilter,
			magFilter: NearestFilter,
			depthTexture: depthTexture
		});

		// ssao render target

		this.ssaoRenderTarget = new WebGLRenderTarget(this.width, this.height);
		this.blurRenderTarget = this.ssaoRenderTarget.clone();

		// ssao material

		if (SSAOShader === undefined) {
			console.error('THREE.SSAOPass: The pass relies on SSAOShader.');
		}
		this.ssaoMaterial = new ShaderMaterial({
			defines: Object.assign({}, SSAOShader.defines),
			uniforms: UniformsUtils.clone(SSAOShader.uniforms),
			vertexShader: SSAOShader.vertexShader,
			fragmentShader: SSAOShader.fragmentShader,
			blending: NoBlending
		});
		this.ssaoMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;
		this.ssaoMaterial.uniforms['tNormal'].value = this.normalRenderTarget.texture;
		this.ssaoMaterial.uniforms['tDepth'].value = this.normalRenderTarget.depthTexture;
		this.ssaoMaterial.uniforms['tNoise'].value = this.noiseTexture;
		this.ssaoMaterial.uniforms['kernel'].value = this.kernel;
		this.ssaoMaterial.uniforms['cameraNear'].value = this.camera.near;
		this.ssaoMaterial.uniforms['cameraFar'].value = this.camera.far;
		this.ssaoMaterial.uniforms['resolution'].value.set(this.width, this.height);
		this.ssaoMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix);
		this.ssaoMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse);

		// normal material

		this.normalMaterial = new MeshNormalMaterial();
		this.normalMaterial.blending = NoBlending;

		// blur material

		this.blurMaterial = new ShaderMaterial({
			defines: Object.assign({}, SSAOBlurShader.defines),
			uniforms: UniformsUtils.clone(SSAOBlurShader.uniforms),
			vertexShader: SSAOBlurShader.vertexShader,
			fragmentShader: SSAOBlurShader.fragmentShader
		});
		this.blurMaterial.uniforms['tDiffuse'].value = this.ssaoRenderTarget.texture;
		this.blurMaterial.uniforms['resolution'].value.set(this.width, this.height);

		// material for rendering the depth

		this.depthRenderMaterial = new ShaderMaterial({
			defines: Object.assign({}, SSAODepthShader.defines),
			uniforms: UniformsUtils.clone(SSAODepthShader.uniforms),
			vertexShader: SSAODepthShader.vertexShader,
			fragmentShader: SSAODepthShader.fragmentShader,
			blending: NoBlending
		});
		this.depthRenderMaterial.uniforms['tDepth'].value = this.normalRenderTarget.depthTexture;
		this.depthRenderMaterial.uniforms['cameraNear'].value = this.camera.near;
		this.depthRenderMaterial.uniforms['cameraFar'].value = this.camera.far;

		// material for rendering the content of a render target

		this.copyMaterial = new ShaderMaterial({
			uniforms: UniformsUtils.clone(CopyShader.uniforms),
			vertexShader: CopyShader.vertexShader,
			fragmentShader: CopyShader.fragmentShader,
			transparent: true,
			depthTest: false,
			depthWrite: false,
			blendSrc: DstColorFactor,
			blendDst: ZeroFactor,
			blendEquation: AddEquation,
			blendSrcAlpha: DstAlphaFactor,
			blendDstAlpha: ZeroFactor,
			blendEquationAlpha: AddEquation
		});
		this.fsQuad = new FullScreenQuad(null);
		this.originalClearColor = new Color$1();
	}
	dispose() {
		// dispose render targets

		this.beautyRenderTarget.dispose();
		this.normalRenderTarget.dispose();
		this.ssaoRenderTarget.dispose();
		this.blurRenderTarget.dispose();

		// dispose materials

		this.normalMaterial.dispose();
		this.blurMaterial.dispose();
		this.copyMaterial.dispose();
		this.depthRenderMaterial.dispose();

		// dipsose full screen quad

		this.fsQuad.dispose();
	}
	render(renderer, writeBuffer /*, readBuffer, deltaTime, maskActive */) {
		if (renderer.capabilities.isWebGL2 === false) this.noiseTexture.format = LuminanceFormat;

		// render beauty

		renderer.setRenderTarget(this.beautyRenderTarget);
		renderer.clear();
		renderer.render(this.scene, this.camera);

		// render normals and depth (honor only meshes, points and lines do not contribute to SSAO)

		this.overrideVisibility();
		this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0);
		this.restoreVisibility();

		// render SSAO

		this.ssaoMaterial.uniforms['kernelRadius'].value = this.kernelRadius;
		this.ssaoMaterial.uniforms['minDistance'].value = this.minDistance;
		this.ssaoMaterial.uniforms['maxDistance'].value = this.maxDistance;
		this.renderPass(renderer, this.ssaoMaterial, this.ssaoRenderTarget);

		// render blur

		this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget);

		// output result to screen

		switch (this.output) {
			case SSAOPass.OUTPUT.SSAO:
				this.copyMaterial.uniforms['tDiffuse'].value = this.ssaoRenderTarget.texture;
				this.copyMaterial.blending = NoBlending;
				this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
				break;
			case SSAOPass.OUTPUT.Blur:
				this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget.texture;
				this.copyMaterial.blending = NoBlending;
				this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
				break;
			case SSAOPass.OUTPUT.Beauty:
				this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;
				this.copyMaterial.blending = NoBlending;
				this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
				break;
			case SSAOPass.OUTPUT.Depth:
				this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer);
				break;
			case SSAOPass.OUTPUT.Normal:
				this.copyMaterial.uniforms['tDiffuse'].value = this.normalRenderTarget.texture;
				this.copyMaterial.blending = NoBlending;
				this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
				break;
			case SSAOPass.OUTPUT.Default:
				this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;
				this.copyMaterial.blending = NoBlending;
				this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
				this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget.texture;
				this.copyMaterial.blending = CustomBlending;
				this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
				break;
			default:
				console.warn('THREE.SSAOPass: Unknown output type.');
		}
	}
	renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {
		// save original state
		renderer.getClearColor(this.originalClearColor);
		const originalClearAlpha = renderer.getClearAlpha();
		const originalAutoClear = renderer.autoClear;
		renderer.setRenderTarget(renderTarget);

		// setup pass state
		renderer.autoClear = false;
		if (clearColor !== undefined && clearColor !== null) {
			renderer.setClearColor(clearColor);
			renderer.setClearAlpha(clearAlpha || 0.0);
			renderer.clear();
		}
		this.fsQuad.material = passMaterial;
		this.fsQuad.render(renderer);

		// restore original state
		renderer.autoClear = originalAutoClear;
		renderer.setClearColor(this.originalClearColor);
		renderer.setClearAlpha(originalClearAlpha);
	}
	renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
		renderer.getClearColor(this.originalClearColor);
		const originalClearAlpha = renderer.getClearAlpha();
		const originalAutoClear = renderer.autoClear;
		renderer.setRenderTarget(renderTarget);
		renderer.autoClear = false;
		clearColor = overrideMaterial.clearColor || clearColor;
		clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
		if (clearColor !== undefined && clearColor !== null) {
			renderer.setClearColor(clearColor);
			renderer.setClearAlpha(clearAlpha || 0.0);
			renderer.clear();
		}
		this.scene.overrideMaterial = overrideMaterial;
		renderer.render(this.scene, this.camera);
		this.scene.overrideMaterial = null;

		// restore original state

		renderer.autoClear = originalAutoClear;
		renderer.setClearColor(this.originalClearColor);
		renderer.setClearAlpha(originalClearAlpha);
	}
	setSize(width, height) {
		this.width = width;
		this.height = height;
		this.beautyRenderTarget.setSize(width, height);
		this.ssaoRenderTarget.setSize(width, height);
		this.normalRenderTarget.setSize(width, height);
		this.blurRenderTarget.setSize(width, height);
		this.ssaoMaterial.uniforms['resolution'].value.set(width, height);
		this.ssaoMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix);
		this.ssaoMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse);
		this.blurMaterial.uniforms['resolution'].value.set(width, height);
	}
	generateSampleKernel() {
		const kernelSize = this.kernelSize;
		const kernel = this.kernel;
		for (let i = 0; i < kernelSize; i++) {
			const sample = new Vector3();
			sample.x = Math.random() * 2 - 1;
			sample.y = Math.random() * 2 - 1;
			sample.z = Math.random();
			sample.normalize();
			let scale = i / kernelSize;
			scale = lerp(0.1, 1, scale * scale);
			sample.multiplyScalar(scale);
			kernel.push(sample);
		}
	}
	generateRandomKernelRotations() {
		const width = 4,
			height = 4;
		if (SimplexNoise === undefined) {
			console.error('THREE.SSAOPass: The pass relies on SimplexNoise.');
		}
		const simplex = new SimplexNoise();
		const size = width * height;
		const data = new Float32Array(size);
		for (let i = 0; i < size; i++) {
			const x = Math.random() * 2 - 1;
			const y = Math.random() * 2 - 1;
			const z = 0;
			data[i] = simplex.noise3d(x, y, z);
		}
		this.noiseTexture = new DataTexture(data, width, height, RedFormat, FloatType);
		this.noiseTexture.wrapS = RepeatWrapping;
		this.noiseTexture.wrapT = RepeatWrapping;
		this.noiseTexture.needsUpdate = true;
	}
	overrideVisibility() {
		const scene = this.scene;
		const cache = this._visibilityCache;
		scene.traverse(function (object) {
			cache.set(object, object.visible);
			if (object.isPoints || object.isLine) object.visible = false;
		});
	}
	restoreVisibility() {
		const scene = this.scene;
		const cache = this._visibilityCache;
		scene.traverse(function (object) {
			const visible = cache.get(object);
			object.visible = visible;
		});
		cache.clear();
	}
}
SSAOPass.OUTPUT = {
	'Default': 0,
	'SSAO': 1,
	'Blur': 2,
	'Beauty': 3,
	'Depth': 4,
	'Normal': 5
};

/**
 * Luminosity
 * http://en.wikipedia.org/wiki/Luminosity
 */

const LuminosityHighPassShader = {
	shaderID: 'luminosityHighPass',
	uniforms: {
		'tDiffuse': {
			value: null
		},
		'luminosityThreshold': {
			value: 1.0
		},
		'smoothWidth': {
			value: 1.0
		},
		'defaultColor': {
			value: new Color$1(0x000000)
		},
		'defaultOpacity': {
			value: 0.0
		}
	},
	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
	fragmentShader: /* glsl */`

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`
};

/**
 * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a
 * mip map chain of bloom textures and blurs them with different radii. Because
 * of the weighted combination of mips, and because larger blurs are done on
 * higher mips, this effect provides good quality and performance.
 *
 * Reference:
 * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/
 */
class UnrealBloomPass extends Pass {
	constructor(resolution, strength, radius, threshold) {
		super();
		this.strength = strength !== undefined ? strength : 1;
		this.radius = radius;
		this.threshold = threshold;
		this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);

		// create color only once here, reuse it later inside the render function
		this.clearColor = new Color$1(0, 0, 0);

		// render targets
		this.renderTargetsHorizontal = [];
		this.renderTargetsVertical = [];
		this.nMips = 5;
		let resx = Math.round(this.resolution.x / 2);
		let resy = Math.round(this.resolution.y / 2);
		this.renderTargetBright = new WebGLRenderTarget(resx, resy);
		this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';
		this.renderTargetBright.texture.generateMipmaps = false;
		for (let i = 0; i < this.nMips; i++) {
			const renderTargetHorizonal = new WebGLRenderTarget(resx, resy);
			renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;
			renderTargetHorizonal.texture.generateMipmaps = false;
			this.renderTargetsHorizontal.push(renderTargetHorizonal);
			const renderTargetVertical = new WebGLRenderTarget(resx, resy);
			renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;
			renderTargetVertical.texture.generateMipmaps = false;
			this.renderTargetsVertical.push(renderTargetVertical);
			resx = Math.round(resx / 2);
			resy = Math.round(resy / 2);
		}

		// luminosity high pass material

		if (LuminosityHighPassShader === undefined) console.error('THREE.UnrealBloomPass relies on LuminosityHighPassShader');
		const highPassShader = LuminosityHighPassShader;
		this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);
		this.highPassUniforms['luminosityThreshold'].value = threshold;
		this.highPassUniforms['smoothWidth'].value = 0.01;
		this.materialHighPassFilter = new ShaderMaterial({
			uniforms: this.highPassUniforms,
			vertexShader: highPassShader.vertexShader,
			fragmentShader: highPassShader.fragmentShader,
			defines: {}
		});

		// Gaussian Blur Materials
		this.separableBlurMaterials = [];
		const kernelSizeArray = [3, 5, 7, 9, 11];
		resx = Math.round(this.resolution.x / 2);
		resy = Math.round(this.resolution.y / 2);
		for (let i = 0; i < this.nMips; i++) {
			this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));
			this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);
			resx = Math.round(resx / 2);
			resy = Math.round(resy / 2);
		}

		// Composite material
		this.compositeMaterial = this.getCompositeMaterial(this.nMips);
		this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture;
		this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture;
		this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture;
		this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture;
		this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture;
		this.compositeMaterial.uniforms['bloomStrength'].value = strength;
		this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;
		this.compositeMaterial.needsUpdate = true;
		const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];
		this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;
		this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];
		this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;

		// copy material
		if (CopyShader === undefined) {
			console.error('THREE.UnrealBloomPass relies on CopyShader');
		}
		const copyShader = CopyShader;
		this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
		this.copyUniforms['opacity'].value = 1.0;
		this.materialCopy = new ShaderMaterial({
			uniforms: this.copyUniforms,
			vertexShader: copyShader.vertexShader,
			fragmentShader: copyShader.fragmentShader,
			blending: AdditiveBlending,
			depthTest: false,
			depthWrite: false,
			transparent: true
		});
		this.enabled = true;
		this.needsSwap = false;
		this._oldClearColor = new Color$1();
		this.oldClearAlpha = 1;
		this.basic = new MeshBasicMaterial();
		this.fsQuad = new FullScreenQuad(null);
	}
	dispose() {
		for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {
			this.renderTargetsHorizontal[i].dispose();
		}
		for (let i = 0; i < this.renderTargetsVertical.length; i++) {
			this.renderTargetsVertical[i].dispose();
		}
		this.renderTargetBright.dispose();

		//

		for (let i = 0; i < this.separableBlurMaterials.length; i++) {
			this.separableBlurMaterials[i].dispose();
		}
		this.compositeMaterial.dispose();
		this.materialCopy.dispose();
		this.basic.dispose();

		//

		this.fsQuad.dispose();
	}
	setSize(width, height) {
		let resx = Math.round(width / 2);
		let resy = Math.round(height / 2);
		this.renderTargetBright.setSize(resx, resy);
		for (let i = 0; i < this.nMips; i++) {
			this.renderTargetsHorizontal[i].setSize(resx, resy);
			this.renderTargetsVertical[i].setSize(resx, resy);
			this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);
			resx = Math.round(resx / 2);
			resy = Math.round(resy / 2);
		}
	}
	render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
		renderer.getClearColor(this._oldClearColor);
		this.oldClearAlpha = renderer.getClearAlpha();
		const oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;
		renderer.setClearColor(this.clearColor, 0);
		if (maskActive) renderer.state.buffers.stencil.setTest(false);

		// Render input to screen

		if (this.renderToScreen) {
			this.fsQuad.material = this.basic;
			this.basic.map = readBuffer.texture;
			renderer.setRenderTarget(null);
			renderer.clear();
			this.fsQuad.render(renderer);
		}

		// 1. Extract Bright Areas

		this.highPassUniforms['tDiffuse'].value = readBuffer.texture;
		this.highPassUniforms['luminosityThreshold'].value = this.threshold;
		this.fsQuad.material = this.materialHighPassFilter;
		renderer.setRenderTarget(this.renderTargetBright);
		renderer.clear();
		this.fsQuad.render(renderer);

		// 2. Blur All the mips progressively

		let inputRenderTarget = this.renderTargetBright;
		for (let i = 0; i < this.nMips; i++) {
			this.fsQuad.material = this.separableBlurMaterials[i];
			this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;
			this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX;
			renderer.setRenderTarget(this.renderTargetsHorizontal[i]);
			renderer.clear();
			this.fsQuad.render(renderer);
			this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;
			this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY;
			renderer.setRenderTarget(this.renderTargetsVertical[i]);
			renderer.clear();
			this.fsQuad.render(renderer);
			inputRenderTarget = this.renderTargetsVertical[i];
		}

		// Composite All the mips

		this.fsQuad.material = this.compositeMaterial;
		this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;
		this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;
		this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;
		renderer.setRenderTarget(this.renderTargetsHorizontal[0]);
		renderer.clear();
		this.fsQuad.render(renderer);

		// Blend it additively over the input texture

		this.fsQuad.material = this.materialCopy;
		this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;
		if (maskActive) renderer.state.buffers.stencil.setTest(true);
		if (this.renderToScreen) {
			renderer.setRenderTarget(null);
			this.fsQuad.render(renderer);
		} else {
			renderer.setRenderTarget(readBuffer);
			this.fsQuad.render(renderer);
		}

		// Restore renderer settings

		renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
		renderer.autoClear = oldAutoClear;
	}
	getSeperableBlurMaterial(kernelRadius) {
		return new ShaderMaterial({
			defines: {
				'KERNEL_RADIUS': kernelRadius,
				'SIGMA': kernelRadius
			},
			uniforms: {
				'colorTexture': {
					value: null
				},
				'texSize': {
					value: new Vector2(0.5, 0.5)
				},
				'direction': {
					value: new Vector2(0.5, 0.5)
				}
			},
			vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
			fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`
		});
	}
	getCompositeMaterial(nMips) {
		return new ShaderMaterial({
			defines: {
				'NUM_MIPS': nMips
			},
			uniforms: {
				'blurTexture1': {
					value: null
				},
				'blurTexture2': {
					value: null
				},
				'blurTexture3': {
					value: null
				},
				'blurTexture4': {
					value: null
				},
				'blurTexture5': {
					value: null
				},
				'bloomStrength': {
					value: 1.0
				},
				'bloomFactors': {
					value: null
				},
				'bloomTintColors': {
					value: null
				},
				'bloomRadius': {
					value: 0.0
				}
			},
			vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
			fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
		});
	}
}
UnrealBloomPass.BlurDirectionX = new Vector2(1.0, 0.0);
UnrealBloomPass.BlurDirectionY = new Vector2(0.0, 1.0);

class RenderableObject {
	constructor() {
		this.id = 0;
		this.object = null;
		this.z = 0;
		this.renderOrder = 0;
	}
}

//

class RenderableFace {
	constructor() {
		this.id = 0;
		this.v1 = new RenderableVertex();
		this.v2 = new RenderableVertex();
		this.v3 = new RenderableVertex();
		this.normalModel = new Vector3();
		this.vertexNormalsModel = [new Vector3(), new Vector3(), new Vector3()];
		this.vertexNormalsLength = 0;
		this.color = new Color$1();
		this.material = null;
		this.uvs = [new Vector2(), new Vector2(), new Vector2()];
		this.z = 0;
		this.renderOrder = 0;
	}
}

//

class RenderableVertex {
	constructor() {
		this.position = new Vector3();
		this.positionWorld = new Vector3();
		this.positionScreen = new Vector4();
		this.visible = true;
	}
	copy(vertex) {
		this.positionWorld.copy(vertex.positionWorld);
		this.positionScreen.copy(vertex.positionScreen);
	}
}

//

class RenderableLine {
	constructor() {
		this.id = 0;
		this.v1 = new RenderableVertex();
		this.v2 = new RenderableVertex();
		this.vertexColors = [new Color$1(), new Color$1()];
		this.material = null;
		this.z = 0;
		this.renderOrder = 0;
	}
}

//

class RenderableSprite {
	constructor() {
		this.id = 0;
		this.object = null;
		this.x = 0;
		this.y = 0;
		this.z = 0;
		this.rotation = 0;
		this.scale = new Vector2();
		this.material = null;
		this.renderOrder = 0;
	}
}

//

class Projector {
	constructor() {
		let _object,
			_objectCount,
			_objectPoolLength = 0,
			_vertex,
			_vertexCount,
			_vertexPoolLength = 0,
			_face,
			_faceCount,
			_facePoolLength = 0,
			_line,
			_lineCount,
			_linePoolLength = 0,
			_sprite,
			_spriteCount,
			_spritePoolLength = 0,
			_modelMatrix;
		const _renderData = {
				objects: [],
				lights: [],
				elements: []
			},
			_vector3 = new Vector3(),
			_vector4 = new Vector4(),
			_clipBox = new Box3(new Vector3(-1, -1, -1), new Vector3(1, 1, 1)),
			_boundingBox = new Box3(),
			_points3 = new Array(3),
			_viewMatrix = new Matrix4(),
			_viewProjectionMatrix = new Matrix4(),
			_modelViewProjectionMatrix = new Matrix4(),
			_frustum = new Frustum(),
			_objectPool = [],
			_vertexPool = [],
			_facePool = [],
			_linePool = [],
			_spritePool = [];

		//

		function RenderList() {
			const normals = [];
			const colors = [];
			const uvs = [];
			let object = null;
			const normalMatrix = new Matrix3();
			function setObject(value) {
				object = value;
				normalMatrix.getNormalMatrix(object.matrixWorld);
				normals.length = 0;
				colors.length = 0;
				uvs.length = 0;
			}
			function projectVertex(vertex) {
				const position = vertex.position;
				const positionWorld = vertex.positionWorld;
				const positionScreen = vertex.positionScreen;
				positionWorld.copy(position).applyMatrix4(_modelMatrix);
				positionScreen.copy(positionWorld).applyMatrix4(_viewProjectionMatrix);
				const invW = 1 / positionScreen.w;
				positionScreen.x *= invW;
				positionScreen.y *= invW;
				positionScreen.z *= invW;
				vertex.visible = positionScreen.x >= -1 && positionScreen.x <= 1 && positionScreen.y >= -1 && positionScreen.y <= 1 && positionScreen.z >= -1 && positionScreen.z <= 1;
			}
			function pushVertex(x, y, z) {
				_vertex = getNextVertexInPool();
				_vertex.position.set(x, y, z);
				projectVertex(_vertex);
			}
			function pushNormal(x, y, z) {
				normals.push(x, y, z);
			}
			function pushColor(r, g, b) {
				colors.push(r, g, b);
			}
			function pushUv(x, y) {
				uvs.push(x, y);
			}
			function checkTriangleVisibility(v1, v2, v3) {
				if (v1.visible === true || v2.visible === true || v3.visible === true) return true;
				_points3[0] = v1.positionScreen;
				_points3[1] = v2.positionScreen;
				_points3[2] = v3.positionScreen;
				return _clipBox.intersectsBox(_boundingBox.setFromPoints(_points3));
			}
			function checkBackfaceCulling(v1, v2, v3) {
				return (v3.positionScreen.x - v1.positionScreen.x) * (v2.positionScreen.y - v1.positionScreen.y) - (v3.positionScreen.y - v1.positionScreen.y) * (v2.positionScreen.x - v1.positionScreen.x) < 0;
			}
			function pushLine(a, b) {
				const v1 = _vertexPool[a];
				const v2 = _vertexPool[b];

				// Clip

				v1.positionScreen.copy(v1.position).applyMatrix4(_modelViewProjectionMatrix);
				v2.positionScreen.copy(v2.position).applyMatrix4(_modelViewProjectionMatrix);
				if (clipLine(v1.positionScreen, v2.positionScreen) === true) {
					// Perform the perspective divide
					v1.positionScreen.multiplyScalar(1 / v1.positionScreen.w);
					v2.positionScreen.multiplyScalar(1 / v2.positionScreen.w);
					_line = getNextLineInPool();
					_line.id = object.id;
					_line.v1.copy(v1);
					_line.v2.copy(v2);
					_line.z = Math.max(v1.positionScreen.z, v2.positionScreen.z);
					_line.renderOrder = object.renderOrder;
					_line.material = object.material;
					if (object.material.vertexColors) {
						_line.vertexColors[0].fromArray(colors, a * 3);
						_line.vertexColors[1].fromArray(colors, b * 3);
					}
					_renderData.elements.push(_line);
				}
			}
			function pushTriangle(a, b, c, material) {
				const v1 = _vertexPool[a];
				const v2 = _vertexPool[b];
				const v3 = _vertexPool[c];
				if (checkTriangleVisibility(v1, v2, v3) === false) return;
				if (material.side === DoubleSide || checkBackfaceCulling(v1, v2, v3) === true) {
					_face = getNextFaceInPool();
					_face.id = object.id;
					_face.v1.copy(v1);
					_face.v2.copy(v2);
					_face.v3.copy(v3);
					_face.z = (v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3;
					_face.renderOrder = object.renderOrder;

					// face normal
					_vector3.subVectors(v3.position, v2.position);
					_vector4.subVectors(v1.position, v2.position);
					_vector3.cross(_vector4);
					_face.normalModel.copy(_vector3);
					_face.normalModel.applyMatrix3(normalMatrix).normalize();
					for (let i = 0; i < 3; i++) {
						const normal = _face.vertexNormalsModel[i];
						normal.fromArray(normals, arguments[i] * 3);
						normal.applyMatrix3(normalMatrix).normalize();
						const uv = _face.uvs[i];
						uv.fromArray(uvs, arguments[i] * 2);
					}
					_face.vertexNormalsLength = 3;
					_face.material = material;
					if (material.vertexColors) {
						_face.color.fromArray(colors, a * 3);
					}
					_renderData.elements.push(_face);
				}
			}
			return {
				setObject: setObject,
				projectVertex: projectVertex,
				checkTriangleVisibility: checkTriangleVisibility,
				checkBackfaceCulling: checkBackfaceCulling,
				pushVertex: pushVertex,
				pushNormal: pushNormal,
				pushColor: pushColor,
				pushUv: pushUv,
				pushLine: pushLine,
				pushTriangle: pushTriangle
			};
		}
		const renderList = new RenderList();
		function projectObject(object) {
			if (object.visible === false) return;
			if (object.isLight) {
				_renderData.lights.push(object);
			} else if (object.isMesh || object.isLine || object.isPoints) {
				if (object.material.visible === false) return;
				if (object.frustumCulled === true && _frustum.intersectsObject(object) === false) return;
				addObject(object);
			} else if (object.isSprite) {
				if (object.material.visible === false) return;
				if (object.frustumCulled === true && _frustum.intersectsSprite(object) === false) return;
				addObject(object);
			}
			const children = object.children;
			for (let i = 0, l = children.length; i < l; i++) {
				projectObject(children[i]);
			}
		}
		function addObject(object) {
			_object = getNextObjectInPool();
			_object.id = object.id;
			_object.object = object;
			_vector3.setFromMatrixPosition(object.matrixWorld);
			_vector3.applyMatrix4(_viewProjectionMatrix);
			_object.z = _vector3.z;
			_object.renderOrder = object.renderOrder;
			_renderData.objects.push(_object);
		}
		this.projectScene = function (scene, camera, sortObjects, sortElements) {
			_faceCount = 0;
			_lineCount = 0;
			_spriteCount = 0;
			_renderData.elements.length = 0;
			if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
			if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
			_viewMatrix.copy(camera.matrixWorldInverse);
			_viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);
			_frustum.setFromProjectionMatrix(_viewProjectionMatrix);

			//

			_objectCount = 0;
			_renderData.objects.length = 0;
			_renderData.lights.length = 0;
			projectObject(scene);
			if (sortObjects === true) {
				_renderData.objects.sort(painterSort);
			}

			//

			const objects = _renderData.objects;
			for (let o = 0, ol = objects.length; o < ol; o++) {
				const object = objects[o].object;
				const geometry = object.geometry;
				renderList.setObject(object);
				_modelMatrix = object.matrixWorld;
				_vertexCount = 0;
				if (object.isMesh) {
					let material = object.material;
					const isMultiMaterial = Array.isArray(material);
					const attributes = geometry.attributes;
					const groups = geometry.groups;
					if (attributes.position === undefined) continue;
					const positions = attributes.position.array;
					for (let i = 0, l = positions.length; i < l; i += 3) {
						let x = positions[i];
						let y = positions[i + 1];
						let z = positions[i + 2];
						const morphTargets = geometry.morphAttributes.position;
						if (morphTargets !== undefined) {
							const morphTargetsRelative = geometry.morphTargetsRelative;
							const morphInfluences = object.morphTargetInfluences;
							for (let t = 0, tl = morphTargets.length; t < tl; t++) {
								const influence = morphInfluences[t];
								if (influence === 0) continue;
								const target = morphTargets[t];
								if (morphTargetsRelative) {
									x += target.getX(i / 3) * influence;
									y += target.getY(i / 3) * influence;
									z += target.getZ(i / 3) * influence;
								} else {
									x += (target.getX(i / 3) - positions[i]) * influence;
									y += (target.getY(i / 3) - positions[i + 1]) * influence;
									z += (target.getZ(i / 3) - positions[i + 2]) * influence;
								}
							}
						}
						renderList.pushVertex(x, y, z);
					}
					if (attributes.normal !== undefined) {
						const normals = attributes.normal.array;
						for (let i = 0, l = normals.length; i < l; i += 3) {
							renderList.pushNormal(normals[i], normals[i + 1], normals[i + 2]);
						}
					}
					if (attributes.color !== undefined) {
						const colors = attributes.color.array;
						for (let i = 0, l = colors.length; i < l; i += 3) {
							renderList.pushColor(colors[i], colors[i + 1], colors[i + 2]);
						}
					}
					if (attributes.uv !== undefined) {
						const uvs = attributes.uv.array;
						for (let i = 0, l = uvs.length; i < l; i += 2) {
							renderList.pushUv(uvs[i], uvs[i + 1]);
						}
					}
					if (geometry.index !== null) {
						const indices = geometry.index.array;
						if (groups.length > 0) {
							for (let g = 0; g < groups.length; g++) {
								const group = groups[g];
								material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material;
								if (material === undefined) continue;
								for (let i = group.start, l = group.start + group.count; i < l; i += 3) {
									renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2], material);
								}
							}
						} else {
							for (let i = 0, l = indices.length; i < l; i += 3) {
								renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2], material);
							}
						}
					} else {
						if (groups.length > 0) {
							for (let g = 0; g < groups.length; g++) {
								const group = groups[g];
								material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material;
								if (material === undefined) continue;
								for (let i = group.start, l = group.start + group.count; i < l; i += 3) {
									renderList.pushTriangle(i, i + 1, i + 2, material);
								}
							}
						} else {
							for (let i = 0, l = positions.length / 3; i < l; i += 3) {
								renderList.pushTriangle(i, i + 1, i + 2, material);
							}
						}
					}
				} else if (object.isLine) {
					_modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);
					const attributes = geometry.attributes;
					if (attributes.position !== undefined) {
						const positions = attributes.position.array;
						for (let i = 0, l = positions.length; i < l; i += 3) {
							renderList.pushVertex(positions[i], positions[i + 1], positions[i + 2]);
						}
						if (attributes.color !== undefined) {
							const colors = attributes.color.array;
							for (let i = 0, l = colors.length; i < l; i += 3) {
								renderList.pushColor(colors[i], colors[i + 1], colors[i + 2]);
							}
						}
						if (geometry.index !== null) {
							const indices = geometry.index.array;
							for (let i = 0, l = indices.length; i < l; i += 2) {
								renderList.pushLine(indices[i], indices[i + 1]);
							}
						} else {
							const step = object.isLineSegments ? 2 : 1;
							for (let i = 0, l = positions.length / 3 - 1; i < l; i += step) {
								renderList.pushLine(i, i + 1);
							}
						}
					}
				} else if (object.isPoints) {
					_modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);
					const attributes = geometry.attributes;
					if (attributes.position !== undefined) {
						const positions = attributes.position.array;
						for (let i = 0, l = positions.length; i < l; i += 3) {
							_vector4.set(positions[i], positions[i + 1], positions[i + 2], 1);
							_vector4.applyMatrix4(_modelViewProjectionMatrix);
							pushPoint(_vector4, object, camera);
						}
					}
				} else if (object.isSprite) {
					object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
					_vector4.set(_modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1);
					_vector4.applyMatrix4(_viewProjectionMatrix);
					pushPoint(_vector4, object, camera);
				}
			}
			if (sortElements === true) {
				_renderData.elements.sort(painterSort);
			}
			return _renderData;
		};
		function pushPoint(_vector4, object, camera) {
			const invW = 1 / _vector4.w;
			_vector4.z *= invW;
			if (_vector4.z >= -1 && _vector4.z <= 1) {
				_sprite = getNextSpriteInPool();
				_sprite.id = object.id;
				_sprite.x = _vector4.x * invW;
				_sprite.y = _vector4.y * invW;
				_sprite.z = _vector4.z;
				_sprite.renderOrder = object.renderOrder;
				_sprite.object = object;
				_sprite.rotation = object.rotation;
				_sprite.scale.x = object.scale.x * Math.abs(_sprite.x - (_vector4.x + camera.projectionMatrix.elements[0]) / (_vector4.w + camera.projectionMatrix.elements[12]));
				_sprite.scale.y = object.scale.y * Math.abs(_sprite.y - (_vector4.y + camera.projectionMatrix.elements[5]) / (_vector4.w + camera.projectionMatrix.elements[13]));
				_sprite.material = object.material;
				_renderData.elements.push(_sprite);
			}
		}

		// Pools

		function getNextObjectInPool() {
			if (_objectCount === _objectPoolLength) {
				const object = new RenderableObject();
				_objectPool.push(object);
				_objectPoolLength++;
				_objectCount++;
				return object;
			}
			return _objectPool[_objectCount++];
		}
		function getNextVertexInPool() {
			if (_vertexCount === _vertexPoolLength) {
				const vertex = new RenderableVertex();
				_vertexPool.push(vertex);
				_vertexPoolLength++;
				_vertexCount++;
				return vertex;
			}
			return _vertexPool[_vertexCount++];
		}
		function getNextFaceInPool() {
			if (_faceCount === _facePoolLength) {
				const face = new RenderableFace();
				_facePool.push(face);
				_facePoolLength++;
				_faceCount++;
				return face;
			}
			return _facePool[_faceCount++];
		}
		function getNextLineInPool() {
			if (_lineCount === _linePoolLength) {
				const line = new RenderableLine();
				_linePool.push(line);
				_linePoolLength++;
				_lineCount++;
				return line;
			}
			return _linePool[_lineCount++];
		}
		function getNextSpriteInPool() {
			if (_spriteCount === _spritePoolLength) {
				const sprite = new RenderableSprite();
				_spritePool.push(sprite);
				_spritePoolLength++;
				_spriteCount++;
				return sprite;
			}
			return _spritePool[_spriteCount++];
		}

		//

		function painterSort(a, b) {
			if (a.renderOrder !== b.renderOrder) {
				return a.renderOrder - b.renderOrder;
			} else if (a.z !== b.z) {
				return b.z - a.z;
			} else if (a.id !== b.id) {
				return a.id - b.id;
			} else {
				return 0;
			}
		}
		function clipLine(s1, s2) {
			let alpha1 = 0,
				alpha2 = 1;

			// Calculate the boundary coordinate of each vertex for the near and far clip planes,
			// Z = -1 and Z = +1, respectively.

			const bc1near = s1.z + s1.w,
				bc2near = s2.z + s2.w,
				bc1far = -s1.z + s1.w,
				bc2far = -s2.z + s2.w;
			if (bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0) {
				// Both vertices lie entirely within all clip planes.
				return true;
			} else if (bc1near < 0 && bc2near < 0 || bc1far < 0 && bc2far < 0) {
				// Both vertices lie entirely outside one of the clip planes.
				return false;
			} else {
				// The line segment spans at least one clip plane.

				if (bc1near < 0) {
					// v1 lies outside the near plane, v2 inside
					alpha1 = Math.max(alpha1, bc1near / (bc1near - bc2near));
				} else if (bc2near < 0) {
					// v2 lies outside the near plane, v1 inside
					alpha2 = Math.min(alpha2, bc1near / (bc1near - bc2near));
				}
				if (bc1far < 0) {
					// v1 lies outside the far plane, v2 inside
					alpha1 = Math.max(alpha1, bc1far / (bc1far - bc2far));
				} else if (bc2far < 0) {
					// v2 lies outside the far plane, v2 inside
					alpha2 = Math.min(alpha2, bc1far / (bc1far - bc2far));
				}
				if (alpha2 < alpha1) {
					// The line segment spans two boundaries, but is outside both of them.
					// (This can't happen when we're only clipping against just near/far but good
					//	to leave the check here for future usage if other clip planes are added.)
					return false;
				} else {
					// Update the s1 and s2 vertices to match the clipped line segment.
					s1.lerp(s2, alpha1);
					s2.lerp(s1, 1 - alpha2);
					return true;
				}
			}
		}
	}
}

class SVGRenderer {
	constructor() {
		let _renderData,
			_elements,
			_lights,
			_svgWidth,
			_svgHeight,
			_svgWidthHalf,
			_svgHeightHalf,
			_v1,
			_v2,
			_v3,
			_svgNode,
			_pathCount = 0,
			_precision = null,
			_quality = 1,
			_currentPath,
			_currentStyle;
		const _this = this,
			_clipBox = new Box2(),
			_elemBox = new Box2(),
			_color = new Color$1(),
			_diffuseColor = new Color$1(),
			_ambientLight = new Color$1(),
			_directionalLights = new Color$1(),
			_pointLights = new Color$1(),
			_clearColor = new Color$1(),
			_vector3 = new Vector3(),
			// Needed for PointLight
			_centroid = new Vector3(),
			_normal = new Vector3(),
			_normalViewMatrix = new Matrix3(),
			_viewMatrix = new Matrix4(),
			_viewProjectionMatrix = new Matrix4(),
			_svgPathPool = [],
			_projector = new Projector(),
			_svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
		this.domElement = _svg;
		this.autoClear = true;
		this.sortObjects = true;
		this.sortElements = true;
		this.overdraw = 0.5;
		this.info = {
			render: {
				vertices: 0,
				faces: 0
			}
		};
		this.setQuality = function (quality) {
			switch (quality) {
				case 'high':
					_quality = 1;
					break;
				case 'low':
					_quality = 0;
					break;
			}
		};
		this.setClearColor = function (color) {
			_clearColor.set(color);
		};
		this.setPixelRatio = function () {};
		this.setSize = function (width, height) {
			_svgWidth = width;
			_svgHeight = height;
			_svgWidthHalf = _svgWidth / 2;
			_svgHeightHalf = _svgHeight / 2;
			_svg.setAttribute('viewBox', -_svgWidthHalf + ' ' + -_svgHeightHalf + ' ' + _svgWidth + ' ' + _svgHeight);
			_svg.setAttribute('width', _svgWidth);
			_svg.setAttribute('height', _svgHeight);
			_clipBox.min.set(-_svgWidthHalf, -_svgHeightHalf);
			_clipBox.max.set(_svgWidthHalf, _svgHeightHalf);
		};
		this.getSize = function () {
			return {
				width: _svgWidth,
				height: _svgHeight
			};
		};
		this.setPrecision = function (precision) {
			_precision = precision;
		};
		function removeChildNodes() {
			_pathCount = 0;
			while (_svg.childNodes.length > 0) {
				_svg.removeChild(_svg.childNodes[0]);
			}
		}
		function convert(c) {
			return _precision !== null ? c.toFixed(_precision) : c;
		}
		this.clear = function () {
			removeChildNodes();
			_svg.style.backgroundColor = _clearColor.getStyle();
		};
		this.render = function (scene, camera) {
			if (camera instanceof Camera === false) {
				console.error('THREE.SVGRenderer.render: camera is not an instance of Camera.');
				return;
			}
			const background = scene.background;
			if (background && background.isColor) {
				removeChildNodes();
				_svg.style.backgroundColor = background.getStyle();
			} else if (this.autoClear === true) {
				this.clear();
			}
			_this.info.render.vertices = 0;
			_this.info.render.faces = 0;
			_viewMatrix.copy(camera.matrixWorldInverse);
			_viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);
			_renderData = _projector.projectScene(scene, camera, this.sortObjects, this.sortElements);
			_elements = _renderData.elements;
			_lights = _renderData.lights;
			_normalViewMatrix.getNormalMatrix(camera.matrixWorldInverse);
			calculateLights(_lights);

			// reset accumulated path

			_currentPath = '';
			_currentStyle = '';
			for (let e = 0, el = _elements.length; e < el; e++) {
				const element = _elements[e];
				const material = element.material;
				if (material === undefined || material.opacity === 0) continue;
				_elemBox.makeEmpty();
				if (element instanceof RenderableSprite) {
					_v1 = element;
					_v1.x *= _svgWidthHalf;
					_v1.y *= -_svgHeightHalf;
					renderSprite(_v1, element, material);
				} else if (element instanceof RenderableLine) {
					_v1 = element.v1;
					_v2 = element.v2;
					_v1.positionScreen.x *= _svgWidthHalf;
					_v1.positionScreen.y *= -_svgHeightHalf;
					_v2.positionScreen.x *= _svgWidthHalf;
					_v2.positionScreen.y *= -_svgHeightHalf;
					_elemBox.setFromPoints([_v1.positionScreen, _v2.positionScreen]);
					if (_clipBox.intersectsBox(_elemBox) === true) {
						renderLine(_v1, _v2, material);
					}
				} else if (element instanceof RenderableFace) {
					_v1 = element.v1;
					_v2 = element.v2;
					_v3 = element.v3;
					if (_v1.positionScreen.z < -1 || _v1.positionScreen.z > 1) continue;
					if (_v2.positionScreen.z < -1 || _v2.positionScreen.z > 1) continue;
					if (_v3.positionScreen.z < -1 || _v3.positionScreen.z > 1) continue;
					_v1.positionScreen.x *= _svgWidthHalf;
					_v1.positionScreen.y *= -_svgHeightHalf;
					_v2.positionScreen.x *= _svgWidthHalf;
					_v2.positionScreen.y *= -_svgHeightHalf;
					_v3.positionScreen.x *= _svgWidthHalf;
					_v3.positionScreen.y *= -_svgHeightHalf;
					if (this.overdraw > 0) {
						expand(_v1.positionScreen, _v2.positionScreen, this.overdraw);
						expand(_v2.positionScreen, _v3.positionScreen, this.overdraw);
						expand(_v3.positionScreen, _v1.positionScreen, this.overdraw);
					}
					_elemBox.setFromPoints([_v1.positionScreen, _v2.positionScreen, _v3.positionScreen]);
					if (_clipBox.intersectsBox(_elemBox) === true) {
						renderFace3(_v1, _v2, _v3, element, material);
					}
				}
			}
			flushPath(); // just to flush last svg:path

			scene.traverseVisible(function (object) {
				if (object.isSVGObject) {
					_vector3.setFromMatrixPosition(object.matrixWorld);
					_vector3.applyMatrix4(_viewProjectionMatrix);
					if (_vector3.z < -1 || _vector3.z > 1) return;
					const x = _vector3.x * _svgWidthHalf;
					const y = -_vector3.y * _svgHeightHalf;
					const node = object.node;
					node.setAttribute('transform', 'translate(' + x + ',' + y + ')');
					_svg.appendChild(node);
				}
			});
		};
		function calculateLights(lights) {
			_ambientLight.setRGB(0, 0, 0);
			_directionalLights.setRGB(0, 0, 0);
			_pointLights.setRGB(0, 0, 0);
			for (let l = 0, ll = lights.length; l < ll; l++) {
				const light = lights[l];
				const lightColor = light.color;
				if (light.isAmbientLight) {
					_ambientLight.r += lightColor.r;
					_ambientLight.g += lightColor.g;
					_ambientLight.b += lightColor.b;
				} else if (light.isDirectionalLight) {
					_directionalLights.r += lightColor.r;
					_directionalLights.g += lightColor.g;
					_directionalLights.b += lightColor.b;
				} else if (light.isPointLight) {
					_pointLights.r += lightColor.r;
					_pointLights.g += lightColor.g;
					_pointLights.b += lightColor.b;
				}
			}
		}
		function calculateLight(lights, position, normal, color) {
			for (let l = 0, ll = lights.length; l < ll; l++) {
				const light = lights[l];
				const lightColor = light.color;
				if (light.isDirectionalLight) {
					const lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld).normalize();
					let amount = normal.dot(lightPosition);
					if (amount <= 0) continue;
					amount *= light.intensity;
					color.r += lightColor.r * amount;
					color.g += lightColor.g * amount;
					color.b += lightColor.b * amount;
				} else if (light.isPointLight) {
					const lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld);
					let amount = normal.dot(_vector3.subVectors(lightPosition, position).normalize());
					if (amount <= 0) continue;
					amount *= light.distance == 0 ? 1 : 1 - Math.min(position.distanceTo(lightPosition) / light.distance, 1);
					if (amount == 0) continue;
					amount *= light.intensity;
					color.r += lightColor.r * amount;
					color.g += lightColor.g * amount;
					color.b += lightColor.b * amount;
				}
			}
		}
		function renderSprite(v1, element, material) {
			let scaleX = element.scale.x * _svgWidthHalf;
			let scaleY = element.scale.y * _svgHeightHalf;
			if (material.isPointsMaterial) {
				scaleX *= material.size;
				scaleY *= material.size;
			}
			const path = 'M' + convert(v1.x - scaleX * 0.5) + ',' + convert(v1.y - scaleY * 0.5) + 'h' + convert(scaleX) + 'v' + convert(scaleY) + 'h' + convert(-scaleX) + 'z';
			let style = '';
			if (material.isSpriteMaterial || material.isPointsMaterial) {
				style = 'fill:' + material.color.getStyle() + ';fill-opacity:' + material.opacity;
			}
			addPath(style, path);
		}
		function renderLine(v1, v2, material) {
			const path = 'M' + convert(v1.positionScreen.x) + ',' + convert(v1.positionScreen.y) + 'L' + convert(v2.positionScreen.x) + ',' + convert(v2.positionScreen.y);
			if (material.isLineBasicMaterial) {
				let style = 'fill:none;stroke:' + material.color.getStyle() + ';stroke-opacity:' + material.opacity + ';stroke-width:' + material.linewidth + ';stroke-linecap:' + material.linecap;
				if (material.isLineDashedMaterial) {
					style = style + ';stroke-dasharray:' + material.dashSize + ',' + material.gapSize;
				}
				addPath(style, path);
			}
		}
		function renderFace3(v1, v2, v3, element, material) {
			_this.info.render.vertices += 3;
			_this.info.render.faces++;
			const path = 'M' + convert(v1.positionScreen.x) + ',' + convert(v1.positionScreen.y) + 'L' + convert(v2.positionScreen.x) + ',' + convert(v2.positionScreen.y) + 'L' + convert(v3.positionScreen.x) + ',' + convert(v3.positionScreen.y) + 'z';
			let style = '';
			if (material.isMeshBasicMaterial) {
				_color.copy(material.color);
				if (material.vertexColors) {
					_color.multiply(element.color);
				}
			} else if (material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial) {
				_diffuseColor.copy(material.color);
				if (material.vertexColors) {
					_diffuseColor.multiply(element.color);
				}
				_color.copy(_ambientLight);
				_centroid.copy(v1.positionWorld).add(v2.positionWorld).add(v3.positionWorld).divideScalar(3);
				calculateLight(_lights, _centroid, element.normalModel, _color);
				_color.multiply(_diffuseColor).add(material.emissive);
			} else if (material.isMeshNormalMaterial) {
				_normal.copy(element.normalModel).applyMatrix3(_normalViewMatrix).normalize();
				_color.setRGB(_normal.x, _normal.y, _normal.z).multiplyScalar(0.5).addScalar(0.5);
			}
			if (material.wireframe) {
				style = 'fill:none;stroke:' + _color.getStyle() + ';stroke-opacity:' + material.opacity + ';stroke-width:' + material.wireframeLinewidth + ';stroke-linecap:' + material.wireframeLinecap + ';stroke-linejoin:' + material.wireframeLinejoin;
			} else {
				style = 'fill:' + _color.getStyle() + ';fill-opacity:' + material.opacity;
			}
			addPath(style, path);
		}

		// Hide anti-alias gaps

		function expand(v1, v2, pixels) {
			let x = v2.x - v1.x,
				y = v2.y - v1.y;
			const det = x * x + y * y;
			if (det === 0) return;
			const idet = pixels / Math.sqrt(det);
			x *= idet;
			y *= idet;
			v2.x += x;
			v2.y += y;
			v1.x -= x;
			v1.y -= y;
		}
		function addPath(style, path) {
			if (_currentStyle === style) {
				_currentPath += path;
			} else {
				flushPath();
				_currentStyle = style;
				_currentPath = path;
			}
		}
		function flushPath() {
			if (_currentPath) {
				_svgNode = getPathNode(_pathCount++);
				_svgNode.setAttribute('d', _currentPath);
				_svgNode.setAttribute('style', _currentStyle);
				_svg.appendChild(_svgNode);
			}
			_currentPath = '';
			_currentStyle = '';
		}
		function getPathNode(id) {
			if (_svgPathPool[id] == null) {
				_svgPathPool[id] = document.createElementNS('http://www.w3.org/2000/svg', 'path');
				if (_quality == 0) {
					_svgPathPool[id].setAttribute('shape-rendering', 'crispEdges'); //optimizeSpeed
				}

				return _svgPathPool[id];
			}
			return _svgPathPool[id];
		}
	}
}

let HelveticerRegularJson = json1;

// end of jsroot part

if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
	/* eslint-disable no-undef */
	__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
		detail: {
			revision: REVISION
		}
	}));
	/* eslint-enable no-undef */
}

if (typeof window !== 'undefined') {
	if (window.__THREE__) {
		console.warn('WARNING: Multiple instances of Three.js being imported.');
	} else {
		window.__THREE__ = REVISION;
	}
}

const HelveticerRegularFont = new Font(HelveticerRegularJson);

function createSVGRenderer(as_is, precision, doc) {
   if (as_is) {
      if (doc !== undefined)
         globalThis.docuemnt = doc;
      let rndr = new SVGRenderer();
      rndr.setPrecision(precision);
      return rndr;
   }

   const excl_style1 = ';stroke-opacity:1;stroke-width:1;stroke-linecap:round',
         excl_style2 = ';fill-opacity:1';

   let doc_wrapper = {
     svg_attr: {},
     svg_style: {},
     path_attr: {},
     accPath: '',
     createElementNS(ns,kind) {
        if (kind == 'path')
           return {
              _wrapper: this,
              setAttribute(name, value) {
                 // cut useless fill-opacity:1 at the end of many SVG attributes
                 if ((name == 'style') && value) {
                    let pos1 = value.indexOf(excl_style1);
                    if ((pos1 >= 0) && (pos1 == value.length - excl_style1.length))
                       value = value.slice(0, value.length - excl_style1.length);
                    let pos2 = value.indexOf(excl_style2);
                    if ((pos2 >= 0) && (pos2 == value.length - excl_style2.length))
                       value = value.slice(0, value.length - excl_style2.length);
                 }
                 this._wrapper.path_attr[name] = value;
              }
           }

        if (kind != 'svg') {
           console.error(`not supported element for SVGRenderer ${kind}`);
           return null;
        }

        return {
           _wrapper: this,
           childNodes: [], // may be accessed - make dummy
           style: this.svg_style, // for background color
           setAttribute(name, value) {
              this._wrapper.svg_attr[name] = value;
           },
           appendChild(node) {
              this._wrapper.accPath += `<path style="${this._wrapper.path_attr['style']}" d="${this._wrapper.path_attr['d']}"/>`;
              this._wrapper.path_attr = {};
           },
           removeChild(node) {
              this.childNodes = [];
           }
        };
     }
   };

   let originalDocument = globalThis.document;
   globalThis.document = doc_wrapper;

   let rndr = new SVGRenderer();

   globalThis.document = originalDocument;

   rndr.doc_wrapper = doc_wrapper; // use it to get final SVG code

   rndr.originalRender = rndr.render;

   rndr.render = function (scene, camera) {
      let originalDocument = globalThis.document;
      globalThis.document = this.doc_wrapper;

      this.originalRender(scene, camera);

      globalThis.document = originalDocument;
   };

   rndr.clearHTML = function() {
      this.doc_wrapper.accPath = '';
   };

   rndr.makeOuterHTML = function() {

      let wrap = this.doc_wrapper,
         _textSizeAttr = `viewBox="${wrap.svg_attr['viewBox']}" width="${wrap.svg_attr['width']}" height="${wrap.svg_attr['height']}"`,
         _textClearAttr = wrap.svg_style.backgroundColor ? ` style="background:${wrap.svg_style.backgroundColor}"` : '';

      return `<svg xmlns="http://www.w3.org/2000/svg" ${_textSizeAttr}${_textClearAttr}>${wrap.accPath}</svg>`;
   };

   rndr.setPrecision(precision);

   return rndr;
}


/** @ummary Define rendering kind which will be used for rendering of 3D elements
  * @param {value} [render3d] - preconfigured value, will be used if applicable
  * @return {value} - rendering kind, see constants.Render3D
  * @private */
function getRender3DKind(render3d) {
   if (!render3d) render3d = isBatchMode() ? settings.Render3DBatch : settings.Render3D;
   let rc = constants$1.Render3D;

   if (render3d == rc.Default) render3d = isBatchMode() ? rc.WebGLImage : rc.WebGL;
   if (isBatchMode() && (render3d == rc.WebGL)) render3d = rc.WebGLImage;

   return render3d;
}

let Handling3DDrawings = {

   /** @summary Access current 3d mode
     * @param {string} [new_value] - when specified, set new 3d mode
     * @return current value
     * @private */
   access3dKind(new_value) {
      let svg = this.getPadSvg();
      if (svg.empty()) return -1;

      // returns kind of currently created 3d canvas
      let kind = svg.property('can3d');
      if (new_value !== undefined) svg.property('can3d', new_value);
      return ((kind === null) || (kind === undefined)) ? -1 : kind;
   },

   /** @summary Returns size which availble for 3D drawing.
     * @desc One uses frame sizes for the 3D drawing - like TH2/TH3 objects
     * @private */
   getSizeFor3d(can3d, render3d) {

      if (can3d === undefined) {
         // analyze which render/embed mode can be used
         can3d = getRender3DKind();
         // all non-webgl elements can be embedded into SVG as is
         if (can3d !== constants$1.Render3D.WebGL)
            can3d = constants$1.Embed3D.EmbedSVG;
         else if (settings.Embed3D != constants$1.Embed3D.Default)
            can3d = settings.Embed3D;
         else if (browser$1.isFirefox)
            can3d = constants$1.Embed3D.Embed;
         else if (browser$1.chromeVersion > 95)
         // version 96 works partially, 97 works fine
            can3d = constants$1.Embed3D.Embed;
         else
            can3d = constants$1.Embed3D.Overlay;
      }

      let pad = this.getPadSvg(),
          clname = 'draw3d_' + (this.getPadName() || 'canvas');

      if (pad.empty()) {
         // this is a case when object drawn without canvas

         let rect = getElementRect(this.selectDom());

         if ((rect.height < 10) && (rect.width > 10)) {
            rect.height = Math.round(0.66 * rect.width);
            this.selectDom().style('height', rect.height + 'px');
         }
         rect.x = 0; rect.y = 0; rect.clname = clname; rect.can3d = -1;
         return rect;
      }

      let fp = this.getFramePainter(), pp = this.getPadPainter(), size;

      if (fp?.mode3d && (can3d > 0)) {
         size = fp.getFrameRect();
      } else {
         let elem = (can3d > 0) ? pad : this.getCanvSvg();
         size = { x: 0, y: 0, width: elem.property('draw_width'), height: elem.property('draw_height') };
         if (Number.isNaN(size.width) || Number.isNaN(size.height)) {
            size.width = pp.getPadWidth();
            size.height = pp.getPadHeight();
         } else if (fp && !fp.mode3d) {
            elem = this.getFrameSvg();
            size.x = elem.property('draw_x');
            size.y = elem.property('draw_y');
         }
      }

      size.clname = clname;
      size.can3d = can3d;

      let rect = pp?.getPadRect();
      if (rect) {
         // while 3D canvas uses area also for the axis labels, extend area relative to normal frame
         let dx = Math.round(size.width*0.07), dy = Math.round(size.height*0.05);

         size.x = Math.max(0, size.x-dx);
         size.y = Math.max(0, size.y-dy);
         size.width = Math.min(size.width + 2*dx, rect.width - size.x);
         size.height = Math.min(size.height + 2*dy, rect.height - size.y);
      }

      if (can3d === 1)
         size = getAbsPosInCanvas(this.getPadSvg(), size);

      return size;
   },

   /** @summary Clear all 3D drawings
     * @return can3d value - how webgl canvas was placed
     * @private */
   clear3dCanvas() {
      let can3d = this.access3dKind(null);
      if (can3d < 0) {
         // remove first child from main element - if it is canvas
         let main = this.selectDom().node(),
             chld = main ? main.firstChild : null;

         if (chld && !chld.$jsroot)
            chld = chld.nextSibling;

         if (chld && chld.$jsroot) {
            delete chld.painter;
            main.removeChild(chld);
         }
         return can3d;
      }

      let size = this.getSizeFor3d(can3d);

      if (size.can3d === 0) {
         select(this.getCanvSvg().node().nextSibling).remove(); // remove html5 canvas
         this.getCanvSvg().style('display', null); // show SVG canvas
      } else {
         if (this.getPadSvg().empty()) return;

         this.apply3dSize(size).remove();

         this.getFrameSvg().style('display', null);  // clear display property
      }
      return can3d;
   },

   /** @summary Add 3D canvas
     * @private */
   add3dCanvas(size, canv, webgl) {

      if (!canv || (size.can3d < -1)) return;

      if (size.can3d === -1) {
         // case when 3D object drawn without canvas

         let main = this.selectDom().node();
         if (main !== null) {
            main.appendChild(canv);
            canv.painter = this;
            canv.$jsroot = true; // mark canvas as added by jsroot
         }

         return;
      }

      if ((size.can3d > 0) && !webgl)
         size.can3d = constants$1.Embed3D.EmbedSVG;

      this.access3dKind(size.can3d);

      if (size.can3d === 0) {
         this.getCanvSvg().style('display', 'none'); // hide SVG canvas

         this.getCanvSvg().node().parentNode.appendChild(canv); // add directly
      } else {
         if (this.getPadSvg().empty()) return;

         // first hide normal frame
         this.getFrameSvg().style('display', 'none');

         let elem = this.apply3dSize(size);

         elem.attr('title', '').node().appendChild(canv);
      }
   },

   /** @summary Apply size to 3D elements
     * @private */
   apply3dSize(size, onlyget) {

      if (size.can3d < 0) return select(null);

      let elem;

      if (size.can3d > 1) {

         elem = this.getLayerSvg(size.clname);

         // elem = layer.select('.' + size.clname);
         if (onlyget) return elem;

         let svg = this.getPadSvg();

         if (size.can3d === constants$1.Embed3D.EmbedSVG) {
            // this is SVG mode or image mode - just create group to hold element

            if (elem.empty())
               elem = svg.insert('g', '.primitives_layer').attr('class', size.clname);

            elem.attr('transform', `translate(${size.x},${size.y})`);

         } else {

            if (elem.empty())
               elem = svg.insert('foreignObject', '.primitives_layer').attr('class', size.clname);

            elem.attr('x', size.x)
                .attr('y', size.y)
                .attr('width', size.width)
                .attr('height', size.height)
                .attr('viewBox', `0 0 ${size.width} ${size.height}`)
                .attr('preserveAspectRatio', 'xMidYMid');
         }

      } else {
         let prnt = this.getCanvSvg().node().parentNode;

         elem = select(prnt).select('.' + size.clname);
         if (onlyget) return elem;

         // force redraw by resize
         this.getCanvSvg().property('redraw_by_resize', true);

         if (elem.empty())
            elem = select(prnt).append('div').attr('class', size.clname)
                                  .style('user-select', 'none');

         // our position inside canvas, but to set 'absolute' position we should use
         // canvas element offset relative to first parent with non-static position
         // now try to use getBoundingClientRect - it should be more precise

         let pos0 = prnt.getBoundingClientRect();

         while (prnt) {
            if (prnt === document) { prnt = null; break; }
            try {
               if (getComputedStyle(prnt).position !== 'static') break;
            } catch (err) {
               break;
            }
            prnt = prnt.parentNode;
         }

         let pos1 = prnt?.getBoundingClientRect() ?? { top: 0, left: 0 },
             offx = Math.round(pos0.left - pos1.left),
             offy = Math.round(pos0.top - pos1.top);

         elem.style('position', 'absolute').style('left', (size.x + offx) + 'px').style('top', (size.y + offy) + 'px').style('width', size.width + 'px').style('height', size.height + 'px');
      }

      return elem;
   }

}; // Handling3DDrawings


/** @summary Assigns method to handle 3D drawings inside SVG
  * @private */
function assign3DHandler(painter) {
   Object.assign(painter, Handling3DDrawings);
}


/** @summary Creates renderer for the 3D drawings
  * @param {value} width - rendering width
  * @param {value} height - rendering height
  * @param {value} render3d - render type, see {@link constants.Render3D}
  * @param {object} args - different arguments for creating 3D renderer
  * @return {Promise} with renderer object
  * @private */

async function createRender3D(width, height, render3d, args) {

   let rc = constants$1.Render3D, promise, need_workaround = false, doc = getDocument();

   render3d = getRender3DKind(render3d);

   if (!args) args = { antialias: true, alpha: true };

   if (render3d == rc.WebGL) {
      // interactive WebGL Rendering
      promise = Promise.resolve(new WebGLRenderer(args));

   } else if (render3d == rc.SVG) {
      // SVG rendering
      let r = createSVGRenderer(false, 0, doc);

      if (isBatchMode()) {
         need_workaround = true;
      } else {
         r.jsroot_dom = doc.createElementNS('http://www.w3.org/2000/svg', 'svg');
         // d3_select(r.jsroot_dom).attr('width', width).attr('height', height);
      }
      promise = Promise.resolve(r);
   } else if (isNodeJs()) {
      // try to use WebGL inside node.js - need to create headless context
      promise = Promise.resolve().then(function () { return _rollup_plugin_ignore_empty_module_placeholder$1; }).then(node_canvas => {
         args.canvas = node_canvas.default.createCanvas(width, height);
         args.canvas.addEventListener = function() { }; // dummy
         args.canvas.removeEventListener = function() { }; // dummy
         args.canvas.style = {};
         return Promise.resolve().then(function () { return _rollup_plugin_ignore_empty_module_placeholder$1; });
      }).then(node_gl => {
         let gl = node_gl.default(width, height, { preserveDrawingBuffer: true });
         if (!gl) throw(Error('Fail to create headless-gl'));
         args.context = gl;
         gl.canvas = args.canvas;

         let r = new WebGLRenderer(args);

         r.jsroot_output = new WebGLRenderTarget(width, height);
         r.setRenderTarget(r.jsroot_output);
         need_workaround = true;
         return r;
      });

   } else {
      // rendering with WebGL directly into svg image
      let r = new WebGLRenderer(args);
      r.jsroot_dom = doc.createElementNS('http://www.w3.org/2000/svg', 'image');
      select(r.jsroot_dom).attr('width', width).attr('height', height);
      promise = Promise.resolve(r);
   }

   return promise.then(renderer => {

      if (need_workaround) {
          if (!internals.svg_3ds) internals.svg_3ds = [];
         renderer.workaround_id = internals.svg_3ds.length;
         internals.svg_3ds[renderer.workaround_id] = '<svg></svg>'; // dummy, provided in afterRender3D

         // replace DOM element in renderer
         renderer.jsroot_dom = doc.createElementNS('http://www.w3.org/2000/svg', 'path');
         renderer.jsroot_dom.setAttribute('jsroot_svg_workaround', renderer.workaround_id);
      } else if (!renderer.jsroot_dom) {
         renderer.jsroot_dom = renderer.domElement;
      }

      // res.renderer.setClearColor('#000000', 1);
      // res.renderer.setClearColor(0x0, 0);
      renderer.setSize(width, height);
      renderer.jsroot_render3d = render3d;

      // apply size to dom element
      renderer.setJSROOTSize = function(width, height) {
         if ((this.jsroot_render3d === constants$1.Render3D.WebGLImage) && !isBatchMode() && !isNodeJs())
            return select(this.jsroot_dom).attr('width', width).attr('height', height);
      };

      return renderer;
   });
}


/** @summary Cleanup created renderer object
  * @private */
function cleanupRender3D(renderer) {
   if (!renderer) return;

   if (isNodeJs()) {
      let ctxt = isFunc(renderer.getContext) ? renderer.getContext() : null,
          ext = ctxt?.getExtension('STACKGL_destroy_context');
      if (ext) ext.destroy();
   } else {
      // suppress warnings in Chrome about lost webgl context, not required in firefox
      if (browser$1.isChrome && isFunc(renderer.forceContextLoss))
         renderer.forceContextLoss();

      if (isFunc(renderer.dispose))
         renderer.dispose();
   }
}

/** @summary Cleanup previous renderings before doing next one
  * @desc used together with SVG
  * @private */
function beforeRender3D(renderer) {
   if (renderer.clearHTML) renderer.clearHTML();
}

/** @summary Post-process result of rendering
  * @desc used together with SVG or node.js image rendering
  * @private */
function afterRender3D(renderer) {

   let rc = constants$1.Render3D;
   if (renderer.jsroot_render3d == rc.WebGL) return;

   if (renderer.jsroot_render3d == rc.SVG) {
      // case of SVGRenderer
      if (isBatchMode()) {
         internals.svg_3ds[renderer.workaround_id] = renderer.makeOuterHTML();
      } else {
         let parent = renderer.jsroot_dom.parentNode;
         if (parent) {
            parent.innerHTML = renderer.makeOuterHTML();
            renderer.jsroot_dom = parent.firstChild;
         }
      }
   } else if (isNodeJs()) {
      // this is WebGL rendering in node.js
      let canvas = renderer.domElement,
         context = canvas.getContext('2d');

      let pixels = new Uint8Array(4 * canvas.width * canvas.height);
      renderer.readRenderTargetPixels(renderer.jsroot_output, 0, 0, canvas.width, canvas.height, pixels);

      // small code to flip Y scale
      let indx1 = 0, indx2 = (canvas.height - 1) * 4 * canvas.width, k, d;
      while (indx1 < indx2) {
         for  (k = 0; k < 4 * canvas.width; ++k) {
            d = pixels[indx1 + k]; pixels[indx1 + k] = pixels[indx2 + k]; pixels[indx2 + k] = d;
         }
         indx1 += 4 * canvas.width;
         indx2 -= 4 * canvas.width;
      }

      let imageData = context.createImageData(canvas.width, canvas.height);
      imageData.data.set(pixels);
      context.putImageData(imageData, 0, 0);

      let dataUrl = canvas.toDataURL('image/png'),
          svg = `<image width="${canvas.width}" height="${canvas.height}" xlink:href="${dataUrl}"></image>`;
      internals.svg_3ds[renderer.workaround_id] = svg;
   } else {
      let dataUrl = renderer.domElement.toDataURL('image/png');
      select(renderer.jsroot_dom).attr('xlink:href', dataUrl);
   }
}

/** @summary Special way to insert WebGL drawing into produced SVG batch code
  * @desc Used only in batch mode for SVG images generation
  * @private */
internals.processSvgWorkarounds = function(svg, keep_workarounds) {
   if (!internals.svg_3ds) return svg;
   for (let k = 0;  k < internals.svg_3ds.length; ++k)
      svg = svg.replace(`<path jsroot_svg_workaround="${k}"></path>`, internals.svg_3ds[k]);
   if (!keep_workarounds)
      internals.svg_3ds = undefined;
   return svg;
};

// ========================================================================================================

/**
 * @summary Tooltip handler for 3D drawings
 *
 * @private
 */

class TooltipFor3D {

   /** @summary constructor
     * @param {object} dom - DOM element
     * @param {object} canvas - canvas for 3D rendering */
   constructor(prnt, canvas) {
      this.tt = null;
      this.cont = null;
      this.lastlbl = '';
      this.parent = prnt ? prnt : document.body;
      this.canvas = canvas; // we need canvas to recalculate mouse events
      this.abspos = !prnt;
   }

   /** @summary check parent */
   checkParent(prnt) {
      if (prnt && (this.parent !== prnt)) {
         this.hide();
         this.parent = prnt;
      }
   }

   /** @summary extract position from event
     * @desc can be used to process it later when event is gone */
   extract_pos(e) {
      if (isObject(e) && (e.u !== undefined) && (e.l !== undefined)) return e;
      let res = { u: 0, l: 0 };
      if (this.abspos) {
         res.l = e.pageX;
         res.u = e.pageY;
      } else {
         res.l = e.offsetX;
         res.u = e.offsetY;
      }

      return res;
   }

   /** @summary Method used to define position of next tooltip
     * @desc event is delivered from canvas,
     * but position should be calculated relative to the element where tooltip is placed */
   pos(e) {

      if (!this.tt) return;

      let pos = this.extract_pos(e);
      if (!this.abspos) {
         let rect1 = this.parent.getBoundingClientRect(),
             rect2 = this.canvas.getBoundingClientRect();

         if ((rect1.left !== undefined) && (rect2.left!== undefined)) pos.l += (rect2.left-rect1.left);

         if ((rect1.top !== undefined) && (rect2.top!== undefined)) pos.u += rect2.top-rect1.top;

         if (pos.l + this.tt.offsetWidth + 3 >= this.parent.offsetWidth)
            pos.l = this.parent.offsetWidth - this.tt.offsetWidth - 3;

         if (pos.u + this.tt.offsetHeight + 15 >= this.parent.offsetHeight)
            pos.u = this.parent.offsetHeight - this.tt.offsetHeight - 15;

         // one should find parent with non-static position,
         // all absolute coordinates calculated relative to such node
         let abs_parent = this.parent;
         while (abs_parent) {
            let style = getComputedStyle(abs_parent);
            if (!style || (style.position !== 'static')) break;
            if (!abs_parent.parentNode || (abs_parent.parentNode.nodeType != 1)) break;
            abs_parent = abs_parent.parentNode;
         }

         if (abs_parent && (abs_parent !== this.parent)) {
            let rect0 = abs_parent.getBoundingClientRect();
            pos.l += (rect1.left - rect0.left);
            pos.u += (rect1.top - rect0.top);
         }
      }

      this.tt.style.top = (pos.u + 15) + 'px';
      this.tt.style.left = (pos.l + 3) + 'px';
   }

   /** @summary Show tooltip */
   show(v /*, mouse_pos, status_func*/) {
      if (!v) return this.hide();

      if (isObject(v) && (v.lines || v.line)) {
         if (v.only_status) return this.hide();

         if (v.line) {
            v = v.line;
         } else {
            let res = v.lines[0];
            for (let n=1;n<v.lines.length;++n) res+= '<br/>' + v.lines[n];
            v = res;
         }
      }

      if (this.tt === null) {
         this.tt = document.createElement('div');
         this.tt.setAttribute('style', 'opacity: 1; filter: alpha(opacity=1); position: absolute; display: block; overflow: hidden; z-index: 101;');
         this.cont = document.createElement('div');
         this.cont.setAttribute('style', 'display: block; padding: 2px 12px 3px 7px; margin-left: 5px; font-size: 11px; background: #777; color: #fff;');
         this.tt.appendChild(this.cont);
         this.parent.appendChild(this.tt);
      }

      if (this.lastlbl !== v) {
         this.cont.innerHTML = v;
         this.lastlbl = v;
         this.tt.style.width = 'auto'; // let it be automatically resizing...
      }
   }

   /** @summary Hide tooltip */
   hide() {
      if (this.tt !== null)
         this.parent.removeChild(this.tt);

      this.tt = null;
      this.lastlbl = '';
   }

} // class TooltipFor3D

/** @summary Create OrbitControls for painter
  * @private */
function createOrbitControl(painter, camera, scene, renderer, lookat) {

   let control = null,
       enable_zoom = settings.Zooming && settings.ZoomMouse,
       enable_select = isFunc(painter.processMouseClick);

   function control_mousedown(evnt) {
      if (!control) return;

      // function used to hide some events from orbit control and redirect them to zooming rect
      if (control.mouse_zoom_mesh) {
         evnt.stopImmediatePropagation();
         evnt.stopPropagation();
         return;
      }

      // only left-button is considered
      if ((evnt.button!==undefined) && (evnt.button !== 0)) return;
      if ((evnt.buttons!==undefined) && (evnt.buttons !== 1)) return;

      if (control.enable_zoom) {
         control.mouse_zoom_mesh = control.detectZoomMesh(evnt);
         if (control.mouse_zoom_mesh) {
            // just block orbit control
            evnt.stopImmediatePropagation();
            evnt.stopPropagation();
            return;
         }
      }

      if (control.enable_select)
         control.mouse_select_pnt = control.getMousePos(evnt, {});
   }

   function control_mouseup(evnt) {
      if (!control) return;

      if (control.mouse_zoom_mesh && control.mouse_zoom_mesh.point2 && control.painter.get3dZoomCoord) {

         let kind = control.mouse_zoom_mesh.object.zoom,
             pos1 = control.painter.get3dZoomCoord(control.mouse_zoom_mesh.point, kind),
             pos2 = control.painter.get3dZoomCoord(control.mouse_zoom_mesh.point2, kind);

         if (pos1 > pos2) { let v = pos1; pos1 = pos2; pos2 = v; }

         if ((kind === 'z') && control.mouse_zoom_mesh.object.use_y_for_z) kind = 'y';

         // try to zoom
         if (pos1 < pos2)
           if (control.painter.zoom(kind, pos1, pos2))
              control.mouse_zoom_mesh = null;
      }

      // if selection was drawn, it should be removed and picture rendered again
      if (control.enable_zoom)
         control.removeZoomMesh();

      // only left-button is considered
      //if ((evnt.button!==undefined) && (evnt.button !== 0)) return;
      //if ((evnt.buttons!==undefined) && (evnt.buttons !== 1)) return;

      if (control.enable_select && control.mouse_select_pnt) {

         let pnt = control.getMousePos(evnt, {}),
             same_pnt = (pnt.x == control.mouse_select_pnt.x) && (pnt.y == control.mouse_select_pnt.y);
         delete control.mouse_select_pnt;

         if (same_pnt) {
            let intersects = control.getMouseIntersects(pnt);
            control.painter.processMouseClick(pnt, intersects, evnt);
         }
      }
   }

   function render3DFired(painter) {
      if (!painter || painter.renderer === undefined) return false;
      return painter.render_tmout !== undefined; // when timeout configured, object is prepared for rendering
   }

   function control_mousewheel(evnt) {
      if (!control) return;

      // try to handle zoom extra

      if (render3DFired(control.painter) || control.mouse_zoom_mesh) {
         evnt.preventDefault();
         evnt.stopPropagation();
         evnt.stopImmediatePropagation();
         return; // already fired redraw, do not react on the mouse wheel
      }

      let intersect = control.detectZoomMesh(evnt);
      if (!intersect) return;

      evnt.preventDefault();
      evnt.stopPropagation();
      evnt.stopImmediatePropagation();

      if (isFunc(control.painter?.analyzeMouseWheelEvent)) {
         let kind = intersect.object.zoom,
             position = intersect.point[kind],
             item = { name: kind, ignore: false };

         // z changes from 0..2*size_z3d, others -size_x3d..+size_x3d
         switch (kind) {
            case 'x': position = (position + control.painter.size_x3d)/2/control.painter.size_x3d; break;
            case 'y': position = (position + control.painter.size_y3d)/2/control.painter.size_y3d; break;
            case 'z': position = position/2/control.painter.size_z3d; break;
         }

         control.painter.analyzeMouseWheelEvent(evnt, item, position, false);

         if ((kind === 'z') && intersect.object.use_y_for_z) kind = 'y';

         control.painter.zoom(kind, item.min, item.max);
      }
   }

   // assign own handler before creating OrbitControl

   if (settings.Zooming && settings.ZoomWheel)
      renderer.domElement.addEventListener('wheel', control_mousewheel);

   if (enable_zoom || enable_select) {
      renderer.domElement.addEventListener('pointerdown', control_mousedown);
      renderer.domElement.addEventListener('pointerup', control_mouseup);
   }

   control = new OrbitControls(camera, renderer.domElement);

   control.enableDamping = false;
   control.dampingFactor = 1.0;
   control.enableZoom = true;
   control.enableKeys = settings.HandleKeys;

   if (lookat) {
      control.target.copy(lookat);
      control.target0.copy(lookat);
      control.update();
   }

   control.tooltip = new TooltipFor3D(painter.selectDom().node(), renderer.domElement);

   control.painter = painter;
   control.camera = camera;
   control.scene = scene;
   control.renderer = renderer;
   control.raycaster = new Raycaster();
   control.raycaster.params.Line.threshold = 10;
   control.raycaster.params.Points.threshold = 5;
   control.mouse_zoom_mesh = null; // zoom mesh, currently used in the zooming
   control.block_ctxt = false; // require to block context menu command appearing after control ends, required in chrome which inject contextmenu when key released
   control.block_mousemove = false; // when true, tooltip or cursor will not react on mouse move
   control.cursor_changed = false;
   control.control_changed = false;
   control.control_active = false;
   control.mouse_ctxt = { x:0, y: 0, on: false };
   control.enable_zoom = enable_zoom;
   control.enable_select = enable_select;

   control.cleanup = function() {
      if (settings.Zooming && settings.ZoomWheel)
         this.domElement.removeEventListener('wheel', control_mousewheel);
      if (this.enable_zoom || this.enable_select) {
         this.domElement.removeEventListener('pointerdown', control_mousedown);
         this.domElement.removeEventListener('pointerup', control_mouseup);
      }

      this.domElement.removeEventListener('click', this.lstn_click);
      this.domElement.removeEventListener('dblclick', this.lstn_dblclick);
      this.domElement.removeEventListener('contextmenu', this.lstn_contextmenu);
      this.domElement.removeEventListener('mousemove', this.lstn_mousemove);
      this.domElement.removeEventListener('mouseleave', this.lstn_mouseleave);

      this.dispose(); // this is from OrbitControl itself

      this.tooltip.hide();
      delete this.tooltip;
      delete this.painter;
      delete this.camera;
      delete this.scene;
      delete this.renderer;
      delete this.raycaster;
      delete this.mouse_zoom_mesh;
   };

   control.HideTooltip = function() {
      this.tooltip.hide();
   };

   control.getMousePos = function(evnt, mouse) {
      mouse.x = ('offsetX' in evnt) ? evnt.offsetX : evnt.layerX;
      mouse.y = ('offsetY' in evnt) ? evnt.offsetY : evnt.layerY;
      mouse.clientX = evnt.clientX;
      mouse.clientY = evnt.clientY;
      return mouse;
   };

   control.getOriginDirectionIntersects = function(origin, direction) {
      this.raycaster.set(origin, direction);
      let intersects = this.raycaster.intersectObjects(this.scene.children, true);
      // painter may want to filter intersects
      if (isFunc(this.painter.filterIntersects))
         intersects = this.painter.filterIntersects(intersects);
      return intersects;
   };

   control.getMouseIntersects = function(mouse) {
      // domElement gives correct coordinate with canvas render, but isn't always right for webgl renderer
      if (!this.renderer) return [];

      let sz = (this.renderer instanceof WebGLRenderer) ? this.renderer.getSize(new Vector2()) : this.renderer.domElement,
          pnt = { x: mouse.x / sz.width * 2 - 1, y: -mouse.y / sz.height * 2 + 1 };

      this.camera.updateMatrix();
      this.camera.updateMatrixWorld();
      this.raycaster.setFromCamera( pnt, this.camera );
      let intersects = this.raycaster.intersectObjects(this.scene.children, true);

      // painter may want to filter intersects
      if (isFunc(this.painter.filterIntersects))
         intersects = this.painter.filterIntersects(intersects);

      return intersects;
   };

   control.detectZoomMesh = function(evnt) {
      let mouse = this.getMousePos(evnt, {}),
          intersects = this.getMouseIntersects(mouse);
      if (intersects)
         for (let n = 0; n < intersects.length; ++n)
            if (intersects[n].object.zoom)
               return intersects[n];

      return null;
   };

   control.getInfoAtMousePosition = function(mouse_pos) {
      let intersects = this.getMouseIntersects(mouse_pos),
          tip = null, painter = null;

      for (let i = 0; i < intersects.length; ++i)
         if (intersects[i].object.tooltip) {
            tip = intersects[i].object.tooltip(intersects[i]);
            painter = intersects[i].object.painter;
            break;
      }

      if (tip && painter)
         return { obj: painter.getObject(),  name: painter.getObject().fName,
                  bin: tip.bin, cont: tip.value,
                  binx: tip.ix, biny: tip.iy, binz: tip.iz,
                  grx: (tip.x1+tip.x2)/2, gry: (tip.y1+tip.y2)/2, grz: (tip.z1+tip.z2)/2 };
   };

   control.processDblClick = function(evnt) {
      // first check if zoom mesh clicked
      let zoom_intersect = this.detectZoomMesh(evnt);
      if (zoom_intersect && this.painter) {
         this.painter.unzoom(zoom_intersect.object.use_y_for_z ? 'y' : zoom_intersect.object.zoom);
         return;
      }

      // then check if double-click handler assigned
      let fp = this.painter ? this.painter.getFramePainter() : null;
      if (isFunc(fp?._dblclick_handler)) {
         let info = this.getInfoAtMousePosition(this.getMousePos(evnt, {}));
         if (info) {
            fp._dblclick_handler(info);
            return;
         }
       }

       this.reset();
   };

   control.changeEvent = function() {
      this.mouse_ctxt.on = false; // disable context menu if any changes where done by orbit control
      this.painter.render3D(0);
      this.control_changed = true;
   };

   control.startEvent = function() {
      this.control_active = true;
      this.block_ctxt = false;
      this.mouse_ctxt.on = false;

      this.tooltip.hide();

      // do not reset here, problem of events sequence in orbitcontrol
      // it issue change/start/stop event when do zooming
      // control.control_changed = false;
   };

   control.endEvent = function() {
      this.control_active = false;
      if (this.mouse_ctxt.on) {
         this.mouse_ctxt.on = false;
         this.contextMenu(this.mouse_ctxt, this.getMouseIntersects(this.mouse_ctxt));
      } /* else if (this.control_changed) {
         // react on camera change when required
      } */
      this.control_changed = false;
   };

   control.mainProcessContextMenu = function(evnt) {
      evnt.preventDefault();
      this.getMousePos(evnt, this.mouse_ctxt);
      if (this.control_active)
         this.mouse_ctxt.on = true;
      else if (this.block_ctxt)
         this.block_ctxt = false;
      else
         this.contextMenu(this.mouse_ctxt, this.getMouseIntersects(this.mouse_ctxt));
   };

   control.contextMenu = function(/* pos, intersects */) {
      // do nothing, function called when context menu want to be activated
   };

   control.setTooltipEnabled = function(on) {
      this.block_mousemove = !on;
      if (on === false) {
         this.tooltip.hide();
         this.removeZoomMesh();
      }
   };

   control.removeZoomMesh = function() {
      if (this.mouse_zoom_mesh && this.mouse_zoom_mesh.object.showSelection())
         this.painter.render3D();
      this.mouse_zoom_mesh = null; // in any case clear mesh, enable orbit control again
   };

   control.mainProcessMouseMove = function(evnt) {
      if (!this.painter) return; // protect when cleanup

      if (this.control_active && evnt.buttons && (evnt.buttons & 2))
         this.block_ctxt = true; // if right button in control was active, block next context menu

      if (this.control_active || this.block_mousemove || !this.processMouseMove) return;

      if (this.mouse_zoom_mesh) {
         // when working with zoom mesh, need special handling

         let zoom2 = this.detectZoomMesh(evnt),
             pnt2 = (zoom2?.object === this.mouse_zoom_mesh.object) ? zoom2.point : this.mouse_zoom_mesh.object.globalIntersect(this.raycaster);

         if (pnt2) this.mouse_zoom_mesh.point2 = pnt2;

         if (pnt2 && this.painter.enable_highlight)
            if (this.mouse_zoom_mesh.object.showSelection(this.mouse_zoom_mesh.point, pnt2))
               this.painter.render3D(0);

         this.tooltip.hide();
         return;
      }

      evnt.preventDefault();

      // extract mouse position
      this.tmout_mouse = this.getMousePos(evnt, {});
      this.tmout_ttpos =  this.tooltip ? this.tooltip.extract_pos(evnt) : null;

      if (this.tmout_handle) {
         clearTimeout(this.tmout_handle);
         delete this.tmout_handle;
      }

      if (!this.mouse_tmout)
         this.delayedProcessMouseMove();
      else
         this.tmout_handle = setTimeout(() => this.delayedProcessMouseMove(), this.mouse_tmout);
   };

   control.delayedProcessMouseMove = function() {
      // remove handle - allow to trigger new timeout
      delete this.tmout_handle;
      if (!this.painter) return; // protect when cleanup

      let mouse = this.tmout_mouse,
          intersects = this.getMouseIntersects(mouse),
          tip = this.processMouseMove(intersects);

      if (tip) {
         let name = '', title = '', coord = '', info = '';
         if (mouse) coord = mouse.x.toFixed(0) + ',' + mouse.y.toFixed(0);
         if (isStr(tip)) {
            info = tip;
         } else {
            name = tip.name; title = tip.title;
            if (tip.line) info = tip.line; else
            if (tip.lines) { info = tip.lines.slice(1).join(' '); name = tip.lines[0]; }
         }
         this.painter.showObjectStatus(name, title, info, coord);
      }

      this.cursor_changed = false;
      if (tip && this.painter?.isTooltipAllowed()) {
         this.tooltip.checkParent(this.painter.selectDom().node());

         this.tooltip.show(tip, mouse);
         this.tooltip.pos(this.tmout_ttpos);
      } else {
         this.tooltip.hide();
         if (intersects)
            for (let n = 0; n < intersects.length; ++n)
               if (intersects[n].object.zoom) this.cursor_changed = true;
      }

      document.body.style.cursor = this.cursor_changed ? 'pointer' : 'auto';
   };

   control.mainProcessMouseLeave = function() {
      if (!this.painter) return; // protect when cleanup

      // do not enter main event at all
      if (this.tmout_handle) {
         clearTimeout(this.tmout_handle);
         delete this.tmout_handle;
      }
      this.tooltip.hide();
      if (isFunc(this.processMouseLeave))
         this.processMouseLeave();
      if (this.cursor_changed) {
         document.body.style.cursor = 'auto';
         this.cursor_changed = false;
      }
   };

   control.mainProcessDblClick = function(evnt) {
      // suppress simple click handler if double click detected
      if (this.single_click_tm) {
         clearTimeout(this.single_click_tm);
         delete this.single_click_tm;
      }
      this.processDblClick(evnt);
   };

   control.processClick = function(mouse_pos, kind) {
      delete this.single_click_tm;

      if (kind == 1) {
         let fp = this.painter ? this.painter.getFramePainter() : null;
         if (isFunc(fp?._click_handler)) {
            let info = this.getInfoAtMousePosition(mouse_pos);
            if (info) {
               fp._click_handler(info);
               return;
            }
         }
      }

      // method assigned in the Eve7 and used for object selection
      if ((kind == 2) && isFunc(this.processSingleClick)) {
         let intersects = this.getMouseIntersects(mouse_pos);
         this.processSingleClick(intersects);
      }
   };

   control.lstn_click = function(evnt) {
      // ignore right-mouse click
      if (evnt.detail == 2) return;

      if (this.single_click_tm) {
         clearTimeout(this.single_click_tm);
         delete this.single_click_tm;
      }

      let kind = 0, fp = this.painter?.getFramePainter();
      if (isFunc(fp?._click_handler))
         kind = 1; // user click handler
      else if (this.processSingleClick && this.painter?.options?.mouse_click)
         kind = 2;  // eve7 click handler

      // if normal event, set longer timeout waiting if double click not detected
      if (kind)
         this.single_click_tm = setTimeout(this.processClick.bind(this, this.getMousePos(evnt, {}), kind), 300);
   }.bind(control);

   control.addEventListener('change', () => control.changeEvent());
   control.addEventListener('start', () => control.startEvent());
   control.addEventListener('end', () => control.endEvent());

   control.lstn_contextmenu = evnt => control.mainProcessContextMenu(evnt);
   control.lstn_dblclick = evnt => control.mainProcessDblClick(evnt);
   control.lstn_mousemove = evnt => control.mainProcessMouseMove(evnt);
   control.lstn_mouseleave = () => control.mainProcessMouseLeave();

   renderer.domElement.addEventListener('click', control.lstn_click);
   renderer.domElement.addEventListener('dblclick', control.lstn_dblclick);
   renderer.domElement.addEventListener('contextmenu', control.lstn_contextmenu);
   renderer.domElement.addEventListener('mousemove', control.lstn_mousemove);
   renderer.domElement.addEventListener('mouseleave', control.lstn_mouseleave);

   return control;
}

/** @summary Method cleanup three.js object as much as possible.
  * @desc Simplify JS engine to remove it from memory
  * @private */
function disposeThreejsObject(obj, only_childs) {
   if (!obj) return;

   if (obj.children) {
      for (let i = 0; i < obj.children.length; i++)
         disposeThreejsObject(obj.children[i]);
   }

   if (only_childs) {
      obj.children = [];
      return;
   }

   obj.children = undefined;

   if (obj.geometry) {
      obj.geometry.dispose();
      obj.geometry = undefined;
   }
   if (obj.material) {
      if (obj.material.map) {
         obj.material.map.dispose();
         obj.material.map = undefined;
      }
      obj.material.dispose();
      obj.material = undefined;
   }

   // cleanup jsroot fields to simplify browser cleanup job
   delete obj.painter;
   delete obj.bins_index;
   delete obj.tooltip;
   delete obj.stack; // used in geom painter
   delete obj.drawn_highlight; // special highlight object

   obj = undefined;
}


/** @summary Create LineSegments mesh (or only geometry)
  * @desc If required, calculates lineDistance attribute for dashed geometries
  * @private */
function createLineSegments(arr, material, index = undefined, only_geometry = false) {

   let geom = new BufferGeometry();

   geom.setAttribute('position', arr instanceof Float32Array ? new BufferAttribute(arr, 3) : new Float32BufferAttribute(arr, 3));
   if (index) geom.setIndex(new BufferAttribute(index, 1));

   if (material.isLineDashedMaterial) {

      let v1 = new Vector3(),
          v2 = new Vector3(),
          d = 0, distances = null;

      if (index) {
         distances = new Float32Array(index.length);
         for (let n = 0; n < index.length; n += 2) {
            let i1 = index[n], i2 = index[n+1];
            v1.set(arr[i1],arr[i1+1],arr[i1+2]);
            v2.set(arr[i2],arr[i2+1],arr[i2+2]);
            distances[n] = d;
            d += v2.distanceTo(v1);
            distances[n+1] = d;
         }
      } else {
         distances = new Float32Array(arr.length/3);
         for (let n = 0; n < arr.length; n += 6) {
            v1.set(arr[n],arr[n+1],arr[n+2]);
            v2.set(arr[n+3],arr[n+4],arr[n+5]);
            distances[n/3] = d;
            d += v2.distanceTo(v1);
            distances[n/3+1] = d;
         }
      }
      geom.setAttribute('lineDistance', new BufferAttribute(distances, 1));
   }

   return only_geometry ? geom : new LineSegments(geom, material);
}

/** @summary Help structures for calculating Box mesh
  * @private */
const Box3D = {
    Vertices: [ new Vector3(1, 1, 1), new Vector3(1, 1, 0),
                new Vector3(1, 0, 1), new Vector3(1, 0, 0),
                new Vector3(0, 1, 0), new Vector3(0, 1, 1),
                new Vector3(0, 0, 0), new Vector3(0, 0, 1) ],
    Indexes: [ 0,2,1, 2,3,1, 4,6,5, 6,7,5, 4,5,1, 5,0,1, 7,6,2, 6,3,2, 5,7,0, 7,2,0, 1,3,4, 3,6,4 ],
    Normals: [ 1,0,0, -1,0,0, 0,1,0, 0,-1,0, 0,0,1, 0,0,-1 ],
    Segments: [0, 2, 2, 7, 7, 5, 5, 0, 1, 3, 3, 6, 6, 4, 4, 1, 1, 0, 3, 2, 6, 7, 4, 5]  // segments addresses Vertices
};

// these segments address vertices from the mesh, we can use positions from box mesh
Box3D.MeshSegments = (function() {
   let box3d = Box3D,
       arr = new Int32Array(box3d.Segments.length);

   for (let n = 0; n < arr.length; ++n) {
      for (let k = 0; k < box3d.Indexes.length; ++k)
         if (box3d.Segments[n] === box3d.Indexes[k]) {
            arr[n] = k; break;
         }
   }
   return arr;
})();


/**
 * @summary Abstract interactive control interface for 3D objects
 *
 * @abstract
 * @private
 */

class InteractiveControl {
   cleanup() {}
   extractIndex(/*intersect*/) {}
   setSelected(/*col, indx*/) {}
   setHighlight(/*col, indx*/) {}
   checkHighlightIndex(/*indx*/) {}
} // class InteractiveControl


/**
 * @summary Class for creation of 3D points
 *
 * @private
 */

class PointsCreator {

   /** @summary constructor
     * @param {number} size - number of points
     * @param {boolean} [iswebgl=true] - if WebGL is used
     * @param {number} [scale=1] - scale factor */
   constructor(size, iswebgl, scale) {
      this.webgl = (iswebgl === undefined) ? true : iswebgl;
      this.scale = scale || 1.;

      this.pos = new Float32Array(size*3);
      this.geom = new BufferGeometry();
      this.geom.setAttribute('position', new BufferAttribute(this.pos, 3));
      this.indx = 0;
   }

   /** @summary Add point */
   addPoint(x,y,z) {
      this.pos[this.indx]   = x;
      this.pos[this.indx+1] = y;
      this.pos[this.indx+2] = z;
      this.indx += 3;
   }

   /** @summary Create points */
   createPoints(args) {

      if (!isObject(args))
         args = { color: args };
      if (!args.color)
         args.color = 'black';

      let k = 1;

      // special dots
      if (!args.style) k = 1.1; else
      if (args.style === 1) k = 0.3; else
      if (args.style === 6) k = 0.5; else
      if (args.style === 7) k = 0.7;

      let makePoints = texture => {
         let material_args = { size: 3*this.scale*k };
         if (texture) {
            material_args.map = texture;
            material_args.transparent = true;
         } else {
            material_args.color = args.color || 'black';
         }

         let pnts = new Points(this.geom, new PointsMaterial(material_args));
         pnts.nvertex = 1;
         return pnts;
      };

      // this is plain creation of points, no need for texture loading

      if (k !== 1) {
         let res = makePoints();
         return this.noPromise ? res : Promise.resolve(res);
      }

      let handler = new TAttMarkerHandler({ style: args.style, color: args.color, size: 7 }),
          w = handler.fill ? 1 : 7,
          imgdata = `<svg width="64" height="64" xmlns="http://www.w3.org/2000/svg">` +
                    `<path d="${handler.create(32,32)}" style="stroke: ${handler.getStrokeColor()}; stroke-width: ${w}; fill: ${handler.getFillColor()}"></path>`+
                    `</svg>`,
          dataUrl = 'data:image/svg+xml;charset=utf8,' + (isNodeJs() ? imgdata : encodeURIComponent(imgdata)),
          promise;

      if (isNodeJs()) {
         promise = Promise.resolve().then(function () { return _rollup_plugin_ignore_empty_module_placeholder$1; }).then(handle => handle.default.loadImage(dataUrl).then(img => {
               const canvas = handle.default.createCanvas(64, 64),
                     ctx = canvas.getContext('2d');
               ctx.drawImage(img, 0, 0, 64, 64);
               return new CanvasTexture(canvas);
            }));
      } else if (this.noPromise) {
         // only for v6 support
         return makePoints(new TextureLoader().load(dataUrl));
      } else {
         promise = new Promise((resolveFunc, rejectFunc) => {
            let loader = new TextureLoader();
            loader.load(dataUrl, res => resolveFunc(res), undefined, () => rejectFunc());
         });
      }

      return promise.then(makePoints);
   }

} // class PointsCreator


/** @summary Create material for 3D line
  * @desc Takes into account dashed properties
  * @private */
function create3DLineMaterial(painter, arg, is_v7 = false) {
   if (!painter || !arg) return null;

   let lcolor, lstyle, lwidth;
   if (isStr(arg) || is_v7) {
      lcolor = painter.v7EvalColor(arg+'color', 'black');
      lstyle = parseInt(painter.v7EvalAttr(arg+'style', 0));
      lwidth = parseInt(painter.v7EvalAttr(arg+'width', 1));
   } else {
      lcolor = painter.getColor(arg.fLineColor);
      lstyle = arg.fLineStyle;
      lwidth = arg.fLineWidth;
   }

   let style = lstyle ? getSvgLineStyle(lstyle) : '',
       dash = style ? style.split(',') : [], material;

   if (dash && dash.length >= 2)
      material = new LineDashedMaterial({ color: lcolor, dashSize: parseInt(dash[0]), gapSize: parseInt(dash[1]) });
   else
      material = new LineBasicMaterial({ color: lcolor });

   if (lwidth && (lwidth > 1)) material.linewidth = lwidth;

   return material;
}

/** @summary Text 3d axis visibility
  * @private */
function testAxisVisibility(camera, toplevel, fb, bb) {
   let top;
   if (toplevel && toplevel.children)
      for (let n = 0; n < toplevel.children.length; ++n) {
         top = toplevel.children[n];
         if (top.axis_draw) break;
         top = undefined;
      }

   if (!top) return;

   if (!camera) {
      // this is case when axis drawing want to be removed
      toplevel.remove(top);
      return;
   }

   fb = fb ? true : false;
   bb = bb ? true : false;

   let qudrant = 1, pos = camera.position;
   if ((pos.x < 0) && (pos.y >= 0)) qudrant = 2;
   if ((pos.x >= 0) && (pos.y >= 0)) qudrant = 3;
   if ((pos.x >= 0) && (pos.y < 0)) qudrant = 4;

   let testvisible = (id, range) => {
      if (id <= qudrant) id+=4;
      return (id > qudrant) && (id < qudrant+range);
   };

   for (let n = 0; n < top.children.length; ++n) {
      let chld = top.children[n];
      if (chld.grid) chld.visible = bb && testvisible(chld.grid, 3); else
      if (chld.zid) chld.visible = testvisible(chld.zid, 2); else
      if (chld.xyid) chld.visible = testvisible(chld.xyid, 3); else
      if (chld.xyboxid) {
         let range = 5, shift = 0;
         if (bb && !fb) { range = 3; shift = -2; } else
         if (fb && !bb) range = 3; else
         if (!fb && !bb) range = (chld.bottom ? 3 : 0);
         chld.visible = testvisible(chld.xyboxid + shift, range);
         if (!chld.visible && chld.bottom && bb)
            chld.visible = testvisible(chld.xyboxid, 3);
      } else if (chld.zboxid) {
         let range = 2, shift = 0;
         if (fb && bb) range = 5; else
         if (bb && !fb) range = 4; else
         if (!bb && fb) { shift = -2; range = 4; }
         chld.visible = testvisible(chld.zboxid + shift, range);
      }
   }
}

/** @summary Set default camera position
  * @private */
function setCameraPosition(fp, first_time) {
   let pad = fp.getPadPainter().getRootPad(true),
       max3dx = Math.max(0.75*fp.size_x3d, fp.size_z3d),
       max3dy = Math.max(0.75*fp.size_y3d, fp.size_z3d);

   if (first_time) {
      if (max3dx === max3dy)
         fp.camera.position.set(-1.6*max3dx, -3.5*max3dy, 1.4*fp.size_z3d);
      else if (max3dx > max3dy)
         fp.camera.position.set(-2*max3dx, -3.5*max3dy, 1.4*fp.size_z3d);
      else
         fp.camera.position.set(-3.5*max3dx, -2*max3dy, 1.4*fp.size_z3d);
   }

   if (pad && (first_time || !fp.zoomChangedInteractive()))
      if (Number.isFinite(pad.fTheta) && Number.isFinite(pad.fPhi) && ((pad.fTheta !== fp.camera_Theta) || (pad.fPhi !== fp.camera_Phi))) {
         fp.camera_Phi = pad.fPhi;
         fp.camera_Theta = pad.fTheta;
         max3dx = 3*Math.max(fp.size_x3d, fp.size_z3d);
         max3dy = 3*Math.max(fp.size_y3d, fp.size_z3d);
         let phi = (270-pad.fPhi)/180*Math.PI, theta = (pad.fTheta-10)/180*Math.PI;
         fp.camera.position.set(max3dx*Math.cos(phi)*Math.cos(theta),
                                max3dy*Math.sin(phi)*Math.cos(theta),
                                fp.size_z3d + (max3dx+max3dy)*0.5*Math.sin(theta));
         first_time = true;
      }

   if (first_time)
      fp.camera.lookAt(fp.lookat);
}

/** @summary Create all necessary components for 3D drawings in frame painter
  * @return {Promise} when render3d !== -1
  * @private */
function create3DScene(render3d, x3dscale, y3dscale) {

   if (render3d === -1) {

      if (!this.mode3d) return;

      if (!this.clear3dCanvas) {
         console.error(`Strange, why mode3d=${this.mode3d} is configured!!!!`);
         return;
      }

      testAxisVisibility(null, this.toplevel);

      this.clear3dCanvas();

      disposeThreejsObject(this.scene);
      if (this.control) this.control.cleanup();

      cleanupRender3D(this.renderer);

      delete this.size_x3d;
      delete this.size_y3d;
      delete this.size_z3d;
      delete this.tooltip_mesh;
      delete this.scene;
      delete this.toplevel;
      delete this.camera;
      delete this.pointLight;
      delete this.renderer;
      delete this.control;
      if (this.render_tmout) {
         clearTimeout(this.render_tmout);
         delete this.render_tmout;
      }

      this.mode3d = false;

      return;
   }

   this.mode3d = true; // indicate 3d mode as hist painter does

   if ('toplevel' in this) {
      // it is indication that all 3D object created, just replace it with empty
      this.scene.remove(this.toplevel);
      disposeThreejsObject(this.toplevel);
      delete this.tooltip_mesh;
      delete this.toplevel;
      if (this.control) this.control.HideTooltip();

      let newtop = new Object3D();
      this.scene.add(newtop);
      this.toplevel = newtop;

      this.resize3D(); // set actual sizes

      setCameraPosition(this, false);

      return Promise.resolve(true);
   }

   render3d = getRender3DKind(render3d);

   assign3DHandler(this);

   let sz = this.getSizeFor3d(undefined, render3d);

   this.size_z3d = 100;
   this.size_x3d = this.size_y3d = (sz.height > 10) && (sz.width > 10) ? Math.round(sz.width/sz.height*this.size_z3d) : this.size_z3d;
   if (x3dscale) this.size_x3d *= x3dscale;
   if (y3dscale) this.size_y3d *= y3dscale;

   // three.js 3D drawing
   this.scene = new Scene();
   //scene.fog = new Fog(0xffffff, 500, 3000);

   this.toplevel = new Object3D();
   this.scene.add(this.toplevel);
   this.scene_width = sz.width;
   this.scene_height = sz.height;

   this.camera = new PerspectiveCamera(45, this.scene_width / this.scene_height, 1, 40*this.size_z3d);

   this.camera_Phi = 30;
   this.camera_Theta = 30;

   this.pointLight = new PointLight(0xffffff,1);
   this.camera.add(this.pointLight);
   this.pointLight.position.set(this.size_x3d/2, this.size_y3d/2, this.size_z3d/2);
   this.lookat = new Vector3(0,0,0.8*this.size_z3d);
   this.camera.up = new Vector3(0,0,1);
   this.scene.add( this.camera );

   setCameraPosition(this, true);

   return createRender3D(this.scene_width, this.scene_height, render3d).then(r => {

      this.renderer = r;

      this.webgl = (render3d === constants$1.Render3D.WebGL);
      this.add3dCanvas(sz, this.renderer.jsroot_dom, this.webgl);

      this.first_render_tm = 0;
      this.enable_highlight = false;

      if (isBatchMode() || !this.webgl)
         return this;

      this.control = createOrbitControl(this, this.camera, this.scene, this.renderer, this.lookat);

      let frame_painter = this, obj_painter = this.getMainPainter();

      this.control.processMouseMove = function(intersects) {

         let tip = null, mesh = null, zoom_mesh = null;

         for (let i = 0; i < intersects.length; ++i) {
            if (intersects[i].object.tooltip) {
               tip = intersects[i].object.tooltip(intersects[i]);
               if (tip) { mesh = intersects[i].object; break; }
            } else if (intersects[i].object.zoom && !zoom_mesh) {
               zoom_mesh = intersects[i].object;
            }
         }

         if (tip && !tip.use_itself) {
            let delta_x = 1e-4*frame_painter.size_x3d,
                delta_y = 1e-4*frame_painter.size_y3d,
                delta_z = 1e-4*frame_painter.size_z3d;
            if ((tip.x1 > tip.x2) || (tip.y1 > tip.y2) || (tip.z1 > tip.z2)) console.warn('check 3D hints coordinates');
            tip.x1 -= delta_x; tip.x2 += delta_x;
            tip.y1 -= delta_y; tip.y2 += delta_y;
            tip.z1 -= delta_z; tip.z2 += delta_z;
         }

         frame_painter.highlightBin3D(tip, mesh);

         if (!tip && zoom_mesh && frame_painter.get3dZoomCoord) {
            let pnt = zoom_mesh.globalIntersect(this.raycaster),
                axis_name = zoom_mesh.zoom,
                axis_value = frame_painter.get3dZoomCoord(pnt, axis_name);

            if ((axis_name === 'z') && zoom_mesh.use_y_for_z) axis_name = 'y';

            return { name: axis_name,
                     title: 'axis object',
                     line: axis_name + ' : ' + frame_painter.axisAsText(axis_name, axis_value),
                     only_status: true };
         }

         return tip?.lines ? tip : '';
      };

      this.control.processMouseLeave = function() {
         frame_painter.highlightBin3D(null);
      };

      this.control.contextMenu = function(pos, intersects) {
         let kind = 'painter', p = obj_painter;
         if (intersects)
            for (let n = 0; n < intersects.length; ++n) {
               let mesh = intersects[n].object;
               if (mesh.zoom) { kind = mesh.zoom; p = null; break; }
               if (isFunc(mesh.painter?.fillContextMenu)) {
                  p = mesh.painter; break;
               }
            }

         let fp = obj_painter.getFramePainter();
         if (isFunc(fp?.showContextMenu))
            fp.showContextMenu(kind, pos, p);
      };

      return this;
   });
}

/** @summary call 3D rendering of the frame
  * @param {number} tmout - specifies delay, after which actual rendering will be invoked
  * @desc Timeout used to avoid multiple rendering of the picture when several 3D drawings
  * superimposed with each other.
  * If tmeout <= 0, rendering performed immediately
  * If tmout == -1111, immediate rendering with SVG renderer is performed
  * @private */
function render3D(tmout) {

   if (tmout === -1111) {
      // special handling for direct SVG renderer
      let doc = getDocument(),
          rrr = createSVGRenderer(false, 0, doc);
      rrr.setSize(this.scene_width, this.scene_height);
      rrr.render(this.scene, this.camera);
      if (rrr.makeOuterHTML) {
         // use text mode, it is faster
         let d = doc.createElement('div');
         d.innerHTML = rrr.makeOuterHTML();
         return d.childNodes[0];
      }
      return rrr.domElement;
   }

   if (tmout === undefined) tmout = 5; // by default, rendering happens with timeout

   if ((tmout > 0) && !this.usesvg && !isBatchMode()) {
      if (!this.render_tmout)
         this.render_tmout = setTimeout(() => this.render3D(0), tmout);
      return;
   }

   if (this.render_tmout) {
      clearTimeout(this.render_tmout);
      delete this.render_tmout;
   }

   if (!this.renderer) return;

   beforeRender3D(this.renderer);

   let tm1 = new Date();

   if (!this.opt3d) this.opt3d = { FrontBox: true, BackBox: true };

   testAxisVisibility(this.camera, this.toplevel, this.opt3d.FrontBox, this.opt3d.BackBox);

   // do rendering, most consuming time
   this.renderer.render(this.scene, this.camera);

   afterRender3D(this.renderer);

   let tm2 = new Date();

   if (this.first_render_tm === 0) {
      this.first_render_tm = tm2.getTime() - tm1.getTime();
      this.enable_highlight = (this.first_render_tm < 1200) && this.isTooltipAllowed();
      console.log(`three.js r${REVISION}, first render tm = ${this.first_render_tm}`);
   }
}

/** @summary Check is 3D drawing need to be resized
  * @private */
function resize3D() {

   let sz = this.getSizeFor3d(this.access3dKind());

   this.apply3dSize(sz);

   if ((this.scene_width === sz.width) && (this.scene_height === sz.height)) return false;

   if ((sz.width < 10) || (sz.height < 10)) return false;

   this.scene_width = sz.width;
   this.scene_height = sz.height;

   this.camera.aspect = this.scene_width / this.scene_height;
   this.camera.updateProjectionMatrix();

   this.renderer.setSize( this.scene_width, this.scene_height );
   if (this.renderer.setJSROOTSize)
      this.renderer.setJSROOTSize(this.scene_width, this.scene_height);

   return true;
}

/** @summary Hilight bin in frame painter 3D drawing
  * @private */
function highlightBin3D(tip, selfmesh) {

   let changed = false, tooltip_mesh = null, changed_self = true,
       want_remove = !tip || (tip.x1 === undefined) || !this.enable_highlight,
       mainp = this.getMainPainter();

   if (mainp && (!mainp.provideUserTooltip || !mainp.hasUserTooltip())) mainp = null;

   if (this.tooltip_selfmesh) {
      changed_self = (this.tooltip_selfmesh !== selfmesh);
      this.tooltip_selfmesh.material.color = this.tooltip_selfmesh.save_color;
      delete this.tooltip_selfmesh;
      changed = true;
   }

   if (this.tooltip_mesh) {
      tooltip_mesh = this.tooltip_mesh;
      this.toplevel.remove(this.tooltip_mesh);
      delete this.tooltip_mesh;
      changed = true;
   }

   if (want_remove) {
      if (changed) this.render3D();
      if (changed && mainp) mainp.provideUserTooltip(null);
      return;
   }

   if (tip.use_itself) {
      selfmesh.save_color = selfmesh.material.color;
      selfmesh.material.color = new Color$1(tip.color);
      this.tooltip_selfmesh = selfmesh;
      changed = changed_self;
   } else {
      changed = true;

      const indicies = Box3D.Indexes,
            normals = Box3D.Normals,
            vertices = Box3D.Vertices,
            color = new Color$1(tip.color ? tip.color : 0xFF0000),
            opacity = tip.opacity || 1;

      let pos, norm;

      if (!tooltip_mesh) {
         pos = new Float32Array(indicies.length*3);
         norm = new Float32Array(indicies.length*3);
         const geom = new BufferGeometry();
         geom.setAttribute('position', new BufferAttribute(pos, 3));
         geom.setAttribute('normal', new BufferAttribute(norm, 3));
         const material = new MeshBasicMaterial({ color: color, opacity: opacity, vertexColors: false });
         tooltip_mesh = new Mesh(geom, material);
      } else {
         pos = tooltip_mesh.geometry.attributes.position.array;
         tooltip_mesh.geometry.attributes.position.needsUpdate = true;
         tooltip_mesh.material.color = color;
         tooltip_mesh.material.opacity = opacity;
      }

      if (tip.x1 === tip.x2) console.warn(`same tip X ${tip.x1} ${tip.x2}`);
      if (tip.y1 === tip.y2) console.warn(`same tip Y ${tip.y1} ${tip.y2}`);
      if (tip.z1 === tip.z2) { tip.z2 = tip.z1 + 0.0001; } // avoid zero faces

      for (let k = 0, nn = -3; k < indicies.length; ++k) {
         let vert = vertices[indicies[k]];
         pos[k*3]   = tip.x1 + vert.x * (tip.x2 - tip.x1);
         pos[k*3+1] = tip.y1 + vert.y * (tip.y2 - tip.y1);
         pos[k*3+2] = tip.z1 + vert.z * (tip.z2 - tip.z1);

         if (norm) {
            if (k % 6 === 0) nn += 3;
            norm[k*3] = normals[nn];
            norm[k*3+1] = normals[nn+1];
            norm[k*3+2] = normals[nn+2];
         }
      }
      this.tooltip_mesh = tooltip_mesh;
      this.toplevel.add(tooltip_mesh);
   }

   if (changed) this.render3D();

   if (changed && isFunc(tip.$painter?.redrawProjection))
      tip.$painter.redrawProjection(tip.ix-1, tip.ix, tip.iy-1, tip.iy);

   if (changed && mainp?.getObject())
      mainp.provideUserTooltip({ obj: mainp.getObject(),  name: mainp.getObject().fName,
                                 bin: tip.bin, cont: tip.value,
                                 binx: tip.ix, biny: tip.iy, binz: tip.iz,
                                 grx: (tip.x1+tip.x2)/2, gry: (tip.y1+tip.y2)/2, grz: (tip.z1+tip.z2)/2 });
}

/** @summary Set options used for 3D drawings
  * @private */
function set3DOptions(hopt) {
   this.opt3d = hopt;
}

/** @summary Draw axes in 3D mode
  * @private */
function drawXYZ(toplevel, AxisPainter, opts) {
   if (!opts) opts = {};

   let grminx = -this.size_x3d, grmaxx = this.size_x3d,
       grminy = -this.size_y3d, grmaxy = this.size_y3d,
       grminz = 0, grmaxz = 2*this.size_z3d,
       scalingSize = this.size_z3d,
       pad = opts.v7 ? null : this.getPadPainter().getRootPad(true),
       xmin = this.xmin, xmax = this.xmax,
       ymin = this.ymin, ymax = this.ymax,
       zmin = this.zmin, zmax = this.zmax,
       y_zoomed = false, z_zoomed = false;

   if (!this.size_z3d) {
      grminx = this.xmin; grmaxx = this.xmax;
      grminy = this.ymin; grmaxy = this.ymax;
      grminz = this.zmin; grmaxz = this.zmax;
      scalingSize = (grmaxz - grminz);
   }

   if (('zoom_xmin' in this) && ('zoom_xmax' in this) && (this.zoom_xmin !== this.zoom_xmax)) {
      xmin = this.zoom_xmin; xmax = this.zoom_xmax;
   }
   if (('zoom_ymin' in this) && ('zoom_ymax' in this) && (this.zoom_ymin !== this.zoom_ymax)) {
      ymin = this.zoom_ymin; ymax = this.zoom_ymax; y_zoomed = true;
   }
   if (('zoom_zmin' in this) && ('zoom_zmax' in this) && (this.zoom_zmin !== this.zoom_zmax)) {
      zmin = this.zoom_zmin; zmax = this.zoom_zmax; z_zoomed = true;
   }

   if (opts.use_y_for_z) {
      this.zmin = this.ymin; this.zmax = this.ymax;
      zmin = ymin; zmax = ymax; z_zoomed = y_zoomed;
      // if (!z_zoomed && (this.hmin!==this.hmax)) { zmin = this.hmin; zmax = this.hmax; }
      ymin = 0; ymax = 1;
   }

   // z axis range used for lego plot
   this.lego_zmin = zmin; this.lego_zmax = zmax;

   // factor 1.1 used in ROOT for lego plots
   if ((opts.zmult !== undefined) && !z_zoomed) zmax *= opts.zmult;

   this.x_handle = new AxisPainter(null, this.xaxis);
   if (opts.v7) {
      this.x_handle.setPadName(this.getPadName());
      this.x_handle.snapid = this.snapid;
   }
   this.x_handle.configureAxis('xaxis', this.xmin, this.xmax, xmin, xmax, false, [grminx, grmaxx],
                               { log: pad ? pad.fLogx : 0 });
   this.x_handle.assignFrameMembers(this, 'x');
   this.x_handle.extractDrawAttributes(scalingSize);

   this.y_handle = new AxisPainter(null, this.yaxis);
   if (opts.v7) {
      this.y_handle.setPadName(this.getPadName());
      this.y_handle.snapid = this.snapid;
   }
   this.y_handle.configureAxis('yaxis', this.ymin, this.ymax, ymin, ymax, false, [grminy, grmaxy],
                               { log: pad && !opts.use_y_for_z ? pad.fLogy : 0 });
   this.y_handle.assignFrameMembers(this, 'y');
   this.y_handle.extractDrawAttributes(scalingSize);

   this.z_handle = new AxisPainter(null, this.zaxis);
   if (opts.v7) {
      this.z_handle.setPadName(this.getPadName());
      this.z_handle.snapid = this.snapid;
   }
   this.z_handle.configureAxis('zaxis', this.zmin, this.zmax, zmin, zmax, false, [grminz, grmaxz],
                               { log: pad ? pad.fLogz : 0 });
   this.z_handle.assignFrameMembers(this, 'z');
   this.z_handle.extractDrawAttributes(scalingSize);

   this.setRootPadRange(pad, true); // set some coordinates typical for 3D projections in ROOT

   let textMaterials = {}, lineMaterials = {}, text_scale = 1,
       xticks = this.x_handle.createTicks(false, true),
       yticks = this.y_handle.createTicks(false, true),
       zticks = this.z_handle.createTicks(false, true);

   function getLineMaterial(handle, kind) {
      let color = (kind == 'ticks') ? handle.ticksColor : handle.lineatt.color,
          linewidth = (kind == 'ticks') ? handle.ticksWidth : handle.lineatt.width;
      if (!color) color = 'black';
      let name = `${color}_${linewidth}`;
      if (!lineMaterials[name])
         lineMaterials[name] = new LineBasicMaterial({ color, linewidth, vertexColors: false });
      return lineMaterials[name];
   }

   function getTextMaterial(handle, kind) {
      let color = (kind == 'title') ? handle.titleFont?.color : handle.labelsFont?.color;
      if (!color) color = 'black';
      if (!textMaterials[color])
         textMaterials[color] = new MeshBasicMaterial({ color, vertexColors: false });
      return textMaterials[color];
   }

   // main element, where all axis elements are placed
   let top = new Object3D();
   top.axis_draw = true; // mark element as axis drawing
   toplevel.add(top);

   let ticks = [], lbls = [], maxtextheight = 0;

   while (xticks.next()) {
      let grx = xticks.grpos,
         is_major = xticks.kind === 1,
         lbl = this.x_handle.format(xticks.tick, 2);

      if (xticks.last_major()) {
         if (!this.x_handle.fTitle) lbl = 'x';
      } else if (lbl === null) {
         is_major = false; lbl = '';
      }

      if (is_major && lbl && opts.draw) {
         let text3d = new TextGeometry(lbl, { font: HelveticerRegularFont, size: this.x_handle.labelsFont.size, height: 0, curveSegments: 5 });
         text3d.computeBoundingBox();
         let draw_width = text3d.boundingBox.max.x - text3d.boundingBox.min.x,
             draw_height = text3d.boundingBox.max.y - text3d.boundingBox.min.y;
         text3d.center = true; // place central

         text3d.offsety = this.x_handle.labelsOffset + (grmaxy - grminy) * 0.005;

         maxtextheight = Math.max(maxtextheight, draw_height);

         text3d.grx = grx;
         lbls.push(text3d);

         let space = 0;
         if (!xticks.last_major()) {
            space = (xticks.next_major_grpos() - grx);
            if (draw_width > 0)
               text_scale = Math.min(text_scale, 0.9*space/draw_width);
         }

         if (this.x_handle.isCenteredLabels()) {
            if (!space) space = Math.min(grx - grminx, grmaxx - grx);
            text3d.grx += space/2;
         }
      }

      ticks.push(grx,0,0, grx,this.x_handle.ticksSize*(is_major ? -1 : -0.6),0);
   }

   if (this.x_handle.fTitle && opts.draw) {
      const text3d = new TextGeometry(translateLaTeX(this.x_handle.fTitle), { font: HelveticerRegularFont, size: this.x_handle.titleFont.size, height: 0, curveSegments: 5 });
      text3d.computeBoundingBox();
      text3d.center = this.x_handle.titleCenter;
      text3d.opposite = this.x_handle.titleOpposite;
      text3d.offsety = 1.6 * this.x_handle.titleOffset + (grmaxy - grminy) * 0.005;
      text3d.grx = (grminx + grmaxx)/2; // default position for centered title
      text3d.kind = 'title';
      lbls.push(text3d);
   }

   this.get3dZoomCoord = function(point, kind) {
      // return axis coordinate from intersection point with axis geometry
      let pos = point[kind], min = this[`scale_${kind}min`], max = this[`scale_${kind}max`];

      switch(kind) {
         case 'x': pos = (pos + this.size_x3d)/2/this.size_x3d; break;
         case 'y': pos = (pos + this.size_y3d)/2/this.size_y3d; break;
         case 'z': pos = pos/2/this.size_z3d; break;
      }
      if (this['log'+kind]) {
         pos = Math.exp(Math.log(min) + pos*(Math.log(max)-Math.log(min)));
      } else {
         pos = min + pos*(max-min);
      }
      return pos;
   };

   const createZoomMesh = (kind, size_3d, use_y_for_z) => {
      let positions, geom = new BufferGeometry(), tsz = Math.max(this[kind+'_handle'].ticksSize, 0.005 * size_3d);
      if (kind === 'z')
         positions = new Float32Array([0,0,0, tsz*4,0,2*size_3d, tsz*4,0,0, 0,0,0, 0,0,2*size_3d, tsz*4,0,2*size_3d]);
      else
         positions = new Float32Array([-size_3d,0,0, size_3d,-tsz*4,0, size_3d,0,0, -size_3d,0,0, -size_3d,-tsz*4,0, size_3d,-tsz*4,0]);

      geom.setAttribute('position', new BufferAttribute(positions, 3));
      geom.computeVertexNormals();

      let material = new MeshBasicMaterial({ transparent: true, vertexColors: false, side: DoubleSide, opacity: 0 }),
          mesh = new Mesh(geom, material);
      mesh.zoom = kind;
      mesh.size_3d = size_3d;
      mesh.tsz = tsz;
      mesh.use_y_for_z = use_y_for_z;
      if (kind == 'y') mesh.rotateZ(Math.PI/2).rotateX(Math.PI);

      mesh.v1 = new Vector3(positions[0], positions[1], positions[2]);
      mesh.v2 = new Vector3(positions[6], positions[7], positions[8]);
      mesh.v3 = new Vector3(positions[3], positions[4], positions[5]);

      mesh.globalIntersect = function(raycaster) {
         if (!this.v1 || !this.v2 || !this.v3) return undefined;

         let plane = new Plane();
         plane.setFromCoplanarPoints(this.v1, this.v2, this.v3);
         plane.applyMatrix4(this.matrixWorld);

         let v1 = raycaster.ray.origin.clone(),
             v2 = v1.clone().addScaledVector(raycaster.ray.direction, 1e10),
             pnt = plane.intersectLine(new Line3(v1,v2), new Vector3());

         if (!pnt) return undefined;

         let min = -this.size_3d, max = this.size_3d;
         if (this.zoom === 'z') { min = 0; max = 2*this.size_3d; }

         if (pnt[this.zoom] < min)
            pnt[this.zoom] = min;
         else if (pnt[this.zoom] > max)
            pnt[this.zoom] = max;

         return pnt;
      };

      mesh.showSelection = function(pnt1, pnt2) {
         // used to show selection

         let tgtmesh = this.children ? this.children[0] : null, gg, kind = this.zoom;
         if (!pnt1 || !pnt2) {
            if (tgtmesh) {
               this.remove(tgtmesh);
               disposeThreejsObject(tgtmesh);
            }
            return tgtmesh;
         }

         if (!this.geometry) return false;

         if (!tgtmesh) {
            gg = this.geometry.clone();
            let pos = gg.getAttribute('position').array;

            // original vertices [0, 2, 1, 0, 3, 2]
            if (kind == 'z') pos[6] = pos[3] = pos[15] = this.tsz;
                        else pos[4] = pos[16] = pos[13] = -this.tsz;
            tgtmesh = new Mesh(gg, new MeshBasicMaterial({ color: 0xFF00, side: DoubleSide, vertexColors: false }));
            this.add(tgtmesh);
         } else {
            gg = tgtmesh.geometry;
         }

         let pos = gg.getAttribute('position').array;

         if (kind == 'z') {
            pos[2] = pos[11] = pos[8] = pnt1[kind];
            pos[5] = pos[17] = pos[14] = pnt2[kind];
         } else {
            pos[0] = pos[9] = pos[12] = pnt1[kind];
            pos[6] = pos[3] = pos[15] = pnt2[kind];
         }

         gg.getAttribute('position').needsUpdate = true;

         return true;
      };

      return mesh;
   };

   let xcont = new Object3D(), xtickslines;
   xcont.position.set(0, grminy, grminz);
   xcont.rotation.x = 1/4*Math.PI;
   xcont.xyid = 2;

   if (opts.draw) {
      xtickslines = createLineSegments(ticks, getLineMaterial(this.x_handle, 'ticks'));
      xcont.add(xtickslines);
   }

   lbls.forEach(lbl => {
      let w = lbl.boundingBox.max.x - lbl.boundingBox.min.x,
          posx = lbl.center ? lbl.grx - w/2 : (lbl.opposite ? grminx : grmaxx - w),
          m = new Matrix4();
      // matrix to swap y and z scales and shift along z to its position
      m.set(text_scale, 0,           0,  posx,
            0,          text_scale,  0,  -maxtextheight*text_scale - this.x_handle.ticksSize - lbl.offsety,
            0,          0,           1,  0,
            0,          0,           0,  1);

      let mesh = new Mesh(lbl, getTextMaterial(this.x_handle, lbl.kind));
      mesh.applyMatrix4(m);
      xcont.add(mesh);
   });

   if (opts.zoom) xcont.add(createZoomMesh('x', this.size_x3d));
   top.add(xcont);

   xcont = new Object3D();
   xcont.position.set(0, grmaxy, grminz);
   xcont.rotation.x = 3/4*Math.PI;

   if (opts.draw)
      xcont.add(new LineSegments(xtickslines.geometry, xtickslines.material));

   lbls.forEach(lbl => {
      let w = lbl.boundingBox.max.x - lbl.boundingBox.min.x,
          posx = (lbl.center ? lbl.grx + w/2 : lbl.opposite ? grminx + w : grmaxx),
          m = new Matrix4();
      // matrix to swap y and z scales and shift along z to its position
      m.set(-text_scale, 0,          0, posx,
            0,           text_scale, 0, -maxtextheight*text_scale - this.x_handle.ticksSize - lbl.offsety,
            0,           0,         -1, 0,
            0,           0,          0, 1);
      let mesh = new Mesh(lbl, getTextMaterial(this.x_handle, lbl.kind));
      mesh.applyMatrix4(m);
      xcont.add(mesh);
   });

   xcont.xyid = 4;
   if (opts.zoom) xcont.add(createZoomMesh('x', this.size_x3d));
   top.add(xcont);

   lbls = []; text_scale = 1; maxtextheight = 0; ticks = [];

   while (yticks.next()) {
      let gry = yticks.grpos,
          is_major = (yticks.kind === 1),
          lbl = this.y_handle.format(yticks.tick, 2);

      if (yticks.last_major()) {
         if (!this.y_handle.fTitle) lbl = 'y';
      }  else if (lbl === null) {
         is_major = false; lbl = '';
      }

      if (is_major && lbl && opts.draw) {
         const text3d = new TextGeometry(lbl, { font: HelveticerRegularFont, size: this.y_handle.labelsFont.size, height: 0, curveSegments: 5 });
         text3d.computeBoundingBox();
         let draw_width = text3d.boundingBox.max.x - text3d.boundingBox.min.x,
             draw_height = text3d.boundingBox.max.y - text3d.boundingBox.min.y;
         text3d.center = true;

         maxtextheight = Math.max(maxtextheight, draw_height);

         text3d.gry = gry;
         text3d.offsetx = this.y_handle.labelsOffset + (grmaxx - grminx) * 0.005;
         lbls.push(text3d);

         let space = 0;
         if (!yticks.last_major()) {
            space = (yticks.next_major_grpos() - gry);
            if (draw_width > 0)
               text_scale = Math.min(text_scale, 0.9*space/draw_width);
         }
         if (this.y_handle.isCenteredLabels()) {
            if (!space) space = Math.min(gry - grminy, grmaxy - gry);
            text3d.gry += space/2;
         }
      }
      ticks.push(0,gry,0, this.y_handle.ticksSize*(is_major ? -1 : -0.6),gry,0);
   }

   if (this.y_handle.fTitle && opts.draw) {
      const text3d = new TextGeometry(translateLaTeX(this.y_handle.fTitle), { font: HelveticerRegularFont, size: this.y_handle.titleFont.size, height: 0, curveSegments: 5 });
      text3d.computeBoundingBox();
      text3d.center = this.y_handle.titleCenter;
      text3d.opposite = this.y_handle.titleOpposite;
      text3d.offsetx = 1.6 * this.y_handle.titleOffset + (grmaxx - grminx) * 0.005;
      text3d.gry = (grminy + grmaxy)/2; // default position for centered title
      text3d.kind = 'title';
      lbls.push(text3d);
   }

   if (!opts.use_y_for_z) {
      let yticksline, ycont = new Object3D();
      ycont.position.set(grminx, 0, grminz);
      ycont.rotation.y = -1/4*Math.PI;
      if (opts.draw) {
         yticksline = createLineSegments(ticks, getLineMaterial(this.y_handle, 'ticks'));
         ycont.add(yticksline);
      }

      lbls.forEach(lbl => {

         let w = lbl.boundingBox.max.x - lbl.boundingBox.min.x,
             posy = lbl.center ? lbl.gry + w/2 : (lbl.opposite ? grminy + w : grmaxy),
             m = new Matrix4();
         // matrix to swap y and z scales and shift along z to its position
         m.set(0, text_scale,  0, -maxtextheight*text_scale - this.y_handle.ticksSize - lbl.offsetx,
               -text_scale,  0, 0, posy,
               0, 0,  1, 0,
               0, 0,  0, 1);

         let mesh = new Mesh(lbl, getTextMaterial(this.y_handle, lbl.kind));
         mesh.applyMatrix4(m);
         ycont.add(mesh);
      });

      ycont.xyid = 3;
      if (opts.zoom) ycont.add(createZoomMesh('y', this.size_y3d));
      top.add(ycont);

      ycont = new Object3D();
      ycont.position.set(grmaxx, 0, grminz);
      ycont.rotation.y = -3/4*Math.PI;
      if (opts.draw)
         ycont.add(new LineSegments(yticksline.geometry, yticksline.material));

      lbls.forEach(lbl => {
         let w = lbl.boundingBox.max.x - lbl.boundingBox.min.x,
             posy = lbl.center ? lbl.gry - w/2 : (lbl.opposite ? grminy : grmaxy - w),
             m = new Matrix4();
         m.set(0, text_scale, 0,  -maxtextheight*text_scale - this.y_handle.ticksSize - lbl.offsetx,
               text_scale, 0, 0,  posy,
               0,         0, -1,  0,
               0, 0, 0, 1);

         let mesh = new Mesh(lbl, getTextMaterial(this.y_handle, lbl.kind));
         mesh.applyMatrix4(m);
         ycont.add(mesh);
      });
      ycont.xyid = 1;
      if (opts.zoom) ycont.add(createZoomMesh('y', this.size_y3d));
      top.add(ycont);
   }

   lbls = []; text_scale = 1; ticks = []; // just array, will be used for the buffer geometry

   let zgridx = null, zgridy = null, lastmajorz = null, maxzlblwidth = 0;

   if (this.size_z3d) {
      zgridx = []; zgridy = [];
   }

   while (zticks.next()) {
      let grz = zticks.grpos,
          is_major = (zticks.kind == 1),
          lbl = this.z_handle.format(zticks.tick, 2);

      if (lbl === null) { is_major = false; lbl = ''; }

      if (is_major && lbl && opts.draw) {
         let text3d = new TextGeometry(lbl, { font: HelveticerRegularFont, size: this.z_handle.labelsFont.size, height: 0, curveSegments: 5 });
         text3d.computeBoundingBox();
         let draw_width = text3d.boundingBox.max.x - text3d.boundingBox.min.x,
             draw_height = text3d.boundingBox.max.y - text3d.boundingBox.min.y;
         text3d.translate(-draw_width, -draw_height/2, 0);
         text3d.grz = grz;
         lbls.push(text3d);

         if ((lastmajorz !== null) && (draw_height > 0))
            text_scale = Math.min(text_scale, 0.9*(grz - lastmajorz)/draw_height);

         maxzlblwidth = Math.max(maxzlblwidth, draw_width);

         lastmajorz = grz;
      }

      // create grid
      if (zgridx && is_major)
         zgridx.push(grminx,0,grz, grmaxx,0,grz);

      if (zgridy && is_major)
         zgridy.push(0,grminy,grz, 0,grmaxy,grz);

      ticks.push(0,0,grz, this.z_handle.ticksSize*(is_major ? 1 : 0.6),0,grz);
   }

   if (zgridx && (zgridx.length > 0)) {

      const material = new LineDashedMaterial({ color: this.x_handle.ticksColor, dashSize: 2, gapSize: 2 }),
            lines1 = createLineSegments(zgridx, material);

      lines1.position.set(0,grmaxy,0);
      lines1.grid = 2; // mark as grid
      lines1.visible = false;
      top.add(lines1);

      const lines2 = new LineSegments(lines1.geometry, material);
      lines2.position.set(0,grminy,0);
      lines2.grid = 4; // mark as grid
      lines2.visible = false;
      top.add(lines2);
   }

   if (zgridy && (zgridy.length > 0)) {

      const material = new LineDashedMaterial({ color: this.y_handle.ticksColor, dashSize: 2, gapSize: 2 }),
            lines1 = createLineSegments(zgridy, material);

      lines1.position.set(grmaxx,0, 0);
      lines1.grid = 3; // mark as grid
      lines1.visible = false;
      top.add(lines1);

      const lines2 = new LineSegments(lines1.geometry, material);
      lines2.position.set(grminx, 0, 0);
      lines2.grid = 1; // mark as grid
      lines2.visible = false;
      top.add(lines2);
   }

   let zcont = [], zticksline = opts.draw ? createLineSegments(ticks, getLineMaterial(this.z_handle, 'ticks')) : null;
   for (let n = 0; n < 4; ++n) {
      zcont.push(new Object3D());

      lbls.forEach((lbl,indx) => {
         let m = new Matrix4(), grz = lbl.grz;

         if (this.z_handle.isCenteredLabels()) {
            if (indx < lbls.length - 1)
               grz = (grz + lbls[indx+1].grz) / 2;
            else if (indx > 0)
               grz = Math.min(1.5*grz - lbls[indx-1].grz*0.5, grmaxz);
         }

         // matrix to swap y and z scales and shift along z to its position
         m.set(-text_scale,          0,  0, this.z_handle.ticksSize + (grmaxx - grminx) * 0.005 + this.z_handle.labelsOffset,
                         0,          0,  1, 0,
                         0, text_scale,  0, grz);
         let mesh = new Mesh(lbl, getTextMaterial(this.z_handle));
         mesh.applyMatrix4(m);
         zcont[n].add(mesh);
      });

      if (this.z_handle.fTitle && opts.draw) {
         let text3d = new TextGeometry(translateLaTeX(this.z_handle.fTitle), { font: HelveticerRegularFont, size: this.z_handle.titleFont.size, height: 0, curveSegments: 5 });
         text3d.computeBoundingBox();
         let draw_width = text3d.boundingBox.max.x - text3d.boundingBox.min.x,
             posz = this.z_handle.titleCenter ? (grmaxz + grminz - draw_width)/2 : (this.z_handle.titleOpposite ? grminz : grmaxz - draw_width);

         text3d.rotateZ(Math.PI/2);

         let m = new Matrix4();
         m.set(-text_scale,          0,  0, this.z_handle.ticksSize + (grmaxx - grminx) * 0.005 + maxzlblwidth + this.z_handle.titleOffset,
                         0,          0,  1, 0,
                         0, text_scale,  0, posz);
         let mesh = new Mesh(text3d, getTextMaterial(this.z_handle, 'title'));
         mesh.applyMatrix4(m);
         zcont[n].add(mesh);
      }

      if (opts.draw && zticksline)
         zcont[n].add(n == 0 ? zticksline : new LineSegments(zticksline.geometry, zticksline.material));
      if (opts.zoom)
         zcont[n].add(createZoomMesh('z', this.size_z3d, opts.use_y_for_z));

      zcont[n].zid = n + 2;
      top.add(zcont[n]);
   }

   zcont[0].position.set(grminx,grmaxy,0);
   zcont[0].rotation.z = 3/4*Math.PI;

   zcont[1].position.set(grmaxx,grmaxy,0);
   zcont[1].rotation.z = 1/4*Math.PI;

   zcont[2].position.set(grmaxx,grminy,0);
   zcont[2].rotation.z = -1/4*Math.PI;

   zcont[3].position.set(grminx,grminy,0);
   zcont[3].rotation.z = -3/4*Math.PI;

   let linex_material = getLineMaterial(this.x_handle),
       linex_geom = createLineSegments([grminx,0,0, grmaxx,0,0], linex_material, null, true);
   for(let n = 0; n < 2; ++n) {
      let line = new LineSegments(linex_geom, linex_material);
      line.position.set(0, grminy, n == 0 ? grminz : grmaxz);
      line.xyboxid = 2; line.bottom = (n == 0);
      top.add(line);

      line = new LineSegments(linex_geom, linex_material);
      line.position.set(0, grmaxy, n == 0 ? grminz : grmaxz);
      line.xyboxid = 4; line.bottom = (n == 0);
      top.add(line);
   }

   let liney_material = getLineMaterial(this.y_handle),
       liney_geom = createLineSegments([0,grminy,0, 0,grmaxy,0], liney_material, null, true);
   for(let n = 0; n < 2; ++n) {
      let line = new LineSegments(liney_geom, liney_material);
      line.position.set(grminx, 0, n == 0 ? grminz : grmaxz);
      line.xyboxid = 3; line.bottom = (n == 0);
      top.add(line);

      line = new LineSegments(liney_geom, liney_material);
      line.position.set(grmaxx, 0, n == 0 ? grminz : grmaxz);
      line.xyboxid = 1; line.bottom = (n == 0);
      top.add(line);
   }

   let linez_material = getLineMaterial(this.z_handle),
       linez_geom = createLineSegments([0,0,grminz, 0,0,grmaxz], linez_material, null, true);
   for(let n = 0; n < 4; ++n) {
      let line = new LineSegments(linez_geom, linez_material);
      line.zboxid = zcont[n].zid;
      line.position.copy(zcont[n].position);
      top.add(line);
   }
}

/** @summary Assign 3D methods for frame painter
  * @private */
function assignFrame3DMethods(fpainter) {
   Object.assign(fpainter, { create3DScene, render3D, resize3D, highlightBin3D, set3DOptions, drawXYZ });
}


/** @summary Draw histograms in 3D mode
  * @private */
function drawBinsLego(painter, is_v7 = false) {

   if (!painter.draw_content) return;

   // Perform TH1/TH2 lego plot with BufferGeometry

   const vertices = Box3D.Vertices,
         indicies = Box3D.Indexes,
         vnormals = Box3D.Normals,
         segments = Box3D.Segments,
         // reduced line segments
         rsegments = [0, 1, 1, 2, 2, 3, 3, 0],
         // reduced vertices
         rvertices = [ new Vector3(0, 0, 0), new Vector3(0, 1, 0), new Vector3(1, 1, 0), new Vector3(1, 0, 0) ],
         main = painter.getFramePainter(),
         handle = painter.prepareDraw({ rounding: false, use3d: true, extra: 1 }),
         i1 = handle.i1, i2 = handle.i2, j1 = handle.j1, j2 = handle.j2,
         histo = painter.getHisto(),
         basehisto = histo ? histo.$baseh : null,
         split_faces = (painter.options.Lego === 11) || (painter.options.Lego === 13), // split each layer on two parts
         use16indx = (histo.getBin(i2, j2) < 0xFFFF); // if bin ID fit into 16 bit, use smaller arrays for intersect indexes

   if ((i1 >= i2) || (j1 >= j2)) return;

   let zmin, zmax, i, j, k, vert, x1, x2, y1, y2, binz1, binz2, reduced, nobottom, notop,
       axis_zmin = main.z_handle.getScaleMin(),
       axis_zmax = main.z_handle.getScaleMax();

   const getBinContent = (ii,jj,level) => {
      // return bin content in binz1, binz2, reduced flags
      // return true if bin should be displayed

      binz2 = histo.getBinContent(ii+1, jj+1);
      if (basehisto)
         binz1 = basehisto.getBinContent(ii+1, jj+1);
      else if (painter.options.BaseLine !== false)
         binz1 = painter.options.BaseLine;
      else
         binz1 = painter.options.Zero ? axis_zmin : 0;
      if (binz2 < binz1)
         [binz1, binz2] = [binz2, binz1];

      if ((binz1 >= zmax) || (binz2 < zmin)) return false;

      reduced = (binz2 === zmin) || (binz1 >= binz2);

      if (!reduced || (level > 0)) return true;

      if (basehisto) return false; // do not draw empty bins on top of other bins

      if (painter.options.Zero || (axis_zmin > 0)) return true;

      return painter._show_empty_bins;
   };

   let levels = [ axis_zmin, axis_zmax ], palette = null;

   // DRAW ALL CUBES

   if ((painter.options.Lego === 12) || (painter.options.Lego === 14)) {
      // drawing colors levels, axis can not exceed palette

      if (is_v7) {
         palette = main.getHistPalette();
         painter.createContour(main, palette, { full_z_range: true });
         levels = palette.getContour();
         axis_zmin = levels[0];
         axis_zmax = levels[levels.length-1];
      } else {
         let cntr = painter.createContour(histo.fContour ? histo.fContour.length : 20, main.lego_zmin, main.lego_zmax);
         levels = cntr.arr;
         palette = painter.getHistPalette();
         // axis_zmin = levels[0];
         // axis_zmax = levels[levels.length-1];
      }
   }

   for (let nlevel = 0; nlevel < levels.length-1; ++nlevel) {

      zmin = levels[nlevel];
      zmax = levels[nlevel+1];

      // artificially extend last level of color palette to maximal visible value
      if (palette && (nlevel==levels.length-2) && zmax < axis_zmax) zmax = axis_zmax;

      let z1 = 0, z2 = 0, numvertices = 0, num2vertices = 0,
          grzmin = main.grz(zmin), grzmax = main.grz(zmax);

      // now calculate size of buffer geometry for boxes

      for (i = i1; i < i2; ++i)
         for (j = j1; j < j2; ++j) {

            if (!getBinContent(i,j,nlevel)) continue;

            nobottom = !reduced && (nlevel > 0);
            notop = !reduced && (binz2 > zmax) && (nlevel < levels.length-2);

            numvertices += (reduced ? 12 : indicies.length);
            if (nobottom) numvertices -= 6;
            if (notop) numvertices -= 6;

            if (split_faces && !reduced) {
               numvertices -= 12;
               num2vertices += 12;
            }
         }

      const positions = new Float32Array(numvertices*3),
            normals = new Float32Array(numvertices*3),
            face_to_bins_index = use16indx ? new Uint16Array(numvertices/3) : new Uint32Array(numvertices/3),
            pos2 = (num2vertices === 0) ? null : new Float32Array(num2vertices*3),
            norm2 = (num2vertices === 0) ? null : new Float32Array(num2vertices*3),
            face_to_bins_indx2 = (num2vertices === 0) ? null : (use16indx ? new Uint16Array(num2vertices/3) : new Uint32Array(num2vertices/3));

      let v = 0, v2 = 0, vert, k, nn;

      for (i = i1; i < i2; ++i) {
         x1 = handle.grx[i] + handle.xbar1*(handle.grx[i+1] - handle.grx[i]);
         x2 = handle.grx[i] + handle.xbar2*(handle.grx[i+1] - handle.grx[i]);
         for (j = j1; j < j2; ++j) {

            if (!getBinContent(i,j,nlevel)) continue;

            nobottom = !reduced && (nlevel > 0);
            notop = !reduced && (binz2 > zmax) && (nlevel < levels.length-2);

            y1 = handle.gry[j] + handle.ybar1*(handle.gry[j+1] - handle.gry[j]);
            y2 = handle.gry[j] + handle.ybar2*(handle.gry[j+1] - handle.gry[j]);

            z1 = (binz1 <= zmin) ? grzmin : main.grz(binz1);
            z2 = (binz2 > zmax) ? grzmax : main.grz(binz2);

            nn = 0; // counter over the normals, each normals correspond to 6 vertices
            k = 0; // counter over vertices

            if (reduced) {
               // we skip all side faces, keep only top and bottom
               nn += 12;
               k += 24;
            }

            let size = indicies.length, bin_index = histo.getBin(i+1, j+1);
            if (nobottom) size -= 6;

            // array over all vertices of the single bin
            while(k < size) {

               vert = vertices[indicies[k]];

               if (split_faces && (k < 12)) {
                  pos2[v2]   = x1 + vert.x * (x2 - x1);
                  pos2[v2+1] = y1 + vert.y * (y2 - y1);
                  pos2[v2+2] = z1 + vert.z * (z2 - z1);

                  norm2[v2] = vnormals[nn];
                  norm2[v2+1] = vnormals[nn+1];
                  norm2[v2+2] = vnormals[nn+2];
                  if (v2 % 9 === 0) face_to_bins_indx2[v2/9] = bin_index; // remember which bin corresponds to the face
                  v2 += 3;
               } else {
                  positions[v]   = x1 + vert.x * (x2 - x1);
                  positions[v+1] = y1 + vert.y * (y2 - y1);
                  positions[v+2] = z1 + vert.z * (z2 - z1);

                  normals[v] = vnormals[nn];
                  normals[v+1] = vnormals[nn+1];
                  normals[v+2] = vnormals[nn+2];
                  if (v % 9 === 0) face_to_bins_index[v/9] = bin_index; // remember which bin corresponds to the face
                  v += 3;
               }

               ++k;

               if (k % 6 === 0) {
                  nn += 3;
                  if (notop && (k === indicies.length - 12)) {
                     k += 6; nn += 3; // jump over notop indexes
                  }
               }
            }
         }
      }

      let geometry = new BufferGeometry();
      geometry.setAttribute('position', new BufferAttribute(positions, 3));
      geometry.setAttribute('normal', new BufferAttribute(normals, 3));
      // geometry.computeVertexNormals();

      let rootcolor = is_v7 ? 3 : histo.fFillColor,
          fcolor = painter.getColor(rootcolor);

      if (palette) {
         fcolor = is_v7 ? palette.getColor(nlevel) : palette.calcColor(nlevel, levels.length);
      } else if ((painter.options.Lego === 1) || (rootcolor < 2)) {
         rootcolor = 1;
         fcolor = 'white';
      }

      let material = new MeshBasicMaterial({ color: fcolor, vertexColors: false }),
          mesh = new Mesh(geometry, material);

      mesh.face_to_bins_index = face_to_bins_index;
      mesh.painter = painter;
      mesh.zmin = axis_zmin;
      mesh.zmax = axis_zmax;
      mesh.baseline = (painter.options.BaseLine !== false) ? painter.options.BaseLine : (painter.options.Zero ? axis_zmin : 0);
      mesh.tip_color = (rootcolor===3) ? 0xFF0000 : 0x00FF00;
      mesh.handle = handle;

      mesh.tooltip = function(intersect) {
         if (!Number.isInteger(intersect.faceIndex)) {
            console.error(`faceIndex not provided, three.js version ${REVISION}`);
            return null;
         }

         if ((intersect.faceIndex < 0) || (intersect.faceIndex >= this.face_to_bins_index.length)) return null;

         const p = this.painter,
               handle = this.handle,
               main = p.getFramePainter(),
               histo = p.getHisto(),
               tip = p.get3DToolTip(this.face_to_bins_index[intersect.faceIndex]);

         tip.x1 = Math.max(-main.size_x3d,  handle.grx[tip.ix-1] + handle.xbar1*(handle.grx[tip.ix] - handle.grx[tip.ix-1]));
         tip.x2 = Math.min(main.size_x3d, handle.grx[tip.ix-1] + handle.xbar2*(handle.grx[tip.ix] - handle.grx[tip.ix-1]));

         tip.y1 = Math.max(-main.size_y3d, handle.gry[tip.iy-1] + handle.ybar1*(handle.gry[tip.iy] - handle.gry[tip.iy-1]));
         tip.y2 = Math.min(main.size_y3d, handle.gry[tip.iy-1] + handle.ybar2*(handle.gry[tip.iy] - handle.gry[tip.iy-1]));

         let binz1 = this.baseline, binz2 = tip.value;
         if (histo.$baseh) binz1 = histo.$baseh.getBinContent(tip.ix, tip.iy);
         if (binz2<binz1) { let v = binz1; binz1 = binz2; binz2 = v; }

         tip.z1 = main.grz(Math.max(this.zmin,binz1));
         tip.z2 = main.grz(Math.min(this.zmax,binz2));

         tip.color = this.tip_color;

         if (p.is_projection && (p.getDimension()==2)) tip.$painter = p; // used only for projections

         return tip;
      };

      main.toplevel.add(mesh);

      if (num2vertices > 0) {
         const geom2 = new BufferGeometry();
         geom2.setAttribute('position', new BufferAttribute(pos2, 3));
         geom2.setAttribute('normal', new BufferAttribute(norm2, 3));
         //geom2.computeVertexNormals();

         const color2 = (rootcolor < 2) ? new Color$1(0xFF0000) : new Color$1(rgb(fcolor).darker(0.5).toString()),
               material2 = new MeshBasicMaterial({ color: color2, vertexColors: false }),
               mesh2 = new Mesh(geom2, material2);
         mesh2.face_to_bins_index = face_to_bins_indx2;
         mesh2.painter = painter;
         mesh2.handle = mesh.handle;
         mesh2.tooltip = mesh.tooltip;
         mesh2.zmin = mesh.zmin;
         mesh2.zmax = mesh.zmax;
         mesh2.baseline = mesh.baseline;
         mesh2.tip_color = mesh.tip_color;

         main.toplevel.add(mesh2);
      }
   }

   // lego3 or lego4 do not draw border lines
   if (painter.options.Lego > 12) return;

   // DRAW LINE BOXES

   let numlinevertices = 0, numsegments = 0;

   zmax = axis_zmax; zmin = axis_zmin;

   for (i = i1; i < i2; ++i)
      for (j = j1; j < j2; ++j) {
         if (!getBinContent(i,j,0)) continue;

         // calculate required buffer size for line segments
         numlinevertices += (reduced ? rvertices.length : vertices.length);
         numsegments += (reduced ? rsegments.length : segments.length);
      }

   // On some platforms vertex index required to be Uint16 array
   // While we cannot use index for large vertex list
   // skip index usage at all. It happens for relatively large histograms (100x100 bins)
   const uselineindx = (numlinevertices <= 0xFFF0);

   if (!uselineindx) numlinevertices = numsegments*3;

   const lpositions = new Float32Array(numlinevertices * 3),
         lindicies = uselineindx ? new Uint16Array(numsegments) : null,
         grzmin = main.grz(axis_zmin),
         grzmax = main.grz(axis_zmax);
   let z1 = 0, z2 = 0, ll = 0, ii = 0;

   for (i = i1; i < i2; ++i) {
      x1 = handle.grx[i] + handle.xbar1*(handle.grx[i+1] - handle.grx[i]);
      x2 = handle.grx[i] + handle.xbar2*(handle.grx[i+1] - handle.grx[i]);
      for (j = j1; j < j2; ++j) {

         if (!getBinContent(i,j,0)) continue;

         y1 = handle.gry[j] + handle.ybar1*(handle.gry[j+1] - handle.gry[j]);
         y2 = handle.gry[j] + handle.ybar2*(handle.gry[j+1] - handle.gry[j]);

         z1 = (binz1 <= axis_zmin) ? grzmin : main.grz(binz1);
         z2 = (binz2 > axis_zmax) ? grzmax : main.grz(binz2);

         const seg = reduced ? rsegments : segments,
               vvv = reduced ? rvertices : vertices;

         if (uselineindx) {
            // array of indicies for the lines, to avoid duplication of points
            for (k = 0; k < seg.length; ++k) {
               // intersect_index[ii] = bin_index;
               lindicies[ii++] = ll/3 + seg[k];
            }

            for (k = 0; k < vvv.length; ++k) {
               vert = vvv[k];
               lpositions[ll]   = x1 + vert.x * (x2 - x1);
               lpositions[ll+1] = y1 + vert.y * (y2 - y1);
               lpositions[ll+2] = z1 + vert.z * (z2 - z1);
               ll += 3;
            }
         } else {
            // copy only vertex positions
            for (k = 0; k < seg.length; ++k) {
               vert = vvv[seg[k]];
               lpositions[ll]   = x1 + vert.x * (x2 - x1);
               lpositions[ll+1] = y1 + vert.y * (y2 - y1);
               lpositions[ll+2] = z1 + vert.z * (z2 - z1);
               // intersect_index[ll/3] = bin_index;
               ll += 3;
            }
         }
      }
   }

   // create boxes
   const lcolor = is_v7 ? painter.v7EvalColor('line_color', 'lightblue') : painter.getColor(histo.fLineColor),
         material = new LineBasicMaterial({ color: new Color$1(lcolor), linewidth: is_v7 ? painter.v7EvalAttr('line_width', 1) : histo.fLineWidth }),
         line = createLineSegments(lpositions, material, uselineindx ? lindicies : null );

   /*
   line.painter = painter;
   line.intersect_index = intersect_index;
   line.tooltip = function(intersect) {
      if ((intersect.index < 0) || (intersect.index >= this.intersect_index.length)) return null;
      return this.painter.get3DToolTip(this.intersect_index[intersect.index]);
   }
   */

   main.toplevel.add(line);
}

/** @summary Draw TH2 histogram in error mode
  * @private */
function drawBinsError3D(painter, is_v7 = false) {
   const main = painter.getFramePainter(),
         histo = painter.getHisto(),
         handle = painter.prepareDraw({ rounding: false, use3d: true, extra: 1 }),
         zmin = main.z_handle.getScaleMin(),
         zmax = main.z_handle.getScaleMax();
   let i, j, bin, binz, binerr, x1, y1, x2, y2, z1, z2,
       nsegments = 0, lpos = null, binindx = null, lindx = 0;

   const check_skip_min = () => {
       // return true if minimal histogram value should be skipped
       if (painter.options.Zero || (zmin > 0)) return false;
       return !painter._show_empty_bins;
   };

    // loop over the points - first loop counts points, second fill arrays
   for (let loop = 0; loop < 2; ++loop) {

      for (i = handle.i1; i < handle.i2; ++i) {
         x1 = handle.grx[i];
         x2 = handle.grx[i + 1];
         for (j = handle.j1; j < handle.j2; ++j) {
            binz = histo.getBinContent(i + 1, j + 1);
            if ((binz < zmin) || (binz > zmax)) continue;
            if ((binz === zmin) && check_skip_min()) continue;

            // just count number of segments
            if (loop === 0) { nsegments += 3; continue; }

            bin = histo.getBin(i + 1, j + 1);
            binerr = histo.getBinError(bin);
            binindx[lindx / 18] = bin;

            y1 = handle.gry[j];
            y2 = handle.gry[j + 1];

            z1 = main.grz((binz - binerr < zmin) ? zmin : binz - binerr);
            z2 = main.grz((binz + binerr > zmax) ? zmax : binz + binerr);

            lpos[lindx] = x1; lpos[lindx + 3] = x2;
            lpos[lindx + 1] = lpos[lindx + 4] = (y1 + y2) / 2;
            lpos[lindx + 2] = lpos[lindx + 5] = (z1 + z2) / 2;
            lindx += 6;

            lpos[lindx] = lpos[lindx + 3] = (x1 + x2) / 2;
            lpos[lindx + 1] = y1; lpos[lindx + 4] = y2;
            lpos[lindx + 2] = lpos[lindx + 5] = (z1 + z2) / 2;
            lindx += 6;

            lpos[lindx] = lpos[lindx + 3] = (x1 + x2) / 2;
            lpos[lindx + 1] = lpos[lindx + 4] = (y1 + y2) / 2;
            lpos[lindx + 2] = z1; lpos[lindx + 5] = z2;
            lindx += 6;
         }
      }

      if (loop === 0) {
         if (nsegments === 0) return;
         lpos = new Float32Array(nsegments * 6);
         binindx = new Int32Array(nsegments / 3);
      }
   }

    // create lines
    const lcolor = is_v7 ? painter.v7EvalColor('line_color', 'lightblue') : painter.getColor(histo.fLineColor),
          material = new LineBasicMaterial({ color: new Color$1(lcolor), linewidth: is_v7 ? painter.v7EvalAttr('line_width', 1) : histo.fLineWidth }),
          line = createLineSegments(lpos, material);

    line.painter = painter;
    line.intersect_index = binindx;
    line.zmin = zmin;
    line.zmax = zmax;
    line.tip_color = (histo.fLineColor === 3) ? 0xFF0000 : 0x00FF00;

    line.tooltip = function(intersect) {
       if (!Number.isInteger(intersect.index)) {
          console.error(`segment index not provided, three.js version ${REVISION}`);
          return null;
       }

       let pos = Math.floor(intersect.index / 6);
       if ((pos < 0) || (pos >= this.intersect_index.length)) return null;
       let p = this.painter,
           histo = p.getHisto(),
           main = p.getFramePainter(),
           tip = p.get3DToolTip(this.intersect_index[pos]);

       tip.x1 = Math.max(-main.size_x3d, main.grx(histo.fXaxis.GetBinLowEdge(tip.ix)));
       tip.x2 = Math.min(main.size_x3d, main.grx(histo.fXaxis.GetBinLowEdge(tip.ix+1)));
       tip.y1 = Math.max(-main.size_y3d, main.gry(histo.fYaxis.GetBinLowEdge(tip.iy)));
       tip.y2 = Math.min(main.size_y3d, main.gry(histo.fYaxis.GetBinLowEdge(tip.iy+1)));

       tip.z1 = main.grz(tip.value-tip.error < this.zmin ? this.zmin : tip.value-tip.error);
       tip.z2 = main.grz(tip.value+tip.error > this.zmax ? this.zmax : tip.value+tip.error);

       tip.color = this.tip_color;

       return tip;
    };

    main.toplevel.add(line);
}

/** @summary Draw TH2 as 3D contour plot
  * @private */
function drawBinsContour3D(painter, realz = false, is_v7 = false) {
   // for contour plots one requires handle with full range
   let main = painter.getFramePainter(),
       handle = painter.prepareDraw({rounding: false, use3d: true, extra: 100, middle: 0.0 }),
       histo = painter.getHisto(), // get levels
       levels = painter.getContourLevels(), // init contour if not exists
       palette = painter.getHistPalette(),
       layerz = 2*main.size_z3d, pnts = [];

   painter.buildContour(handle, levels, palette,
      (colindx, xp, yp, iminus, iplus, ilevel) => {
          // ignore less than three points
          if (iplus - iminus < 3) return;

          if (realz) {
             layerz = main.grz(levels[ilevel]);
             if ((layerz < 0) || (layerz > 2*main.size_z3d)) return;
          }

          for (let i=iminus;i<iplus;++i) {
             pnts.push(xp[i], yp[i], layerz);
             pnts.push(xp[i+1], yp[i+1], layerz);
          }
      }
   );

   let lines = createLineSegments(pnts, create3DLineMaterial(painter, is_v7 ? 'line_' : histo));
   main.toplevel.add(lines);
}


/** @summary Draw TH2 histograms in surf mode
  * @private */
function drawBinsSurf3D(painter, is_v7 = false) {
   let histo = painter.getHisto(),
       main = painter.getFramePainter(),
       handle = painter.prepareDraw({rounding: false, use3d: true, extra: 1, middle: 0.5 }),
       i,j, x1, y1, x2, y2, z11, z12, z21, z22,
       axis_zmin = main.z_handle.getScaleMin();
       // axis_zmax = main.z_handle.getScaleMax();

   // first adjust ranges

   let main_grz = !main.logz ? main.grz : value => (value < axis_zmin) ? -0.1 : main.grz(value);

   if ((handle.i2 - handle.i1 < 2) || (handle.j2 - handle.j1 < 2)) return;

   let ilevels = null, levels = null, dolines = true, dogrid = false,
       donormals = false, palette = null;

   if (is_v7) {
      let need_palette = 0;
      switch(painter.options.Surf) {
         case 11: need_palette = 2; break;
         case 12:
         case 15: // make surf5 same as surf2
         case 17: need_palette = 2; dolines = false; break;
         case 14: dolines = false; donormals = true; break;
         case 16: need_palette = 1; dogrid = true; dolines = false; break;
         default: ilevels = main.z_handle.createTicks(true); dogrid = true; break;
      }

      if (need_palette > 0) {
         palette = main.getHistPalette();
         if (need_palette == 2)
            painter.createContour(main, palette, { full_z_range: true });
         ilevels = palette.getContour();
      }

   } else {
      switch(painter.options.Surf) {
         case 11: ilevels = painter.getContourLevels(); palette = painter.getHistPalette(); break;
         case 12:
         case 15: // make surf5 same as surf2
         case 17: ilevels = painter.getContourLevels(); palette = painter.getHistPalette(); dolines = false; break;
         case 14: dolines = false; donormals = true; break;
         case 16: ilevels = painter.getContourLevels(); dogrid = true; dolines = false; break;
         default: ilevels = main.z_handle.createTicks(true); dogrid = true; break;
      }
   }

   if (ilevels) {
      // recalculate levels into graphical coordinates
      levels = new Float32Array(ilevels.length);
      for (let ll=0;ll<ilevels.length;++ll)
         levels[ll] = main_grz(ilevels[ll]);
   } else {
      levels = [0, 2*main.size_z3d]; // just cut top/bottom parts
   }

   let loop, nfaces = [], pos = [], indx = [],    // buffers for faces
       nsegments = 0, lpos = null, lindx = 0,     // buffer for lines
       ngridsegments = 0, grid = null, gindx = 0, // buffer for grid lines segments
       normindx = [];                             // buffer to remember place of vertex for each bin

   function CheckSide(z,level1, level2) {
      if (z<level1) return -1;
      if (z>level2) return 1;
      return 0;
   }

   function AddLineSegment(x1,y1,z1, x2,y2,z2) {
      if (!dolines) return;
      let side1 = CheckSide(z1,0,2*main.size_z3d),
          side2 = CheckSide(z2,0,2*main.size_z3d);
      if ((side1 === side2) && (side1 !== 0)) return;
      if (!loop) return ++nsegments;

      if (side1 !== 0) {
         let diff = z2 - z1;
         z1 = (side1 < 0) ? 0 : 2*main.size_z3d;
         x1 = x2 - (x2-x1)/diff*(z2-z1);
         y1 = y2 - (y2-y1)/diff*(z2-z1);
      }
      if (side2 !== 0) {
         let diff = z1 - z2;
         z2 = (side2 < 0) ? 0 : 2*main.size_z3d;
         x2 = x1 - (x1-x2)/diff*(z1-z2);
         y2 = y1 - (y1-y2)/diff*(z1-z2);
      }

      lpos[lindx] = x1; lpos[lindx+1] = y1; lpos[lindx+2] = z1; lindx+=3;
      lpos[lindx] = x2; lpos[lindx+1] = y2; lpos[lindx+2] = z2; lindx+=3;
   }

   let pntbuf = new Float32Array(6*3), k = 0, lastpart = 0, // maximal 6 points
       gridpnts = new Float32Array(2*3), gridcnt = 0;

   function AddCrossingPoint(xx1,yy1,zz1, xx2,yy2,zz2, crossz, with_grid) {
      if (k>=pntbuf.length) console.log('more than 6 points???');

      let part = (crossz - zz1) / (zz2 - zz1), shift = 3;
      if ((lastpart !== 0) && (Math.abs(part) < Math.abs(lastpart))) {
         // while second crossing point closer than first to original, move it in memory
         pntbuf[k] = pntbuf[k-3];
         pntbuf[k+1] = pntbuf[k-2];
         pntbuf[k+2] = pntbuf[k-1];
         k-=3; shift = 6;
      }

      pntbuf[k] = xx1 + part*(xx2-xx1);
      pntbuf[k+1] = yy1 + part*(yy2-yy1);
      pntbuf[k+2] = crossz;

      if (with_grid && grid) {
         gridpnts[gridcnt] = pntbuf[k];
         gridpnts[gridcnt+1] = pntbuf[k+1];
         gridpnts[gridcnt+2] = pntbuf[k+2];
         gridcnt+=3;
      }

      k += shift;
      lastpart = part;
   }

   function RememberVertex(indx, ii,jj) {
      let bin = ((ii-handle.i1) * (handle.j2-handle.j1) + (jj-handle.j1))*8;

      if (normindx[bin] >= 0)
         return console.error('More than 8 vertexes for the bin');

      let pos = bin+8+normindx[bin]; // position where write index
      normindx[bin]--;
      normindx[pos] = indx; // at this moment index can be overwritten, means all 8 position are there
   }

   function RecalculateNormals(arr) {
      for (let ii=handle.i1;ii<handle.i2;++ii) {
         for (let jj=handle.j1;jj<handle.j2;++jj) {
            let bin = ((ii-handle.i1) * (handle.j2-handle.j1) + (jj-handle.j1)) * 8;

            if (normindx[bin] === -1) continue; // nothing there

            let beg = (normindx[bin]  >= 0) ? bin : bin+9+normindx[bin],
                end = bin+8, sumx=0, sumy = 0, sumz = 0;

            for (let kk=beg;kk<end;++kk) {
               let indx = normindx[kk];
               if (indx < 0) return console.error('FAILURE in NORMALS RECALCULATIONS');
               sumx+=arr[indx];
               sumy+=arr[indx+1];
               sumz+=arr[indx+2];
            }

            sumx = sumx/(end-beg); sumy = sumy/(end-beg); sumz = sumz/(end-beg);

            for (let kk=beg;kk<end;++kk) {
               let indx = normindx[kk];
               arr[indx] = sumx;
               arr[indx+1] = sumy;
               arr[indx+2] = sumz;
            }
         }
      }
   }

   function AddMainTriangle(x1,y1,z1, x2,y2,z2, x3,y3,z3, is_first) {

      for (let lvl=1;lvl<levels.length;++lvl) {

         let side1 = CheckSide(z1, levels[lvl-1], levels[lvl]),
             side2 = CheckSide(z2, levels[lvl-1], levels[lvl]),
             side3 = CheckSide(z3, levels[lvl-1], levels[lvl]),
             side_sum = side1 + side2 + side3;

         if (side_sum === 3) continue;
         if (side_sum === -3) return;

         if (!loop) {
            let npnts = Math.abs(side2-side1) + Math.abs(side3-side2) + Math.abs(side1-side3);
            if (side1 === 0) ++npnts;
            if (side2 === 0) ++npnts;
            if (side3 === 0) ++npnts;

            if ((npnts === 1) || (npnts === 2)) console.error(`FOUND npnts = ${npnts}`);

            if (npnts > 2) {
               if (nfaces[lvl] === undefined) nfaces[lvl] = 0;
               nfaces[lvl] += npnts-2;
            }

            // check if any(contours for given level exists
            if (((side1 > 0) || (side2 > 0) || (side3 > 0)) &&
                ((side1!==side2) || (side2!==side3) || (side3!==side1))) ++ngridsegments;

            continue;
         }

         gridcnt = 0;

         k = 0;
         if (side1 === 0) { pntbuf[k] = x1; pntbuf[k+1] = y1; pntbuf[k+2] = z1; k += 3; }

         if (side1!==side2) {
            // order is important, should move from 1->2 point, checked via lastpart
            lastpart = 0;
            if ((side1 < 0) || (side2 < 0)) AddCrossingPoint(x1,y1,z1, x2,y2,z2, levels[lvl-1]);
            if ((side1 > 0) || (side2 > 0)) AddCrossingPoint(x1,y1,z1, x2,y2,z2, levels[lvl], true);
         }

         if (side2 === 0) { pntbuf[k] = x2; pntbuf[k+1] = y2; pntbuf[k+2] = z2; k += 3; }

         if (side2!==side3) {
            // order is important, should move from 2->3 point, checked via lastpart
            lastpart = 0;
            if ((side2 < 0) || (side3 < 0)) AddCrossingPoint(x2,y2,z2, x3,y3,z3, levels[lvl-1]);
            if ((side2 > 0) || (side3 > 0)) AddCrossingPoint(x2,y2,z2, x3,y3,z3, levels[lvl], true);
         }

         if (side3 === 0) { pntbuf[k] = x3; pntbuf[k+1] = y3; pntbuf[k+2] = z3; k+=3; }

         if (side3 !== side1) {
            // order is important, should move from 3->1 point, checked via lastpart
            lastpart = 0;
            if ((side3 < 0) || (side1 < 0)) AddCrossingPoint(x3,y3,z3, x1,y1,z1, levels[lvl-1]);
            if ((side3 > 0) || (side1 > 0)) AddCrossingPoint(x3,y3,z3, x1,y1,z1, levels[lvl], true);
         }

         if (k === 0) continue;
         if (k < 9) { console.log('found less than 3 points', k/3); continue; }

         if (grid && (gridcnt === 6)) {
            for (let jj = 0; jj < 6; ++jj)
               grid[gindx+jj] = gridpnts[jj];
            gindx+=6;
         }


         // if three points and surf == 14, remember vertex for each point

         let buf = pos[lvl], s = indx[lvl];
         if (donormals && (k===9)) {
            RememberVertex(s, i, j);
            RememberVertex(s+3, i+1, is_first ? j+1 : j);
            RememberVertex(s+6, is_first ? i : i+1, j+1);
         }

         for (let k1 = 3; k1 < k-3; k1 += 3) {
            buf[s] = pntbuf[0]; buf[s+1] = pntbuf[1]; buf[s+2] = pntbuf[2]; s+=3;
            buf[s] = pntbuf[k1]; buf[s+1] = pntbuf[k1+1]; buf[s+2] = pntbuf[k1+2]; s+=3;
            buf[s] = pntbuf[k1+3]; buf[s+1] = pntbuf[k1+4]; buf[s+2] = pntbuf[k1+5]; s+=3;
         }
         indx[lvl] = s;

      }
   }

   if (donormals)
      // for each bin maximal 8 points reserved
      normindx = new Int32Array((handle.i2-handle.i1)*(handle.j2-handle.j1)*8).fill(-1);

   for (loop = 0; loop < 2; ++loop) {
      if (loop) {
         for (let lvl = 1; lvl < levels.length; ++lvl)
            if (nfaces[lvl]) {
               pos[lvl] = new Float32Array(nfaces[lvl] * 9);
               indx[lvl] = 0;
            }
         if (dolines && (nsegments > 0))
            lpos = new Float32Array(nsegments * 6);
         if (dogrid && (ngridsegments > 0))
            grid = new Float32Array(ngridsegments * 6);
      }
      for (i = handle.i1;i < handle.i2-1; ++i) {
         x1 = handle.grx[i];
         x2 = handle.grx[i+1];
         for (j = handle.j1; j < handle.j2-1; ++j) {
            y1 = handle.gry[j];
            y2 = handle.gry[j+1];
            z11 = main_grz(histo.getBinContent(i+1, j+1));
            z12 = main_grz(histo.getBinContent(i+1, j+2));
            z21 = main_grz(histo.getBinContent(i+2, j+1));
            z22 = main_grz(histo.getBinContent(i+2, j+2));

            AddMainTriangle(x1,y1,z11, x2,y2,z22, x1,y2,z12, true);

            AddMainTriangle(x1,y1,z11, x2,y1,z21, x2,y2,z22, false);

            AddLineSegment(x1,y2,z12, x1,y1,z11);
            AddLineSegment(x1,y1,z11, x2,y1,z21);

            if (i===handle.i2-2) AddLineSegment(x2,y1,z21, x2,y2,z22);
            if (j===handle.j2-2) AddLineSegment(x1,y2,z12, x2,y2,z22);
         }
      }
   }

   for (let lvl = 1; lvl < levels.length; ++lvl)
      if (pos[lvl]) {
         if (indx[lvl] !== nfaces[lvl]*9)
              console.error(`SURF faces missmatch lvl=${lvl} faces=${nfaces[lvl]} index=${indx[lvl]} check=${nfaces[lvl]*9 - indx[lvl]}`);
         let geometry = new BufferGeometry();
         geometry.setAttribute('position', new BufferAttribute(pos[lvl], 3));
         geometry.computeVertexNormals();
         if (donormals && (lvl === 1)) RecalculateNormals(geometry.getAttribute('normal').array);

         let fcolor, material;
         if (is_v7) {
            fcolor = palette ? palette.getColor(lvl-1) : painter.getColor(5);
         } else if (palette) {
            fcolor = palette.calcColor(lvl, levels.length);
         } else {
            fcolor = histo.fFillColor > 1 ? painter.getColor(histo.fFillColor) : 'white';
            if ((painter.options.Surf === 14) && (histo.fFillColor < 2)) fcolor = painter.getColor(48);
         }
         if (painter.options.Surf === 14)
            material = new MeshLambertMaterial({ color: fcolor, side: DoubleSide, vertexColors: false });
         else
            material = new MeshBasicMaterial({ color: fcolor, side: DoubleSide, vertexColors: false });

         let mesh = new Mesh(geometry, material);

         main.toplevel.add(mesh);

         mesh.painter = painter; // to let use it with context menu
      }


   if (lpos) {
      if (nsegments*6 !== lindx)
         console.error(`SURF lines mismmatch nsegm=${nsegments} lindx=${lindx} diff=${nsegments*6 - lindx}`);

      const lcolor = painter.getColor(histo.fLineColor),
            material = new LineBasicMaterial({ color: new Color$1(lcolor), linewidth: histo.fLineWidth }),
            line = createLineSegments(lpos, material);
      line.painter = painter;
      main.toplevel.add(line);
   }

   if (grid) {
      if (ngridsegments*6 !== gindx)
         console.error(`SURF grid draw mismatch ngridsegm=${ngridsegments} gindx=${gindx} diff=${ngridsegments*6 - gindx}`);

      const material = (painter.options.Surf === 1)
                      ? new LineDashedMaterial({ color: 0x0, dashSize: 2, gapSize: 2 })
                      : new LineBasicMaterial({ color: new Color$1(painter.getColor(histo.fLineColor)) }),
           line = createLineSegments(grid, material);
      line.painter = painter;
      main.toplevel.add(line);
   }

   if (painter.options.Surf === 17)
      drawBinsContour3D(painter, false, is_v7);

   if (painter.options.Surf === 13) {

      handle = painter.prepareDraw({rounding: false, use3d: true, extra: 100, middle: 0.0 });

      // get levels
      let levels = painter.getContourLevels(), // init contour
          palette = painter.getHistPalette(),
          lastcolindx = -1, layerz = 2*main.size_z3d;

      painter.buildContour(handle, levels, palette,
         (colindx,xp,yp,iminus,iplus) => {
             // no need for duplicated point
             if ((xp[iplus] === xp[iminus]) && (yp[iplus] === yp[iminus])) iplus--;

             // ignore less than three points
             if (iplus - iminus < 3) return;

             let pnts = [];

             for (let i = iminus; i <= iplus; ++i)
                if ((i === iminus) || (xp[i] !== xp[i-1]) || (yp[i] !== yp[i-1]))
                   pnts.push(new Vector2(xp[i], yp[i]));

             if (pnts.length < 3) return;

             const faces = ShapeUtils.triangulateShape(pnts , []);

             if (!faces || (faces.length === 0)) return;

             if ((lastcolindx < 0) || (lastcolindx !== colindx)) {
                lastcolindx = colindx;
                layerz+=0.0001*main.size_z3d; // change layers Z
             }

             const pos = new Float32Array(faces.length*9),
                   norm = new Float32Array(faces.length*9);
             let indx = 0;

             for (let n = 0; n < faces.length; ++n) {
                let face = faces[n];
                for (let v = 0; v < 3; ++v) {
                   let pnt = pnts[face[v]];
                   pos[indx] = pnt.x;
                   pos[indx+1] = pnt.y;
                   pos[indx+2] = layerz;
                   norm[indx] = 0;
                   norm[indx+1] = 0;
                   norm[indx+2] = 1;

                   indx+=3;
                }
             }

             const geometry = new BufferGeometry();
             geometry.setAttribute('position', new BufferAttribute(pos, 3));
             geometry.setAttribute('normal', new BufferAttribute(norm, 3));

             const material = new MeshBasicMaterial({ color: palette.getColor(colindx), side: DoubleSide, opacity: 0.5, vertexColors: false }),
                   mesh = new Mesh(geometry, material);
             mesh.painter = painter;
             main.toplevel.add(mesh);
         }
      );
   }
}

/** @summary Return time offset value for given TAxis object
  * @private */
function getTimeOffset(axis) {
   let dflt_time_offset = 788918400000;
   if (!axis) return dflt_time_offset;
   let idF = axis.fTimeFormat.indexOf('%F');
   if (idF < 0) return gStyle.fTimeOffset * 1000;
   let sof = axis.fTimeFormat.slice(idF + 2);
   // default string in axis offset
   if (sof.indexOf('1995-01-01 00:00:00s0') == 0) return dflt_time_offset;
   // special case, used from DABC painters
   if ((sof == '0') || (sof == '')) return 0;

   // decode time from ROOT string
   const next = (separ, min, max) => {
      let pos = sof.indexOf(separ);
      if (pos < 0) return min;
      let val = parseInt(sof.slice(0, pos));
      sof = sof.slice(pos + 1);
      if (!Number.isInteger(val) || (val < min) || (val > max)) return min;
      return val;
   }, year = next('-', 1970, 2300),
      month = next('-', 1, 12) - 1,
      day = next(' ', 1, 31),
      hour = next(':', 0, 23),
      min = next(':', 0, 59),
      sec = next('s', 0, 59),
      msec = next(' ', 0, 999),
      dt = new Date(Date.UTC(year, month, day, hour, min, sec, msec));

   let offset = dt.getTime();

   // now also handle suffix like GMT or GMT -0600
   sof = sof.toUpperCase();

   if (sof.indexOf('GMT') == 0) {
      offset += dt.getTimezoneOffset() * 60000;
      sof = sof.slice(4).trim();
      if (sof.length > 3) {
         let p = 0, sign = 1000;
         if (sof[0] == '-') { p = 1; sign = -1000; }
         offset -= sign * (parseInt(sof.slice(p, p+2)) * 3600 + parseInt(sof.slice(p+2, p+4)) * 60);
      }
   }

   return offset;
}


/** @summary Tries to choose time format for provided time interval
  * @private */
function chooseTimeFormat(awidth, ticks) {
   if (awidth < .5) return ticks ? '%S.%L' : '%H:%M:%S.%L';
   if (awidth < 30) return ticks ? '%Mm%S' : '%H:%M:%S';
   awidth /= 60; if (awidth < 30) return ticks ? '%Hh%M' : '%d/%m %H:%M';
   awidth /= 60; if (awidth < 12) return ticks ? '%d-%Hh' : '%d/%m/%y %Hh';
   awidth /= 24; if (awidth < 15.218425) return ticks ? '%d/%m' : '%d/%m/%y';
   awidth /= 30.43685; if (awidth < 6) return '%d/%m/%y';
   awidth /= 12; if (awidth < 2) return ticks ? '%m/%y' : '%d/%m/%y';
   return '%Y';
}

/**
  * @summary Base axis painter methods
  *
  * @private
  */

const AxisPainterMethods = {

   initAxisPainter() {
      this.name = 'yaxis';
      this.kind = 'normal';
      this.func = null;
      this.order = 0; // scaling order for axis labels

      this.full_min = 0;
      this.full_max = 1;
      this.scale_min = 0;
      this.scale_max = 1;
      this.ticks = []; // list of major ticks
   },

   /** @summary Cleanup axis painter */
   cleanupAxisPainter() {
      this.ticks = [];
      delete this.format;
      delete this.func;
      delete this.tfunc1;
      delete this.tfunc2;
      delete this.gr;
   },

   /** @summary Assign often used members of frame painter */
   assignFrameMembers(fp, axis) {
      fp['gr'+axis] = this.gr;                    // fp.grx
      fp['log'+axis] = this.log;                  // fp.logx
      fp[`scale_${axis}min`] = this.scale_min;   // fp.scale_xmin
      fp[`scale_${axis}max`] = this.scale_max;   // fp.scale_xmax
   },

   /** @summary Convert axis value into the Date object */
   convertDate(v) {
      return new Date(this.timeoffset + v*1000);
   },

   /** @summary Convert graphical point back into axis value */
   revertPoint(pnt) {
      let value = this.func.invert(pnt);
      return (this.kind == 'time') ?  (value - this.timeoffset) / 1000 : value;
   },

   /** @summary Provide label for time axis */
   formatTime(d, asticks) {
      return asticks ? this.tfunc1(d) : this.tfunc2(d);
   },

   /** @summary Provide label for log axis */
   formatLog(d, asticks, fmt) {
      let val = parseFloat(d), rnd = Math.round(val);
      if (!asticks)
         return ((rnd === val) && (Math.abs(rnd) < 1e9)) ? rnd.toString() : floatToString(val, fmt || gStyle.fStatFormat);
      if (val <= 0) return null;
      let vlog = Math.log10(val), base = this.logbase;
      if (base !== 10) vlog = vlog / Math.log10(base);
      if (this.moreloglabels || (Math.abs(vlog - Math.round(vlog)) < 0.001)) {
         if (!this.noexp && (asticks != 2))
            return this.formatExp(base, Math.floor(vlog+0.01), val);

         return vlog < 0 ? val.toFixed(Math.round(-vlog+0.5)) : val.toFixed(0);
      }
      return null;
   },

   /** @summary Provide label for normal axis */
   formatNormal(d, asticks, fmt) {
      let val = parseFloat(d);
      if (asticks && this.order) val = val / Math.pow(10, this.order);

      if (val === Math.round(val))
         return Math.abs(val) < 1e9 ? val.toFixed(0) : val.toExponential(4);

      if (asticks) return (this.ndig>10) ? val.toExponential(this.ndig-11) : val.toFixed(this.ndig);

      return floatToString(val, fmt || gStyle.fStatFormat);
   },

   /** @summary Provide label for exponential form */
   formatExp(base, order, value) {
      let res = '';
      if (value) {
         value = Math.round(value/Math.pow(base,order));
         if ((value!=0) && (value!=1)) res = value.toString() + (settings.Latex ? '#times' : 'x');
      }
      if (Math.abs(base-Math.exp(1)) < 0.001)
         res += 'e';
      else
         res += base.toString();
      if (settings.Latex > constants$1.Latex.Symbols)
         return res + `^{${order}}`;
      const superscript_symbols = {
            '0': '\u2070', '1': '\xB9', '2': '\xB2', '3': '\xB3', '4': '\u2074', '5': '\u2075',
            '6': '\u2076', '7': '\u2077', '8': '\u2078', '9': '\u2079', '-': '\u207B'
         };
      let str = order.toString();
      for (let n = 0; n < str.length; ++n)
         res += superscript_symbols[str[n]];
      return res;
   },

   /** @summary Convert 'raw' axis value into text */
   axisAsText(value, fmt) {
      if (this.kind == 'time')
         value = this.convertDate(value);
      if (this.format)
         return this.format(value, false, fmt);
      return value.toPrecision(4);
   },

   /** @summary Produce ticks for d3.scaleLog
     * @desc Fixing following problem, described [here]{@link https://stackoverflow.com/questions/64649793} */
   poduceLogTicks(func, number) {
      const linearArray = arr => {
         let sum1 = 0, sum2 = 0;
         for (let k = 1; k < arr.length; ++k) {
            let diff = (arr[k] - arr[k-1]);
            sum1 += diff;
            sum2 += diff**2;
         }
         let mean = sum1/(arr.length-1),
             dev = sum2/(arr.length-1) - mean**2;

         if (dev <= 0) return true;
         if (Math.abs(mean) < 1e-100) return false;
         return Math.sqrt(dev)/mean < 1e-6;
      };

      let arr = func.ticks(number);

      while ((number > 4) && linearArray(arr)) {
         number = Math.round(number*0.8);
         arr = func.ticks(number);
      }

      // if still linear array, try to sort out 'bad' ticks
      if ((number < 5) && linearArray(arr) && this.logbase && (this.logbase != 10)) {
         let arr2 = [];
         arr.forEach(val => {
            let pow = Math.log10(val) / Math.log10(this.logbase);
            if (Math.abs(Math.round(pow) - pow) < 0.01) arr2.push(val);
         });
         if (arr2.length > 0) arr = arr2;
      }

      return arr;
   },

   /** @summary Produce axis ticks */
   produceTicks(ndiv, ndiv2) {
      if (!this.noticksopt) {
         let total = ndiv * (ndiv2 || 1);

         if (this.log) return this.poduceLogTicks(this.func, total);

         let dom = this.func.domain();

         const check = ticks => {
            if (ticks.length <= total) return true;
            if (ticks.length > total + 1) return false;
            return (ticks[0] === dom[0]) || (ticks[total] === dom[1]); // special case of N+1 ticks, but match any range
         };

         let res1 = this.func.ticks(total);
         if (ndiv2 || check(res1)) return res1;

         let res2 = this.func.ticks(Math.round(total * 0.7));
         return (res2.length > 2) && check(res2) ? res2 : res1;
      }

      let dom = this.func.domain(), ticks = [];
      if (ndiv2) ndiv = (ndiv-1) * ndiv2;
      for (let n = 0; n <= ndiv; ++n)
         ticks.push((dom[0]*(ndiv-n) + dom[1]*n)/ndiv);
      return ticks;
   },

   /** @summary Method analyze mouse wheel event and returns item with suggested zooming range */
   analyzeWheelEvent(evnt, dmin, item, test_ignore) {
      if (!item) item = {};

      let delta = 0, delta_left = 1, delta_right = 1;

      if ('dleft' in item) { delta_left = item.dleft; delta = 1; }
      if ('dright' in item) { delta_right = item.dright; delta = 1; }

      if (item.delta) {
         delta = item.delta;
      } else if (evnt) {
         delta = evnt.wheelDelta ? -evnt.wheelDelta : (evnt.deltaY || evnt.detail);
      }

      if (!delta || (test_ignore && item.ignore)) return;

      delta = (delta < 0) ? -0.2 : 0.2;
      delta_left *= delta;
      delta_right *= delta;

      let lmin = item.min = this.scale_min,
          lmax = item.max = this.scale_max,
          gmin = this.full_min,
          gmax = this.full_max;

      if ((item.min === item.max) && (delta < 0)) {
         item.min = gmin;
         item.max = gmax;
      }

      if (item.min >= item.max) return;

      if (item.reverse) dmin = 1 - dmin;

      if ((dmin > 0) && (dmin < 1)) {
         if (this.log) {
            let factor = (item.min > 0) ? Math.log10(item.max/item.min) : 2;
            if (factor>10) factor = 10; else if (factor < 0.01) factor = 0.01;
            item.min = item.min / Math.pow(10, factor*delta_left*dmin);
            item.max = item.max * Math.pow(10, factor*delta_right*(1-dmin));
         } else if ((delta_left === -delta_right) && !item.reverse) {
            // shift left/right, try to keep range constant
            let delta = (item.max - item.min) * delta_right * dmin;

            if ((Math.round(item.max) === item.max) && (Math.round(item.min) === item.min) && (Math.abs(delta) > 1)) delta = Math.round(delta);

            if (item.min + delta < gmin)
               delta = gmin - item.min;
            else if (item.max + delta > gmax)
               delta = gmax - item.max;

            if (delta != 0) {
               item.min += delta;
               item.max += delta;
             } else {
               delete item.min;
               delete item.max;
            }

         } else {
            let rx_left = (item.max - item.min), rx_right = rx_left;
            if (delta_left > 0) rx_left = 1.001 * rx_left / (1-delta_left);
            item.min += -delta_left*dmin*rx_left;
            if (delta_right > 0) rx_right = 1.001 * rx_right / (1-delta_right);
            item.max -= -delta_right*(1-dmin)*rx_right;
         }
         if (item.min >= item.max) {
            item.min = item.max = undefined;
         } else if (delta_left !== delta_right) {
            // extra check case when moving left or right
            if (((item.min < gmin) && (lmin === gmin)) ||
                ((item.max > gmax) && (lmax === gmax)))
                   item.min = item.max = undefined;
         } else {
            if (item.min < gmin) item.min = gmin;
            if (item.max > gmax) item.max = gmax;
         }
      } else {
         item.min = item.max = undefined;
      }

      item.changed = ((item.min !== undefined) && (item.max !== undefined));

      return item;
   }

}; // AxisPainterMethods


/**
 * @summary Painter for TAxis/TGaxis objects
 *
 * @private
 */

class TAxisPainter extends ObjectPainter {

   /** @summary constructor
     * @param {object|string} dom - identifier or dom element
     * @param {object} axis - object to draw
     * @param {boolean} embedded - if true, painter used in other objects painters */
   constructor(dom, axis, embedded) {
      super(dom, axis);

      Object.assign(this, AxisPainterMethods);
      this.initAxisPainter();

      this.embedded = embedded; // indicate that painter embedded into the histo painter
      this.invert_side = false;
      this.lbls_both_sides = false; // draw labels on both sides
   }

   /** @summary cleanup painter */
   cleanup() {
      this.cleanupAxisPainter();
      super.cleanup();
   }

   /** @summary Use in GED to identify kind of axis */
   getAxisType() { return clTAxis; }

   /** @summary Configure axis painter
     * @desc Axis can be drawn inside frame <g> group with offset to 0 point for the frame
     * Therefore one should distinguish when caclulated coordinates used for axis drawing itself or for calculation of frame coordinates
     * @private */
   configureAxis(name, min, max, smin, smax, vertical, range, opts) {
      this.name = name;
      this.full_min = min;
      this.full_max = max;
      this.kind = 'normal';
      this.vertical = vertical;
      this.log = opts.log || 0;
      this.symlog = opts.symlog || false;
      this.reverse = opts.reverse || false;
      this.swap_side = opts.swap_side || false;
      this.fixed_ticks = opts.fixed_ticks || null;
      this.maxTickSize = opts.maxTickSize || 0;

      let axis = this.getObject();

      if (opts.time_scale || axis.fTimeDisplay) {
         this.kind = 'time';
         this.timeoffset = getTimeOffset(axis);
      } else {
         this.kind = !axis.fLabels ? 'normal' : 'labels';
      }

      if (this.kind == 'time') {
         this.func = time().domain([this.convertDate(smin), this.convertDate(smax)]);
      } else if (this.log) {
         this.logbase = this.log === 2 ? 2 : 10;
         if (smax <= 0) smax = 1;

         if ((smin <= 0) && axis && !opts.logcheckmin)
            for (let i = 0; i < axis.fNbins; ++i) {
               smin = Math.max(smin, axis.GetBinLowEdge(i+1));
               if (smin > 0) break;
            }

         if ((smin <= 0) && opts.log_min_nz)
            smin = opts.log_min_nz;

         if ((smin <= 0) || (smin >= smax))
            smin = smax * (opts.logminfactor || 1e-4);

         this.func = log().base((this.log == 2) ? 2 : 10).domain([smin,smax]);
      } else if (this.symlog) {
         let v = Math.max(Math.abs(smin), Math.abs(smax));
         if (Number.isInteger(this.symlog) && (this.symlog > 0))
            v *= Math.pow(10,-1*this.symlog);
         else
            v *= 0.01;
         this.func = symlog().constant(v).domain([smin,smax]);
      } else {
         this.func = linear().domain([smin,smax]);
      }

      if (this.vertical ^ this.reverse) {
         let d = range[0]; range[0] = range[1]; range[1] = d;
      }

      this.func.range(range);

      this.scale_min = smin;
      this.scale_max = smax;

      if (this.kind == 'time')
         this.gr = val => this.func(this.convertDate(val));
      else if (this.log)
         this.gr = val => (val < this.scale_min) ? (this.vertical ? this.func.range()[0]+5 : -5) : this.func(val);
      else
         this.gr = this.func;

      let is_gaxis = (axis?._typename === clTGaxis);

      delete this.format;// remove formatting func

      let ndiv = 508;
      if (is_gaxis)
         ndiv = axis.fNdiv;
       else if (axis)
          ndiv = Math.max(axis.fNdivisions, 4);

      this.nticks = ndiv % 100;
      this.nticks2 = (ndiv % 10000 - this.nticks) / 100;
      this.nticks3 = Math.floor(ndiv/10000);

      if (axis && !is_gaxis && (this.nticks > 20)) this.nticks = 20;

      let gr_range = Math.abs(this.func.range()[1] - this.func.range()[0]);
      if (gr_range <= 0) gr_range = 100;

      if (this.kind == 'time') {
         if (this.nticks > 8) this.nticks = 8;

         let scale_range = this.scale_max - this.scale_min,
             idF = axis.fTimeFormat.indexOf('%F'),
             tf1 = (idF >= 0) ? axis.fTimeFormat.slice(0, idF) : axis.fTimeFormat,
             tf2 = chooseTimeFormat(scale_range / gr_range, false);

         if (!tf1 || (scale_range < 0.1 * (this.full_max - this.full_min)))
            tf1 = chooseTimeFormat(scale_range / this.nticks, true);

         this.tfunc1 = this.tfunc2 = timeFormat(tf1);
         if (tf2 !== tf1)
            this.tfunc2 = timeFormat(tf2);

         this.format = this.formatTime;

      } else if (this.log) {
         if (this.nticks2 > 1) {
            this.nticks *= this.nticks2; // all log ticks (major or minor) created centrally
            this.nticks2 = 1;
         }
         this.noexp = axis ? axis.TestBit(EAxisBits.kNoExponent) : false;
         if ((this.scale_max < 300) && (this.scale_min > 0.3)) this.noexp = true;
         this.moreloglabels = axis ? axis.TestBit(EAxisBits.kMoreLogLabels) : false;

         this.format = this.formatLog;

      } else if (this.kind == 'labels') {
         this.nticks = 50; // for text output allow max 50 names
         let scale_range = this.scale_max - this.scale_min;
         if (this.nticks > scale_range)
            this.nticks = Math.round(scale_range);

         this.regular_labels = true;

         if (axis && axis.fNbins && axis.fLabels) {
            if ((axis.fNbins != Math.round(axis.fXmax - axis.fXmin)) ||
                (axis.fXmin != 0) || (axis.fXmax != axis.fNbins)) {
               this.regular_labels = false;
            }
         }

         this.nticks2 = 1;

         this.format = this.formatLabels;
      } else {
         this.order = 0;
         this.ndig = 0;
         this.format = this.formatNormal;
      }
   }

   /** @summary Return scale min */
   getScaleMin() {
      return this.func ? this.func.domain()[0] : 0;
   }

   /** @summary Return scale max */
   getScaleMax() {
      return this.func ? this.func.domain()[1] : 0;
   }

   /** @summary Provide label for axis value */
   formatLabels(d) {
      let indx = parseFloat(d), a = this.getObject();
      if (!this.regular_labels)
         indx = Math.round((indx - a.fXmin)/(a.fXmax - a.fXmin) * a.fNbins);
      else
         indx = Math.floor(indx);
      if ((indx < 0) || (indx >= a.fNbins)) return null;
      for (let i = 0; i < a.fLabels.arr.length; ++i) {
         let tstr = a.fLabels.arr[i];
         if (tstr.fUniqueID === indx+1) return tstr.fString;
      }
      return null;
   }

   /** @summary Creates array with minor/middle/major ticks */
   createTicks(only_major_as_array, optionNoexp, optionNoopt, optionInt) {

      if (optionNoopt && this.nticks && (this.kind == 'normal'))
         this.noticksopt = true;

      let handle = { nminor: 0, nmiddle: 0, nmajor: 0, func: this.func }, ticks;

      if (this.fixed_ticks) {
         ticks = [];
         this.fixed_ticks.forEach(v => {
            if ((v >= this.scale_min) && (v <= this.scale_max)) ticks.push(v);
         });
      } else if ((this.kind == 'labels') && !this.regular_labels) {
         ticks = [];
         handle.lbl_pos = [];
         let axis = this.getObject();
         for (let n = 0; n < axis.fNbins; ++n) {
            let x = axis.fXmin + n / axis.fNbins * (axis.fXmax - axis.fXmin);
            if ((x >= this.scale_min) && (x < this.scale_max)) {
               handle.lbl_pos.push(x);
               if (x > this.scale_min) ticks.push(x);
            }
         }
      } else {
         ticks = this.produceTicks(this.nticks);
      }

      handle.minor = handle.middle = handle.major = ticks;

      if (only_major_as_array) {
         let res = handle.major, delta = (this.scale_max - this.scale_min)*1e-5;
         if (res[0] > this.scale_min + delta) res.unshift(this.scale_min);
         if (res[res.length-1] < this.scale_max - delta) res.push(this.scale_max);
         return res;
      }

      if ((this.nticks2 > 1) && (!this.log || (this.logbase === 10)) && !this.fixed_ticks) {
         handle.minor = handle.middle = this.produceTicks(handle.major.length, this.nticks2);

         let gr_range = Math.abs(this.func.range()[1] - this.func.range()[0]);

         // avoid black filling by middle-size
         if ((handle.middle.length <= handle.major.length) || (handle.middle.length > gr_range/3.5)) {
            handle.minor = handle.middle = handle.major;
         } else if ((this.nticks3 > 1) && !this.log)  {
            handle.minor = this.produceTicks(handle.middle.length, this.nticks3);
            if ((handle.minor.length <= handle.middle.length) || (handle.minor.length > gr_range/1.7))
               handle.minor = handle.middle;
         }
      }

      handle.reset = function() {
         this.nminor = this.nmiddle = this.nmajor = 0;
      };

      handle.next = function(doround) {
         if (this.nminor >= this.minor.length) return false;

         this.tick = this.minor[this.nminor++];
         this.grpos = this.func(this.tick);
         if (doround) this.grpos = Math.round(this.grpos);
         this.kind = 3;

         if ((this.nmiddle < this.middle.length) && (Math.abs(this.grpos - this.func(this.middle[this.nmiddle])) < 1)) {
            this.nmiddle++;
            this.kind = 2;
         }

         if ((this.nmajor < this.major.length) && (Math.abs(this.grpos - this.func(this.major[this.nmajor])) < 1) ) {
            this.nmajor++;
            this.kind = 1;
         }
         return true;
      };

      handle.last_major = function() {
         return (this.kind !== 1) ? false : this.nmajor == this.major.length;
      };

      handle.next_major_grpos = function() {
         if (this.nmajor >= this.major.length) return null;
         return this.func(this.major[this.nmajor]);
      };

      this.order = 0;
      this.ndig = 0;

      // at the moment when drawing labels, we can try to find most optimal text representation for them

      if ((this.kind == 'normal') && !this.log && (handle.major.length > 0)) {

         let maxorder = 0, minorder = 0, exclorder3 = false;

         if (!optionNoexp) {
            let maxtick = Math.max(Math.abs(handle.major[0]),Math.abs(handle.major[handle.major.length-1])),
                mintick = Math.min(Math.abs(handle.major[0]),Math.abs(handle.major[handle.major.length-1])),
                ord1 = (maxtick > 0) ? Math.round(Math.log10(maxtick)/3)*3 : 0,
                ord2 = (mintick > 0) ? Math.round(Math.log10(mintick)/3)*3 : 0;

             exclorder3 = (maxtick < 2e4); // do not show 10^3 for values below 20000

             if (maxtick || mintick) {
                maxorder = Math.max(ord1,ord2) + 3;
                minorder = Math.min(ord1,ord2) - 3;
             }
         }

         // now try to find best combination of order and ndig for labels

         let bestorder = 0, bestndig = this.ndig, bestlen = 1e10;

         for (let order = minorder; order <= maxorder; order+=3) {
            if (exclorder3 && (order===3)) continue;
            this.order = order;
            this.ndig = 0;
            let lbls = [], indx = 0, totallen = 0;
            while (indx < handle.major.length) {
               let lbl = this.format(handle.major[indx], true);
               if (lbls.indexOf(lbl) < 0) {
                  lbls.push(lbl);
                  totallen += lbl.length;
                  indx++;
                  continue;
               }
               if (++this.ndig > 15) break; // not too many digits, anyway it will be exponential
               lbls = []; indx = 0; totallen = 0;
            }

            // for order == 0 we should virtually remove '0.' and extra label on top
            if (!order && (this.ndig < 4))
               totallen -= handle.major.length * 2 + 3;

            if (totallen < bestlen) {
               bestlen = totallen;
               bestorder = this.order;
               bestndig = this.ndig;
            }
         }

         this.order = bestorder;
         this.ndig = bestndig;

         if (optionInt) {
            if (this.order) console.warn(`Axis painter - integer labels are configured, but axis order ${this.order} is preferable`);
            if (this.ndig) console.warn(`Axis painter - integer labels are configured, but ${this.ndig} decimal digits are required`);
            this.ndig = 0;
            this.order = 0;
         }
      }

      return handle;
   }

   /** @summary Is labels should be centered */
   isCenteredLabels() {
      if (this.kind === 'labels') return true;
      if (this.log) return false;
      let axis = this.getObject();
      return axis && axis.TestBit(EAxisBits.kCenterLabels);
   }

   /** @summary Add interactive elements to draw axes title */
   addTitleDrag(title_g, vertical, offset_k, reverse, axis_length) {
      if (!settings.MoveResize || isBatchMode()) return;

      let drag_rect = null,
          acc_x, acc_y, new_x, new_y, sign_0, alt_pos, curr_indx,
          drag_move = drag().subject(Object);

      drag_move
         .on('start', evnt => {

            evnt.sourceEvent.preventDefault();
            evnt.sourceEvent.stopPropagation();

            let box = title_g.node().getBBox(), // check that elements visible, request precise value
                title_length = vertical ? box.height : box.width;

            new_x = acc_x = title_g.property('shift_x');
            new_y = acc_y = title_g.property('shift_y');

            sign_0 = vertical ? (acc_x > 0) : (acc_y > 0); // sign should remain

            alt_pos = vertical ? [axis_length, axis_length/2, 0] : [0, axis_length/2, axis_length]; // possible positions
            let off = vertical ? -title_length/2 : title_length/2;
            if (this.title_align == 'middle') {
               alt_pos[0] +=  off;
               alt_pos[2] -=  off;
            } else if (this.title_align == 'begin') {
               alt_pos[1] -= off;
               alt_pos[2] -= 2*off;
            } else { // end
               alt_pos[0] += 2*off;
               alt_pos[1] += off;
            }

            if (this.titleCenter)
               curr_indx = 1;
            else if (reverse ^ this.titleOpposite)
               curr_indx = 0;
            else
               curr_indx = 2;

            alt_pos[curr_indx] = vertical ? acc_y : acc_x;

            drag_rect = title_g.append('rect')
                 .classed('zoom', true)
                 .attr('x', box.x)
                 .attr('y', box.y)
                 .attr('width', box.width)
                 .attr('height', box.height)
                 .style('cursor', 'move');
//                 .style('pointer-events','none'); // let forward double click to underlying elements
          }).on('drag', evnt => {
               if (!drag_rect) return;

               evnt.sourceEvent.preventDefault();
               evnt.sourceEvent.stopPropagation();

               acc_x += evnt.dx;
               acc_y += evnt.dy;

               let set_x, set_y, besti = 0,
                   p = vertical ? acc_y : acc_x;

               for (let i = 1; i < 3; ++i)
                  if (Math.abs(p - alt_pos[i]) < Math.abs(p - alt_pos[besti])) besti = i;

               if (vertical) {
                  set_x = acc_x;
                  set_y = alt_pos[besti];
               } else {
                  set_y = acc_y;
                  set_x = alt_pos[besti];
               }

               if (sign_0 === (vertical ? (set_x > 0) : (set_y > 0))) {
                  new_x = set_x; new_y = set_y; curr_indx = besti;
                  title_g.attr('transform', `translate(${new_x},${new_y})`);
               }

          }).on('end', evnt => {
               if (!drag_rect) return;

               evnt.sourceEvent.preventDefault();
               evnt.sourceEvent.stopPropagation();

               title_g.property('shift_x', new_x)
                      .property('shift_y', new_y);

               const axis = this.getObject(), abits = EAxisBits,
                     set_bit = (bit, on) => { if (axis.TestBit(bit) != on) axis.InvertBit(bit); };

               this.titleOffset = (vertical ? new_x : new_y) / offset_k;
               axis.fTitleOffset = this.titleOffset / this.titleSize;

               if (curr_indx == 1) {
                  set_bit(abits.kCenterTitle, true); this.titleCenter = true;
                  set_bit(abits.kOppositeTitle, false); this.titleOpposite = false;
               } else if (curr_indx == 0) {
                  set_bit(abits.kCenterTitle, false); this.titleCenter = false;
                  set_bit(abits.kOppositeTitle, true); this.titleOpposite = true;
               } else {
                  set_bit(abits.kCenterTitle, false); this.titleCenter = false;
                  set_bit(abits.kOppositeTitle, false); this.titleOpposite = false;
               }

               this.submitAxisExec(`SetTitleOffset(${axis.fTitleOffset});;SetBit(${abits.kCenterTitle},${this.titleCenter?1:0})`);

               drag_rect.remove();
               drag_rect = null;
            });

      title_g.style('cursor', 'move').call(drag_move);
   }

   /** @summary Configure hist painter which creates axis - to be able submit execs
     * @private */
   setHistPainter(hist_painter, axis_name) {
      this.hist_painter = hist_painter;
      this.hist_axis = axis_name;
   }

   /** @summary Submit exec for the axis - if possible
     * @private */
   submitAxisExec(exec) {
      let snapid = this.hist_painter?.snapid;
      if (snapid && this.hist_axis)
         this.submitCanvExec(exec, snapid + '#' + this.hist_axis);
   }

   /** @summary Produce svg path for axis ticks */
   produceTicksPath(handle, side, tickSize, ticksPlusMinus, secondShift, real_draw) {
      let path1 = '', path2 = '';
      this.ticks = [];

      while (handle.next(true)) {

         let h1 = Math.round(tickSize/4), h2 = 0;

         if (handle.kind < 3)
            h1 = Math.round(tickSize/2);

         if (handle.kind == 1) {
            // if not showing labels, not show large tick
            // FIXME: for labels last tick is smaller,
            if (/*(this.kind == 'labels') || */ (this.format(handle.tick,true) !== null)) h1 = tickSize;
            this.ticks.push(handle.grpos); // keep graphical positions of major ticks
         }

         if (ticksPlusMinus > 0) {
            h2 = -h1;
         } else if (side < 0) {
            h2 = -h1; h1 = 0;
         }

         path1 += this.vertical ? `M${h1},${handle.grpos}H${h2}` : `M${handle.grpos},${-h1}V${-h2}`;

         if (secondShift)
            path2 += this.vertical ? `M${secondShift-h1},${handle.grpos}H${secondShift-h2}` : `M${handle.grpos},${secondShift+h1}V${secondShift+h2}`;
      }

      return real_draw ? path1 + path2  : '';
   }

   /** @summary Returns modifier for axis label */
   findLabelModifier(axis, nlabel, num_labels) {
      if (!axis.fModLabs) return null;
      for (let n = 0; n < axis.fModLabs.arr.length; ++n) {
         let mod = axis.fModLabs.arr[n];
         if (mod.fLabNum === nlabel + 1) return mod;
         if ((mod.fLabNum < 0) && (nlabel === num_labels + mod.fLabNum)) return mod;
      }
      return null;
   }

   /** @summary Draw axis labels
     * @return {Promise} with array label size and max width */
   async drawLabels(axis_g, axis, w, h, handle, side, labelsFont, labeloffset, tickSize, ticksPlusMinus, max_text_width) {
      let center_lbls = this.isCenteredLabels(),
          rotate_lbls = axis.TestBit(EAxisBits.kLabelsVert),
          textscale = 1, maxtextlen = 0, applied_scale = 0,
          label_g = [ axis_g.append('svg:g').attr('class','axis_labels') ],
          lbl_pos = handle.lbl_pos || handle.major, lbl_tilt = false, max_textwidth = 0;

      if (this.lbls_both_sides)
         label_g.push(axis_g.append('svg:g').attr('class','axis_labels').attr('transform', this.vertical ? `translate(${w})` : `translate(0,${-h})`));

      // function called when text is drawn to analyze width, required to correctly scale all labels
      // must be function to correctly handle 'this' argument
      function process_drawtext_ready(painter) {
         let textwidth = this.result_width;
         max_textwidth = Math.max(max_textwidth, textwidth);

         if (textwidth && ((!painter.vertical && !rotate_lbls) || (painter.vertical && rotate_lbls)) && !painter.log) {
            let maxwidth = this.gap_before*0.45 + this.gap_after*0.45;
            if (!this.gap_before) maxwidth = 0.9*this.gap_after; else
            if (!this.gap_after) maxwidth = 0.9*this.gap_before;
            textscale = Math.min(textscale, maxwidth / textwidth);
         } else if (painter.vertical && max_text_width && this.normal_side && (max_text_width - labeloffset > 20) && (textwidth > max_text_width - labeloffset)) {
            textscale = Math.min(textscale, (max_text_width - labeloffset) / textwidth);
         }

         if ((textscale > 0.0001) && (textscale < 0.7) && !painter.vertical && !rotate_lbls && (maxtextlen > 5) && (label_g.length == 1))
            lbl_tilt = true;

         let scale = textscale * (lbl_tilt ? 3 : 1);

         if ((scale > 0.0001) && (scale < 1)) {
            applied_scale = 1/scale;
            painter.scaleTextDrawing(applied_scale, label_g[0]);
         }
      }

      for (let lcnt = 0; lcnt < label_g.length; ++lcnt) {

         if (lcnt > 0) side = -side;

         let lastpos = 0, fix_coord = this.vertical ? -labeloffset*side : (labeloffset+2)*side + ticksPlusMinus*tickSize;

         this.startTextDrawing(labelsFont, 'font', label_g[lcnt]);

         for (let nmajor = 0; nmajor < lbl_pos.length; ++nmajor) {

            let text = this.format(lbl_pos[nmajor], true);
            if (text === null) continue;

            let mod = this.findLabelModifier(axis, nmajor, lbl_pos.length);
            if (mod?.fTextSize === 0) continue;

            if (mod?.fLabText) text = mod.fLabText;

            let arg = { text, color: labelsFont.color, latex: 1, draw_g: label_g[lcnt], normal_side: (lcnt == 0) },
                pos = Math.round(this.func(lbl_pos[nmajor]));

            if (mod && mod.fTextColor > 0) arg.color = this.getColor(mod.fTextColor);

            arg.gap_before = (nmajor > 0) ? Math.abs(Math.round(pos - this.func(lbl_pos[nmajor-1]))) : 0;

            arg.gap_after = (nmajor < lbl_pos.length-1) ? Math.abs(Math.round(this.func(lbl_pos[nmajor+1])-pos)) : 0;

            if (center_lbls) {
               let gap = arg.gap_after || arg.gap_before;
               pos = Math.round(pos - ((this.vertical != this.reverse) ? 0.5*gap : -0.5*gap));
               if ((pos < -5) || (pos > (this.vertical ? h : w) + 5)) continue;
            }

            maxtextlen = Math.max(maxtextlen, text.length);

            if (this.vertical) {
               arg.x = fix_coord;
               arg.y = pos;
               arg.align = rotate_lbls ? ((side < 0) ? 23 : 20) : ((side < 0) ? 12 : 32);
            } else {
               arg.x = pos;
               arg.y = fix_coord;
               arg.align = rotate_lbls ? ((side < 0) ? 12 : 32) : ((side < 0) ? 20 : 23);
            }

            if (rotate_lbls)
               arg.rotate = 270;

            // only for major text drawing scale factor need to be checked
            if (lcnt == 0) arg.post_process = process_drawtext_ready;

            this.drawText(arg);

            if (lastpos && (pos != lastpos) && ((this.vertical && !rotate_lbls) || (!this.vertical && rotate_lbls))) {
               let axis_step = Math.abs(pos-lastpos);
               textscale = Math.min(textscale, 0.9*axis_step/labelsFont.size);
            }

            lastpos = pos;
         }

         if (this.order)
            this.drawText({ color: labelsFont.color,
                            x: this.vertical ? side*5 : w+5,
                            y: this.has_obstacle ? fix_coord : (this.vertical ? -3 : -3*side),
                            align: this.vertical ? ((side < 0) ? 30 : 10) : ( (this.has_obstacle ^ (side < 0)) ? 13 : 10 ),
                            latex: 1,
                            text: '#times' + this.formatExp(10, this.order),
                            draw_g: label_g[lcnt]
            });
      }

      // first complete major labels drawing
      return this.finishTextDrawing(label_g[0], true).then(() => {
         if (label_g.length > 1) {
            // now complete drawing of second half with scaling if necessary
            if (applied_scale)
               this.scaleTextDrawing(applied_scale, label_g[1]);
            return this.finishTextDrawing(label_g[1], true);
         }
      }).then(() => {
         if (lbl_tilt)
            label_g[0].selectAll('text').each(function() {
               let txt = select(this), tr = txt.attr('transform');
               txt.attr('transform', tr + ' rotate(25)').style('text-anchor', 'start');
            });

         return max_textwidth;
      });
   }

   /** @summary Extract major draw attributes, which are also used in interactive operations
     * @private  */
   extractDrawAttributes(scalingSize, w, h) {
      let axis = this.getObject(),
          is_gaxis = axis?._typename === clTGaxis,
          pp = this.getPadPainter(),
          frect = pp?.getFrameRect(),
          pad_w = Math.round((frect?.width || 8)/0.8), // use factor 0.8 as ratio between frame and pad size, frame size is visible and more obvios
          pad_h = Math.round((frect?.height || 8)/0.8),
          tickSize = 0, tickScalingSize = 0, titleColor;

      this.scalingSize = scalingSize || Math.max(Math.min(pad_w, pad_h), 10);

      if (is_gaxis) {
         let optionSize = axis.fChopt.indexOf('S') >= 0;
         this.optionUnlab = axis.fChopt.indexOf('U') >= 0;
         this.optionMinus = (axis.fChopt.indexOf('-') >= 0) || axis.TestBit(EAxisBits.kTickMinus);
         this.optionPlus = (axis.fChopt.indexOf('+') >= 0) || axis.TestBit(EAxisBits.kTickPlus);
         this.optionNoopt = (axis.fChopt.indexOf('N') >= 0);  // no ticks position optimization
         this.optionInt = (axis.fChopt.indexOf('I') >= 0);  // integer labels

         this.createAttLine({ attr: axis });
         tickScalingSize = scalingSize || (this.vertical ? 1.7*h : 0.6*w);
         tickSize = optionSize ? axis.fTickSize : 0.03;
         titleColor = this.getColor(axis.fTextColor);
      } else {
         this.optionUnlab = false;
         this.optionMinus = this.vertical ^ this.invert_side;
         this.optionPlus = !this.optionMinus;
         this.optionNoopt = false;  // no ticks position optimization
         this.optionInt = false;  // integer labels
         this.createAttLine({ color: axis.fAxisColor, width: 1, style: 1 });
         tickScalingSize = scalingSize || (this.vertical ? pad_w : pad_h);
         tickSize = axis.fTickLength;
         titleColor = this.getColor(axis.fTitleColor);
      }

      this.optionNoexp = axis.TestBit(EAxisBits.kNoExponent);

      this.ticksSize = Math.round(tickSize * tickScalingSize);
      if (scalingSize && (this.ticksSize < 0))
         this.ticksSize = -this.ticksSize;

      if (this.maxTickSize && (this.ticksSize > this.maxTickSize)) this.ticksSize = this.maxTickSize;

      // now used only in 3D drawing
      this.ticksColor = this.lineatt.color;
      this.ticksWidth = this.lineatt.width;

      this.labelSize = Math.round((axis.fLabelSize < 1) ? axis.fLabelSize * this.scalingSize : axis.fLabelSize);
      this.labelsOffset = Math.round(Math.abs(axis.fLabelOffset) * this.scalingSize);
      this.labelsFont = new FontHandler(axis.fLabelFont, this.labelSize, scalingSize);
      if ((this.labelSize <= 0) || (Math.abs(axis.fLabelOffset) > 1.1)) this.optionUnlab = true; // disable labels when size not specified
      this.labelsFont.setColor(this.getColor(axis.fLabelColor));

      this.fTitle = axis.fTitle;
      if (this.fTitle) {
         this.titleSize = (axis.fTitleSize >= 1) ? axis.fTitleSize : Math.round(axis.fTitleSize * this.scalingSize);
         this.titleFont = new FontHandler(axis.fTitleFont, this.titleSize, scalingSize);
         this.titleFont.setColor(titleColor);
         this.titleOffset = axis.fTitleOffset * this.titleSize; // in pixels
         this.titleCenter = axis.TestBit(EAxisBits.kCenterTitle);
         this.titleOpposite = axis.TestBit(EAxisBits.kOppositeTitle);
      } else {
         delete this.titleSize;
         delete this.titleFont;
         delete this.titleOffset;
         delete this.titleCenter;
         delete this.titleOpposite;
      }

   }

   /** @summary function draws TAxis or TGaxis object
     * @return {Promise} for drawing ready */
   async drawAxis(layer, w, h, transform, secondShift, disable_axis_drawing, max_text_width, calculate_position) {

      let axis = this.getObject(),
          is_gaxis = axis?._typename === clTGaxis,
          axis_g = layer,
          draw_lines = true,
          pp = this.getPadPainter(),
          pad_w = pp?.getPadWidth() || 10,
          pad_h = pp?.getPadHeight() || 10,
          swap_side = this.swap_side || false;

      // shift for second ticks set (if any)
      if (!secondShift)
         secondShift = 0;
      else if (this.invert_side)
         secondShift = -secondShift;

      this.extractDrawAttributes(undefined, w, h);

      if (is_gaxis) {
         draw_lines = axis.fLineColor != 0;
      }

      // indicate that attributes created not for TAttLine, therefore cannot be updated as TAttLine in GED
      this.lineatt.not_standard = true;

      if (!is_gaxis || (this.name === 'zaxis')) {
         axis_g = layer.select('.' + this.name + '_container');
         if (axis_g.empty())
            axis_g = layer.append('svg:g').attr('class',this.name + '_container');
         else
            axis_g.selectAll('*').remove();
      }

      let axis_lines = '';
      if (draw_lines) {
         axis_lines = 'M0,0' + (this.vertical ? `v${h}` : `h${w}`);
         if (secondShift)
            axis_lines += this.vertical ? `M${secondShift},0v${h}` : `M0,${secondShift}h${w}`;
      }

      axis_g.attr('transform', transform || null);

      let side = 1, ticksPlusMinus = 0;

      if (this.optionPlus && this.optionMinus) {
         side = 1; ticksPlusMinus = 1;
      } else if (this.optionMinus) {
         side = (swap_side ^ this.vertical) ? 1 : -1;
      } else if (this.optionPlus) {
         side = (swap_side ^ this.vertical) ? -1 : 1;
      }

      // first draw ticks

      const handle = this.createTicks(false, this.optionNoexp, this.optionNoopt, this.optionInt);

      axis_lines += this.produceTicksPath(handle, side, this.ticksSize, ticksPlusMinus, secondShift, draw_lines && !disable_axis_drawing && !this.disable_ticks);

      if (!disable_axis_drawing && axis_lines && !this.lineatt.empty())
         axis_g.append('svg:path')
               .attr('d', axis_lines)
               .call(this.lineatt.func);

      let title_shift_x = 0, title_shift_y = 0, title_g = null, axis_rect = null, labelsMaxWidth = 0,
          // draw labels (sometime on both sides)
          pr = (disable_axis_drawing || this.optionUnlab) ? Promise.resolve(0) :
                this.drawLabels(axis_g, axis, w, h, handle, side, this.labelsFont, this.labelsOffset, this.ticksSize, ticksPlusMinus, max_text_width);

      return pr.then(maxw => {

         labelsMaxWidth = maxw;

         if (settings.Zooming && !this.disable_zooming && !isBatchMode()) {
            let labelSize = Math.max(this.labelsFont.size, 5),
                r = axis_g.append('svg:rect')
                          .attr('class', 'axis_zoom')
                          .style('opacity', '0')
                          .style('cursor', 'crosshair');

            if (this.vertical) {
               let rw = (labelsMaxWidth || 2*labelSize) + 3;
               r.attr('x', (side > 0) ? -rw : 0).attr('y', 0)
                .attr('width', rw).attr('height', h);
            } else {
               r.attr('x', 0).attr('y', (side > 0) ? 0 : -labelSize - 3)
                .attr('width', w).attr('height', labelSize + 3);
            }
         }

         this.position = 0;

         if (calculate_position) {
            let node1 = axis_g.node(), node2 = this.getPadSvg().node();
            if (node1 && node2 && node1.getBoundingClientRect && node2.getBoundingClientRect) {
               let rect1 = node1.getBoundingClientRect(),
                   rect2 = node2.getBoundingClientRect();

               this.position = rect1.left - rect2.left; // use to control left position of Y scale
            }
            if (node1 && !node2)
               console.warn('Why PAD element missing when search for position');
         }

         if (!this.fTitle || disable_axis_drawing) return true;

         title_g = axis_g.append('svg:g').attr('class', 'axis_title');

         let title_offest_k = 1.6 / this.scalingSize,
             rotate = axis.TestBit(EAxisBits.kRotateTitle) ? -1 : 1;

         this.startTextDrawing(this.titleFont, 'font', title_g);

         let xor_reverse = swap_side ^ this.titleOpposite, myxor = (rotate < 0) ^ xor_reverse;

         this.title_align = this.titleCenter ? 'middle' : (myxor ? 'begin' : 'end');

         if (this.vertical) {
            title_offest_k *= -side*pad_w;

            title_shift_x = Math.round(title_offest_k * this.titleOffset);

            if ((this.name == 'zaxis') && is_gaxis && ('getBoundingClientRect' in axis_g.node())) {
               // special handling for color palette labels - draw them always on right side
               let rect = axis_g.node().getBoundingClientRect();
               if (title_shift_x < rect.width - this.ticksSize)
                  title_shift_x = Math.round(rect.width - this.ticksSize);
            }

            title_shift_y = Math.round(this.titleCenter ? h/2 : (xor_reverse ? h : 0));

            this.drawText({ align: this.title_align+';middle',
                            rotate: (rotate < 0) ? 90 : 270,
                            text: this.fTitle, color: this.titleFont.color, draw_g: title_g });
         } else {
            title_offest_k *= side*pad_h;

            title_shift_x = Math.round(this.titleCenter ? w/2 : (xor_reverse ? 0 : w));
            title_shift_y = Math.round(title_offest_k * this.titleOffset);
            this.drawText({ align: this.title_align+';middle',
                            rotate: (rotate < 0) ? 180 : 0,
                            text: this.fTitle, color: this.titleFont.color, draw_g: title_g });
         }

         if (this.vertical && !this.titleOffset && ('getBoundingClientRect' in axis_g.node()))
            axis_rect = axis_g.node().getBoundingClientRect();

         this.addTitleDrag(title_g, this.vertical, title_offest_k, swap_side, this.vertical ? h : w);

         return this.finishTextDrawing(title_g);
      }).then(() => {
         if (title_g) {
            // fine-tuning of title position when possible
            if (axis_rect) {
               let title_rect = title_g.node().getBoundingClientRect();
               if ((axis_rect.left != axis_rect.right) && (title_rect.left != title_rect.right))
                  title_shift_x = (side > 0) ? Math.round(axis_rect.left - title_rect.right - this.titleFont.size*0.3) :
                                               Math.round(axis_rect.right - title_rect.left + this.titleFont.size*0.3);
               else
                  title_shift_x = -1 * Math.round(((side > 0) ? (this.labelsOffset + labelsMaxWidth) : 0) + this.titleFont.size*0.7);
            }

            title_g.attr('transform', `translate(${title_shift_x},${title_shift_y})`)
                   .property('shift_x', title_shift_x)
                   .property('shift_y', title_shift_y);
         }

         return this;
      });
   }

   /** @summary Convert TGaxis position into NDC to fix it when frame zoomed */
   convertTo(opt) {
      let gaxis = this.getObject(),
          x1 = this.axisToSvg('x', gaxis.fX1),
          y1 = this.axisToSvg('y', gaxis.fY1),
          x2 = this.axisToSvg('x', gaxis.fX2),
          y2 = this.axisToSvg('y', gaxis.fY2);

      if (opt == 'ndc') {
          let pw = this.getPadPainter().getPadWidth(),
              ph = this.getPadPainter().getPadHeight();

          gaxis.fX1 = x1 / pw;
          gaxis.fX2 = x2 / pw;
          gaxis.fY1 = (ph - y1) / ph;
          gaxis.fY2 = (ph - y2)/ ph;
          this.use_ndc = true;
      } else if (opt == 'frame') {
         let rect = this.getFramePainter().getFrameRect();
         gaxis.fX1 = (x1 - rect.x) / rect.width;
         gaxis.fX2 = (x2 - rect.x) / rect.width;
         gaxis.fY1 = (y1 - rect.y) / rect.height;
         gaxis.fY2 = (y2 - rect.y) / rect.height;
         this.bind_frame = true;
      }
   }

   /** @summary Redraw axis, used in standalone mode for TGaxis */
   redraw() {

      let gaxis = this.getObject(), x1, y1, x2, y2;

      if (this.bind_frame) {
         let rect = this.getFramePainter().getFrameRect();
         x1 = Math.round(rect.x + gaxis.fX1 * rect.width);
         x2 = Math.round(rect.x + gaxis.fX2 * rect.width);
         y1 = Math.round(rect.y + gaxis.fY1 * rect.height);
         y2 = Math.round(rect.y + gaxis.fY2 * rect.height);
      } else {
          x1 = this.axisToSvg('x', gaxis.fX1, this.use_ndc);
          y1 = this.axisToSvg('y', gaxis.fY1, this.use_ndc);
          x2 = this.axisToSvg('x', gaxis.fX2, this.use_ndc);
          y2 = this.axisToSvg('y', gaxis.fY2, this.use_ndc);
      }
      let w = x2 - x1, h = y1 - y2,
          vertical = Math.abs(w) < Math.abs(h),
          sz = vertical ? h : w,
          reverse = false,
          min = gaxis.fWmin, max = gaxis.fWmax;

      if (sz < 0) {
         reverse = true;
         sz = -sz;
         if (vertical) y2 = y1; else x1 = x2;
      }

      this.configureAxis(vertical ? 'yaxis' : 'xaxis', min, max, min, max, vertical, [0, sz], {
         time_scale: gaxis.fChopt.indexOf('t') >= 0,
         log: (gaxis.fChopt.indexOf('G') >= 0) ? 1 : 0,
         reverse,
         swap_side: reverse
      });

      this.createG();

      return this.drawAxis(this.getG(), Math.abs(w), Math.abs(h), `translate(${x1},${y2})`);
   }

} // class TAxisPainter

/**
 * A math namespace - all functions can be exported from base/math.mjs.
 * Also all these functions can be used with TFormula calcualtions
 * @namespace Math
 */

const kMACHEP  = 1.11022302462515654042363166809e-16,
      kMINLOG  = -708.396418532264078748994506896,
      kMAXLOG  = 709.782712893383973096206318587,
      kMAXSTIR = 108.116855767857671821730036754,
      kBig     = 4.503599627370496e15,
      kBiginv  =  2.22044604925031308085e-16,
      kSqrt2   = 1.41421356237309515,
      M_PI    =  3.14159265358979323846264338328;

/** @summary Polynomialeval function
  * @desc calculates a value of a polynomial of the form:
  * a[0]x^N+a[1]x^(N-1) + ... + a[N]
  * @memberof Math */
function Polynomialeval(x, a, N) {
   if (!N) return a[0];

   let pom = a[0];
   for (let i = 1; i <= N; ++i)
      pom = pom *x + a[i];
   return pom;
}

/** @summary Polynomial1eval function
  * @desc calculates a value of a polynomial of the form:
  * x^N+a[0]x^(N-1) + ... + a[N-1]
  * @memberof Math */
function Polynomial1eval(x, a, N) {
   if (!N) return a[0];

   let pom = x + a[0];
   for (let i = 1; i < N; ++i)
      pom = pom *x + a[i];
   return pom;
}

/** @summary lgam function, logarithm from gamma
  * @memberof Math */
function lgam(x) {
   let p, q, u, w, z;
   const kMAXLGM = 2.556348e305,
         LS2PI = 0.91893853320467274178,
   A = [
      8.11614167470508450300E-4,
      -5.95061904284301438324E-4,
      7.93650340457716943945E-4,
      -2.77777777730099687205E-3,
      8.33333333333331927722E-2
   ], B = [
      -1.37825152569120859100E3,
      -3.88016315134637840924E4,
      -3.31612992738871184744E5,
      -1.16237097492762307383E6,
      -1.72173700820839662146E6,
      -8.53555664245765465627E5
   ], C = [
   /* 1.00000000000000000000E0, */
      -3.51815701436523470549E2,
      -1.70642106651881159223E4,
      -2.20528590553854454839E5,
      -1.13933444367982507207E6,
      -2.53252307177582951285E6,
      -2.01889141433532773231E6
   ];

   if ((x >= Number.MAX_VALUE) || (x == Number.POSITIVE_INFINITY))
      return Number.POSITIVE_INFINITY;

   if ( x < -34.0 ) {
      q = -x;
      w = lgam(q);
      p = Math.floor(q);
      if ( p==q )//_unur_FP_same(p,q)
         return Number.POSITIVE_INFINITY;
      z = q - p;
      if ( z > 0.5 ) {
         p += 1.0;
         z = p - q;
      }
      z = q * Math.sin( Math.PI * z );
      if ( z < 1e-300 )
         return Number.POSITIVE_INFINITY;
      z = Math.log(Math.PI) - Math.log( z ) - w;
      return z;
   }
   if ( x < 13.0 ) {
      z = 1.0;
      p = 0.0;
      u = x;
      while ( u >= 3.0 ) {
         p -= 1.0;
         u = x + p;
         z *= u;
      }
      while ( u < 2.0 ) {
         if ( u < 1e-300 )
            return Number.POSITIVE_INFINITY;
         z /= u;
         p += 1.0;
         u = x + p;
      }
      if ( z < 0.0 ) {
         z = -z;
      }
      if ( u == 2.0 )
         return Math.log(z);
      p -= 2.0;
      x = x + p;
      p = x * Polynomialeval(x, B, 5 ) / Polynomial1eval( x, C, 6);
      return Math.log(z) + p;
   }
   if ( x > kMAXLGM )
      return Number.POSITIVE_INFINITY;

   q = ( x - 0.5 ) * Math.log(x) - x + LS2PI;
   if ( x > 1.0e8 )
      return q;

   p = 1.0/(x*x);
   if ( x >= 1000.0 )
      q += ((7.9365079365079365079365e-4 * p
            - 2.7777777777777777777778e-3) *p
            + 0.0833333333333333333333) / x;
   else
      q += Polynomialeval( p, A, 4 ) / x;
   return q;
}

/** @summary Stirling formula for the gamma function
  * @memberof Math */
function stirf(x) {
   let y, w, v;

   const STIR = [
      7.87311395793093628397E-4,
      -2.29549961613378126380E-4,
      -2.68132617805781232825E-3,
      3.47222221605458667310E-3,
      8.33333333333482257126E-2,
   ], SQTPI = Math.sqrt(2*Math.PI);

   w = 1.0/x;
   w = 1.0 + w * Polynomialeval( w, STIR, 4 );
   y = Math.exp(x);

/*   #define kMAXSTIR kMAXLOG/log(kMAXLOG)  */

   if( x > kMAXSTIR )
   { /* Avoid overflow in pow() */
      v = Math.pow( x, 0.5 * x - 0.25 );
      y = v * (v / y);
   }
   else
   {
      y = Math.pow( x, x - 0.5 ) / y;
   }
   y = SQTPI * y * w;
   return y;
}

/** @summary complementary error function
  * @memberof Math */
function erfc(a) {
   const erfP = [
      2.46196981473530512524E-10,
      5.64189564831068821977E-1,
      7.46321056442269912687E0,
      4.86371970985681366614E1,
      1.96520832956077098242E2,
      5.26445194995477358631E2,
      9.34528527171957607540E2,
      1.02755188689515710272E3,
      5.57535335369399327526E2
   ], erfQ = [
      1.32281951154744992508E1,
      8.67072140885989742329E1,
      3.54937778887819891062E2,
      9.75708501743205489753E2,
      1.82390916687909736289E3,
      2.24633760818710981792E3,
      1.65666309194161350182E3,
      5.57535340817727675546E2
   ], erfR = [
      5.64189583547755073984E-1,
      1.27536670759978104416E0,
      5.01905042251180477414E0,
      6.16021097993053585195E0,
      7.40974269950448939160E0,
      2.97886665372100240670E0
   ], erfS = [
      2.26052863220117276590E0,
      9.39603524938001434673E0,
      1.20489539808096656605E1,
      1.70814450747565897222E1,
      9.60896809063285878198E0,
      3.36907645100081516050E0
   ];

   let p,q,x,y,z;

   if( a < 0.0 )
      x = -a;
   else
      x = a;

   if( x < 1.0 )
      return 1.0 - erf(a);

   z = -a * a;

   if(z < -kMAXLOG)
      return (a < 0) ? 2.0 : 0.0;

   z = Math.exp(z);

   if( x < 8.0 ) {
      p = Polynomialeval( x, erfP, 8 );
      q = Polynomial1eval( x, erfQ, 8 );
   } else {
      p = Polynomialeval( x, erfR, 5 );
      q = Polynomial1eval( x, erfS, 6 );
   }
   y = (z * p)/q;

   if(a < 0)
      y = 2.0 - y;

   if(y == 0)
      return (a < 0) ? 2.0 : 0.0;

   return y;
}

/** @summary error function
  * @memberof Math */
function erf(x) {
   if(Math.abs(x) > 1.0)
      return 1.0 - erfc(x);

   const erfT = [
      9.60497373987051638749E0,
      9.00260197203842689217E1,
      2.23200534594684319226E3,
      7.00332514112805075473E3,
      5.55923013010394962768E4
   ], erfU = [
      3.35617141647503099647E1,
      5.21357949780152679795E2,
      4.59432382970980127987E3,
      2.26290000613890934246E4,
      4.92673942608635921086E4
   ];

   let z = x * x;

   return x * Polynomialeval(z, erfT, 4) / Polynomial1eval(z, erfU, 5);
}

/** @summary lognormal_cdf_c function
  * @memberof Math */
function lognormal_cdf_c(x, m, s, x0) {
   if (x0 === undefined) x0 = 0;
   let z = (Math.log((x-x0))-m)/(s*kSqrt2);
   if (z > 1.)  return 0.5*erfc(z);
   else         return 0.5*(1.0 - erf(z));
}

/** @summary lognormal_cdf_c function
  * @memberof Math */
function lognormal_cdf(x, m, s, x0 = 0) {
   let z = (Math.log((x-x0))-m)/(s*kSqrt2);
   if (z < -1.) return 0.5*erfc(-z);
   else         return 0.5*(1.0 + erf(z));
}

/** @summary normal_cdf_c function
  * @memberof Math */
function normal_cdf_c(x, sigma, x0 = 0) {
   let z = (x-x0)/(sigma*kSqrt2);
   if (z > 1.)  return 0.5*erfc(z);
   else         return 0.5*(1.-erf(z));
}

/** @summary normal_cdf function
  * @memberof Math */
function normal_cdf(x, sigma, x0 = 0) {
   let z = (x-x0)/(sigma*kSqrt2);
   if (z < -1.) return erfc(-z);
   else         return 0.5*(1.0 + erf(z));
}

/** @summary log normal pdf
  * @memberof Math */
function lognormal_pdf(x, m, s, x0 = 0) {
   if ((x-x0) <= 0)
      return 0.0;
   let tmp = (Math.log((x-x0)) - m)/s;
   return 1.0 / ((x-x0) * Math.abs(s) * Math.sqrt(2 * M_PI)) * Math.exp(-(tmp * tmp) /2);
}

/** @summary normal pdf
  * @memberof Math */
function normal_pdf(x, sigma = 1, x0 = 0) {
   let  tmp = (x-x0)/sigma;
   return (1.0/(Math.sqrt(2 * M_PI) * Math.abs(sigma))) * Math.exp(-tmp*tmp/2);
}

/** @summary gamma calculation
  * @memberof Math */
function gamma(x) {
   let p, q, z, i, sgngam = 1;

   if (x >= Number.MAX_VALUE)
      return x;

   q = Math.abs(x);

   if( q > 33.0 )
   {
      if( x < 0.0 )
      {
         p = Math.floor(q);
         if( p == q )
            return Number.POSITIVE_INFINITY;
         i = Math.round(p);
         if( (i & 1) == 0 )
            sgngam = -1;
         z = q - p;
         if( z > 0.5 )
         {
            p += 1.0;
            z = q - p;
         }
         z = q * Math.sin( Math.PI * z );
         if( z == 0 )
         {
            return sgngam > 0 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
         }
         z = Math.abs(z);
         z = Math.PI / (z * stirf(q) );
      }
      else
      {
         z = stirf(x);
      }
      return sgngam * z;
   }

   z = 1.0;
   while( x >= 3.0 )
   {
      x -= 1.0;
      z *= x;
   }

  let small = false;

   while(( x < 0.0 ) && !small)
   {
      if( x > -1.E-9 )
         small = true;
      else {
         z /= x;
         x += 1.0;
      }
   }

   while(( x < 2.0 ) && !small)
   {
      if( x < 1.e-9 )
         small = true;
      else {
         z /= x;
         x += 1.0;
      }
   }

   if (small) {
      if( x == 0 )
         return Number.POSITIVE_INFINITY;
      else
         return z/((1.0 + 0.5772156649015329 * x) * x);
   }

   if( x == 2.0 )
      return z;

   const P = [
      1.60119522476751861407E-4,
      1.19135147006586384913E-3,
      1.04213797561761569935E-2,
      4.76367800457137231464E-2,
      2.07448227648435975150E-1,
      4.94214826801497100753E-1,
      9.99999999999999996796E-1
   ], Q = [
      -2.31581873324120129819E-5,
      5.39605580493303397842E-4,
      -4.45641913851797240494E-3,
      1.18139785222060435552E-2,
      3.58236398605498653373E-2,
      -2.34591795718243348568E-1,
      7.14304917030273074085E-2,
      1.00000000000000000320E0 ];

   x -= 2.0;
   p = Polynomialeval( x, P, 6 );
   q = Polynomialeval( x, Q, 7 );
   return z * p / q;
}

/** @summary ndtri function
  * @memberof Math */
function ndtri(y0) {
   if ( y0 <= 0.0 )
      return Number.NEGATIVE_INFINITY;
   if ( y0 >= 1.0 )
      return Number.POSITIVE_INFINITY;

   const P0 = [
        -5.99633501014107895267E1,
         9.80010754185999661536E1,
        -5.66762857469070293439E1,
         1.39312609387279679503E1,
        -1.23916583867381258016E0
   ], Q0 = [
         1.95448858338141759834E0,
         4.67627912898881538453E0,
         8.63602421390890590575E1,
        -2.25462687854119370527E2,
         2.00260212380060660359E2,
        -8.20372256168333339912E1,
         1.59056225126211695515E1,
        -1.18331621121330003142E0
   ], P1 = [
         4.05544892305962419923E0,
         3.15251094599893866154E1,
         5.71628192246421288162E1,
         4.40805073893200834700E1,
         1.46849561928858024014E1,
         2.18663306850790267539E0,
        -1.40256079171354495875E-1,
        -3.50424626827848203418E-2,
        -8.57456785154685413611E-4
   ], Q1 = [
         1.57799883256466749731E1,
         4.53907635128879210584E1,
         4.13172038254672030440E1,
         1.50425385692907503408E1,
         2.50464946208309415979E0,
        -1.42182922854787788574E-1,
        -3.80806407691578277194E-2,
        -9.33259480895457427372E-4
   ], P2 = [
         3.23774891776946035970E0,
         6.91522889068984211695E0,
         3.93881025292474443415E0,
         1.33303460815807542389E0,
         2.01485389549179081538E-1,
         1.23716634817820021358E-2,
         3.01581553508235416007E-4,
         2.65806974686737550832E-6,
         6.23974539184983293730E-9
   ], Q2 = [
         6.02427039364742014255E0,
         3.67983563856160859403E0,
         1.37702099489081330271E0,
         2.16236993594496635890E-1,
         1.34204006088543189037E-2,
         3.28014464682127739104E-4,
         2.89247864745380683936E-6,
         6.79019408009981274425E-9
   ], s2pi = 2.50662827463100050242e0, dd = 0.13533528323661269189;

   let code = 1, y = y0, x, z, y2, x0, x1;

   if ( y > (1.0 - dd) ) {
      y = 1.0 - y;
      code = 0;
   }
   if ( y > dd ) {
      y = y - 0.5;
      y2 = y * y;
      x = y + y * (y2 * Polynomialeval( y2, P0, 4)/ Polynomial1eval( y2, Q0, 8 ));
      x = x * s2pi;
      return x;
   }
   x = Math.sqrt( -2.0 * Math.log(y) );
   x0 = x - Math.log(x)/x;
   z = 1.0/x;
   if ( x < 8.0 )
      x1 = z * Polynomialeval( z, P1, 8 )/ Polynomial1eval( z, Q1, 8 );
   else
      x1 = z * Polynomialeval( z, P2, 8 )/ Polynomial1eval( z, Q2, 8 );
   x = x0 - x1;
   if ( code != 0 )
      x = -x;
   return x;
}

/** @summary normal_quantile function
  * @memberof Math */
function normal_quantile(z, sigma) {
   return  sigma * ndtri(z);
}

/** @summary normal_quantile_c function
  * @memberof Math */
function normal_quantile_c(z, sigma) {
   return - sigma * ndtri(z);
}

/** @summary igamc function
  * @memberof Math */
function igamc(a,x) {
   // LM: for negative values returns 0.0
   // This is correct if a is a negative integer since Gamma(-n) = +/- inf
   if (a <= 0)  return 0.0;

   if (x <= 0) return 1.0;

   if((x < 1.0) || (x < a))
      return (1.0 - igam(a,x));

   let ax = a * Math.log(x) - x - lgam(a);
   if( ax < -kMAXLOG )
      return 0.0;

   ax = Math.exp(ax);

   /* continued fraction */
   let y = 1.0 - a,
       z = x + y + 1.0,
       c = 0.0,
       pkm2 = 1.0,
       qkm2 = x,
       pkm1 = x + 1.0,
       qkm1 = z * x,
       ans = pkm1/qkm1,
       yc, r, t, pk,  qk;

   do {
      c += 1.0;
      y += 1.0;
      z += 2.0;
      yc = y * c;
      pk = pkm1 * z  -  pkm2 * yc;
      qk = qkm1 * z  -  qkm2 * yc;
      if(qk)
      {
         r = pk/qk;
         t = Math.abs( (ans - r)/r );
         ans = r;
      }
      else
         t = 1.0;
      pkm2 = pkm1;
      pkm1 = pk;
      qkm2 = qkm1;
      qkm1 = qk;
      if( Math.abs(pk) > kBig )
      {
         pkm2 *= kBiginv;
         pkm1 *= kBiginv;
         qkm2 *= kBiginv;
         qkm1 *= kBiginv;
      }
   } while( t > kMACHEP );

   return ans * ax;
}

/** @summary igam function
  * @memberof Math */
function igam(a, x) {

   // LM: for negative values returns 1.0 instead of zero
   // This is correct if a is a negative integer since Gamma(-n) = +/- inf
   if (a <= 0)  return 1.0;

   if (x <= 0)  return 0.0;

   if( (x > 1.0) && (x > a ) )
      return 1.0 - igamc(a,x);

   /* Compute  x**a * exp(-x) / gamma(a)  */
   let ax = a * Math.log(x) - x - lgam(a);
   if( ax < -kMAXLOG )
      return 0.0;

   ax = Math.exp(ax);

   /* power series */
   let r = a, c = 1.0, ans = 1.0;

   do {
      r += 1.0;
      c *= x/r;
      ans += c;
   } while( c/ans > kMACHEP );

   return ans * ax/a;
}


/** @summary igami function
  * @memberof Math */
function igami(a, y0) {
   // check the domain
   if (a <= 0) {
      console.error('igami : Wrong domain for parameter a (must be > 0)');
      return 0;
   }
   if (y0 <= 0) {
      return Number.POSITIVE_INFINITY;
   }
   if (y0 >= 1) {
      return 0;
   }
   const kMAXNUM = Number.MAX_VALUE;
   let x0 = kMAXNUM, x1 = 0, x, yl = 0, yh = 1, y, d, lgm, dithresh = 5.0 * kMACHEP, i, dir;

   /* approximation to inverse function */
   d = 1.0/(9.0*a);
   y = ( 1.0 - d - ndtri(y0) * Math.sqrt(d) );
   x = a * y * y * y;

   lgm = lgam(a);

   for( i=0; i<10; ++i ) {
      if ( x > x0 || x < x1 )
         break;
      y = igamc(a,x);
      if ( y < yl || y > yh )
         break;
      if ( y < y0 ) {
         x0 = x;
         yl = y;
      }
      else {
         x1 = x;
         yh = y;
      }
      /* compute the derivative of the function at this point */
      d = (a - 1.0) * Math.log(x) - x - lgm;
      if ( d < -kMAXLOG )
         break;
      d = -Math.exp(d);
      /* compute the step to the next approximation of x */
      d = (y - y0)/d;
      if ( Math.abs(d/x) < kMACHEP )
         return x;
      x = x - d;
   }
   /* Resort to interval halving if Newton iteration did not converge. */
   d = 0.0625;
   if ( x0 == kMAXNUM ) {
      if ( x <= 0.0 )
         x = 1.0;
      while ( x0 == kMAXNUM ) {
         x = (1.0 + d) * x;
         y = igamc( a, x );
         if ( y < y0 ) {
            x0 = x;
            yl = y;
            break;
         }
         d = d + d;
      }
   }
   d = 0.5;
   dir = 0;

   for( i=0; i<400; ++i ) {
      x = x1  +  d * (x0 - x1);
      y = igamc( a, x );
      lgm = (x0 - x1)/(x1 + x0);
      if ( Math.abs(lgm) < dithresh )
         break;
      lgm = (y - y0)/y0;
      if ( Math.abs(lgm) < dithresh )
         break;
      if ( x <= 0.0 )
         break;
      if ( y >= y0 ) {
         x1 = x;
         yh = y;
         if ( dir < 0 ) {
            dir = 0;
            d = 0.5;
         }
         else if ( dir > 1 )
            d = 0.5 * d + 0.5;
         else
            d = (y0 - yl)/(yh - yl);
         dir += 1;
      }
      else {
         x0 = x;
         yl = y;
         if ( dir > 0 ) {
            dir = 0;
            d = 0.5;
         }
         else if ( dir < -1 )
            d = 0.5 * d;
         else
            d = (y0 - yl)/(yh - yl);
         dir -= 1;
      }
   }
   return x;
}

/** @summary landau_pdf function
  * @desc LANDAU pdf : algorithm from CERNLIB G110 denlan
  *  same algorithm is used in GSL
  * @memberof Math */
function landau_pdf(x, xi, x0 = 0) {
   if (xi <= 0) return 0;
   const v = (x - x0)/xi;
   let u, ue, us, denlan;
   const p1 = [0.4259894875,-0.1249762550, 0.03984243700, -0.006298287635,   0.001511162253],
         q1 = [1.0         ,-0.3388260629, 0.09594393323, -0.01608042283,    0.003778942063],
         p2 = [0.1788541609, 0.1173957403, 0.01488850518, -0.001394989411,   0.0001283617211],
         q2 = [1.0         , 0.7428795082, 0.3153932961,   0.06694219548,    0.008790609714],
         p3 = [0.1788544503, 0.09359161662,0.006325387654, 0.00006611667319,-0.000002031049101],
         q3 = [1.0         , 0.6097809921, 0.2560616665,   0.04746722384,    0.006957301675],
         p4 = [0.9874054407, 118.6723273,  849.2794360,   -743.7792444,      427.0262186],
         q4 = [1.0         , 106.8615961,  337.6496214,    2016.712389,      1597.063511],
         p5 = [1.003675074,  167.5702434,  4789.711289,    21217.86767,     -22324.94910],
         q5 = [1.0         , 156.9424537,  3745.310488,    9834.698876,      66924.28357],
         p6 = [1.000827619,  664.9143136,  62972.92665,    475554.6998,     -5743609.109],
         q6 = [1.0         , 651.4101098,  56974.73333,    165917.4725,     -2815759.939],
         a1 = [0.04166666667,-0.01996527778, 0.02709538966],
         a2 = [-1.845568670,-4.284640743];

   if (v < -5.5) {
      u   = Math.exp(v+1.0);
      if (u < 1e-10) return 0.0;
      ue  = Math.exp(-1/u);
      us  = Math.sqrt(u);
      denlan = 0.3989422803*(ue/us)*(1+(a1[0]+(a1[1]+a1[2]*u)*u)*u);
   } else if(v < -1) {
      u   = Math.exp(-v-1);
      denlan = Math.exp(-u)*Math.sqrt(u)*
         (p1[0]+(p1[1]+(p1[2]+(p1[3]+p1[4]*v)*v)*v)*v)/
         (q1[0]+(q1[1]+(q1[2]+(q1[3]+q1[4]*v)*v)*v)*v);
   } else if(v < 1) {
      denlan = (p2[0]+(p2[1]+(p2[2]+(p2[3]+p2[4]*v)*v)*v)*v)/
         (q2[0]+(q2[1]+(q2[2]+(q2[3]+q2[4]*v)*v)*v)*v);
   } else if(v < 5) {
      denlan = (p3[0]+(p3[1]+(p3[2]+(p3[3]+p3[4]*v)*v)*v)*v)/
         (q3[0]+(q3[1]+(q3[2]+(q3[3]+q3[4]*v)*v)*v)*v);
   } else if(v < 12) {
      u   = 1/v;
      denlan = u*u*(p4[0]+(p4[1]+(p4[2]+(p4[3]+p4[4]*u)*u)*u)*u)/
         (q4[0]+(q4[1]+(q4[2]+(q4[3]+q4[4]*u)*u)*u)*u);
   } else if(v < 50) {
      u   = 1/v;
      denlan = u*u*(p5[0]+(p5[1]+(p5[2]+(p5[3]+p5[4]*u)*u)*u)*u)/
         (q5[0]+(q5[1]+(q5[2]+(q5[3]+q5[4]*u)*u)*u)*u);
   } else if(v < 300) {
      u   = 1/v;
      denlan = u*u*(p6[0]+(p6[1]+(p6[2]+(p6[3]+p6[4]*u)*u)*u)*u)/
         (q6[0]+(q6[1]+(q6[2]+(q6[3]+q6[4]*u)*u)*u)*u);
   } else {
      u   = 1/(v-v*Math.log(v)/(v+1));
      denlan = u*u*(1+(a2[0]+a2[1]*u)*u);
   }
   return denlan/xi;
}

/** @summary Landau function
  * @memberof Math */
function Landau(x, mpv, sigma, norm) {
   if (sigma <= 0) return 0;
   const den = landau_pdf((x - mpv) / sigma, 1, 0);
   if (!norm) return den;
   return den/sigma;
}

/** @summary inc_gamma_c
  * @memberof Math */
function inc_gamma_c(a,x) {
   return igamc(a,x);
}

/** @summary inc_gamma
  * @memberof Math */
function inc_gamma(a,x) {
   return igam(a,x);
}

/** @summary lgamma
  * @memberof Math */
function lgamma(z) {
   return lgam(z);
}

/** @summary Probability density function of the beta distribution.
  * @memberof Math */
function beta_pdf(x, a, b) {
  if (x < 0 || x > 1.0) return 0;
  if (x == 0 ) {
     if (a < 1) return Number.POSITIVE_INFINITY;
     else if (a > 1) return  0;
     else if ( a == 1) return b; // to avoid a nan from log(0)*0
   }
   if (x == 1 ) {
      if (b < 1) return Number.POSITIVE_INFINITY;
      else if (b > 1) return  0;
      else if ( b == 1) return a; // to avoid a nan from log(0)*0
   }
   return Math.exp(lgamma(a + b) - lgamma(a) - lgamma(b) +
                    Math.log(x) * (a -1.) + Math.log1p(-x) * (b - 1.));
}

/** @summary beta
  * @memberof Math */
function beta(x,y) {
   return Math.exp(lgamma(x)+lgamma(y)-lgamma(x+y));
}

/** @summary chisquared_cdf_c
  * @memberof Math */
function chisquared_cdf_c(x,r,x0 = 0) {
   return inc_gamma_c ( 0.5 * r , 0.5*(x-x0) );
}

/** @summary Continued fraction expansion #1 for incomplete beta integral
  * @memberof Math */
function incbcf(a,b,x) {
   let xk, pk, pkm1, pkm2, qk, qkm1, qkm2,
       k1, k2, k3, k4, k5, k6, k7, k8,
       r, t, ans, thresh, n;

   k1 = a;
   k2 = a + b;
   k3 = a;
   k4 = a + 1.0;
   k5 = 1.0;
   k6 = b - 1.0;
   k7 = k4;
   k8 = a + 2.0;

   pkm2 = 0.0;
   qkm2 = 1.0;
   pkm1 = 1.0;
   qkm1 = 1.0;
   ans = 1.0;
   r = 1.0;
   n = 0;
   thresh = 3.0 * kMACHEP;
   do
   {

      xk = -( x * k1 * k2 )/( k3 * k4 );
      pk = pkm1 +  pkm2 * xk;
      qk = qkm1 +  qkm2 * xk;
      pkm2 = pkm1;
      pkm1 = pk;
      qkm2 = qkm1;
      qkm1 = qk;

      xk = ( x * k5 * k6 )/( k7 * k8 );
      pk = pkm1 +  pkm2 * xk;
      qk = qkm1 +  qkm2 * xk;
      pkm2 = pkm1;
      pkm1 = pk;
      qkm2 = qkm1;
      qkm1 = qk;

      if( qk !=0 )
         r = pk/qk;
      if( r != 0 )
      {
         t = Math.abs( (ans - r)/r );
         ans = r;
      }
      else
         t = 1.0;

      if( t < thresh )
         break; // goto cdone;

      k1 += 1.0;
      k2 += 1.0;
      k3 += 2.0;
      k4 += 2.0;
      k5 += 1.0;
      k6 -= 1.0;
      k7 += 2.0;
      k8 += 2.0;

      if( (Math.abs(qk) + Math.abs(pk)) > kBig )
      {
         pkm2 *= kBiginv;
         pkm1 *= kBiginv;
         qkm2 *= kBiginv;
         qkm1 *= kBiginv;
      }
      if( (Math.abs(qk) < kBiginv) || (Math.abs(pk) < kBiginv) )
      {
         pkm2 *= kBig;
         pkm1 *= kBig;
         qkm2 *= kBig;
         qkm1 *= kBig;
      }
   }
   while( ++n < 300 );

// cdone:
   return ans;
}

/** @summary Continued fraction expansion #2 for incomplete beta integral
  * @memberof Math */
function incbd(a,b,x) {
   let xk, pk, pkm1, pkm2, qk, qkm1, qkm2,
       k1, k2, k3, k4, k5, k6, k7, k8,
       r, t, ans, z, thresh, n;

   k1 = a;
   k2 = b - 1.0;
   k3 = a;
   k4 = a + 1.0;
   k5 = 1.0;
   k6 = a + b;
   k7 = a + 1.0;   k8 = a + 2.0;

   pkm2 = 0.0;
   qkm2 = 1.0;
   pkm1 = 1.0;
   qkm1 = 1.0;
   z = x / (1.0-x);
   ans = 1.0;
   r = 1.0;
   n = 0;
   thresh = 3.0 * kMACHEP;
   do
   {

      xk = -( z * k1 * k2 )/( k3 * k4 );
      pk = pkm1 +  pkm2 * xk;
      qk = qkm1 +  qkm2 * xk;
      pkm2 = pkm1;
      pkm1 = pk;
      qkm2 = qkm1;
      qkm1 = qk;

      xk = ( z * k5 * k6 )/( k7 * k8 );
      pk = pkm1 +  pkm2 * xk;
      qk = qkm1 +  qkm2 * xk;
      pkm2 = pkm1;
      pkm1 = pk;
      qkm2 = qkm1;
      qkm1 = qk;

      if( qk != 0 )
         r = pk/qk;
      if( r != 0 )
      {
         t = Math.abs( (ans - r)/r );
         ans = r;
      }
      else
         t = 1.0;

      if( t < thresh )
         break; // goto cdone;

      k1 += 1.0;
      k2 -= 1.0;
      k3 += 2.0;
      k4 += 2.0;
      k5 += 1.0;
      k6 += 1.0;
      k7 += 2.0;
      k8 += 2.0;

      if( (Math.abs(qk) + Math.abs(pk)) > kBig )
      {
         pkm2 *= kBiginv;
         pkm1 *= kBiginv;
         qkm2 *= kBiginv;
         qkm1 *= kBiginv;
      }
      if( (Math.abs(qk) < kBiginv) || (Math.abs(pk) < kBiginv) )
      {
         pkm2 *= kBig;
         pkm1 *= kBig;
         qkm2 *= kBig;
         qkm1 *= kBig;
      }
   }
   while( ++n < 300 );
//cdone:
   return ans;
}

/** @summary ROOT::Math::Cephes::pseries
  * @memberof Math */
function pseries(a,b,x) {
   let s, t, u, v, n, t1, z, ai;

   ai = 1.0 / a;
   u = (1.0 - b) * x;
   v = u / (a + 1.0);
   t1 = v;
   t = u;
   n = 2.0;
   s = 0.0;
   z = kMACHEP * ai;
   while( Math.abs(v) > z )
   {
      u = (n - b) * x / n;
      t *= u;
      v = t / (a + n);
      s += v;
      n += 1.0;
   }
   s += t1;
   s += ai;

   u = a * Math.log(x);
   if( (a+b) < kMAXSTIR && Math.abs(u) < kMAXLOG )
   {
      t = gamma(a+b) / (gamma(a)*gamma(b));
      s = s * t * Math.pow(x,a);
   }
   else
   {
      t = lgam(a+b) - lgam(a) - lgam(b) + u + Math.log(s);
      if( t < kMINLOG )
         s = 0.0;
      else
         s = Math.exp(t);
   }
   return s;
}

/** @summary ROOT::Math::Cephes::incbet
  * @memberof Math */
function incbet(aa,bb,xx) {
   let a, b, t, x, xc, w, y, flag;

   if( aa <= 0.0 || bb <= 0.0 )
      return 0.0;

   // LM: changed: for X > 1 return 1.
   if  (xx <= 0.0)  return 0.0;
   if ( xx >= 1.0)  return 1.0;

   flag = 0;

/* - to test if that way is better for large b/  (comment out from Cephes version)
   if( (bb * xx) <= 1.0 && xx <= 0.95)
   {
   t = pseries(aa, bb, xx);
   goto done;
   }

**/
   w = 1.0 - xx;

/* Reverse a and b if x is greater than the mean. */
/* aa,bb > 1 -> sharp rise at x=aa/(aa+bb) */
   if( xx > (aa/(aa+bb)) )
   {
      flag = 1;
      a = bb;
      b = aa;
      xc = xx;
      x = w;
   }
   else
   {
      a = aa;
      b = bb;
      xc = w;
      x = xx;
   }

   if( flag == 1 && (b * x) <= 1.0 && x <= 0.95)
   {
      t = pseries(a, b, x);
      // goto done;
   } else {

   /* Choose expansion for better convergence. */
      y = x * (a+b-2.0) - (a-1.0);
      if( y < 0.0 )
         w = incbcf( a, b, x );
      else
         w = incbd( a, b, x ) / xc;

   /* Multiply w by the factor
      a      b   _             _     _
      x  (1-x)   | (a+b) / ( a | (a) | (b) ) .   */

      y = a * Math.log(x);
      t = b * Math.log(xc);
      if( (a+b) < kMAXSTIR && Math.abs(y) < kMAXLOG && Math.abs(t) < kMAXLOG )
      {
         t = Math.pow(xc,b);
         t *= Math.pow(x,a);
         t /= a;
         t *= w;
         t *= gamma(a+b) / (gamma(a) * gamma(b));
         // goto done;
      } else {
      /* Resort to logarithms.  */
         y += t + lgam(a+b) - lgam(a) - lgam(b);
         y += Math.log(w/a);
         if( y < kMINLOG )
            t = 0.0;
         else
            t = Math.exp(y);
      }
   }

//done:

   if( flag == 1 )
   {
      if( t <= kMACHEP )
         t = 1.0 - kMACHEP;
      else
         t = 1.0 - t;
   }
   return  t;
}

/** @summary copy of ROOT::Math::Cephes::incbi
  * @memberof Math */
function incbi(aa,bb,yy0) {
   let a, b, y0, d, y, x, x0, x1, lgm, yp, di, dithresh, yl, yh, xt;
   let i, rflg, dir, nflg, ihalve = true;

   // check the domain
   if (aa <= 0) {
      // MATH_ERROR_MSG('Cephes::incbi','Wrong domain for parameter a (must be > 0)');
      return 0;
   }
   if (bb <= 0) {
      // MATH_ERROR_MSG('Cephes::incbi','Wrong domain for parameter b (must be > 0)');
      return 0;
   }

   const process_done = () => {
      if( rflg ) {
         if( x <= kMACHEP )
            x = 1.0 - kMACHEP;
         else
            x = 1.0 - x;
      }
      return x;
   };

   i = 0;
   if( yy0 <= 0 )
      return 0.0;
   if( yy0 >= 1.0 )
      return 1.0;
   x0 = 0.0;
   yl = 0.0;
   x1 = 1.0;
   yh = 1.0;
   nflg = 0;

   if( aa <= 1.0 || bb <= 1.0 )
   {
      dithresh = 1.0e-6;
      rflg = 0;
      a = aa;
      b = bb;
      y0 = yy0;
      x = a/(a+b);
      y = incbet( a, b, x );
      // goto ihalve; // will start
   }
   else
   {
      dithresh = 1.0e-4;
/* approximation to inverse function */

      yp = -ndtri(yy0);

      if( yy0 > 0.5 )
      {
         rflg = 1;
         a = bb;
         b = aa;
         y0 = 1.0 - yy0;
         yp = -yp;
      }
      else
      {
         rflg = 0;
         a = aa;
         b = bb;
         y0 = yy0;
      }

      lgm = (yp * yp - 3.0)/6.0;
      x = 2.0/( 1.0/(2.0*a-1.0)  +  1.0/(2.0*b-1.0) );
      d = yp * Math.sqrt( x + lgm ) / x
         - ( 1.0/(2.0*b-1.0) - 1.0/(2.0*a-1.0) )
         * (lgm + 5.0/6.0 - 2.0/(3.0*x));
      d = 2.0 * d;
      if( d < kMINLOG )
      {
         // x = 1.0;
         // goto under;
         x = 0.0;
         return process_done();
      }
      x = a/( a + b * Math.exp(d) );
      y = incbet( a, b, x );
      yp = (y - y0)/y0;
      if( Math.abs(yp) < 0.2 )
         ihalve = false; // instead goto newt; exclude ihalve for the first time
   }

  let mainloop = 1000;

  // endless loop until coverage
  while (mainloop-- > 0) {

   /* Resort to interval halving if not close enough. */
   // ihalve:
      while(ihalve) {

         dir = 0;
         di = 0.5;
         for( i=0; i<100; i++ )
         {
            if( i != 0 )
            {
               x = x0  +  di * (x1 - x0);
               if( x == 1.0 )
                  x = 1.0 - kMACHEP;
               if( x == 0.0 )
               {
                  di = 0.5;
                  x = x0  +  di * (x1 - x0);
                  if( x == 0.0 )
                     return process_done(); // goto under;
               }
               y = incbet( a, b, x );
               yp = (x1 - x0)/(x1 + x0);
               if( Math.abs(yp) < dithresh )
                  break; // goto newt;
               yp = (y-y0)/y0;
               if( Math.abs(yp) < dithresh )
                  break; // goto newt;
            }
            if( y < y0 )
            {
               x0 = x;
               yl = y;
               if( dir < 0 )
               {
                  dir = 0;
                  di = 0.5;
               }
               else if( dir > 3 )
                  di = 1.0 - (1.0 - di) * (1.0 - di);
               else if( dir > 1 )
                  di = 0.5 * di + 0.5;
               else
                  di = (y0 - y)/(yh - yl);
               dir += 1;
               if( x0 > 0.75 )
               {
                  if( rflg == 1 )
                  {
                     rflg = 0;
                     a = aa;
                     b = bb;
                     y0 = yy0;
                  }
                  else
                  {
                     rflg = 1;
                     a = bb;
                     b = aa;
                     y0 = 1.0 - yy0;
                  }
                  x = 1.0 - x;
                  y = incbet( a, b, x );
                  x0 = 0.0;
                  yl = 0.0;
                  x1 = 1.0;
                  yh = 1.0;
                  continue; // goto ihalve;
               }
            }
            else
            {
               x1 = x;
               if( rflg == 1 && x1 < kMACHEP )
               {
                  x = 0.0;
                  return process_done(); // goto done;
               }
               yh = y;
               if( dir > 0 )
               {
                  dir = 0;
                  di = 0.5;
               }
               else if( dir < -3 )
                  di = di * di;
               else if( dir < -1 )
                  di = 0.5 * di;
               else
                  di = (y - y0)/(yh - yl);
               dir -= 1;
            }
         }
         //math_error( 'incbi', PLOSS );
         if( x0 >= 1.0 ) {
            x = 1.0 - kMACHEP;
            return process_done(); //goto done;
         }
         if( x <= 0.0 ) {
            //math_error( 'incbi', UNDERFLOW );
            x = 0.0;
            return process_done(); //goto done;
         }
         break; // if here, break ihalve

      } // end of ihalve

      ihalve = true; // enter loop next time

   // newt:

      if( nflg )
         return process_done(); //goto done;
      nflg = 1;
      lgm = lgam(a+b) - lgam(a) - lgam(b);

      for( i=0; i<8; i++ )
      {
         /* Compute the function at this point. */
         if( i != 0 )
            y = incbet(a,b,x);
         if( y < yl )
         {
            x = x0;
            y = yl;
         }
         else if( y > yh )
         {
            x = x1;
            y = yh;
         }
         else if( y < y0 )
         {
            x0 = x;
            yl = y;
         }
         else
         {
            x1 = x;
            yh = y;
         }
         if( x == 1.0 || x == 0.0 )
            break;
         /* Compute the derivative of the function at this point. */
         d = (a - 1.0) * Math.log(x) + (b - 1.0) * Math.log(1.0-x) + lgm;
         if( d < kMINLOG )
            return process_done(); // goto done;
         if( d > kMAXLOG )
            break;
         d = Math.exp(d);
         /* Compute the step to the next approximation of x. */
         d = (y - y0)/d;
         xt = x - d;
         if( xt <= x0 )
         {
            y = (x - x0) / (x1 - x0);
            xt = x0 + 0.5 * y * (x - x0);
            if( xt <= 0.0 )
               break;
         }
         if( xt >= x1 )
         {
            y = (x1 - x) / (x1 - x0);
            xt = x1 - 0.5 * y * (x1 - x);
            if( xt >= 1.0 )
               break;
         }
         x = xt;
         if( Math.abs(d/x) < 128.0 * kMACHEP )
            return process_done(); // goto done;
      }
   /* Did not converge.  */
      dithresh = 256.0 * kMACHEP;

   } // endless loop instead of // goto ihalve;

// done:

   return process_done();
}

/** @summary Calculates the normalized (regularized) incomplete beta function.
  * @memberof Math */
function inc_beta(x,a,b) {
   return incbet(a,b,x);
}

const BetaIncomplete = inc_beta;

/** @summary ROOT::Math::beta_quantile
  * @memberof Math */
function beta_quantile(z,a,b) {
   return incbi(a,b,z);
}

/** @summary Complement of the cumulative distribution function of the beta distribution.
  * @memberof Math */
function beta_cdf_c(x,a,b) {
   return inc_beta(1-x, b, a);
}

/** @summary chisquared_cdf
  * @memberof Math */
function chisquared_cdf(x,r,x0=0) {
   return inc_gamma ( 0.5 * r , 0.5*(x-x0) );
}

/** @summary gamma_quantile_c function
  * @memberof Math */
function gamma_quantile_c(z, alpha, theta) {
   return theta * igami( alpha, z);
}

/** @summary gamma_quantile function
  * @memberof Math */
function gamma_quantile(z, alpha, theta) {
   return theta * igami( alpha, 1.- z);
}

/** @summary breitwigner_cdf_c function
  * @memberof Math */
function breitwigner_cdf_c(x,gamma, x0 = 0) {
   return 0.5 - Math.atan(2.0 * (x-x0) / gamma) / M_PI;
}

/** @summary breitwigner_cdf function
  * @memberof Math */
function breitwigner_cdf(x, gamma, x0 = 0) {
   return 0.5 + Math.atan(2.0 * (x-x0) / gamma) / M_PI;
}

/** @summary cauchy_cdf_c function
  * @memberof Math */
function cauchy_cdf_c(x, b, x0 = 0) {
   return 0.5 - Math.atan( (x-x0) / b) / M_PI;
}

/** @summary cauchy_cdf function
  * @memberof Math */
function cauchy_cdf(x, b, x0 = 0) {
   return 0.5 + Math.atan( (x-x0) / b) / M_PI;
}

/** @summary cauchy_pdf function
  * @memberof Math */
function cauchy_pdf(x, b = 1, x0 = 0) {
   return b/(M_PI * ((x-x0)*(x-x0) + b*b));
}

/** @summary gaussian_pdf function
  * @memberof Math */
function gaussian_pdf(x, sigma = 1, x0 = 0) {
   let tmp = (x-x0)/sigma;
   return (1.0/(Math.sqrt(2 * M_PI) * Math.abs(sigma))) * Math.exp(-tmp*tmp/2);
}

/** @summary gamma_pdf function
  * @memberof Math */
function gamma_pdf(x, alpha, theta, x0 = 0) {
   if ((x - x0) < 0) {
      return 0.0;
   } else if ((x - x0) == 0) {
      return (alpha == 1) ? 1.0 / theta : 0;
   } else if (alpha == 1) {
      return Math.exp(-(x - x0) / theta) / theta;
   }
   return Math.exp((alpha - 1) * Math.log((x - x0) / theta) - (x - x0) / theta - lgamma(alpha)) / theta;
}

/** @summary tdistribution_cdf_c function
  * @memberof Math */
function tdistribution_cdf_c(x, r, x0 = 0) {
   let p    = x - x0,
       sign = (p > 0) ? 1. : -1;
   return .5 - .5*inc_beta(p*p/(r + p*p), .5, .5*r)*sign;
}

/** @summary tdistribution_cdf function
  * @memberof Math */
function tdistribution_cdf(x, r, x0 = 0) {
   let p    = x - x0,
       sign = (p > 0) ? 1. : -1;
   return  .5 + .5*inc_beta(p*p/(r + p*p), .5, .5*r)*sign;
}

/** @summary tdistribution_pdf function
  * @memberof Math */
function tdistribution_pdf(x, r, x0 = 0) {
   return (Math.exp (lgamma((r + 1.0)/2.0) - lgamma(r/2.0)) / Math.sqrt (M_PI * r))
          * Math.pow ((1.0 + (x-x0)*(x-x0)/r), -(r + 1.0)/2.0);
}

/** @summary exponential_cdf_c function
  * @memberof Math */
function exponential_cdf_c(x, lambda, x0 = 0) {
   return ((x-x0) < 0) ? 1.0 : Math.exp(-lambda * (x-x0));
}

/** @summary exponential_cdf function
  * @memberof Math */
function exponential_cdf(x, lambda, x0 = 0) {
   return ((x-x0) < 0) ? 0.0 : -Math.expm1(-lambda * (x-x0));
}

/** @summary chisquared_pdf
  * @memberof Math */
function chisquared_pdf(x, r, x0 = 0) {
   if ((x-x0) < 0) return 0.0;
   const a = r/2 -1.;
   // let return inf for case x  = x0 and treat special case of r = 2 otherwise will return nan
   if (x == x0 && a == 0) return 0.5;

   return Math.exp ((r/2 - 1) * Math.log((x-x0)/2) - (x-x0)/2 - lgamma(r/2))/2;
}

/** @summary Probability density function of the F-distribution.
  * @memberof Math */
function fdistribution_pdf(x, n, m, x0 = 0) {
   if (n < 0 || m < 0)
      return Number.NaN;
   if ((x-x0) < 0)
      return 0.0;

   return Math.exp((n/2) * Math.log(n) + (m/2) * Math.log(m) + lgamma((n+m)/2) - lgamma(n/2) - lgamma(m/2)
                 + (n/2 -1) * Math.log(x-x0) - ((n+m)/2) * Math.log(m +  n*(x-x0)) );
}

/** @summary fdistribution_cdf_c function
  * @memberof Math */
function fdistribution_cdf_c(x, n, m, x0 = 0) {
   if (n < 0 || m < 0) return Number.NaN;

   let z = m / (m + n * (x - x0));
   // fox z->1 and large a and b IB looses precision use complement function
   if (z > 0.9 && n > 1 && m > 1) return 1. - fdistribution_cdf(x, n, m, x0);

   // for the complement use the fact that IB(x,a,b) = 1. - IB(1-x,b,a)
   return inc_beta(m / (m + n * (x - x0)), .5 * m, .5 * n);
}

/** @summary fdistribution_cdf function
  * @memberof Math */
function fdistribution_cdf(x, n, m, x0 = 0) {
   if (n < 0 || m < 0) return Number.NaN;

   let z = n * (x - x0) / (m + n * (x - x0));
   // fox z->1 and large a and b IB looses precision use complement function
   if (z > 0.9 && n > 1 && m > 1)
      return 1. - fdistribution_cdf_c(x, n, m, x0);

   return inc_beta(z, .5 * n, .5 * m);
}

/** @summary Prob function
  * @memberof Math */
function Prob(chi2, ndf) {
   if (ndf <= 0) return 0; // Set CL to zero in case ndf <= 0

   if (chi2 <= 0) {
      if (chi2 < 0) return 0;
      else          return 1;
   }

   return chisquared_cdf_c(chi2,ndf,0);
}

/** @summary Gaus function
  * @memberof Math */
function Gaus(x, mean, sigma) {
   return Math.exp(-0.5 * Math.pow((x-mean) / sigma, 2));
}

/** @summary BreitWigner function
  * @memberof Math */
function BreitWigner(x, mean, gamma) {
   return gamma/((x-mean)*(x-mean) + gamma*gamma/4) / 2 / Math.PI;
}

/** @summary Calculates Beta-function Gamma(p)*Gamma(q)/Gamma(p+q).
  * @memberof Math */
function Beta(x,y) {
   return Math.exp(lgamma(x) + lgamma(y) - lgamma(x+y));
}

/** @summary GammaDist function
  * @memberof Math */
function GammaDist(x, gamma, mu = 0, beta = 1) {
   if ((x < mu) || (gamma <= 0) || (beta <= 0)) return 0;
   return gamma_pdf(x, gamma, beta, mu);
}

/** @summary probability density function of Laplace distribution
  * @memberof Math */
function LaplaceDist(x, alpha = 0, beta = 1) {
   return Math.exp(-Math.abs((x-alpha)/beta)) / (2.*beta);
}

/** @summary distribution function of Laplace distribution
  * @memberof Math */
function LaplaceDistI(x, alpha = 0, beta = 1) {
   return (x <= alpha) ? 0.5*Math.exp(-Math.abs((x-alpha)/beta)) : 1 - 0.5*Math.exp(-Math.abs((x-alpha)/beta));
}

/** @summary density function for Student's t- distribution
  * @memberof Math */
function Student(T, ndf) {
   if (ndf < 1) return 0;

   let r   = ndf,
       rh  = 0.5*r,
       rh1 = rh + 0.5,
       denom = Math.sqrt(r*Math.PI)*gamma(rh)*Math.pow(1+T*T/r, rh1);
   return gamma(rh1)/denom;
}

/** @summary cumulative distribution function of Student's
  * @memberof Math */
function StudentI(T, ndf) {
   let r = ndf;

   return (T > 0) ? (1 - 0.5*BetaIncomplete((r/(r + T*T)), r*0.5, 0.5))
                  :  0.5*BetaIncomplete((r/(r + T*T)), r*0.5, 0.5);
}

/** @summary LogNormal function
  * @memberof Math */
function LogNormal(x, sigma, theta = 0, m = 1) {
   if ((x < theta) || (sigma <= 0) || (m <= 0)) return 0;
   return lognormal_pdf(x, Math.log(m), sigma, theta);
}

/** @summary Computes the probability density function of the Beta distribution
  * @memberof Math */
function BetaDist(x, p, q) {
   if ((x < 0) || (x > 1) || (p <= 0) || (q <= 0))
     return 0;
   let beta = Beta(p, q);
   return Math.pow(x, p-1) * Math.pow(1-x, q-1) / beta;
}

/** @summary Computes the distribution function of the Beta distribution.
  * @memberof Math */
function BetaDistI(x, p, q) {
   if ((x < 0) || (x > 1) || (p <= 0) || (q <= 0)) return 0;
   return BetaIncomplete(x, p, q);
}

/** @summary gaus function for TFormula
  * @memberof Math */
function gaus(f, x, i) {
   return f.GetParValue(i+0) * Math.exp(-0.5 * Math.pow((x-f.GetParValue(i+1)) / f.GetParValue(i+2), 2));
}

/** @summary gausn function for TFormula
  * @memberof Math */
function gausn(f, x, i) {
   return gaus(f, x, i)/(Math.sqrt(2 * Math.PI) * f.GetParValue(i+2));
}

/** @summary gausxy function for TFormula
  * @memberof Math */
function gausxy(f, x, y, i) {
   return f.GetParValue(i+0) * Math.exp(-0.5 * Math.pow((x-f.GetParValue(i+1)) / f.GetParValue(i+2), 2))
                             * Math.exp(-0.5 * Math.pow((y-f.GetParValue(i+3)) / f.GetParValue(i+4), 2));
}

/** @summary expo function for TFormula
  * @memberof Math */
function expo(f, x, i) {
   return Math.exp(f.GetParValue(i+0) + f.GetParValue(i+1) * x);
}

/** @summary landau function for TFormula
  * @memberof Math */
function landau(f, x, i) {
   return Landau(x, f.GetParValue(i+1),f.GetParValue(i+2), false);
}

/** @summary landaun function for TFormula
  * @memberof Math */
function landaun(f, x, i) {
   return Landau(x, f.GetParValue(i+1),f.GetParValue(i+2), true);
}

/** @summary Crystal ball function
  * @memberof Math */
function crystalball_function(x, alpha, n, sigma, mean = 0) {
   if (sigma < 0.)     return 0.;
   let z = (x - mean)/sigma;
   if (alpha < 0) z = -z;
   let abs_alpha = Math.abs(alpha);
   if (z  > - abs_alpha)
      return Math.exp(- 0.5 * z * z);
   let nDivAlpha = n/abs_alpha,
       AA =  Math.exp(-0.5*abs_alpha*abs_alpha),
       B = nDivAlpha - abs_alpha,
       arg = nDivAlpha/(B-z);
  return AA * Math.pow(arg,n);
}

/** @summary pdf definition of the crystal_ball which is defined only for n > 1 otherwise integral is diverging
  * @memberof Math */
function crystalball_pdf(x, alpha, n, sigma, mean = 0) {
   if (sigma < 0.) return 0.;
   if (n <= 1) return Number.NaN;  // pdf is not normalized for n <=1
   let abs_alpha = Math.abs(alpha),
       C = n/abs_alpha * 1./(n-1.) * Math.exp(-alpha*alpha/2.),
       D = Math.sqrt(M_PI/2.)*(1.+erf(abs_alpha/Math.sqrt(2.))),
       N = 1./(sigma*(C+D));
   return N * crystalball_function(x,alpha,n,sigma,mean);
}

/** @summary compute the integral of the crystal ball function
  * @memberof Math */
function crystalball_integral(x, alpha, n, sigma, mean = 0) {
   if (sigma == 0) return 0;
   if (alpha == 0) return 0.;
   let useLog = (n == 1.0),
       z = (x-mean)/sigma;
   if (alpha < 0 ) z = -z;

   let abs_alpha = Math.abs(alpha),
       intgaus = 0., intpow  = 0.;

   const sqrtpiover2 = Math.sqrt(M_PI/2.),
         sqrt2pi = Math.sqrt( 2.*M_PI),
         oneoversqrt2 = 1./Math.sqrt(2.);
   if (z <= -abs_alpha) {
      let A = Math.pow(n/abs_alpha,n) * Math.exp(-0.5 * alpha*alpha),
          B = n/abs_alpha - abs_alpha;

      if (!useLog) {
         let C = (n/abs_alpha) * (1./(n-1)) * Math.exp(-alpha*alpha/2.);
         intpow  = C - A /(n-1.) * Math.pow(B-z,-n+1) ;
      }
      else {
         // for n=1 the primitive of 1/x is log(x)
         intpow = -A * Math.log( n / abs_alpha ) + A * Math.log( B -z );
      }
      intgaus =  sqrtpiover2*(1. + erf(abs_alpha*oneoversqrt2));
   }
   else
   {
      intgaus = normal_cdf_c(z, 1);
      intgaus *= sqrt2pi;
      intpow  =  0;
   }
   return sigma * (intgaus + intpow);
}

/** @summary crystalball_cdf function
  * @memberof Math */
function crystalball_cdf(x, alpha, n, sigma, mean = 0) {
   if (n <= 1.)
      return Number.NaN;

   let abs_alpha = Math.abs(alpha),
       C = n/abs_alpha * 1./(n-1.) * Math.exp(-alpha*alpha/2.),
       D = Math.sqrt(M_PI/2.)*(1. + erf(abs_alpha/Math.sqrt(2.))),
       totIntegral = sigma*(C+D),
       integral = crystalball_integral(x,alpha,n,sigma,mean);

   return (alpha > 0) ? 1. - integral/totIntegral : integral/totIntegral;
}

/** @summary crystalball_cdf_c function
  * @memberof Math */
function crystalball_cdf_c(x, alpha, n, sigma, mean = 0) {
   if (n <= 1.)
      return Number.NaN;

   let abs_alpha = Math.abs(alpha),
       C = n/abs_alpha * 1./(n-1.) * Math.exp(-alpha*alpha/2.),
       D = Math.sqrt(M_PI/2.)*(1. + erf(abs_alpha/Math.sqrt(2.))),
       totIntegral = sigma*(C+D),
       integral = crystalball_integral(x,alpha,n,sigma,mean);

   return (alpha > 0) ? integral/totIntegral : 1. - (integral/totIntegral);
}

/** @summary ChebyshevN function
  * @memberof Math */
function ChebyshevN(n, x, c) {
   let d1 = 0.0, d2 = 0.0, y2 = 2.0 * x;

   for (let i = n; i >= 1; i--) {
      let temp = d1;
      d1 = y2 * d1 - d2 + c[i];
      d2 = temp;
   }

   return x * d1 - d2 + c[0];
}

/** @summary Chebyshev1 function
  * @memberof Math */
function Chebyshev1(x, c0, c1) {
   return c0 + c1*x;
}

/** @summary Chebyshev2 function
  * @memberof Math */
function Chebyshev2(x, c0, c1, c2) {
   return c0 + c1*x + c2*(2.0*x*x - 1.0);
}

/** @summary Chebyshev3 function
  * @memberof Math */
function Chebyshev3(x, ...args) {
   return ChebyshevN(3, x, args);
}

/** @summary Chebyshev4 function
  * @memberof Math */
function Chebyshev4(x, ...args) {
   return ChebyshevN(4, x, args);
}

/** @summary Chebyshev5 function
  * @memberof Math */
function Chebyshev5(x, ...args) {
   return ChebyshevN(5, x, args);
}

/** @summary Chebyshev6 function
  * @memberof Math */
function Chebyshev6(x, ...args) {
   return ChebyshevN(6, x, args);
}

/** @summary Chebyshev7 function
  * @memberof Math */
function Chebyshev7(x, ...args) {
   return ChebyshevN(7, x, args);
}

/** @summary Chebyshev8 function
  * @memberof Math */
function Chebyshev8(x, ...args) {
   return ChebyshevN(8, x, args);
}

/** @summary Chebyshev9 function
  * @memberof Math */
function Chebyshev9(x, ...args) {
   return ChebyshevN(9, x, args);
}

/** @summary Chebyshev10 function
  * @memberof Math */
function Chebyshev10(x, ...args) {
   return ChebyshevN(10, x, args);
}

// =========================================================================

/** @summary Caluclate ClopperPearson
  * @memberof Math */
function eff_ClopperPearson(total,passed,level,bUpper) {
   let alpha = (1.0 - level) / 2;
   if(bUpper)
      return ((passed == total) ? 1.0 : beta_quantile(1 - alpha,passed + 1,total-passed));

   return ((passed == 0) ? 0.0 : beta_quantile(alpha,passed,total-passed+1.0));
}

/** @summary Caluclate normal
  * @memberof Math */
function eff_Normal(total,passed,level,bUpper) {
   if (total == 0) return bUpper ? 1 : 0;

   let alpha = (1.0 - level)/2,
       average = passed / total,
       sigma = Math.sqrt(average * (1 - average) / total),
       delta = normal_quantile(1 - alpha, sigma);

   if(bUpper)
      return ((average + delta) > 1) ? 1.0 : (average + delta);

   return ((average - delta) < 0) ? 0.0 : (average - delta);
}

/** @summary Calculates the boundaries for the frequentist Wilson interval
  * @memberof Math */
function eff_Wilson(total,passed,level,bUpper) {
   let alpha = (1.0 - level)/2;
   if (total == 0) return bUpper ? 1 : 0;
   let average = passed / total,
       kappa = normal_quantile(1 - alpha,1),
       mode = (passed + 0.5 * kappa * kappa) / (total + kappa * kappa),
       delta = kappa / (total + kappa*kappa) * Math.sqrt(total * average * (1 - average) + kappa * kappa / 4);

   if(bUpper)
      return ((mode + delta) > 1) ? 1.0 : (mode + delta);

   return ((mode - delta) < 0) ? 0.0 : (mode - delta);
}

/** @summary Calculates the boundaries for the frequentist Agresti-Coull interval
  * @memberof Math */
function eff_AgrestiCoull(total,passed,level,bUpper) {
   let alpha = (1.0 - level)/2,
       kappa = normal_quantile(1 - alpha,1),
       mode = (passed + 0.5 * kappa * kappa) / (total + kappa * kappa),
       delta = kappa * Math.sqrt(mode * (1 - mode) / (total + kappa * kappa));

  if(bUpper)
     return ((mode + delta) > 1) ? 1.0 : (mode + delta);

  return ((mode - delta) < 0) ? 0.0 : (mode - delta);
}

/** @summary Calculates the boundaries using the  mid-P binomial
  * @memberof Math */
function eff_MidPInterval(total,passed,level,bUpper) {
   const alpha = 1. - level, alpha_min = alpha/2 , tol = 1e-9; // tolerance
   let pmin = 0, pmax = 1, p = 0;

   // treat special case for 0<passed<1
   // do a linear interpolation of the upper limit values
   if ( passed > 0 && passed < 1) {
      let p0 =  eff_MidPInterval(total,0.0,level,bUpper);
      let p1 =  eff_MidPInterval(total,1.0,level,bUpper);
      p = (p1 - p0) * passed + p0;
      return p;
   }

   while (Math.abs(pmax - pmin) > tol) {
      p = (pmin + pmax)/2;
      //double v = 0.5 * ROOT::Math::binomial_pdf(int(passed), p, int(total));
      // make it work for non integer using the binomial - beta relationship
      let v = 0.5 * beta_pdf(p, passed+1., total-passed+1)/(total+1);
      //if (passed > 0) v += ROOT::Math::binomial_cdf(int(passed - 1), p, int(total));
      // compute the binomial cdf at passed -1
      if ( (passed-1) >= 0) v += beta_cdf_c(p, passed, total-passed+1);

      let vmin = bUpper ? alpha_min : 1.- alpha_min;
      if (v > vmin)
         pmin = p;
      else
         pmax = p;
   }

   return p;
}

/** @summary for a central confidence interval for a Beta distribution
  * @memberof Math */
function eff_Bayesian(total,passed,level,bUpper,alpha,beta) {
   let  a = passed + alpha,
        b = total - passed + beta;
   if(bUpper) {
      if((a > 0) && (b > 0))
         return beta_quantile((1+level)/2,a,b);
      else
         return 1;
   } else {
      if((a > 0) && (b > 0))
         return beta_quantile((1-level)/2,a,b);
      else
         return 0;
   }
}

/** @summary Return function to calculate boundary of TEfficiency
  * @memberof Math */
function getTEfficiencyBoundaryFunc(option, isbayessian) {
   const  kFCP = 0,       ///< Clopper-Pearson interval (recommended by PDG)
          kFNormal = 1,   ///< Normal approximation
          kFWilson = 2,   ///< Wilson interval
          kFAC = 3,       ///< Agresti-Coull interval
          kFFC = 4,       ///< Feldman-Cousins interval, too complicated for JavaScript
          // kBJeffrey = 5,  ///< Jeffrey interval (Prior ~ Beta(0.5,0.5)
          // kBUniform = 6,  ///< Prior ~ Uniform = Beta(1,1)
          // kBBayesian = 7, ///< User specified Prior ~ Beta(fBeta_alpha,fBeta_beta)
          kMidP = 8;      ///< Mid-P Lancaster interval

   if (isbayessian)
      return eff_Bayesian;

   switch (option) {
      case kFCP: return eff_ClopperPearson;
      case kFNormal: return eff_Normal;
      case kFWilson: return eff_Wilson;
      case kFAC: return eff_AgrestiCoull;
      case kFFC: console.log('Feldman-Cousins interval kFFC not supported; using kFCP'); return eff_ClopperPearson;
      case kMidP: return eff_MidPInterval;
      // case kBJeffrey:
      // case kBUniform:
      // case kBBayesian: return eff_ClopperPearson;
   }
   console.log(`Not recognized stat option ${option}, using kFCP`);
   return eff_ClopperPearson;
}

var jsroot_math = /*#__PURE__*/Object.freeze({
__proto__: null,
gamma: gamma,
tgamma: gamma,
Gamma: gamma,
Polynomialeval: Polynomialeval,
Polynomial1eval: Polynomial1eval,
stirf: stirf,
gamma_pdf: gamma_pdf,
ndtri: ndtri,
normal_quantile: normal_quantile,
normal_quantile_c: normal_quantile_c,
lognormal_cdf_c: lognormal_cdf_c,
lognormal_cdf: lognormal_cdf,
igami: igami,
igamc: igamc,
igam: igam,
lgam: lgam,
lgamma: lgamma,
erfc: erfc,
erf: erf,
beta_pdf: beta_pdf,
inc_beta: inc_beta,
BetaIncomplete: BetaIncomplete,
pseries: pseries,
incbet: incbet,
incbi: incbi,
beta_quantile: beta_quantile,
chisquared_cdf_c: chisquared_cdf_c,
beta: beta,
inc_gamma: inc_gamma,
inc_gamma_c: inc_gamma_c,
landau_pdf: landau_pdf,
beta_cdf_c: beta_cdf_c,
Landau: Landau,
fdistribution_pdf: fdistribution_pdf,
FDist: fdistribution_pdf,
fdistribution_cdf: fdistribution_cdf,
FDistI: fdistribution_cdf,
fdistribution_cdf_c: fdistribution_cdf_c,
normal_cdf_c: normal_cdf_c,
gaussian_cdf_c: normal_cdf_c,
normal_cdf: normal_cdf,
gaussian_cdf: normal_cdf,
lognormal_pdf: lognormal_pdf,
normal_pdf: normal_pdf,
crystalball_function: crystalball_function,
crystalball_pdf: crystalball_pdf,
crystalball_cdf: crystalball_cdf,
crystalball_cdf_c: crystalball_cdf_c,
chisquared_cdf: chisquared_cdf,
gamma_quantile_c: gamma_quantile_c,
gamma_quantile: gamma_quantile,
breitwigner_cdf_c: breitwigner_cdf_c,
breitwigner_cdf: breitwigner_cdf,
cauchy_cdf_c: cauchy_cdf_c,
cauchy_cdf: cauchy_cdf,
cauchy_pdf: cauchy_pdf,
gaussian_pdf: gaussian_pdf,
tdistribution_cdf_c: tdistribution_cdf_c,
tdistribution_cdf: tdistribution_cdf,
tdistribution_pdf: tdistribution_pdf,
exponential_cdf_c: exponential_cdf_c,
exponential_cdf: exponential_cdf,
chisquared_pdf: chisquared_pdf,
Beta: Beta,
GammaDist: GammaDist,
LaplaceDist: LaplaceDist,
LaplaceDistI: LaplaceDistI,
LogNormal: LogNormal,
Student: Student,
StudentI: StudentI,
gaus: gaus,
gausn: gausn,
gausxy: gausxy,
expo: expo,
Prob: Prob,
Gaus: Gaus,
BreitWigner: BreitWigner,
BetaDist: BetaDist,
BetaDistI: BetaDistI,
landau: landau,
landaun: landaun,
ChebyshevN: ChebyshevN,
Chebyshev1: Chebyshev1,
Chebyshev2: Chebyshev2,
Chebyshev3: Chebyshev3,
Chebyshev4: Chebyshev4,
Chebyshev5: Chebyshev5,
Chebyshev6: Chebyshev6,
Chebyshev7: Chebyshev7,
Chebyshev8: Chebyshev8,
Chebyshev9: Chebyshev9,
Chebyshev10: Chebyshev10,
getTEfficiencyBoundaryFunc: getTEfficiencyBoundaryFunc
});

/** @summary Display progress message in the left bottom corner.
  * @desc Previous message will be overwritten
  * if no argument specified, any shown messages will be removed
  * @param {string} msg - message to display
  * @param {number} tmout - optional timeout in milliseconds, after message will disappear
  * @private */
function showProgress(msg, tmout) {
   if (isBatchMode() || (typeof document === 'undefined')) return;
   let id = 'jsroot_progressbox',
       box = select('#' + id);

   if (!settings.ProgressBox)
      return box.remove();

   if ((arguments.length == 0) || !msg) {
      if ((tmout !== -1) || (!box.empty() && box.property('with_timeout'))) box.remove();
      return;
   }

   if (box.empty()) {
      box = select(document.body)
              .append('div').attr('id', id)
              .attr('style', 'position: fixed; min-width: 100px; height: auto; overflow: visible; z-index: 101; border: 1px solid #999; background: #F8F8F8; left: 10px; bottom: 10px;');
      box.append('p');
   }

   box.property('with_timeout', false);

   if (isStr(msg)) {
      box.select('p').html(msg);
   } else {
      box.html('');
      box.node().appendChild(msg);
   }
   injectStyle('#jsroot_progressbox p { font-size: 10px; margin-left: 10px; margin-right: 10px; margin-top: 3px; margin-bottom: 3px; }', box.node());

   if (Number.isFinite(tmout) && (tmout > 0)) {
      box.property('with_timeout', true);
      setTimeout(() => showProgress('', -1), tmout);
   }
}

/** @summary Tries to close current browser tab
  * @desc Many browsers do not allow simple window.close() call,
  * therefore try several workarounds
  * @private */
function closeCurrentWindow() {
   if (!window) return;
   window.close();
   window.open('', '_self').close();
}


function tryOpenOpenUI(sources, args) {
   if (!sources || (sources.length == 0)) {
      if (args.rejectFunc) {
         args.rejectFunc(Error('openui5 was not possible to load'));
         args.rejectFunc = null;
      }
      return;
   }

   // where to take openui5 sources
   let src = sources.shift();

   if ((src.indexOf('roothandler') == 0) && (src.indexOf('://') < 0))
      src = src.replace(/\:\//g, '://');

   let element = document.createElement('script');
   element.setAttribute('type', 'text/javascript');
   element.setAttribute('id', 'sap-ui-bootstrap');
   // use nojQuery while we are already load jquery and jquery-ui, later one can use directly sap-ui-core.js

   // this is location of openui5 scripts when working with THttpServer or when scripts are installed inside JSROOT
   element.setAttribute('src', src + 'resources/sap-ui-core.js'); // latest openui5 version

   element.setAttribute('data-sap-ui-libs', args.openui5libs ?? 'sap.m, sap.ui.layout, sap.ui.unified, sap.ui.commons');

   element.setAttribute('data-sap-ui-theme', args.openui5theme || 'sap_belize');
   element.setAttribute('data-sap-ui-compatVersion', 'edge');
   // element.setAttribute('data-sap-ui-bindingSyntax', 'complex');

   element.setAttribute('data-sap-ui-preload', 'async'); // '' to disable Component-preload.js

   element.setAttribute('data-sap-ui-evt-oninit', 'completeUI5Loading()');

   element.onerror = function() {
      // remove failed element
      element.parentNode.removeChild(element);
      // and try next
      tryOpenOpenUI(sources, args);
   };

   element.onload = function() {
      console.log(`Load openui5 from ${src}`);
   };

   document.head.appendChild(element);
}


// return Promise let loader wait before dependent source will be invoked

async function loadOpenui5(args) {
   // very simple - openui5 was loaded before and will be used as is
   if (typeof sap == 'object')
      return sap;

   if (!args) args = {};

   let rootui5sys = exports.source_dir.replace(/jsrootsys/g, 'rootui5sys');

   if (rootui5sys == exports.source_dir) {
      // if jsrootsys location not detected, try to guess it
      if (window.location.port && (window.location.pathname.indexOf('/win') >= 0) && (!args.openui5src || args.openui5src == 'nojsroot' || args.openui5src == 'jsroot'))
         rootui5sys = window.location.origin + window.location.pathname + '../rootui5sys/';
      else
         rootui5sys = undefined;
   }

   let openui5_sources = [],
       openui5_dflt = 'https://openui5.hana.ondemand.com/1.98.0/',
       openui5_root = rootui5sys ? rootui5sys + 'distribution/' : '';

   if (isStr(args.openui5src)) {
      switch (args.openui5src) {
         case 'nodefault': openui5_dflt = ''; break;
         case 'default': openui5_sources.push(openui5_dflt); openui5_dflt = ''; break;
         case 'nojsroot': /* openui5_root = ''; */ break;
         case 'jsroot': openui5_sources.push(openui5_root); openui5_root = ''; break;
         default: openui5_sources.push(args.openui5src); break;
      }
   }

   if (openui5_root && (openui5_sources.indexOf(openui5_root) < 0)) openui5_sources.push(openui5_root);
   if (openui5_dflt && (openui5_sources.indexOf(openui5_dflt) < 0)) openui5_sources.push(openui5_dflt);

   return new Promise((resolve, reject) => {

      args.resolveFunc = resolve;
      args.rejectFunc = reject;

      globalThis.completeUI5Loading = function() {
         sap.ui.loader.config({
            paths: {
               jsroot: exports.source_dir,
               rootui5: rootui5sys
            }
         });

         if (args.resolveFunc) {
            args.resolveFunc(sap);
            args.resolveFunc = null;
         }
      };

      tryOpenOpenUI(openui5_sources, args);
   });

}

// some icons taken from http://uxrepo.com/
const ToolbarIcons = {
   camera: { path: 'M 152.00,304.00c0.00,57.438, 46.562,104.00, 104.00,104.00s 104.00-46.562, 104.00-104.00s-46.562-104.00-104.00-104.00S 152.00,246.562, 152.00,304.00z M 480.00,128.00L 368.00,128.00 c-8.00-32.00-16.00-64.00-48.00-64.00L 192.00,64.00 c-32.00,0.00-40.00,32.00-48.00,64.00L 32.00,128.00 c-17.60,0.00-32.00,14.40-32.00,32.00l0.00,288.00 c0.00,17.60, 14.40,32.00, 32.00,32.00l 448.00,0.00 c 17.60,0.00, 32.00-14.40, 32.00-32.00L 512.00,160.00 C 512.00,142.40, 497.60,128.00, 480.00,128.00z M 256.00,446.00c-78.425,0.00-142.00-63.574-142.00-142.00c0.00-78.425, 63.575-142.00, 142.00-142.00c 78.426,0.00, 142.00,63.575, 142.00,142.00 C 398.00,382.426, 334.427,446.00, 256.00,446.00z M 480.00,224.00l-64.00,0.00 l0.00-32.00 l 64.00,0.00 L 480.00,224.00 z' },
   disk: { path: 'M384,0H128H32C14.336,0,0,14.336,0,32v448c0,17.656,14.336,32,32,32h448c17.656,0,32-14.344,32-32V96L416,0H384z M352,160   V32h32v128c0,17.664-14.344,32-32,32H160c-17.664,0-32-14.336-32-32V32h128v128H352z M96,288c0-17.656,14.336-32,32-32h256   c17.656,0,32,14.344,32,32v192H96V288z' },
   question: { path: 'M256,512c141.375,0,256-114.625,256-256S397.375,0,256,0S0,114.625,0,256S114.625,512,256,512z M256,64   c63.719,0,128,36.484,128,118.016c0,47.453-23.531,84.516-69.891,110.016C300.672,299.422,288,314.047,288,320   c0,17.656-14.344,32-32,32c-17.664,0-32-14.344-32-32c0-40.609,37.25-71.938,59.266-84.031   C315.625,218.109,320,198.656,320,182.016C320,135.008,279.906,128,256,128c-30.812,0-64,20.227-64,64.672   c0,17.664-14.336,32-32,32s-32-14.336-32-32C128,109.086,193.953,64,256,64z M256,449.406c-18.211,0-32.961-14.75-32.961-32.969   c0-18.188,14.75-32.953,32.961-32.953c18.219,0,32.969,14.766,32.969,32.953C288.969,434.656,274.219,449.406,256,449.406z' },
   undo: { path: 'M450.159,48.042c8.791,9.032,16.983,18.898,24.59,29.604c7.594,10.706,14.146,22.207,19.668,34.489  c5.509,12.296,9.82,25.269,12.92,38.938c3.113,13.669,4.663,27.834,4.663,42.499c0,14.256-1.511,28.863-4.532,43.822  c-3.009,14.952-7.997,30.217-14.953,45.795c-6.955,15.577-16.202,31.52-27.755,47.826s-25.88,32.9-42.942,49.807  c-5.51,5.444-11.787,11.67-18.834,18.651c-7.033,6.98-14.496,14.366-22.39,22.168c-7.88,7.802-15.955,15.825-24.187,24.069  c-8.258,8.231-16.333,16.203-24.252,23.888c-18.3,18.13-37.354,37.016-57.191,56.65l-56.84-57.445  c19.596-19.472,38.54-38.279,56.84-56.41c7.75-7.685,15.772-15.604,24.108-23.757s16.438-16.163,24.33-24.057  c7.894-7.893,15.356-15.33,22.402-22.312c7.034-6.98,13.312-13.193,18.821-18.651c22.351-22.402,39.165-44.648,50.471-66.738  c11.279-22.09,16.932-43.567,16.932-64.446c0-15.785-3.217-31.005-9.638-45.671c-6.422-14.665-16.229-28.504-29.437-41.529  c-3.282-3.282-7.358-6.395-12.217-9.325c-4.871-2.938-10.381-5.503-16.516-7.697c-6.121-2.201-12.815-3.992-20.058-5.373  c-7.242-1.374-14.9-2.064-23.002-2.064c-8.218,0-16.802,0.834-25.788,2.507c-8.961,1.674-18.053,4.429-27.222,8.271  c-9.189,3.842-18.456,8.869-27.808,15.089c-9.358,6.219-18.521,13.819-27.502,22.793l-59.92,60.271l93.797,94.058H0V40.91  l93.27,91.597l60.181-60.532c13.376-15.018,27.222-27.248,41.536-36.697c14.308-9.443,28.608-16.776,42.89-21.992  c14.288-5.223,28.505-8.74,42.623-10.557C294.645,0.905,308.189,0,321.162,0c13.429,0,26.389,1.185,38.84,3.562  c12.478,2.377,24.2,5.718,35.192,10.029c11.006,4.311,21.126,9.404,30.374,15.265C434.79,34.724,442.995,41.119,450.159,48.042z' },
   arrow_right: { path: 'M30.796,226.318h377.533L294.938,339.682c-11.899,11.906-11.899,31.184,0,43.084c11.887,11.899,31.19,11.893,43.077,0  l165.393-165.386c5.725-5.712,8.924-13.453,8.924-21.539c0-8.092-3.213-15.84-8.924-21.551L338.016,8.925  C332.065,2.975,324.278,0,316.478,0c-7.802,0-15.603,2.968-21.539,8.918c-11.899,11.906-11.899,31.184,0,43.084l113.391,113.384  H30.796c-16.822,0-30.463,13.645-30.463,30.463C0.333,212.674,13.974,226.318,30.796,226.318z' },
   arrow_up: { path: 'M295.505,629.446V135.957l148.193,148.206c15.555,15.559,40.753,15.559,56.308,0c15.555-15.538,15.546-40.767,0-56.304  L283.83,11.662C276.372,4.204,266.236,0,255.68,0c-10.568,0-20.705,4.204-28.172,11.662L11.333,227.859  c-7.777,7.777-11.666,17.965-11.666,28.158c0,10.192,3.88,20.385,11.657,28.158c15.563,15.555,40.762,15.555,56.317,0  l148.201-148.219v493.489c0,21.993,17.837,39.82,39.82,39.82C277.669,669.267,295.505,651.439,295.505,629.446z' },
   arrow_diag: { path: 'M279.875,511.994c-1.292,0-2.607-0.102-3.924-0.312c-10.944-1.771-19.333-10.676-20.457-21.71L233.97,278.348  L22.345,256.823c-11.029-1.119-19.928-9.51-21.698-20.461c-1.776-10.944,4.031-21.716,14.145-26.262L477.792,2.149  c9.282-4.163,20.167-2.165,27.355,5.024c7.201,7.189,9.199,18.086,5.024,27.356L302.22,497.527  C298.224,506.426,289.397,511.994,279.875,511.994z M118.277,217.332l140.534,14.294c11.567,1.178,20.718,10.335,21.878,21.896  l14.294,140.519l144.09-320.792L118.277,217.332z' },
   auto_zoom: { path: 'M505.441,242.47l-78.303-78.291c-9.18-9.177-24.048-9.171-33.216,0c-9.169,9.172-9.169,24.045,0.006,33.217l38.193,38.188  H280.088V80.194l38.188,38.199c4.587,4.584,10.596,6.881,16.605,6.881c6.003,0,12.018-2.297,16.605-6.875  c9.174-9.172,9.174-24.039,0.011-33.217L273.219,6.881C268.803,2.471,262.834,0,256.596,0c-6.229,0-12.202,2.471-16.605,6.881  l-78.296,78.302c-9.178,9.172-9.178,24.045,0,33.217c9.177,9.171,24.051,9.171,33.21,0l38.205-38.205v155.4H80.521l38.2-38.188  c9.177-9.171,9.177-24.039,0.005-33.216c-9.171-9.172-24.039-9.178-33.216,0L7.208,242.464c-4.404,4.403-6.881,10.381-6.881,16.611  c0,6.227,2.477,12.207,6.881,16.61l78.302,78.291c4.587,4.581,10.599,6.875,16.605,6.875c6.006,0,12.023-2.294,16.61-6.881  c9.172-9.174,9.172-24.036-0.005-33.211l-38.205-38.199h152.593v152.063l-38.199-38.211c-9.171-9.18-24.039-9.18-33.216-0.022  c-9.178,9.18-9.178,24.059-0.006,33.222l78.284,78.302c4.41,4.404,10.382,6.881,16.611,6.881c6.233,0,12.208-2.477,16.611-6.881  l78.302-78.296c9.181-9.18,9.181-24.048,0-33.205c-9.174-9.174-24.054-9.174-33.21,0l-38.199,38.188v-152.04h152.051l-38.205,38.199  c-9.18,9.175-9.18,24.037-0.005,33.211c4.587,4.587,10.596,6.881,16.604,6.881c6.01,0,12.024-2.294,16.605-6.875l78.303-78.285  c4.403-4.403,6.887-10.378,6.887-16.611C512.328,252.851,509.845,246.873,505.441,242.47z' },
   statbox: {
      path: 'M28.782,56.902H483.88c15.707,0,28.451-12.74,28.451-28.451C512.331,12.741,499.599,0,483.885,0H28.782   C13.074,0,0.331,12.741,0.331,28.451C0.331,44.162,13.074,56.902,28.782,56.902z' +
         'M483.885,136.845H28.782c-15.708,0-28.451,12.741-28.451,28.451c0,15.711,12.744,28.451,28.451,28.451H483.88   c15.707,0,28.451-12.74,28.451-28.451C512.331,149.586,499.599,136.845,483.885,136.845z' +
         'M483.885,273.275H28.782c-15.708,0-28.451,12.731-28.451,28.452c0,15.707,12.744,28.451,28.451,28.451H483.88   c15.707,0,28.451-12.744,28.451-28.451C512.337,286.007,499.599,273.275,483.885,273.275z' +
         'M256.065,409.704H30.492c-15.708,0-28.451,12.731-28.451,28.451c0,15.707,12.744,28.451,28.451,28.451h225.585   c15.707,0,28.451-12.744,28.451-28.451C284.516,422.436,271.785,409.704,256.065,409.704z'
   },
   circle: { path: 'M256,256 m-150,0 a150,150 0 1,0 300,0 a150,150 0 1,0 -300,0' },
   three_circles: { path: 'M256,85 m-70,0 a70,70 0 1,0 140,0 a70,70 0 1,0 -140,0  M256,255 m-70,0 a70,70 0 1,0 140,0 a70,70 0 1,0 -140,0  M256,425 m-70,0 a70,70 0 1,0 140,0 a70,70 0 1,0 -140,0 ' },
   diamand: { path: 'M256,0L384,256L256,511L128,256z' },
   rect: { path: 'M80,80h352v352h-352z' },
   cross: { path: 'M80,40l176,176l176,-176l40,40l-176,176l176,176l-40,40l-176,-176l-176,176l-40,-40l176,-176l-176,-176z' },
   vrgoggles: { size: '245.82 141.73', path: 'M175.56,111.37c-22.52,0-40.77-18.84-40.77-42.07S153,27.24,175.56,27.24s40.77,18.84,40.77,42.07S198.08,111.37,175.56,111.37ZM26.84,69.31c0-23.23,18.25-42.07,40.77-42.07s40.77,18.84,40.77,42.07-18.26,42.07-40.77,42.07S26.84,92.54,26.84,69.31ZM27.27,0C11.54,0,0,12.34,0,28.58V110.9c0,16.24,11.54,30.83,27.27,30.83H99.57c2.17,0,4.19-1.83,5.4-3.7L116.47,118a8,8,0,0,1,12.52-.18l11.51,20.34c1.2,1.86,3.22,3.61,5.39,3.61h72.29c15.74,0,27.63-14.6,27.63-30.83V28.58C245.82,12.34,233.93,0,218.19,0H27.27Z' },
   th2colorz: { recs: [{ x: 128, y: 486, w: 256, h: 26, f: 'rgb(38,62,168)' }, { y: 461, f: 'rgb(22,82,205)' }, { y: 435, f: 'rgb(16,100,220)' }, { y: 410, f: 'rgb(18,114,217)' }, { y: 384, f: 'rgb(20,129,214)' }, { y: 358, f: 'rgb(14,143,209)' }, { y: 333, f: 'rgb(9,157,204)' }, { y: 307, f: 'rgb(13,167,195)' }, { y: 282, f: 'rgb(30,175,179)' }, { y: 256, f: 'rgb(46,183,164)' }, { y: 230, f: 'rgb(82,186,146)' }, { y: 205, f: 'rgb(116,189,129)' }, { y: 179, f: 'rgb(149,190,113)' }, { y: 154, f: 'rgb(179,189,101)' }, { y: 128, f: 'rgb(209,187,89)' }, { y: 102, f: 'rgb(226,192,75)' }, { y: 77, f: 'rgb(244,198,59)' }, { y: 51, f: 'rgb(253,210,43)' }, { y: 26, f: 'rgb(251,230,29)' }, { y: 0, f: 'rgb(249,249,15)' }] },
   th2color: { recs: [{x:0,y:256,w:13,h:39,f:'rgb(38,62,168)'},{x:13,y:371,w:39,h:39},{y:294,h:39},{y:256,h:39},{y:218,h:39},{x:51,y:410,w:39,h:39},{y:371,h:39},{y:333,h:39},{y:294},{y:256,h:39},{y:218,h:39},{y:179,h:39},{y:141,h:39},{y:102,h:39},{y:64},{x:90,y:448,w:39,h:39},{y:410},{y:371,h:39},{y:333,h:39,f:'rgb(22,82,205)'},{y:294},{y:256,h:39,f:'rgb(16,100,220)'},{y:218,h:39},{y:179,h:39,f:'rgb(22,82,205)'},{y:141,h:39},{y:102,h:39,f:'rgb(38,62,168)'},{y:64},{y:0,h:27},{x:128,y:448,w:39,h:39},{y:410},{y:371,h:39},{y:333,h:39,f:'rgb(22,82,205)'},{y:294,f:'rgb(20,129,214)'},{y:256,h:39,f:'rgb(9,157,204)'},{y:218,h:39,f:'rgb(14,143,209)'},{y:179,h:39,f:'rgb(20,129,214)'},{y:141,h:39,f:'rgb(16,100,220)'},{y:102,h:39,f:'rgb(22,82,205)'},{y:64,f:'rgb(38,62,168)'},{y:26,h:39},{y:0,h:27},{x:166,y:486,h:14},{y:448,h:39},{y:410},{y:371,h:39,f:'rgb(22,82,205)'},{y:333,h:39,f:'rgb(20,129,214)'},{y:294,f:'rgb(82,186,146)'},{y:256,h:39,f:'rgb(179,189,101)'},{y:218,h:39,f:'rgb(116,189,129)'},{y:179,h:39,f:'rgb(82,186,146)'},{y:141,h:39,f:'rgb(14,143,209)'},{y:102,h:39,f:'rgb(16,100,220)'},{y:64,f:'rgb(38,62,168)'},{y:26,h:39},{x:205,y:486,w:39,h:14},{y:448,h:39},{y:410},{y:371,h:39,f:'rgb(16,100,220)'},{y:333,h:39,f:'rgb(9,157,204)'},{y:294,f:'rgb(149,190,113)'},{y:256,h:39,f:'rgb(244,198,59)'},{y:218,h:39},{y:179,h:39,f:'rgb(226,192,75)'},{y:141,h:39,f:'rgb(13,167,195)'},{y:102,h:39,f:'rgb(18,114,217)'},{y:64,f:'rgb(22,82,205)'},{y:26,h:39,f:'rgb(38,62,168)'},{x:243,y:448,w:39,h:39},{y:410},{y:371,h:39,f:'rgb(18,114,217)'},{y:333,h:39,f:'rgb(30,175,179)'},{y:294,f:'rgb(209,187,89)'},{y:256,h:39,f:'rgb(251,230,29)'},{y:218,h:39,f:'rgb(249,249,15)'},{y:179,h:39,f:'rgb(226,192,75)'},{y:141,h:39,f:'rgb(30,175,179)'},{y:102,h:39,f:'rgb(18,114,217)'},{y:64,f:'rgb(38,62,168)'},{y:26,h:39},{x:282,y:448,h:39},{y:410},{y:371,h:39,f:'rgb(18,114,217)'},{y:333,h:39,f:'rgb(14,143,209)'},{y:294,f:'rgb(149,190,113)'},{y:256,h:39,f:'rgb(226,192,75)'},{y:218,h:39,f:'rgb(244,198,59)'},{y:179,h:39,f:'rgb(149,190,113)'},{y:141,h:39,f:'rgb(9,157,204)'},{y:102,h:39,f:'rgb(18,114,217)'},{y:64,f:'rgb(38,62,168)'},{y:26,h:39},{x:320,y:448,w:39,h:39},{y:410},{y:371,h:39,f:'rgb(22,82,205)'},{y:333,h:39,f:'rgb(20,129,214)'},{y:294,f:'rgb(46,183,164)'},{y:256,h:39},{y:218,h:39,f:'rgb(82,186,146)'},{y:179,h:39,f:'rgb(9,157,204)'},{y:141,h:39,f:'rgb(20,129,214)'},{y:102,h:39,f:'rgb(16,100,220)'},{y:64,f:'rgb(38,62,168)'},{y:26,h:39},{x:358,y:448,h:39},{y:410},{y:371,h:39,f:'rgb(22,82,205)'},{y:333,h:39},{y:294,f:'rgb(16,100,220)'},{y:256,h:39,f:'rgb(20,129,214)'},{y:218,h:39,f:'rgb(14,143,209)'},{y:179,h:39,f:'rgb(18,114,217)'},{y:141,h:39,f:'rgb(22,82,205)'},{y:102,h:39,f:'rgb(38,62,168)'},{y:64},{y:26,h:39},{x:397,y:448,w:39,h:39},{y:371,h:39},{y:333,h:39},{y:294,f:'rgb(22,82,205)'},{y:256,h:39},{y:218,h:39},{y:179,h:39,f:'rgb(38,62,168)'},{y:141,h:39},{y:102,h:39},{y:64},{y:26,h:39},{x:435,y:410,h:39},{y:371,h:39},{y:333,h:39},{y:294},{y:256,h:39},{y:218,h:39},{y:179,h:39},{y:141,h:39},{y:102,h:39},{y:64},{x:474,y:256,h:39},{y:179,h:39}] },
   th2draw3d: {
      path: 'M172.768,0H51.726C23.202,0,0.002,23.194,0.002,51.712v89.918c0,28.512,23.2,51.718,51.724,51.718h121.042   c28.518,0,51.724-23.2,51.724-51.718V51.712C224.486,23.194,201.286,0,172.768,0z M177.512,141.63c0,2.611-2.124,4.745-4.75,4.745   H51.726c-2.626,0-4.751-2.134-4.751-4.745V51.712c0-2.614,2.125-4.739,4.751-4.739h121.042c2.62,0,4.75,2.125,4.75,4.739 L177.512,141.63L177.512,141.63z '+
            'M460.293,0H339.237c-28.521,0-51.721,23.194-51.721,51.712v89.918c0,28.512,23.2,51.718,51.721,51.718h121.045   c28.521,0,51.721-23.2,51.721-51.718V51.712C512.002,23.194,488.802,0,460.293,0z M465.03,141.63c0,2.611-2.122,4.745-4.748,4.745   H339.237c-2.614,0-4.747-2.128-4.747-4.745V51.712c0-2.614,2.133-4.739,4.747-4.739h121.045c2.626,0,4.748,2.125,4.748,4.739 V141.63z '+
            'M172.768,256.149H51.726c-28.524,0-51.724,23.205-51.724,51.726v89.915c0,28.504,23.2,51.715,51.724,51.715h121.042   c28.518,0,51.724-23.199,51.724-51.715v-89.915C224.486,279.354,201.286,256.149,172.768,256.149z M177.512,397.784   c0,2.615-2.124,4.736-4.75,4.736H51.726c-2.626-0.006-4.751-2.121-4.751-4.736v-89.909c0-2.626,2.125-4.753,4.751-4.753h121.042 c2.62,0,4.75,2.116,4.75,4.753L177.512,397.784L177.512,397.784z '+
            'M460.293,256.149H339.237c-28.521,0-51.721,23.199-51.721,51.726v89.915c0,28.504,23.2,51.715,51.721,51.715h121.045   c28.521,0,51.721-23.199,51.721-51.715v-89.915C512.002,279.354,488.802,256.149,460.293,256.149z M465.03,397.784   c0,2.615-2.122,4.736-4.748,4.736H339.237c-2.614,0-4.747-2.121-4.747-4.736v-89.909c0-2.626,2.121-4.753,4.747-4.753h121.045 c2.615,0,4.748,2.116,4.748,4.753V397.784z'
   },

   createSVG(group, btn, size, title) {
      injectStyle('.jsroot_svg_toolbar_btn { fill: steelblue; cursor: pointer; opacity: 0.3; } .jsroot_svg_toolbar_btn:hover { opacity: 1.0; }', group.node());

      let svg = group.append('svg:svg')
                     .attr('class', 'jsroot_svg_toolbar_btn')
                     .attr('width', size + 'px')
                     .attr('height', size + 'px')
                     .attr('viewBox', '0 0 512 512')
                     .style('overflow', 'hidden');

      if ('recs' in btn) {
         let rec = {};
         for (let n = 0; n < btn.recs.length; ++n) {
            Object.assign(rec, btn.recs[n]);
            svg.append('rect').attr('x', rec.x).attr('y', rec.y)
               .attr('width', rec.w).attr('height', rec.h)
               .style('fill', rec.f);
         }
      } else {
         svg.append('svg:path').attr('d', btn.path);
      }

      //  special rect to correctly get mouse events for whole button area
      svg.append('svg:rect').attr('x', 0).attr('y', 0).attr('width', 512).attr('height', 512)
         .style('opacity', 0).style('fill', 'none').style('pointer-events', 'visibleFill')
         .append('svg:title').text(title);

      return svg;
   }

}; // ToolbarIcons


/** @summary Register handle to react on window resize
  * @desc function used to react on browser window resize event
  * While many resize events could come in short time,
  * resize will be handled with delay after last resize event
  * @param {object|string} handle can be function or object with checkResize function or dom where painting was done
  * @param {number} [delay] - one could specify delay after which resize event will be handled
  * @protected */
function registerForResize(handle, delay) {

   if (!handle || isBatchMode() || (typeof window == 'undefined')) return;

   let myInterval = null, myDelay = delay ? delay : 300;

   if (myDelay < 20) myDelay = 20;

   function ResizeTimer() {
      myInterval = null;

      document.body.style.cursor = 'wait';
      if (isFunc(handle))
         handle();
      else if (isFunc(handle?.checkResize)) {
         handle.checkResize();
      } else {
         let node = new BasePainter(handle).selectDom();
         if (!node.empty()) {
            let mdi = node.property('mdi');
            if (isFunc(mdi?.checkMDIResize)) {
               mdi.checkMDIResize();
            } else {
               resize(node.node());
            }
         }
      }
      document.body.style.cursor = 'auto';
   }

   window.addEventListener('resize', () => {
      if (myInterval !== null) clearTimeout(myInterval);
      myInterval = setTimeout(ResizeTimer, myDelay);
   });
}

function detectRightButton(event) {
   if ('buttons' in event) return event.buttons === 2;
   if ('which' in event) return event.which === 3;
   if ('button' in event) return event.button === 2;
   return false;
}

/** @summary Add move handlers for drawn element
  * @private */
function addMoveHandler(painter, enabled) {

   if (enabled === undefined) enabled = true;

   if (!settings.MoveResize || isBatchMode() || !painter.draw_g) return;

   if (!enabled) {
      if (painter.draw_g.property('assigned_move')) {
         let drag_move = drag().subject(Object);
         drag_move.on('start', null).on('drag', null).on('end', null);
         painter.draw_g
               .style('cursor', null)
               .property('assigned_move', null)
               .call(drag_move);
      }
      return;
   }

   if (painter.draw_g.property('assigned_move')) return;

   let drag_move = drag().subject(Object),
      not_changed = true, move_disabled = false;

   drag_move
      .on('start', function(evnt) {
         move_disabled = this.moveEnabled ? !this.moveEnabled() : false;
         if (move_disabled) return;
         if (detectRightButton(evnt.sourceEvent)) return;
         evnt.sourceEvent.preventDefault();
         evnt.sourceEvent.stopPropagation();
         let pos = pointer(evnt, this.draw_g.node());
         not_changed = true;
         if (this.moveStart)
            this.moveStart(pos[0], pos[1]);
      }.bind(painter)).on('drag', function(evnt) {
         if (move_disabled) return;
         evnt.sourceEvent.preventDefault();
         evnt.sourceEvent.stopPropagation();
         not_changed = false;
         if (this.moveDrag)
            this.moveDrag(evnt.dx, evnt.dy);
      }.bind(painter)).on('end', function(evnt) {
         if (move_disabled) return;
         evnt.sourceEvent.preventDefault();
         evnt.sourceEvent.stopPropagation();
         if (this.moveEnd)
            this.moveEnd(not_changed);
         this.getPadPainter()?.selectObjectPainter(this);
      }.bind(painter));

   painter.draw_g
          .style('cursor', 'move')
          .property('assigned_move', true)
          .call(drag_move);
}

/** @summary Inject style
  * @param {String} code - css string
  * @private */
function injectStyle(code, node, tag) {
   if (isBatchMode() || !code || (typeof document === 'undefined'))
      return true;

   let styles = (node || document).getElementsByTagName('style');
   for (let n = 0; n < styles.length; ++n) {
      if (tag && styles[n].getAttribute('tag') == tag) {
         styles[n].innerHTML = code;
         return true;
      }

      if (styles[n].innerHTML == code)
         return true;
   }

   let element = document.createElement('style');
   if (tag) element.setAttribute('tag', tag);
   element.innerHTML = code;
   (node || document.head).appendChild(element);
   return true;
}

/** @summary Select predefined style
  * @private */
function selectgStyle(name) {
   gStyle.fName = name;
   switch (name) {
      case 'Modern': Object.assign(gStyle, {
         fFrameBorderMode: 0, fFrameFillColor: 0, fCanvasBorderMode: 0,
         fCanvasColor: 0, fPadBorderMode: 0, fPadColor: 0, fStatColor: 0,
         fTitleAlign: 23, fTitleX: 0.5, fTitleBorderSize: 0, fTitleColor: 0, fTitleStyle: 0,
         fOptStat: 1111, fStatY: 0.935,
         fLegendBorderSize: 1, fLegendFont: 42, fLegendTextSize: 0, fLegendFillColor: 0 }); break;
      case 'Plain': Object.assign(gStyle, {
         fFrameBorderMode: 0, fCanvasBorderMode: 0, fPadBorderMode: 0,
         fPadColor: 0, fCanvasColor: 0,
         fTitleColor: 0, fTitleBorderSize: 0, fStatColor: 0, fStatBorderSize: 1, fLegendBorderSize: 1 }); break;
      case 'Bold': Object.assign(gStyle, {
         fCanvasColor: 10, fCanvasBorderMode: 0,
         fFrameLineWidth: 3, fFrameFillColor: 10,
         fPadColor: 10, fPadTickX: 1, fPadTickY: 1, fPadBottomMargin: 0.15, fPadLeftMargin: 0.15,
         fTitleColor: 10, fTitleTextColor: 600, fStatColor: 10 }); break;
   }
}

function saveCookie(obj, expires, name) {
   let arg = (expires <= 0) ? '' : btoa_func(JSON.stringify(obj)),
       d = new Date();
   d.setTime((expires <= 0) ? 0 : d.getTime() + expires*24*60*60*1000);
   document.cookie = `${name}=${arg}; expires=${d.toUTCString()}; SameSite=None; Secure; path=/;`;
}

function readCookie(name) {
   if (typeof document == 'undefined') return null;
   let decodedCookie = decodeURIComponent(document.cookie),
       ca = decodedCookie.split(';');
   name += '=';
   for(let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == ' ')
        c = c.substring(1);
      if (c.indexOf(name) == 0) {
         let s = JSON.parse(atob_func(c.substring(name.length, c.length)));

         return isObject(s) ? s : null;
      }
   }
   return null;
}

/** @summary Save JSROOT settings as specified cookie parameter
  * @param {Number} expires - days when cookie will be removed by browser, negative - delete immediately
  * @param {String} name - cookie parameter name
  * @private */
function saveSettings(expires = 365, name = 'jsroot_settings') {
   saveCookie(settings, expires, name);
}

/** @summary Read JSROOT settings from specified cookie parameter
  * @param {Boolean} only_check - when true just checks if settings were stored before with provided name
  * @param {String} name - cookie parameter name
  * @private */
function readSettings(only_check = false, name = 'jsroot_settings') {
   let s = readCookie(name);
   if (!s) return false;
   if (!only_check)
      Object.assign(settings, s);
   return true;
}

/** @summary Save JSROOT gStyle object as specified cookie parameter
  * @param {Number} expires - days when cookie will be removed by browser, negative - delete immediately
  * @param {String} name - cookie parameter name
  * @private */
function saveStyle(expires = 365, name = 'jsroot_style') {
   saveCookie(gStyle, expires, name);
}

/** @summary Read JSROOT gStyle object specified cookie parameter
  * @param {Boolean} only_check - when true just checks if settings were stored before with provided name
  * @param {String} name - cookie parameter name
  * @private */
function readStyle(only_check = false, name = 'jsroot_style') {
   let s = readCookie(name);
   if (!s) return false;
   if (!only_check)
      Object.assign(gStyle, s);
   return true;
}

let _saveFileFunc = null;


/** @summary Returns image file content as it should be stored on the disc
  * @desc Replaces all kind of base64 coding
  * @private */

function getBinFileContent(content) {
   const svg_prefix = 'data:image/svg+xml;charset=utf-8,';

   if (content.indexOf(svg_prefix) == 0)
      return decodeURIComponent(content.slice(svg_prefix.length));

   if (content.indexOf('data:image/') == 0) {
      let p = content.indexOf('base64,');
      if (p > 0) {
         let base64 = content.slice(p + 7);
         return atob_func(base64);
      }
   }

   return content;
}

/** @summary Function store content as file with filename
  * @private */
async function saveFile(filename, content) {
   if (isFunc(_saveFileFunc))
      return _saveFileFunc(filename, getBinFileContent(content));
   if (isNodeJs()) {
      return Promise.resolve().then(function () { return _rollup_plugin_ignore_empty_module_placeholder$1; }).then(fs => {
         fs.writeFileSync(filename, getBinFileContent(content));
         return true;
      });
   } else if (typeof document == 'object') {
      let a = document.createElement('a');
      a.download = filename;
      a.href = content;
      document.body.appendChild(a);

      return new Promise(resolve => {
         a.addEventListener('click', () => { a.parentNode.removeChild(a); resolve(true); });
         a.click();
      });
   }
   return false;
}

/** @summary Function store content as file with filename
  * @private */
function setSaveFile(func) {
   _saveFileFunc = func;
}

/** @summary Produce exec string for WebCanas to set color value
  * @desc Color can be id or string, but should belong to list of known colors
  * For higher color numbers TColor::GetColor(r,g,b) will be invoked to ensure color is exists
  * @private */
function getColorExec(col, method) {
   let id = -1, arr = getRootColors();
   if (isStr(col)) {
      if (!col || (col == 'none')) {
         id = 0;
      } else {
         for (let k = 1; k < arr.length; ++k)
            if (arr[k] == col) { id = k; break; }
      }
      if ((id < 0) && (col.indexOf('rgb') == 0))
         id = 9999;
   } else if (Number.isInteger(col) && arr[col]) {
      id = col;
      col = arr[id];
   }

   if (id < 0) return '';

   // for higher color numbers ensure that such color exists
   if (id >= 50) {
      let c = color$1(col);
      id = `TColor::GetColor(${c.r},${c.g},${c.b})`;
    }

   return `exec:${method}(${id})`;
}

/**
 * @summary Abstract class for creating context menu
 *
 * @desc Use {@link createMenu} to create instance of the menu
 * @private
 */

class JSRootMenu {
   constructor(painter, menuname, show_event) {
      this.painter = painter;
      this.menuname = menuname;
      if (isObject(show_event) && (show_event.clientX !== undefined) && (show_event.clientY !== undefined))
         this.show_evnt = { clientX: show_event.clientX, clientY: show_event.clientY };

      this.remove_handler = () => this.remove();
      this.element = null;
      this.cnt = 0;
   }

   native() { return false; }

   async load() { return this; }

   /** @summary Returns object with mouse event position when context menu was actiavted
     * @desc Return object will have members 'clientX' and 'clientY' */
   getEventPosition() { return this.show_evnt; }

   add(/*name, arg, func, title*/) {
      throw Error('add() method has to be implemented in the menu');
   }

   /** @summary Returns menu size */
   size() { return this.cnt; }

   /** @summary Close and remove menu */
   remove() {
      if (this.element !== null) {
         this.element.remove();
         if (this.resolveFunc) {
            this.resolveFunc();
            delete this.resolveFunc;
         }
         document.body.removeEventListener('click', this.remove_handler);
      }
      this.element = null;
   }

   show(/*event*/) {
      throw Error('show() method has to be implemented in the menu class');
   }

   /** @summary Add checked menu item
     * @param {boolean} flag - flag
     * @param {string} name - item name
     * @param {function} func - func called when item is selected */
   addchk(flag, name, arg, func, title) {
      let handler = func;
      if (isFunc(arg)) {
         title = func;
         func = arg;
         handler = res => func(res == '1');
         arg = flag ? '0' : '1';
      }
      this.add((flag ? 'chk:' : 'unk:') + name, arg, handler, title);
   }

   /** @summary Add draw sub-menu with draw options
     * @protected */
   addDrawMenu(top_name, opts, call_back) {
      if (!opts || !opts.length)
         return;

      let without_sub = false;
      if (top_name.indexOf('nosub:') == 0) {
         without_sub = true;
         top_name = top_name.slice(6);
      }

      if (opts.length === 1) {
         if (opts[0] === 'inspect')
            top_name = top_name.replace('Draw', 'Inspect');
         this.add(top_name, opts[0], call_back);
         return;
      }

      if (!without_sub) this.add('sub:' + top_name, opts[0], call_back);

      for (let i = 0; i < opts.length; ++i) {
         let name = opts[i] || (this._use_plain_text ? '<dflt>' : '&lt;dflt&gt;'),
             group = i+1;
         if ((opts.length > 5) && name) {
            // check if there are similar options, which can be grouped once again
            while ((group < opts.length) && (opts[group].indexOf(name) == 0)) group++;
         }

         if (without_sub) name = top_name + ' ' + name;

         if (group < i+2) {
            this.add(name, opts[i], call_back);
         } else {
            this.add('sub:' + name, opts[i], call_back);
            for (let k = i+1; k < group; ++k)
               this.add(opts[k], opts[k], call_back);
            this.add('endsub:');
            i = group-1;
         }
      }
      if (!without_sub) this.add('endsub:');
   }

   /** @summary Add color selection menu entries
     * @protected */
   addColorMenu(name, value, set_func, fill_kind) {
      if (value === undefined) return;
      let useid = !isStr(value);
      this.add('sub:' + name, () => {
         this.input('Enter color ' + (useid ? '(only id number)' : '(name or id)'), value, useid ? 'int' : 'text', useid ? 0 : undefined, useid ? 9999 : undefined).then(col => {
            let id = parseInt(col);
            if (Number.isInteger(id) && getColor(id)) {
               col = getColor(id);
            } else {
               if (useid) return;
            }
            set_func(useid ? id : col);
         });
      });

      for(let ncolumn = 0; ncolumn < 5; ++ncolumn) {
         this.add('column:');

         for (let nrow = 0; nrow < 10; nrow++) {
            let n = ncolumn*10 + nrow;
            if (!useid) --n; // use -1 as none color

            let col = (n < 0) ? 'none' : getColor(n);
            if ((n == 0) && (fill_kind == 1)) col = 'none';
            let lbl = (n <= 0) || (col[0] != '#') ? col : `col ${n}`,
                fill = (n == 1) ? 'white' : 'black',
                stroke = (n == 1) ? 'red' : 'black',
                rect = (value == (useid ? n : col)) ? `<rect width="50" height="18" style="fill:none;stroke-width:3px;stroke:${stroke}"></rect>` : '',
                svg = `<svg width="50" height="18" style="margin:0px;background-color:${col}">${rect}<text x="4" y="12" style='font-size:12px' fill="${fill}">${lbl}</text></svg>`;

            this.add(svg, (useid ? n : col), res => set_func(useid ? parseInt(res) : res), 'Select color ' + col);
         }

         this.add('endcolumn:');
         if (!this.native()) break;
      }

      this.add('endsub:');
   }

   /** @summary Add size selection menu entries
     * @protected */
   addSizeMenu(name, min, max, step, size_value, set_func, title) {

      if (size_value === undefined) return;

      let values = [], miss_current = false;
      if (isObject(step)) {
         values = step; step = 1;
      } else for (let sz = min; sz <= max; sz += step)
         values.push(sz);

      const match = v => Math.abs(v-size_value) < (max - min)*1e-5,
            conv = (v, more) => {
               if ((v === size_value) && miss_current) more = true;
               if (step >= 1) return v.toFixed(0);
               if (step >= 0.1) return v.toFixed(more ? 2 : 1);
               return v.toFixed(more ? 4 : 2);
           };

      if (values.findIndex(match) < 0) {
         miss_current = true;
         values.push(size_value);
         values = values.sort((a,b) => a > b);
      }

      this.add('sub:' + name, () => this.input('Enter value of ' + name, conv(size_value, true), (step >= 1) ? 'int' : 'float').then(set_func), title);
      values.forEach(v => this.addchk(match(v), conv(v), v, res => set_func((step >= 1) ? parseInt(res) : parseFloat(res))));
      this.add('endsub:');
   }

   /** @summary Add palette menu entries
     * @protected */
   addPaletteMenu(curr, set_func) {
      const add = (id, name, title, more) => {
         if (!name)
            name = `pal ${id}`;
         else if (!title)
            title = name;
         if (title) title += `, code ${id}`;
         this.addchk((id === curr) || more, '<nobr>' + name + '</nobr>', id, set_func, title || name);
      };

      this.add('sub:Palette', () => this.input('Enter palette code [1..113]', curr, 'int', 1, 113).then(set_func));

      this.add('column:');

      add(57, 'Bird', 'Default color palette', (curr > 113));
      add(55, 'Rainbow');
      add(51, 'Deep Sea');
      add(52, 'Grayscale', 'New gray scale');
      add(1,  '', 'Old gray scale', (curr > 0) && (curr < 10));
      add(50, 'ROOT 5', 'Default color palette in ROOT 5', (curr >= 10) && (curr < 51));
      add(53, '', 'Dark body radiator');
      add(54, '', 'Two-color hue');
      add(56, '', 'Inverted dark body radiator');
      add(58, 'Cubehelix');
      add(59, '', 'Green Red Violet');
      add(60, '', 'Blue Red Yellow');
      add(61, 'Ocean');

      this.add('endcolumn:');

      if (!this.native())
         return this.add('endsub:');

      this.add('column:');

      add(62, '', 'Color Printable On Grey');
      add(63, 'Alpine');
      add(64, 'Aquamarine');
      add(65, 'Army');
      add(66, 'Atlantic');
      add(67, 'Aurora');
      add(68, 'Avocado');
      add(69, 'Beach');
      add(70, 'Black Body');
      add(71, '', 'Blue Green Yellow');
      add(72, 'Brown Cyan');
      add(73, 'CMYK');
      add(74, 'Candy');

      this.add('endcolumn:');
      this.add('column:');

      add(75, 'Cherry');
      add(76, 'Coffee');
      add(77, '', 'Dark Rain Bow');
      add(78, '', 'Dark Terrain');
      add(79, 'Fall');
      add(80, 'Fruit Punch');
      add(81, 'Fuchsia');
      add(82, 'Grey Yellow');
      add(83, '', 'Green Brown Terrain');
      add(84, 'Green Pink');
      add(85, 'Island');
      add(86, 'Lake');
      add(87, '', 'Light Temperature');

      this.add('endcolumn:');
      this.add('column:');

      add(88, '', 'Light Terrain');
      add(89, 'Mint');
      add(90, 'Neon');
      add(91, 'Pastel');
      add(92, 'Pearl');
      add(93, 'Pigeon');
      add(94, 'Plum');
      add(95, 'Red Blue');
      add(96, 'Rose');
      add(97, 'Rust');
      add(98, '', 'Sandy Terrain');
      add(99, 'Sienna');
      add(100, 'Solar');

      this.add('endcolumn:');
      this.add('column:');

      add(101, '', 'South West');
      add(102, '', 'Starry Night');
      add(103, '', 'Sunset');
      add(104, '', 'Temperature Map');
      add(105, '', 'Thermometer');
      add(106, 'Valentine');
      add(107, '', 'Visible Spectrum');
      add(108, '', 'Water Melon');
      add(109, 'Cool');
      add(110, 'Copper');
      add(111, '', 'Gist Earth');
      add(112, 'Viridis');
      add(113, 'Cividis');

      this.add('endcolumn:');

      this.add('endsub:');
   }

   /** @summary Add rebin menu entries
     * @protected */
   addRebinMenu(rebin_func) {
      this.add('sub:Rebin', () => this.input('Enter rebin value', 2, 'int', 2).then(rebin_func));
      for (let sz = 2; sz <= 7; sz++)
         this.add(sz.toString(), sz, res => rebin_func(parseInt(res)));
      this.add('endsub:');
   }

   /** @summary Add selection menu entries
     * @param {String} name - name of submenu
     * @param {Array} values - array of string entries used as list for selection
     * @param {String|Number} value - currently elected value, either name or index
     * @param {Function} set_func - function called when item selected, either name or index depending from value parameter
     * @protected */
   addSelectMenu(name, values, value, set_func) {
      let use_number = (typeof value == 'number');
      this.add('sub:' + name);
      for (let n = 0; n < values.length; ++n)
         this.addchk(use_number ? (n == value) : (values[n] == value), values[n], use_number ? n : values[n], res => set_func(use_number ? Number.parseInt(res) : res));
      this.add('endsub:');
   }

   /** @summary Add RColor selection menu entries
     * @protected */
   addRColorMenu(name, value, set_func) {
      // if (value === undefined) return;
      let colors = ['default', 'black', 'white', 'red', 'green', 'blue', 'yellow', 'magenta', 'cyan'];

      this.add('sub:' + name, () => {
         this.input('Enter color name - empty string will reset color', value).then(set_func);
      });
      let fillcol = 'black';
      for (let n = 0; n < colors.length; ++n) {
         let coltxt = colors[n], match = false, bkgr = '';
         if (n > 0) {
            bkgr = 'background-color:' + coltxt;
            fillcol = (coltxt == 'white') ? 'black' : 'white';

            if (isStr(value) && value && (value != 'auto') && (value[0] != '['))
               match = (rgb(value).toString() == rgb(coltxt).toString());
         } else {
            match = !value;
         }
         let svg = `<svg width='100' height='18' style='margin:0px;${bkgr}'><text x='4' y='12' style='font-size:12px' fill='${fillcol}'>${coltxt}</text></svg>`;
         this.addchk(match, svg, coltxt, res => set_func(res == 'default' ? null : res));
      }
      this.add('endsub:');
   }

   /** @summary Add items to change RAttrText
     * @protected */
   addRAttrTextItems(fontHandler, opts, set_func) {
      if (!opts) opts = {};
      this.addRColorMenu('color', fontHandler.color, sel => set_func({ name: 'color', value: sel }));
      if (fontHandler.scaled)
         this.addSizeMenu('size', 0.01, 0.10, 0.01, fontHandler.size /fontHandler.scale, sz => set_func({ name: 'size', value: sz }));
      else
         this.addSizeMenu('size', 6, 20, 2, fontHandler.size, sz => set_func({ name: 'size', value: sz }));

      this.addSelectMenu('family', ['Arial', 'Times New Roman', 'Courier New', 'Symbol'], fontHandler.name, res => set_func( {name: 'font_family', value: res }));

      this.addSelectMenu('style', ['normal', 'italic', 'oblique'], fontHandler.style || 'normal', res => set_func( {name: 'font_style', value: res == 'normal' ? null : res }));

      this.addSelectMenu('weight', ['normal', 'lighter', 'bold', 'bolder'], fontHandler.weight || 'normal', res => set_func( {name: 'font_weight', value: res == 'normal' ? null : res }));

      if (!opts.noalign)
         this.add('align');
      if (!opts.noangle)
         this.add('angle');
   }

   /** @summary Fill context menu for text attributes
     * @private */
   addTextAttributesMenu(painter, prefix) {
      // for the moment, text attributes accessed directly from objects

      let obj = painter.getObject();
      if ((obj?.fTextColor === undefined) || (obj?.fTextAlign == undefined)) return;

      this.add('sub:' + (prefix || 'Text'));
      this.addColorMenu('color', obj.fTextColor,
         arg => { obj.fTextColor = arg; painter.interactiveRedraw(true, getColorExec(arg, 'SetTextColor')); });

      let align = [11, 12, 13, 21, 22, 23, 31, 32, 33];

      this.add('sub:align');
      for (let n = 0; n < align.length; ++n) {
         this.addchk(align[n] == obj.fTextAlign,
            align[n], align[n],
            // align[n].toString() + '_h:' + hnames[Math.floor(align[n]/10) - 1] + '_v:' + vnames[align[n]%10-1], align[n],
            function(arg) { this.getObject().fTextAlign = parseInt(arg); this.interactiveRedraw('pad', `exec:SetTextAlign(${arg})`); }.bind(painter));
      }
      this.add('endsub:');

      this.addFontMenu('font', obj.fTextFont, function(fnt) {
         this.getObject().fTextFont = fnt; this.interactiveRedraw(true, `exec:SetTextFont(${fnt})`); }.bind(painter)
      );

      this.add('endsub:');
   }

   /** @summary Add line style menu
     * @private */
   addLineStyleMenu(name, value, set_func) {
      this.add('sub:'+name, () => this.input('Enter line style id (1-solid)', value, 'int', 1, 11).then(val => {
         if (getSvgLineStyle(val)) set_func(val);
      }));
      for (let n = 1; n < 11; ++n) {
         let dash = getSvgLineStyle(n),
             svg = `<svg width='100' height='18'><text x='1' y='12' style='font-size:12px'>${n}</text><line x1='30' y1='8' x2='100' y2='8' stroke='black' stroke-width='3' stroke-dasharray='${dash}'></line></svg>`;

         this.addchk((value == n), svg, n, arg => set_func(parseInt(arg)));
      }
      this.add('endsub:');
   }

   /** @summary Add fill style menu
     * @private */
   addFillStyleMenu(name, value, color_index, painter, set_func) {
      this.add('sub:' + name, () => {
         this.input('Enter fill style id (1001-solid, 3000..3010)', value, 'int', 0, 4000).then(id => {
            if ((id >= 0) && (id <= 4000)) set_func(id);
         });
      });

      let supported = [1, 1001, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3010, 3021, 3022];

      for (let n = 0; n < supported.length; ++n) {
         let svg = supported[n];
         if (painter) {
            let sample = painter.createAttFill({ std: false, pattern: supported[n], color: color_index || 1 });
            svg = `<svg width='100' height='18'><text x='1' y='12' style='font-size:12px'>${supported[n].toString()}</text><rect x='40' y='0' width='60' height='18' stroke='none' fill='${sample.getFillColor()}'></rect></svg>`;
         }
         this.addchk(value == supported[n], svg, supported[n], arg => set_func(parseInt(arg)));
      }
      this.add('endsub:');
   }

   /** @summary Add font selection menu
     * @private */
   addFontMenu(name, value, set_func) {
      this.add('sub:' + name, () => {
         this.input('Enter font id from [0..20]', Math.floor(value/10), 'int', 0, 20).then(id => {
            if ((id >= 0) && (id <= 20)) set_func(id*10 + 2);
         });
      });

      this.add('column:');

      for (let n = 1; n < 20; ++n) {
         let handler = new FontHandler(n*10+2, 14),
             txt = select(document.createElementNS('http://www.w3.org/2000/svg', 'text')),
             fullname = handler.getFontName(),
             name = ' ' + fullname.split(' ')[0] + ' ';
         if (handler.weight) { name = 'b' + name; fullname += ' ' + handler.weight; }
         if (handler.style) { name = handler.style[0] + name; fullname += ' ' + handler.style; }
         txt.attr('x', 1).attr('y',15).text(name);
         handler.setFont(txt);

         let rect = (value != n*10+2) ? '' : `<rect width='90' height='18' style='fill:none;stroke:black'></rect>`,
             svg = `<svg width='90' height='18'>${txt.node().outerHTML}${rect}</svg>`;
         this.add(svg, n, arg => set_func(parseInt(arg)*10+2), fullname);

         if (n == 10) {
            this.add('endcolumn:');
            this.add('column:');
         }
      }

      this.add('endcolumn:');
      this.add('endsub:');
   }

   /** @summary Fill context menu for graphical attributes in painter
     * @private */
   addAttributesMenu(painter, preffix) {
      // this method used to fill entries for different attributes of the object
      // like TAttFill, TAttLine, ....
      // all menu call-backs need to be rebind, while menu can be used from other painter

      if (!preffix) preffix = '';

      if (painter.lineatt?.used) {
         this.add('sub:' + preffix + 'Line att');
         this.addSizeMenu('width', 1, 10, 1, painter.lineatt.width,
            arg => { painter.lineatt.change(undefined, arg); painter.interactiveRedraw(true, `exec:SetLineWidth(${arg})`); });
         this.addColorMenu('color', painter.lineatt.color,
            arg => { painter.lineatt.change(arg); painter.interactiveRedraw(true, getColorExec(arg, 'SetLineColor')); });
         this.addLineStyleMenu('style', painter.lineatt.style, id => {
            painter.lineatt.change(undefined, undefined, id);
            painter.interactiveRedraw(true, `exec:SetLineStyle(${id})`);
         });
         this.add('endsub:');

         if (painter.lineatt?.excl_side) {
            this.add('sub:Exclusion');
            this.add('sub:side');
            for (let side = -1; side <= 1; ++side)
               this.addchk((painter.lineatt.excl_side == side), side, side, function(arg) {
                  this.lineatt.changeExcl(parseInt(arg));
                  this.interactiveRedraw();
               }.bind(painter));
            this.add('endsub:');

            this.addSizeMenu('width', 10, 100, 10, painter.lineatt.excl_width,
               arg => { painter.lineatt.changeExcl(undefined, arg); painter.interactiveRedraw(); });

            this.add('endsub:');
         }
      }

      if (painter.fillatt?.used) {
         this.add('sub:' + preffix + 'Fill att');
         this.addColorMenu('color', painter.fillatt.colorindx, arg => {
            painter.fillatt.change(arg, undefined, painter.getCanvSvg());
            painter.interactiveRedraw(true, getColorExec(arg, 'SetFillColor'));
         }, painter.fillatt.kind);
         this.addFillStyleMenu('style', painter.fillatt.pattern, painter.fillatt.colorindx, painter, id => {
            painter.fillatt.change(undefined, id, painter.getCanvSvg());
            painter.interactiveRedraw(true, `exec:SetFillStyle(${id})`);
         });
         this.add('endsub:');
      }

      if (painter.markeratt?.used) {
         this.add('sub:' + preffix + 'Marker att');
         this.addColorMenu('color', painter.markeratt.color,
            arg => { painter.markeratt.change(arg); painter.interactiveRedraw(true, getColorExec(arg, 'SetMarkerColor'));});
         this.addSizeMenu('size', 0.5, 6, 0.5, painter.markeratt.size,
            arg => { painter.markeratt.change(undefined, undefined, arg); painter.interactiveRedraw(true, `exec:SetMarkerSize(${arg})`); });

         this.add('sub:style');
         let supported = [1, 2, 3, 4, 5, 6, 7, 8, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34];

         for (let n = 0; n < supported.length; ++n) {

            let clone = new TAttMarkerHandler({ style: supported[n], color: painter.markeratt.color, size: 1.7 }),
                svg = `<svg width='60' height='18'><text x='1' y='12' style='font-size:12px'>${supported[n].toString()}</text><path stroke='black' fill='${clone.fill?'black':'none'}' d='${clone.create(40, 8)}'></path></svg>`;

            this.addchk(painter.markeratt.style == supported[n], svg, supported[n],
               function(arg) { this.markeratt.change(undefined, parseInt(arg)); this.interactiveRedraw(true, `exec:SetMarkerStyle(${arg})`); }.bind(painter));
         }
         this.add('endsub:');
         this.add('endsub:');
      }
   }

   /** @summary Fill context menu for axis
     * @private */
   addTAxisMenu(EAxisBits, painter, faxis, kind) {
      this.add('Divisions', () => this.input('Set Ndivisions', faxis.fNdivisions, 'int', 0).then(val => {
         faxis.fNdivisions = val;
         painter.interactiveRedraw('pad', `exec:SetNdivisions(${val})`, kind);
      }));

      this.add('sub:Labels');
      this.addchk(faxis.TestBit(EAxisBits.kCenterLabels), 'Center',
            arg => { faxis.InvertBit(EAxisBits.kCenterLabels); painter.interactiveRedraw('pad', `exec:CenterLabels(${arg})`, kind); });
      this.addchk(faxis.TestBit(EAxisBits.kLabelsVert), 'Rotate',
            arg => { faxis.InvertBit(EAxisBits.kLabelsVert); painter.interactiveRedraw('pad', `exec:SetBit(TAxis::kLabelsVert,${arg})`, kind); });
      this.addColorMenu('Color', faxis.fLabelColor,
            arg => { faxis.fLabelColor = arg; painter.interactiveRedraw('pad', getColorExec(arg, 'SetLabelColor'), kind); });
      this.addSizeMenu('Offset', 0, 0.1, 0.01, faxis.fLabelOffset,
            arg => { faxis.fLabelOffset = arg; painter.interactiveRedraw('pad', `exec:SetLabelOffset(${arg})`, kind); });
      let a = faxis.fLabelSize >= 1;
      this.addSizeMenu('Size', a ? 2 : 0.02, a ? 30 : 0.11, a ? 2 : 0.01, faxis.fLabelSize,
            arg => { faxis.fLabelSize = arg; painter.interactiveRedraw('pad', `exec:SetLabelSize(${arg})`, kind); });
      this.add('endsub:');
      this.add('sub:Title');
      this.add('SetTitle', () => {
         this.input('Enter axis title', faxis.fTitle).then(t => {
            faxis.fTitle = t;
            painter.interactiveRedraw('pad', `exec:SetTitle("${t}")`, kind);
         });
      });
      this.addchk(faxis.TestBit(EAxisBits.kCenterTitle), 'Center',
            arg => { faxis.InvertBit(EAxisBits.kCenterTitle); painter.interactiveRedraw('pad', `exec:CenterTitle(${arg})`, kind); });
      this.addchk(faxis.TestBit(EAxisBits.kOppositeTitle), 'Opposite',
             () => { faxis.InvertBit(EAxisBits.kOppositeTitle); painter.redrawPad(); });
      this.addchk(faxis.TestBit(EAxisBits.kRotateTitle), 'Rotate',
            arg => { faxis.InvertBit(EAxisBits.kRotateTitle); painter.interactiveRedraw('pad', `exec:RotateTitle(${arg})`, kind); });
      this.addColorMenu('Color', faxis.fTitleColor,
            arg => { faxis.fTitleColor = arg; painter.interactiveRedraw('pad', getColorExec(arg, 'SetTitleColor'), kind); });
      this.addSizeMenu('Offset', 0, 3, 0.2, faxis.fTitleOffset,
                      arg => { faxis.fTitleOffset = arg; painter.interactiveRedraw('pad', `exec:SetTitleOffset(${arg})`, kind); });
      a = faxis.fTitleSize >= 1;
      this.addSizeMenu('Size', a ? 2 : 0.02, a ? 30 : 0.11, a ? 2 : 0.01, faxis.fTitleSize,
                      arg => { faxis.fTitleSize = arg; painter.interactiveRedraw('pad', `exec:SetTitleSize(${arg})`, kind); });
      this.add('endsub:');
      this.add('sub:Ticks');
      if (faxis._typename == clTGaxis) {
         this.addColorMenu('Color', faxis.fLineColor,
                  arg => { faxis.fLineColor = arg; painter.interactiveRedraw('pad'); });
         this.addSizeMenu('Size', -0.05, 0.055, 0.01, faxis.fTickSize,
                  arg => { faxis.fTickSize = arg; painter.interactiveRedraw('pad'); });
      } else {
         this.addColorMenu('Color', faxis.fAxisColor,
                  arg => { faxis.fAxisColor = arg; painter.interactiveRedraw('pad', getColorExec(arg, 'SetAxisColor'), kind); });
         this.addSizeMenu('Size', -0.05, 0.055, 0.01, faxis.fTickLength,
                  arg => { faxis.fTickLength = arg; painter.interactiveRedraw('pad', `exec:SetTickLength(${arg})`, kind); });
      }
      this.add('endsub:');
   }

   /** @summary Fill menu to edit settings properties
     * @private */
   addSettingsMenu(with_hierarchy, alone, handle_func) {
      if (alone)
         this.add('header:Settings');
      else
         this.add('sub:Settings');

      this.add('sub:Files');

      if (with_hierarchy) {
         this.addchk(settings.OnlyLastCycle, 'Last cycle', flag => {
            settings.OnlyLastCycle = flag;
            if (handle_func) handle_func('refresh');
         });

         this.addchk(!settings.SkipStreamerInfos, 'Streamer infos', flag => {
            settings.SkipStreamerInfos = !flag;
            if (handle_func) handle_func('refresh');
         });
      }

      this.addchk(settings.UseStamp, 'Use stamp arg', flag => { settings.UseStamp = flag; });
      this.addSizeMenu('Max ranges', 1, 1000, [1, 10, 20, 50, 200, 1000], settings.MaxRanges, value => { settings.MaxRanges = value; }, 'Maximal number of ranges in single http request');

      this.addchk(settings.HandleWrongHttpResponse, 'Handle wrong http response', flag => { settings.HandleWrongHttpResponse = flag; });

      this.add('endsub:');

      this.add('sub:Toolbar');
      this.addchk(settings.ToolBar === false, 'Off', flag => { settings.ToolBar = !flag; });
      this.addchk(settings.ToolBar === true, 'On', flag => { settings.ToolBar = flag; });
      this.addchk(settings.ToolBar === 'popup', 'Popup', flag => { settings.ToolBar = flag ? 'popup' : false; });
      this.add('separator');
      this.addchk(settings.ToolBarSide == 'left', 'Left side', flag => { settings.ToolBarSide = flag ? 'left' : 'right'; });
      this.addchk(settings.ToolBarVert, 'Vertical', flag => { settings.ToolBarVert = flag; });
      this.add('endsub:');

      this.add('sub:Interactive');
      this.addchk(settings.Tooltip, 'Tooltip', flag => { settings.Tooltip = flag; });
      this.addchk(settings.ContextMenu, 'Context menus', flag => { settings.ContextMenu = flag; });
      this.add('sub:Zooming');
      this.addchk(settings.Zooming, 'Global', flag => { settings.Zooming = flag; });
      this.addchk(settings.ZoomMouse, 'Mouse', flag => { settings.ZoomMouse = flag; });
      this.addchk(settings.ZoomWheel, 'Wheel', flag => { settings.ZoomWheel = flag; });
      this.addchk(settings.ZoomTouch, 'Touch', flag => { settings.ZoomTouch = flag; });
      this.add('endsub:');
      this.addchk(settings.HandleKeys, 'Keypress handling', flag => { settings.HandleKeys = flag; });
      this.addchk(settings.MoveResize, 'Move and resize', flag => { settings.MoveResize = flag; });
      this.addchk(settings.DragAndDrop, 'Drag and drop', flag => { settings.DragAndDrop = flag; });
      this.addchk(settings.DragGraphs, 'Drag graph points', flag => { settings.DragGraphs = flag; });
      this.addchk(settings.ProgressBox, 'Progress box', flag => { settings.ProgressBox = flag; });
      this.add('endsub:');

      this.add('sub:Drawing');
      this.addSelectMenu('Optimize', ['None', 'Smart', 'Always'], settings.OptimizeDraw, value => { settings.OptimizeDraw = value; });
      this.addPaletteMenu(settings.Palette, pal => { settings.Palette = pal; });
      this.addchk(settings.AutoStat, 'Auto stat box', flag => { settings.AutoStat = flag; });
      this.addSelectMenu('Latex', ['Off', 'Symbols', 'Normal', 'MathJax', 'Force MathJax'], settings.Latex, value => { settings.Latex = value; });
      this.addSelectMenu('3D rendering', ['Default', 'WebGL', 'Image'], settings.Render3D, value => { settings.Render3D = value; });
      this.addSelectMenu('WebGL embeding', ['Default', 'Overlay', 'Embed'], settings.Embed3D, value => { settings.Embed3D = value; });

      this.add('endsub:');

      this.add('sub:Geometry');
      this.add('Grad per segment:  ' + settings.GeoGradPerSegm, () => this.input('Grad per segment in geometry', settings.GeoGradPerSegm, 'int', 1, 60).then(val => { settings.GeoGradPerSegm = val; }));
      this.addchk(settings.GeoCompressComp, 'Compress composites', flag => { settings.GeoCompressComp = flag; });
      this.add('endsub:');

      if (with_hierarchy)
         this.add('Hierarchy limit:  ' + settings.HierarchyLimit, () => this.input('Max number of items in hierarchy', settings.HierarchyLimit, 'int', 10, 100000).then(val => {
            settings.HierarchyLimit = val;
            if (handle_func) handle_func('refresh');
         }));

      this.add('Dark mode: ' + (settings.DarkMode ? 'On' : 'Off'), () => {
         settings.DarkMode = !settings.DarkMode;
         if (handle_func) handle_func('dark');
      });

      const setStyleField = arg => { gStyle[arg.slice(1)] = parseInt(arg[0]); },
            addStyleIntField = (name, field, arr) => {
         this.add('sub:' + name);
         for (let v = 0; v < arr.length; ++v)
            this.addchk(gStyle[field] == v, arr[v], `${v}${field}`, setStyleField);
         this.add('endsub:');
      };

      this.add('sub:gStyle');

      this.add('sub:Canvas');
      this.addColorMenu('Color', gStyle.fCanvasColor, col => { gStyle.fCanvasColor = col; });
      this.addchk(gStyle.fOptDate, 'Draw date', flag => { gStyle.fOptDate = flag ? 1 : 0; });
      this.addchk(gStyle.fOptFile, 'Draw item', flag => { gStyle.fOptFile = flag ? 1 : 0; });
      this.addSizeMenu('Date X', 0.01, 0.1, 0.01, gStyle.fDateX, x => { gStyle.fDateX = x; }, 'configure gStyle.fDateX for date/item name drawings');
      this.addSizeMenu('Date Y', 0.01, 0.1, 0.01, gStyle.fDateY, y => { gStyle.fDateY = y; }, 'configure gStyle.fDateY for date/item name drawings');
      this.add('endsub:');

      this.add('sub:Pad');
      this.addColorMenu('Color', gStyle.fPadColor, col => { gStyle.fPadColor = col; });
      this.add('sub:Grid');
      this.addchk(gStyle.fPadGridX, 'X', flag => { gStyle.fPadGridX = flag; });
      this.addchk(gStyle.fPadGridY, 'Y', flag => { gStyle.fPadGridY = flag; });
      this.addColorMenu('Color', gStyle.fGridColor, col => { gStyle.fGridColor = col; });
      this.addSizeMenu('Width', 1, 10, 1, gStyle.fGridWidth, w => { gStyle.fGridWidth = w; });
      this.addLineStyleMenu('Style', gStyle.fGridStyle, st => { gStyle.fGridStyle = st; });
      this.add('endsub:');
      addStyleIntField('Ticks X', 'fPadTickX', ['normal', 'ticks on both sides', 'labels on both sides']);
      addStyleIntField('Ticks Y', 'fPadTickY', ['normal', 'ticks on both sides', 'labels on both sides']);
      addStyleIntField('Log X', 'fOptLogx', ['off', 'on', 'log 2']);
      addStyleIntField('Log Y', 'fOptLogy', ['off', 'on', 'log 2']);
      addStyleIntField('Log Z', 'fOptLogz', ['off', 'on', 'log 2']);
      this.addchk(gStyle.fOptTitle == 1, 'Hist title', flag => { gStyle.fOptTitle = flag ? 1 : 0; });
      this.add('endsub:');

      this.add('sub:Frame');
      this.addColorMenu('Fill color', gStyle.fFrameFillColor, col => { gStyle.fFrameFillColor = col; });
      this.addFillStyleMenu('Fill style', gStyle.fFrameFillStyle, gStyle.fFrameFillColor, null, id => { gStyle.fFrameFillStyle = id; });
      this.addColorMenu('Line color', gStyle.fFrameLineColor, col => { gStyle.fFrameLineColor = col; });
      this.addSizeMenu('Line width', 1, 10, 1, gStyle.fFrameLineWidth, w => { gStyle.fFrameLineWidth = w; });
      this.addLineStyleMenu('Line style', gStyle.fFrameLineStyle, st => { gStyle.fFrameLineStyle = st; });
      this.addSizeMenu('Border size', 0, 10, 1, gStyle.fFrameBorderSize, sz => { gStyle.fFrameBorderSize = sz; });
      // fFrameBorderMode: 0,
      this.add('sub:Margins');
      this.addSizeMenu('Bottom', 0, 0.5, 0.05, gStyle.fPadBottomMargin, v => { gStyle.fPadBottomMargin = v; });
      this.addSizeMenu('Top', 0, 0.5, 0.05, gStyle.fPadTopMargin, v => { gStyle.fPadTopMargin = v; });
      this.addSizeMenu('Left', 0, 0.5, 0.05, gStyle.fPadLeftMargin, v => { gStyle.fPadLeftMargin = v; });
      this.addSizeMenu('Right', 0, 0.5, 0.05, gStyle.fPadRightMargin, v => { gStyle.fPadRightMargin = v; });
      this.add('endsub:');
      this.add('endsub:');

      this.add('sub:Title');
      this.addColorMenu('Fill color', gStyle.fTitleColor, col => { gStyle.fTitleColor = col; });
      this.addFillStyleMenu('Fill style', gStyle.fTitleStyle, gStyle.fTitleColor, null, id => { gStyle.fTitleStyle = id; });
      this.addColorMenu('Text color', gStyle.fTitleTextColor, col => { gStyle.fTitleTextColor = col; });
      this.addSizeMenu('Border size', 0, 10, 1, gStyle.fTitleBorderSize, sz => { gStyle.fTitleBorderSize = sz; });
      this.addSizeMenu('Font size', 0.01, 0.1, 0.01, gStyle.fTitleFontSize, sz => { gStyle.fTitleFontSize = sz; });
      this.addFontMenu('Font', gStyle.fTitleFont, fnt => { gStyle.fTitleFont = fnt; });
      this.addSizeMenu('X: ' + gStyle.fTitleX.toFixed(2), 0., 1., 0.1, gStyle.fTitleX, v => { gStyle.fTitleX = v; });
      this.addSizeMenu('Y: ' + gStyle.fTitleY.toFixed(2), 0., 1., 0.1, gStyle.fTitleY, v => { gStyle.fTitleY = v; });
      this.addSizeMenu('W: ' + gStyle.fTitleW.toFixed(2), 0., 1., 0.1, gStyle.fTitleW, v => { gStyle.fTitleW = v; });
      this.addSizeMenu('H: ' + gStyle.fTitleH.toFixed(2), 0., 1., 0.1, gStyle.fTitleH, v => { gStyle.fTitleH = v; });
      this.add('endsub:');

      this.add('sub:Stat box');
      this.addColorMenu('Fill color', gStyle.fStatColor, col => { gStyle.fStatColor = col; });
      this.addFillStyleMenu('Fill style', gStyle.fStatStyle, gStyle.fStatColor, null, id => { gStyle.fStatStyle = id; });
      this.addColorMenu('Text color', gStyle.fStatTextColor, col => { gStyle.fStatTextColor = col; });
      this.addSizeMenu('Border size', 0, 10, 1, gStyle.fStatBorderSize, sz => { gStyle.fStatBorderSize = sz; });
      this.addSizeMenu('Font size', 0, 30, 5, gStyle.fStatFontSize, sz => { gStyle.fStatFontSize = sz; });
      this.addFontMenu('Font', gStyle.fStatFont, fnt => { gStyle.fStatFont = fnt; });
      this.add('Stat format', () => this.input('Stat format', gStyle.fStatFormat).then(fmt => { gStyle.fStatFormat = fmt; }));
      this.addSizeMenu('X: ' + gStyle.fStatX.toFixed(2), 0.2, 1., 0.1, gStyle.fStatX, v => { gStyle.fStatX = v; });
      this.addSizeMenu('Y: ' + gStyle.fStatY.toFixed(2), 0.2, 1., 0.1, gStyle.fStatY, v => { gStyle.fStatY = v; });
      this.addSizeMenu('Width: ' + gStyle.fStatW.toFixed(2), 0.1, 1., 0.1, gStyle.fStatW, v => { gStyle.fStatW = v; });
      this.addSizeMenu('Height: ' + gStyle.fStatH.toFixed(2), 0.1, 1., 0.1, gStyle.fStatH, v => { gStyle.fStatH = v; });
      this.add('endsub:');

      this.add('sub:Legend');
      this.addColorMenu('Fill color', gStyle.fLegendFillColor, col => { gStyle.fLegendFillColor = col; });
      this.addSizeMenu('Border size', 0, 10, 1, gStyle.fLegendBorderSize, sz => { gStyle.fLegendBorderSize = sz; });
      this.addFontMenu('Font', gStyle.fLegendFont, fnt => { gStyle.fLegendFont = fnt; });
      this.addSizeMenu('Text size', 0, 0.1, 0.01, gStyle.fLegendTextSize, v => { gStyle.fLegendTextSize = v; }, 'legend text size, when 0 - auto adjustment is used');
      this.add('endsub:');

      this.add('sub:Histogram');
      this.addchk(gStyle.fHistMinimumZero, 'Base0', flag => { gStyle.fHistMinimumZero = flag; }, 'when true, BAR and LEGO drawing using base = 0');
      this.add('Text format', () => this.input('Paint text format', gStyle.fPaintTextFormat).then(fmt => { gStyle.fPaintTextFormat = fmt; }));
      this.add('Time offset', () => this.input('Time offset in seconds, default is 788918400 for 1/1/1995', gStyle.fTimeOffset, 'int').then(ofset => { gStyle.fTimeOffset = ofset; }));
      this.addSizeMenu('ErrorX: ' + gStyle.fErrorX.toFixed(2), 0., 1., 0.1, gStyle.fErrorX, v => { gStyle.fErrorX = v; });
      this.addSizeMenu('End error', 0, 12, 1, gStyle.fEndErrorSize, v => { gStyle.fEndErrorSize = v; }, 'size in pixels of end error for E1 draw options, gStyle.fEndErrorSize');
      this.addSizeMenu('Top margin', 0., 0.5, 0.05, gStyle.fHistTopMargin, v => { gStyle.fHistTopMargin = v; }, 'Margin between histogram top and frame top');
      this.addColorMenu('Fill color', gStyle.fHistFillColor, col => { gStyle.fHistFillColor = col; });
      this.addFillStyleMenu('Fill style', gStyle.fHistFillStyle, gStyle.fHistFillColor, null, id => { gStyle.fHistFillStyle = id; });
      this.addColorMenu('Line color', gStyle.fHistLineColor, col => { gStyle.fHistLineColor = col; });
      this.addSizeMenu('Line width', 1, 10, 1, gStyle.fHistLineWidth, w => { gStyle.fHistLineWidth = w; });
      this.addLineStyleMenu('Line style', gStyle.fHistLineStyle, st => { gStyle.fHistLineStyle = st; });
      this.add('endsub:');

      this.add('separator');
      this.add('sub:Predefined');
      ['Modern', 'Plain', 'Bold'].forEach(name => this.addchk((gStyle.fName == name), name, name, selectgStyle));
      this.add('endsub:');

      this.add('endsub:'); // gStyle

      this.add('separator');

      this.add('Save settings', () => {
         let promise = readSettings(true) ? Promise.resolve(true) : this.confirm('Save settings', 'Pressing OK one agreess that JSROOT will store settings as browser cookies');
         promise.then(res => { if (res) { saveSettings(); saveStyle(); } });
      }, 'Store settings and gStyle as cookies');
      this.add('Delete settings', () => { saveSettings(-1); saveStyle(-1); }, 'Delete settings and gStyle from cookies');

      if (!alone) this.add('endsub:');
   }

   /** @summary Run modal dialog
     * @return {Promise} with html element inside dialg
     * @private */
   async runModal() {
      throw Error('runModal() must be reimplemented');
   }

   /** @summary Show modal info dialog
     * @param {String} title - title
     * @param {String} message - message
     * @protected */
   info(title, message) {
      return this.runModal(title,`<p>${message}</p>`, { height: 120, width: 400, resizable: true });
   }

   /** @summary Show confirm dialog
     * @param {String} title - title
     * @param {String} message - message
     * @return {Promise} with true when 'Ok' pressed or false when 'Cancel' pressed
     * @protected */
   async confirm(title, message) {
      return this.runModal(title, message, { btns: true, height: 120, width: 400 }).then(elem => { return !!elem; });
   }

   /** @summary Input value
     * @return {Promise} with input value
     * @param {string} title - input dialog title
     * @param value - initial value
     * @param {string} [kind] - use 'text' (default), 'number', 'float' or 'int'
     * @protected */
   async input(title, value, kind, min, max) {

      if (!kind) kind = 'text';
      let inp_type = (kind == 'int') ? 'number' : 'text', ranges = '';
      if ((value === undefined) || (value === null)) value = '';
      if (kind == 'int') {
          if (min !== undefined) ranges += ` min="${min}"`;
          if (max !== undefined) ranges += ` max="${max}"`;
       }

      let main_content =
         '<form><fieldset style="padding:0; border:0">'+
            `<input type="${inp_type}" value="${value}" ${ranges} style="width:98%;display:block" class="jsroot_dlginp"/>`+
         '</fieldset></form>';

      return new Promise(resolveFunc => {

         this.runModal(title, main_content, { btns: true, height: 150, width: 400 }).then(element => {
            if (!element) return;
            let val = element.querySelector(`.jsroot_dlginp`).value;
            if (kind == 'float') {
               val = parseFloat(val);
               if (Number.isFinite(val))
                  resolveFunc(val);
            } else if (kind == 'int') {
               val = parseInt(val);
               if (Number.isInteger(val))
                  resolveFunc(val);
            } else {
               resolveFunc(val);
           }
         });

      });
   }

   /** @summary Let input arguments from the method
     * @return {Promise} with method argument */
   async showMethodArgsDialog(method) {
      let dlg_id = this.menuname + '_dialog',
          main_content = '<form> <fieldset style="padding:0; border:0">';

      for (let n = 0; n < method.fArgs.length; ++n) {
         let arg = method.fArgs[n];
         arg.fValue = arg.fDefault;
         if (arg.fValue == '\"\"') arg.fValue = '';
         main_content += `<label for="${dlg_id}_inp${n}">${arg.fName}</label>
                          <input type='text' tabindex="${n+1}" id="${dlg_id}_inp${n}" value="${arg.fValue}" style="width:100%;display:block"/>`;
      }

      main_content += '</fieldset></form>';

      return new Promise(resolveFunc => {

         this.runModal(method.fClassName + '::' + method.fName, main_content, { btns: true, height: 100 + method.fArgs.length*60, width: 400, resizable: true }).then(element => {
            if (!element) return;
            let args = '';

            for (let k = 0; k < method.fArgs.length; ++k) {
               let arg = method.fArgs[k];
               let value = element.querySelector(`#${dlg_id}_inp${k}`).value;
               if (value === '') value = arg.fDefault;
               if ((arg.fTitle == 'Option_t*') || (arg.fTitle == 'const char*')) {
                  // check quotes,
                  // TODO: need to make more precise checking of escape characters
                  if (!value) value = '""';
                  if (value[0] != '"') value = '"' + value;
                  if (value[value.length-1] != '"') value += '"';
               }

               args += (k > 0 ? ',' : '') + value;
            }

            resolveFunc(args);
         });
      });
   }

   /** @summary Let input arguments from the Command
     * @return {Promise} with command argument */
   async showCommandArgsDialog(cmdname, args) {
      let dlg_id = this.menuname + '_dialog',
          main_content = '<form> <fieldset style="padding:0; border:0">';

      for (let n = 0; n < args.length; ++n)
         main_content += `<label for="${dlg_id}_inp${n}">arg${n+1}</label>`+
                         `<input type='text' id="${dlg_id}_inp${n}" value="${args[n]}" style="width:100%;display:block"/>`;

      main_content += '</fieldset></form>';

      return new Promise(resolveFunc => {

         this.runModal('Arguments for command ' + cmdname, main_content, { btns: true, height: 110 + args.length*60, width: 400, resizable: true}).then(element => {
            if (!element)
               return resolveFunc(null);

            let resargs = [];
            for (let k = 0; k < args.length; ++k)
               resargs.push(element.querySelector(`#${dlg_id}_inp${k}`).value);
            resolveFunc(resargs);
         });
      });
   }

} // class JSRootMenu

/**
 * @summary Context menu class using plain HTML/JavaScript
 *
 * @desc Use {@link createMenu} to create instance of the menu
 * based on {@link https://github.com/L1quidH2O/ContextMenu.js}
 * @private
 */

class StandaloneMenu extends JSRootMenu {

   constructor(painter, menuname, show_event) {
      super(painter, menuname, show_event);

      this.code = [];
      this._use_plain_text = true;
      this.stack = [ this.code ];
   }

   native() { return true; }

   /** @summary Load required modules, noop for that menu class */
   async load() { return this; }

   /** @summary Add menu item
     * @param {string} name - item name
     * @param {function} func - func called when item is selected */
   add(name, arg, func, title) {
      let curr = this.stack[this.stack.length-1];

      if (name == 'separator')
         return curr.push({ divider: true });

      if (name.indexOf('header:') == 0)
         return curr.push({ text: name.slice(7), header: true });

      if ((name == 'endsub:') || (name == 'endcolumn:'))
         return this.stack.pop();

      if (isFunc(arg)) { title = func; func = arg; arg = name; }

      let elem = {};
      curr.push(elem);

      if (name == 'column:') {
         elem.column = true;
         elem.sub = [];
         this.stack.push(elem.sub);
         return;
      }

      if (name.indexOf('sub:') == 0) {
         name = name.slice(4);
         elem.sub = [];
         this.stack.push(elem.sub);
      }

      if (name.indexOf('chk:') == 0) {
         elem.checked = true;
         name = name.slice(4);
      } else if (name.indexOf('unk:') == 0) {
         elem.checked = false;
         name = name.slice(4);
      }

      elem.text = name;
      elem.title = title;
      elem.arg = arg;
      elem.func = func;
   }

   /** @summary Returns size of main menu */
   size() { return this.code.length; }

   /** @summary Build HTML elements of the menu
     * @private */
   _buildContextmenu(menu, left, top, loc) {

      let outer = document.createElement('div');
      outer.className = 'jsroot_ctxt_container';

      //if loc !== document.body then its a submenu, so it needs to have position: relative;
      if (loc === document.body) {
         //delete all elements with className jsroot_ctxt_container
         let deleteElems = document.getElementsByClassName('jsroot_ctxt_container');
         while (deleteElems.length > 0)
            deleteElems[0].parentNode.removeChild(deleteElems[0]);

         outer.style.position = 'fixed';
         outer.style.left = left + 'px';
         outer.style.top = top + 'px';

         injectStyle(
            `.jsroot_ctxt_container {
                position: absolute; top: 0; user-select: none; z-index: 100000; background-color: rgb(250, 250, 250); margin: 0; padding: 0px; width: auto;
                min-width: 100px; box-shadow: 0px 0px 10px rgb(0, 0, 0, 0.2); border: 3px solid rgb(215, 215, 215); font-family: Arial, helvetica, sans-serif, serif;
                font-size: 13px; color: rgb(0, 0, 0, 0.8);
             }
             .jsroot_ctxt_column { float: left; }
             .jsroot_ctxt_divider { width: 85%; margin: 3px auto; border: 1px solid rgb(0, 0, 0, 0.15); }
             .jsroot_ctxt_header { background-color: lightblue; padding: 3px 7px; font-weight: bold; border-bottom: 1px; }
             .jsroot_ctxt_text { margin: 0; padding: 3px 7px; pointer-events: none; white-space: nowrap; }
             .jsroot_ctxt_extraText { margin: 0; padding: 3px 7px; color: rgb(0, 0, 0, 0.6); }
             .jsroot_ctxt_focus { background-color: rgb(220, 220, 220); }
             .jsroot_ctxt_item:hover { background-color: rgb(235, 235, 235); }`, this.element);
      } else if ((left < 0) && (top == left)) {
         // column
         outer.className = 'jsroot_ctxt_column';
         outer.style.width = (100/-left).toFixed(1) + '%';
      } else {
         outer.style.left = -loc.offsetLeft + loc.offsetWidth + 'px';
      }

      let need_check_area = false, ncols = 0;
      menu.forEach(d => {
         if (d.checked) need_check_area = true;
         if (d.column) ncols++;
      });

      menu.forEach(d => {
         if (ncols > 0) {
            outer.style.display = 'flex';
            if (d.column) this._buildContextmenu(d.sub, -ncols, -ncols, outer);
            return;
         }

         if (d.divider) {
            let hr = document.createElement('hr');
            hr.className = 'jsroot_ctxt_divider';
            outer.appendChild(hr);
            return;
         }

         let item = document.createElement('div');
         item.style.position = 'relative';
         outer.appendChild(item);

         if (d.header) {
            item.className = 'jsroot_ctxt_header';
            item.innerHTML = d.text;
            return;
         }

         let hovArea = document.createElement('div');
         hovArea.style.width = '100%';
         hovArea.style.height = '100%';
         hovArea.className = 'jsroot_ctxt_item';
         hovArea.style.display = 'flex';
         hovArea.style.justifyContent = 'space-between';
         hovArea.style.cursor = 'pointer';
         if (d.title) hovArea.setAttribute('title', d.title);

         item.appendChild(hovArea);
         if (!d.text) d.text = 'item';

         let text = document.createElement('div');
         text.className = 'jsroot_ctxt_text';

         if (d.text.indexOf('<svg') >= 0) {
            if (need_check_area) {
               text.style.display = 'flex';

               let chk = document.createElement('span');
               chk.innerHTML = d.checked ? '\u2713' : '';
               chk.style.display = 'inline-block';
               chk.style.width = '1em';
               text.appendChild(chk);

               let sub = document.createElement('div');
               sub.innerHTML = d.text;
               text.appendChild(sub);
            } else {
               text.innerHTML = d.text;
            }

         } else {
            if (need_check_area) {
               let chk = document.createElement('span');
               chk.innerHTML = d.checked ? '\u2713' : '';
               chk.style.display = 'inline-block';
               chk.style.width = '1em';
               text.appendChild(chk);
            }

            let sub = document.createElement('span');
            if (d.text.indexOf('<nobr>') == 0)
               sub.textContent = d.text.slice(6, d.text.length-7);
            else
               sub.textContent = d.text;
            text.appendChild(sub);

         }

         hovArea.appendChild(text);

         if (d.hasOwnProperty('extraText') || d.sub) {
            let extraText = document.createElement('span');
            extraText.className = 'jsroot_ctxt_extraText jsroot_ctxt_text';
            extraText.textContent = d.sub ? '\u25B6' : d.extraText;
            hovArea.appendChild(extraText);
         }

         hovArea.addEventListener('mouseenter', () => {
            let focused = outer.childNodes;
            focused.forEach(d => {
               if (d.classList.contains('jsroot_ctxt_focus')) {
                  d.removeChild(d.getElementsByClassName('jsroot_ctxt_container')[0]);
                  d.classList.remove('jsroot_ctxt_focus');
               }
            });
         });

         if (d.sub)
            hovArea.addEventListener('mouseenter', () => {
               item.classList.add('jsroot_ctxt_focus');
               this._buildContextmenu(d.sub, 0, 0, item);
            });


         if (d.func)
            item.addEventListener('click', evnt => {
               let func = this.painter ? d.func.bind(this.painter) : d.func;
               func(d.arg);
               evnt.stopPropagation();
               this.remove();
            });
      });

      loc.appendChild(outer);

      let docWidth = document.documentElement.clientWidth, docHeight = document.documentElement.clientHeight;

      //Now determine where the contextmenu will be
      if (loc === document.body) {
         if (left + outer.offsetWidth > docWidth) {
            //Does sub-contextmenu overflow window width?
            outer.style.left = (docWidth - outer.offsetWidth) + 'px';
         }
         if (outer.offsetHeight > docHeight) {
            //is the contextmenu height larger than the window height?
            outer.style.top = 0;
            outer.style.overflowY = 'scroll';
            outer.style.overflowX = 'hidden';
            outer.style.height = docHeight + 'px';
         } else if (top + outer.offsetHeight > docHeight) {
            //Does contextmenu overflow window height?
            outer.style.top = (docHeight - outer.offsetHeight) + 'px';
         }

      } else if (outer.className != 'jsroot_ctxt_column') {

         //if its sub-contextmenu
         let dimensionsLoc = loc.getBoundingClientRect(), dimensionsOuter = outer.getBoundingClientRect();

         //Does sub-contextmenu overflow window width?
         if (dimensionsOuter.left + dimensionsOuter.width > docWidth) {
            outer.style.left = (-loc.offsetLeft - dimensionsOuter.width) + 'px';
         }

         if (dimensionsOuter.height > docHeight) {
            //is the sub-contextmenu height larger than the window height?
            outer.style.top = -dimensionsOuter.top + 'px';
            outer.style.overflowY = 'scroll';
            outer.style.overflowX = 'hidden';
            outer.style.height = docHeight + 'px';
         } else if (dimensionsOuter.height < docHeight && dimensionsOuter.height > docHeight / 2) {
            //is the sub-contextmenu height smaller than the window height AND larger than half of window height?
            if (dimensionsOuter.top - docHeight / 2 >= 0) { //If sub-contextmenu is closer to bottom of the screen
               outer.style.top = (-dimensionsOuter.top - dimensionsOuter.height + docHeight) + 'px';
            } else { //If sub-contextmenu is closer to top of the screen
               outer.style.top = (-dimensionsOuter.top) + 'px';
            }
         } else if (dimensionsOuter.top + dimensionsOuter.height > docHeight) {
            //Does sub-contextmenu overflow window height?
            outer.style.top = (-dimensionsOuter.height + dimensionsLoc.height) + 'px';
         }
      }
      return outer;
   }

   /** @summary Show standalone menu */
   async show(event) {
      this.remove();

      if (!event && this.show_evnt) event = this.show_evnt;

      document.body.addEventListener('click', this.remove_handler);

      let oldmenu = document.getElementById(this.menuname);
      if (oldmenu) oldmenu.remove();

      this.element = this._buildContextmenu(this.code, (event?.clientX || 0) + window.pageXOffset, (event?.clientY || 0) + window.pageYOffset, document.body);

      this.element.setAttribute('id', this.menuname);

      return this;
   }

   /** @summary Run modal elements with standalone code */
   async runModal(title, main_content, args) {
      if (!args) args = {};
      let dlg_id = this.menuname + '_dialog';
      select(`#${dlg_id}`).remove();
      select(`#${dlg_id}_block`).remove();

      let block = select('body').append('div').attr('id', dlg_id+'_block').attr('class', 'jsroot_dialog_block');

      let element = select('body')
                      .append('div')
                      .attr('id',dlg_id)
                      .attr('class','jsroot_dialog').style('width',(args.width || 450) + 'px')
                      .attr('tabindex', '0')
                      .html(
         `<div class="jsroot_dialog_body">
            <div class="jsroot_dialog_header">${title}</div>
            <div class="jsroot_dialog_content">${main_content}</div>
            <div class="jsroot_dialog_footer">
               <button class="jsroot_dialog_button">Ok</button>
               ${args.btns ? '<button class="jsroot_dialog_button">Cancel</button>' : ''}
           </div>
          </div>`);

      injectStyle(
         `.jsroot_dialog_block { z-index: 100000; position: absolute; top: 0; left: 0; right: 0; bottom: 0; opacity: 0.2; background-color: white; }
          .jsroot_dialog { z-index: 100001; position: absolute; left: 50%; top: 50%; }
          .jsroot_dialog_body { position: relative; left: -50%; top: -50%; border: solid green 3px; padding: 5px; display: flex; flex-flow: column; background-color: white; }
          .jsroot_dialog_header { flex: 0 1 auto; padding: 5px; }
          .jsroot_dialog_content { flex: 1 1 auto; padding: 5px; }
          .jsroot_dialog_footer { flex: 0 1 auto; padding: 5px; }
          .jsroot_dialog_button { float: right; margin-right: 1em; }`, element.node());

      return new Promise(resolveFunc => {
         element.on('keyup', evnt => {
            if ((evnt.code == 'Enter') || (evnt.code == 'Escape')) {
               evnt.preventDefault();
               evnt.stopPropagation();
               resolveFunc(evnt.code == 'Enter' ? element.node() : null);
               element.remove();
               block.remove();
            }
         });
         element.on('keydown', evnt => {
            if ((evnt.code == 'Enter') || (evnt.code == 'Escape')) {
               evnt.preventDefault();
               evnt.stopPropagation();
            }
         });
         element.selectAll('.jsroot_dialog_button').on('click', evnt => {
            resolveFunc(args.btns && (select(evnt.target).text() == 'Ok') ? element.node() : null);
            element.remove();
            block.remove();
         });

         let f = element.select('.jsroot_dialog_content').select('input');
         if (f.empty()) f = element.select('.jsroot_dialog_footer').select('button');
         if (!f.empty()) f.node().focus();
      });
   }

} // class StandaloneMenu

/**
 * @summary Context menu class using Bootstrap
 *
 * @desc Use {@link createMenu} to create instance of the menu
 * @private
 */

class BootstrapMenu extends JSRootMenu {

   constructor(painter, menuname, show_event) {
      super(painter, menuname, show_event);

      this.code = '';
      this.funcs = {};
      this.lvl = 0;
   }

   /** @summary Load bootstrap functionality, required for menu
     * @private */
   loadBS(with_js) {
      let ext = 'https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.0.2/';

      let promise = internals.bs_path ? Promise.resolve(true) :
                      loadScript(exports.source_dir + 'style/bootstrap.min.css')
                            .then(() => { internals.bs_path = exports.source_dir + 'scripts/'; })
                            .catch(() => { internals.bs_path = ext + 'js/'; return loadScript(ext + 'css/bootstrap.min.css'); });
      return promise.then(() => (!with_js || (typeof bootstrap != 'undefined')) ? true : loadScript(internals.bs_path + 'bootstrap.bundle.min.js'));
   }

   /** @summary Load bootstrap functionality */
   load() { return this.loadBS().then(() => this); }

   /** @summary Add menu item
     * @param {string} name - item name
     * @param {function} func - func called when item is selected */
   add(name, arg, func, title) {
      if (name == 'separator') {
         this.code += '<hr class="dropdown-divider">';
         return;
      }

      if ((name == 'column:') || (name == 'endcolumn:'))
         return;

      if (name.indexOf('header:') == 0) {
         this.code += `<h6 class="dropdown-header">${name.slice(7)}</h6>`;
         return;
      }

      let newlevel = false, extras = '', cl = 'dropdown-item btn-sm', checked = '';

      if (name == 'endsub:') {
         this.lvl--;
         this.code += '</li>';
         this.code += '</ul>';
         return;
      }
      if (name.indexOf('sub:') == 0) { name = name.slice(4); newlevel = true; }

      if (isFunc(arg)) { func = arg; arg = name; }

      if (name.indexOf('chk:') == 0) {
         checked = '\u2713';
         name  = name.slice(4);
      } else if (name.indexOf('unk:') == 0) {
         name = name.slice(4);
      }

      if (title) extras += ` title="${title}"`;
      if (arg !== undefined) extras += ` arg="${arg}"`;
      if (newlevel) { extras += ` data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded='false'`; cl += ' dropdown-toggle'; }

      let item = `<button id="${this.menuname}${this.cnt}" ${extras} class="${cl}" type="button"><span style="width:1em;display:inline-block">${checked}</span>${name}</button>`;

      if (newlevel) item = `<li class="dropend">${item}`;
               else item = `<li>${item}</li>`;

      this.code += item;

      if (newlevel) {
         this.code += `<ul class="dropdown-menu" aria-labelledby="${this.menuname}${this.cnt}">`;
         this.lvl++;
      }

      if (isFunc(func)) this.funcs[this.cnt] = func; // keep call-back function

      this.cnt++;
   }

   /** @summary Show menu */
   async show(event) {
      this.remove();

      if (!event && this.show_evnt) event = this.show_evnt;

      document.body.addEventListener('click', this.remove_handler);

      let oldmenu = document.getElementById(this.menuname);
      if (oldmenu) oldmenu.parentNode.removeChild(oldmenu);

      return this.loadBS().then(() => {

         let ww = window.innerWidth, wh = window.innerHeight;

         this.element = document.createElement('div');
         this.element.id = this.menuname;
         this.element.setAttribute('class', 'dropdown');
         this.element.innerHTML = `<ul class="dropdown-menu dropend" style="display:block">${this.code}</ul>`;

         document.body.appendChild(this.element);

         this.element.style.position = 'absolute';
         this.element.style.background = 'white';
         this.element.style.display = 'block';
         this.element.style.left = (event.clientX + window.pageXOffset) + 'px';
         this.element.style.top = (event.clientY + window.pageYOffset) + 'px';

         let menu = this;

         let myItems = this.element.getElementsByClassName('dropdown-item');

         for (let i = 0; i < myItems.length; i++)
            myItems[i].addEventListener('click', function() {
               let arg = this.getAttribute('arg'),
                   cnt = this.getAttribute('id').slice(menu.menuname.length),
                   func = cnt ? menu.funcs[cnt] : null;
               menu.remove();
               if (isFunc(func)) {
                  if (menu.painter)
                     func.bind(menu.painter)(arg); // if 'painter' field set, returned as this to callback
                  else
                     func(arg);
               }
            });

         let myDropdown = this.element.getElementsByClassName('dropdown-toggle');
         for (let i=0; i < myDropdown.length; i++) {
            myDropdown[i].addEventListener('mouseenter', function() {
               let el = this.nextElementSibling;
               el.style.display = (el.style.display == 'block') ? 'none' : 'block';
               el.style.left = this.scrollWidth + 'px';
               let rect = el.getBoundingClientRect();
               if (rect.bottom > wh) el.style.top = (wh - rect.bottom - 5) + 'px';
               if (rect.right > ww) el.style.left = (-rect.width) + 'px';
            });
            myDropdown[i].addEventListener('mouseleave', function() {
               let el = this.nextElementSibling;
               el.was_entered = false;
               setTimeout(function() { if (!el.was_entered) el.style.display = 'none'; }, 200);
            });
         }

         let myMenus = this.element.getElementsByClassName('dropdown-menu');
         for (let i = 0; i < myMenus.length; i++)
            myMenus[i].addEventListener('mouseenter', function() {
               this.was_entered = true;
            });


         let newx = null, newy = null, rect = this.element.firstChild.getBoundingClientRect();

         if (event.clientX + rect.width > ww) newx = ww - rect.width - 10;
         if (event.clientY + rect.height > wh) newy = wh - rect.height - 10;

         if (newx !== null) this.element.style.left = ((newx > 0 ? newx : 0) + window.pageXOffset) + 'px';
         if (newy !== null) this.element.style.top = ((newy > 0 ? newy : 0) + window.pageYOffset) + 'px';

         return new Promise(resolve => {
            this.resolveFunc = resolve;
         });
      });
   }

   /** @summary Run modal elements with bootstrap code */
   async runModal(title, main_content, args) {
      if (!args) args = {};

      let dlg_id = this.menuname + '_dialog',
          old_dlg = document.getElementById(dlg_id);
      if (old_dlg) old_dlg.remove();

      return this.loadBS(true).then(() => {

         let myModalEl = document.createElement('div');
         myModalEl.setAttribute('id', dlg_id);
         myModalEl.setAttribute('class', 'modal fade');
         myModalEl.setAttribute('role', 'dialog');
         myModalEl.setAttribute('tabindex', '-1');
         myModalEl.setAttribute('aria-hidden', 'true');
         let close_btn = args.btns ? '<button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>' : '';

         myModalEl.innerHTML =
            `<div class="modal-dialog">`+
              `<div class="modal-content">`+
               `<div class="modal-header">`+
                `<h5 class="modal-title">${title}</h5>`+
                `<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>`+
               `</div>`+
               `<div class="modal-body">${main_content}</div>`+
               `<div class="modal-footer">`+
                  `${close_btn}`+
                  `<button type="button" class="btn btn-primary jsroot_okbtn" data-bs-dismiss="modal">Ok</button>`+
               `</div>`+
              `</div>`+
             `</div>`;

         document.body.appendChild(myModalEl);

         let myModal = new bootstrap.Modal(myModalEl, { keyboard: true, backdrop: 'static' });
         myModal.show();

         return new Promise(resolveFunc => {
            let pressOk = false;
            myModalEl.querySelector(`.jsroot_okbtn`).addEventListener('click', () => { pressOk = true; });

            myModalEl.addEventListener('hidden.bs.modal', () => {
               if (pressOk) resolveFunc(myModalEl);
               myModalEl.remove();
            });
         });

     });
   }

} // class BootstrapMenu


/** @summary Create JSROOT menu
  * @desc See {@link JSRootMenu} class for detailed list of methods
  * @param {object} [evnt] - event object like mouse context menu event
  * @param {object} [handler] - object with handling function, in this case one not need to bind function
  * @param {string} [menuname] - optional menu name
  * @example
  * import { createMenu } from 'path_to_jsroot/modules/gui/menu.mjs';
  * let menu = await createMenu());
  * menu.add('First', () => console.log('Click first'));
  * let flag = true;
  * menu.addchk(flag, 'Checked', arg => console.log(`Now flag is ${arg}`));
  * menu.show(); */
function createMenu$1(evnt, handler, menuname) {
   let menu = settings.Bootstrap ? new BootstrapMenu(handler, menuname || 'root_ctx_menu', evnt)
                                 : new StandaloneMenu(handler, menuname || 'root_ctx_menu', evnt);
   return menu.load();
}

/** @summary Close previousely created and shown JSROOT menu
  * @param {string} [menuname] - optional menu name */
function closeMenu(menuname) {
   let x = document.getElementById(menuname || 'root_ctx_menu');
   if (x) { x.parentNode.removeChild(x); return true; }
   return false;
}

function setPainterTooltipEnabled(painter, on) {
   if (!painter) return;

   let fp = painter.getFramePainter();
   if (isFunc(fp?.setTooltipEnabled)) {
      fp.setTooltipEnabled(on);
      fp.processFrameTooltipEvent(null);
   }
   // this is 3D control object
   if (isFunc(painter.control?.setTooltipEnabled))
      painter.control.setTooltipEnabled(on);
}

// global, allow single drag at once
let drag_rect = null, drag_kind = '', drag_painter = null;

/** @summary Check if dragging performed currently
  * @private */
function is_dragging(painter, kind) {
   return drag_rect && (drag_painter === painter) && (drag_kind === kind);
}

/** @summary Add drag for interactive rectangular elements for painter
  * @private */
function addDragHandler(_painter, arg) {
   if (!settings.MoveResize || isBatchMode()) return;

   let painter = _painter, pp = painter.getPadPainter();
   if (pp?._fast_drawing) return;

   function makeResizeElements(group, handler) {
      function addElement(cursor, d) {
         let clname = 'js_' + cursor.replace(/[-]/g, '_'),
             elem = group.select('.' + clname);
         if (elem.empty()) elem = group.append('path').classed(clname, true);
         elem.style('opacity', 0).style('cursor', cursor).attr('d', d);
         if (handler) elem.call(handler);
      }

      addElement('nw-resize', 'M2,2h15v-5h-20v20h5Z');
      addElement('ne-resize', `M${arg.width - 2},2h-15v-5h20v20h-5 Z`);
      addElement('sw-resize', `M2,${arg.height - 2}h15v5h-20v-20h5Z`);
      addElement('se-resize', `M${arg.width - 2},${arg.height - 2}h-15v5h20v-20h-5Z`);

      if (!arg.no_change_x) {
         addElement('w-resize', `M-3,18h5v${Math.max(0, arg.height - 2 * 18)}h-5Z`);
         addElement('e-resize', `M${arg.width + 3},18h-5v${Math.max(0, arg.height - 2 * 18)}h5Z`);
      }
      if (!arg.no_change_y) {
         addElement('n-resize', `M18,-3v5h${Math.max(0, arg.width - 2 * 18)}v-5Z`);
         addElement('s-resize', `M18,${arg.height + 3}v-5h${Math.max(0, arg.width - 2 * 18)}v5Z`);
      }
   }

   const complete_drag = (newx, newy, newwidth, newheight) => {
      drag_painter = null;
      drag_kind = '';
      if (drag_rect) {
         drag_rect.remove();
         drag_rect = null;
      }

      if (!painter.draw_g)
         return false;

      let oldx = arg.x, oldy = arg.y;

      if (arg.minwidth && newwidth < arg.minwidth) newwidth = arg.minwidth;
      if (arg.minheight && newheight < arg.minheight) newheight = arg.minheight;

      let change_size = (newwidth !== arg.width) || (newheight !== arg.height),
          change_pos = (newx !== oldx) || (newy !== oldy);

      arg.x = newx; arg.y = newy; arg.width = newwidth; arg.height = newheight;

      painter.draw_g.attr('transform', `translate(${newx},${newy})`);

      setPainterTooltipEnabled(painter, true);

      makeResizeElements(painter.draw_g);

      if (change_size || change_pos) {
         if (change_size && ('resize' in arg)) arg.resize(newwidth, newheight);
         if (change_pos && ('move' in arg)) arg.move(newx, newy, newx - oldx, newy - oldy);

         if (change_size || change_pos) {
            if ('obj' in arg) {
               let rect = pp.getPadRect();
               arg.obj.fX1NDC = newx / rect.width;
               arg.obj.fX2NDC = (newx + newwidth) / rect.width;
               arg.obj.fY1NDC = 1 - (newy + newheight) / rect.height;
               arg.obj.fY2NDC = 1 - newy / rect.height;
               arg.obj.modified_NDC = true; // indicate that NDC was interactively changed, block in updated
            }
            if ('redraw' in arg) arg.redraw(arg);
         }
      }

      return change_size || change_pos;
   };

   // add interactive styles when frame painter not there
   if (_painter) {
      let fp = _painter.getFramePainter();
      if (!fp || fp.mode3d)
         injectFrameStyle(_painter.draw_g);
   }

   let drag_move = drag().subject(Object);

   drag_move
      .on('start', function(evnt) {
         if (detectRightButton(evnt.sourceEvent) || drag_kind) return;

         closeMenu(); // close menu

         setPainterTooltipEnabled(painter, false); // disable tooltip

         evnt.sourceEvent.preventDefault();
         evnt.sourceEvent.stopPropagation();

         let pad_rect = pp.getPadRect();

         let handle = {
            x: arg.x, y: arg.y, width: arg.width, height: arg.height,
            acc_x1: arg.x, acc_y1: arg.y,
            pad_w: pad_rect.width - arg.width,
            pad_h: pad_rect.height - arg.height,
            drag_tm: new Date(),
            path: `v${arg.height}h${arg.width}v${-arg.height}z`
         };

         drag_painter = painter;
         drag_kind = 'move';
         drag_rect = select(painter.draw_g.node().parentNode).append('path')
            .classed('zoom', true)
            .attr('d', `M${handle.acc_x1},${handle.acc_y1}${handle.path}`)
            .style('cursor', 'move')
            .style('pointer-events', 'none') // let forward double click to underlying elements
            .property('drag_handle', handle);

      }).on('drag', function(evnt) {
         if (!is_dragging(painter, 'move')) return;

         evnt.sourceEvent.preventDefault();
         evnt.sourceEvent.stopPropagation();

         let handle = drag_rect.property('drag_handle');

         if (!arg.no_change_x)
            handle.acc_x1 += evnt.dx;
         if (!arg.no_change_y)
            handle.acc_y1 += evnt.dy;

         handle.x = Math.min(Math.max(handle.acc_x1, 0), handle.pad_w);
         handle.y = Math.min(Math.max(handle.acc_y1, 0), handle.pad_h);

         drag_rect.attr('d', `M${handle.x},${handle.y}${handle.path}`);

      }).on('end', function(evnt) {
         if (!is_dragging(painter, 'move')) return;

         evnt.sourceEvent.preventDefault();

         let handle = drag_rect.property('drag_handle');

         if (complete_drag(handle.x, handle.y, arg.width, arg.height) === false) {
            let spent = (new Date()).getTime() - handle.drag_tm.getTime();
            if (arg.ctxmenu && (spent > 600) && painter.showContextMenu) {
               let rrr = resize_se.node().getBoundingClientRect();
               painter.showContextMenu('main', { clientX: rrr.left, clientY: rrr.top });
            } else if (arg.canselect && (spent <= 600)) {
               painter.getPadPainter()?.selectObjectPainter(painter);
            }
         }
      });

   let drag_resize = drag().subject(Object);

   drag_resize
      .on('start', function(evnt) {
         if (detectRightButton(evnt.sourceEvent) || drag_kind) return;

         evnt.sourceEvent.stopPropagation();
         evnt.sourceEvent.preventDefault();

         setPainterTooltipEnabled(painter, false); // disable tooltip

         let pad_rect = pp.getPadRect();

         let handle = {
            x: arg.x, y: arg.y, width: arg.width, height: arg.height,
            acc_x1: arg.x, acc_y1: arg.y,
            acc_x2: arg.x + arg.width, acc_y2: arg.y + arg.height,
            pad_w: pad_rect.width, pad_h: pad_rect.height
         };

         drag_painter = painter;
         drag_kind = 'resize';
         drag_rect = select(painter.draw_g.node().parentNode)
            .append('rect')
            .classed('zoom', true)
            .style('cursor', select(this).style('cursor'))
            .attr('x', handle.acc_x1)
            .attr('y', handle.acc_y1)
            .attr('width', handle.acc_x2 - handle.acc_x1)
            .attr('height', handle.acc_y2 - handle.acc_y1)
            .property('drag_handle', handle);

      }).on('drag', function(evnt) {
         if (!is_dragging(painter, 'resize')) return;

         evnt.sourceEvent.preventDefault();
         evnt.sourceEvent.stopPropagation();

         let handle = drag_rect.property('drag_handle'),
            dx = evnt.dx, dy = evnt.dy, elem = select(this);

         if (arg.no_change_x) dx = 0;
         if (arg.no_change_y) dy = 0;

         if (elem.classed('js_nw_resize')) { handle.acc_x1 += dx; handle.acc_y1 += dy; }
         else if (elem.classed('js_ne_resize')) { handle.acc_x2 += dx; handle.acc_y1 += dy; }
         else if (elem.classed('js_sw_resize')) { handle.acc_x1 += dx; handle.acc_y2 += dy; }
         else if (elem.classed('js_se_resize')) { handle.acc_x2 += dx; handle.acc_y2 += dy; }
         else if (elem.classed('js_w_resize')) { handle.acc_x1 += dx; }
         else if (elem.classed('js_n_resize')) { handle.acc_y1 += dy; }
         else if (elem.classed('js_e_resize')) { handle.acc_x2 += dx; }
         else if (elem.classed('js_s_resize')) { handle.acc_y2 += dy; }

         let x1 = Math.max(0, handle.acc_x1), x2 = Math.min(handle.acc_x2, handle.pad_w),
             y1 = Math.max(0, handle.acc_y1), y2 = Math.min(handle.acc_y2, handle.pad_h);

         handle.x = Math.min(x1, x2);
         handle.y = Math.min(y1, y2);
         handle.width = Math.abs(x2 - x1);
         handle.height = Math.abs(y2 - y1);

         drag_rect.attr('x', handle.x).attr('y', handle.y).attr('width', handle.width).attr('height', handle.height);

      }).on('end', function(evnt) {
         if (!is_dragging(painter, 'resize')) return;

         evnt.sourceEvent.preventDefault();

         let handle = drag_rect.property('drag_handle');

         complete_drag(handle.x, handle.y, handle.width, handle.height);
      });

   if (!arg.only_resize)
      painter.draw_g.style('cursor', 'move').call(drag_move);

   if (!arg.only_move)
      makeResizeElements(painter.draw_g, drag_resize);
}

const TooltipHandler = {

   /** @desc only canvas info_layer can be used while other pads can overlay
     * @return layer where frame tooltips are shown */
   hints_layer() {
      let pp = this.getCanvPainter();
      return pp ? pp.getLayerSvg('info_layer') : select(null);
   },

   /** @return true if tooltip is shown, use to prevent some other action */
   isTooltipShown() {
      if (!this.tooltip_enabled || !this.isTooltipAllowed()) return false;
      let hintsg = this.hints_layer().select('.objects_hints');
      return hintsg.empty() ? false : hintsg.property('hints_pad') == this.getPadName();
   },

   setTooltipEnabled(enabled) {
      if (enabled !== undefined) this.tooltip_enabled = enabled;
   },

   /** @summary central function which let show selected hints for the object */
   processFrameTooltipEvent(pnt, evnt) {

      if (pnt?.handler) {
         // special use of interactive handler in the frame painter
         let rect = this.draw_g ? this.draw_g.select('.main_layer') : null;
         if (!rect || rect.empty()) {
            pnt = null; // disable
         } else if (pnt.touch && evnt) {
            let pos = pointers(evnt, rect.node());
            pnt = (pos && pos.length == 1) ? { touch: true, x: pos[0][0], y: pos[0][1] } : null;
         } else if (evnt) {
            let pos = pointer(evnt, rect.node());
            pnt = { touch: false, x: pos[0], y: pos[1] };
         }
      }

      let hints = [], nhints = 0, nexact = 0, maxlen = 0, lastcolor1 = 0, usecolor1 = false,
         textheight = 11, hmargin = 3, wmargin = 3, hstep = 1.2,
         frame_rect = this.getFrameRect(),
         pp = this.getPadPainter(),
         pad_width = pp.getPadWidth(),
         font = new FontHandler(160, textheight),
         disable_tootlips = !this.isTooltipAllowed() || !this.tooltip_enabled;

      if (pnt && disable_tootlips) pnt.disabled = true; // indicate that highlighting is not required
      if (pnt) pnt.painters = true; // get also painter

      // collect tooltips from pad painter - it has list of all drawn objects
      if (pp) hints = pp.processPadTooltipEvent(pnt);

      if (pp?._deliver_webcanvas_events && pp?.is_active_pad && pnt && isFunc(pp?.deliverWebCanvasEvent))
         pp.deliverWebCanvasEvent('move', frame_rect.x + pnt.x, frame_rect.y + pnt.y, hints);

      if (pnt?.touch) textheight = 15;

      for (let n = 0; n < hints.length; ++n) {
         let hint = hints[n];
         if (!hint) continue;

         if (hint.painter && (hint.user_info !== undefined))
            hint.painter.provideUserTooltip(hint.user_info);

         if (!hint.lines || (hint.lines.length === 0)) {
            hints[n] = null;
            continue;
         }

         // check if fully duplicated hint already exists
         for (let k = 0; k < n; ++k) {
            let hprev = hints[k], diff = false;
            if (!hprev || (hprev.lines.length !== hint.lines.length)) continue;
            for (let l = 0; l < hint.lines.length && !diff; ++l)
               if (hprev.lines[l] !== hint.lines[l]) diff = true;
            if (!diff) { hints[n] = null; break; }
         }
         if (!hints[n]) continue;

         nhints++;

         if (hint.exact) nexact++;

         hint.lines.forEach(line => { maxlen = Math.max(maxlen, line.length); });

         hint.height = Math.round(hint.lines.length * textheight * hstep + 2 * hmargin - textheight * (hstep - 1));

         if ((hint.color1 !== undefined) && (hint.color1 !== 'none')) {
            if ((lastcolor1 !== 0) && (lastcolor1 !== hint.color1)) usecolor1 = true;
            lastcolor1 = hint.color1;
         }
      }

      let layer = this.hints_layer(),
          hintsg = layer.select('.objects_hints'), // group with all tooltips
          title = '', name = '', info = '',
          hint = null, best_dist2 = 1e10, best_hint = null, show_only_best = nhints > 15,
          coordinates = pnt ? Math.round(pnt.x) + ',' + Math.round(pnt.y) : '';

      // try to select hint with exact match of the position when several hints available
      for (let k = 0; k < (hints?.length || 0); ++k) {
         if (!hints[k]) continue;
         if (!hint) hint = hints[k];

         // select exact hint if this is the only one
         if (hints[k].exact && (nexact < 2) && (!hint || !hint.exact)) { hint = hints[k]; break; }

         if (!pnt || (hints[k].x === undefined) || (hints[k].y === undefined)) continue;

         let dist2 = (pnt.x - hints[k].x) ** 2 + (pnt.y - hints[k].y) ** 2;
         if (dist2 < best_dist2) { best_dist2 = dist2; best_hint = hints[k]; }
      }

      if ((!hint || !hint.exact) && (best_dist2 < 400)) hint = best_hint;

      if (hint) {
         name = (hint.lines && hint.lines.length > 1) ? hint.lines[0] : hint.name;
         title = hint.title || '';
         info = hint.line;
         if (!info && hint.lines) info = hint.lines.slice(1).join(' ');
      }

      this.showObjectStatus(name, title, info, coordinates);

      // end of closing tooltips
      if (!pnt || disable_tootlips || (hints.length === 0) || (maxlen === 0) || (show_only_best && !best_hint)) {
         hintsg.remove();
         return;
      }

      // we need to set pointer-events=none for all elements while hints
      // placed in front of so-called interactive rect in frame, used to catch mouse events

      if (hintsg.empty())
         hintsg = layer.append('svg:g')
            .attr('class', 'objects_hints')
            .style('pointer-events', 'none');

      let frame_shift = { x: 0, y: 0 }, trans = frame_rect.transform || '';
      if (!pp.iscan) {
         frame_shift = getAbsPosInCanvas(this.getPadSvg(), frame_shift);
         trans = `translate(${frame_shift.x},${frame_shift.y}) ${trans}`;
      }

      // copy transform attributes from frame itself
      hintsg.attr('transform', trans)
            .property('last_point', pnt)
            .property('hints_pad', this.getPadName());

      let viewmode = hintsg.property('viewmode') || '',
         actualw = 0, posx = pnt.x + frame_rect.hint_delta_x;

      if (show_only_best || (nhints == 1)) {
         viewmode = 'single';
         posx += 15;
      } else {
         // if there are many hints, place them left or right

         let bleft = 0.5, bright = 0.5;

         if (viewmode == 'left')
            bright = 0.7;
         else if (viewmode == 'right')
            bleft = 0.3;

         if (posx <= bleft * frame_rect.width) {
            viewmode = 'left';
            posx = 20;
         } else if (posx >= bright * frame_rect.width) {
            viewmode = 'right';
            posx = frame_rect.width - 60;
         } else {
            posx = hintsg.property('startx');
         }
      }

      if (viewmode !== hintsg.property('viewmode')) {
         hintsg.property('viewmode', viewmode);
         hintsg.selectAll('*').remove();
      }

      let curry = 10, // normal y coordinate
          gapy = 10,  // y coordinate, taking into account all gaps
          gapminx = -1111, gapmaxx = -1111,
          minhinty = -frame_shift.y,
          cp = this.getCanvPainter(),
          maxhinty = cp.getPadHeight() - frame_rect.y - frame_shift.y;

      const FindPosInGap = y => {
         for (let n = 0; (n < hints.length) && (y < maxhinty); ++n) {
            let hint = hints[n];
            if (!hint) continue;
            if ((hint.y >= y - 5) && (hint.y <= y + hint.height + 5)) {
               y = hint.y + 10;
               n = -1;
            }
         }
         return y;
      };

      for (let n = 0; n < hints.length; ++n) {
         let hint = hints[n],
            group = hintsg.select('.painter_hint_' + n);

         if (show_only_best && (hint !== best_hint)) hint = null;

         if (hint === null) {
            group.remove();
            continue;
         }

         let was_empty = group.empty();

         if (was_empty)
            group = hintsg.append('svg:svg')
               .attr('class', 'painter_hint_' + n)
               .attr('opacity', 0) // use attribute, not style to make animation with d3.transition()
               .style('overflow', 'hidden')
               .style('pointer-events', 'none');

         if (viewmode == 'single') {
            curry = pnt.touch ? (pnt.y - hint.height - 5) : Math.min(pnt.y + 15, maxhinty - hint.height - 3) + frame_rect.hint_delta_y;
         } else {
            gapy = FindPosInGap(gapy);
            if ((gapminx === -1111) && (gapmaxx === -1111)) gapminx = gapmaxx = hint.x;
            gapminx = Math.min(gapminx, hint.x);
            gapmaxx = Math.min(gapmaxx, hint.x);
         }

         group.attr('x', posx)
            .attr('y', curry)
            .property('curry', curry)
            .property('gapy', gapy);

         curry += hint.height + 5;
         gapy += hint.height + 5;

         if (!was_empty)
            group.selectAll('*').remove();

         group.attr('width', 60)
            .attr('height', hint.height);

         let r = group.append('rect')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', 60)
            .attr('height', hint.height)
            .style('fill', 'lightgrey')
            .style('pointer-events', 'none');

         if (nhints > 1) {
            let col = usecolor1 ? hint.color1 : hint.color2;
            if (col && (col !== 'none'))
               r.style('stroke', col);
         }
         r.attr('stroke-width', hint.exact ? 3 : 1);

         for (let l = 0; l < (hint.lines ? hint.lines.length : 0); l++)
            if (hint.lines[l] !== null) {
               let txt = group.append('svg:text')
                  .attr('text-anchor', 'start')
                  .attr('x', wmargin)
                  .attr('y', hmargin + l * textheight * hstep)
                  .attr('dy', '.8em')
                  .style('fill', 'black')
                  .style('pointer-events', 'none')
                  .call(font.func)
                  .text(hint.lines[l]);

               let box = getElementRect(txt, 'bbox');

               actualw = Math.max(actualw, box.width);
            }

         function translateFn() {
            // We only use 'd', but list d,i,a as params just to show can have them as params.
            // Code only really uses d and t.
            return function(/*d, i, a*/) {
               return function(t) {
                  return t < 0.8 ? '0' : (t - 0.8) * 5;
               };
            };
         }

         if (was_empty)
            if (settings.TooltipAnimation > 0)
               group.transition().duration(settings.TooltipAnimation).attrTween('opacity', translateFn());
            else
               group.attr('opacity', 1);
      }

      actualw += 2 * wmargin;

      let svgs = hintsg.selectAll('svg');

      if ((viewmode == 'right') && (posx + actualw > frame_rect.width - 20)) {
         posx = frame_rect.width - actualw - 20;
         svgs.attr('x', posx);
      }

      if ((viewmode == 'single') && (posx + actualw > pad_width - frame_rect.x) && (posx > actualw + 20)) {
         posx -= (actualw + 20);
         svgs.attr('x', posx);
      }

      // if gap not very big, apply gapy coordinate to open view on the histogram
      if ((viewmode !== 'single') && (gapy < maxhinty) && (gapy !== curry)) {
         if ((gapminx <= posx + actualw + 5) && (gapmaxx >= posx - 5))
            svgs.attr('y', function() { return select(this).property('gapy'); });
      } else if ((viewmode !== 'single') && (curry > maxhinty)) {
         let shift = Math.max((maxhinty - curry - 10), minhinty);
         if (shift < 0)
            svgs.attr('y', function() { return select(this).property('curry') + shift; });
      }

      if (actualw > 10)
         svgs.attr('width', actualw)
            .select('rect').attr('width', actualw);

      hintsg.property('startx', posx);

      if (cp._highlight_connect && isFunc(cp.processHighlightConnect))
         cp.processHighlightConnect(hints);
   },

   /** @summary Assigns tooltip methods */
   assign(painter) {
      Object.assign(painter, this, { tooltip_enabled: true });
   }

}; // TooltipHandler


function injectFrameStyle(draw_g) {
   injectStyle(`
.jsroot rect.h1bin { stroke: #4572A7; fill: #4572A7; opacity: 0; }
.jsroot rect.zoom { stroke: steelblue; fill-opacity: 0.1; }
.jsroot path.zoom { stroke: steelblue; fill-opacity: 0.1; }
.jsroot svg:not(:root) { overflow: hidden; }`, draw_g.node());
}

/** @summary Set of frame interactivity methods
  * @private */

const FrameInteractive = {

   /** @summary Adding basic interactivity */
   addBasicInteractivity() {

      TooltipHandler.assign(this);

      if (!this._frame_rotate && !this._frame_fixpos)
         addDragHandler(this, { obj: this, x: this._frame_x, y: this._frame_y, width: this.getFrameWidth(), height: this.getFrameHeight(),
                                only_resize: true, minwidth: 20, minheight: 20, redraw: () => this.sizeChanged() });

      injectFrameStyle(this.draw_g);

      let main_svg = this.draw_g.select('.main_layer');

      main_svg.style('pointer-events','visibleFill')
              .property('handlers_set', 0);

      let pp = this.getPadPainter(),
          handlers_set = pp?._fast_drawing ? 0 : 1;

      if (main_svg.property('handlers_set') != handlers_set) {
         let close_handler = handlers_set ? this.processFrameTooltipEvent.bind(this, null) : null,
             mouse_handler = handlers_set ? this.processFrameTooltipEvent.bind(this, { handler: true, touch: false }) : null;

         main_svg.property('handlers_set', handlers_set)
                 .on('mouseenter', mouse_handler)
                 .on('mousemove', mouse_handler)
                 .on('mouseleave', close_handler);

         if (browser$1.touches) {
            let touch_handler = handlers_set ? this.processFrameTooltipEvent.bind(this, { handler: true, touch: true }) : null;

            main_svg.on('touchstart', touch_handler)
                    .on('touchmove', touch_handler)
                    .on('touchend', close_handler)
                    .on('touchcancel', close_handler);
         }
      }

      main_svg.attr('x', 0)
              .attr('y', 0)
              .attr('width', this.getFrameWidth())
              .attr('height', this.getFrameHeight());

      let hintsg = this.hints_layer().select('.objects_hints');
      // if tooltips were visible before, try to reconstruct them after short timeout
      if (!hintsg.empty() && this.isTooltipAllowed() && (hintsg.property('hints_pad') == this.getPadName()))
         setTimeout(this.processFrameTooltipEvent.bind(this, hintsg.property('last_point'), null), 10);
   },

   /** @summary Add interactive handlers */
   async addFrameInteractivity(for_second_axes) {

      let pp = this.getPadPainter(),
          svg = this.getFrameSvg();
      if (pp?._fast_drawing || svg.empty())
         return this;

      if (for_second_axes) {

         // add extra handlers for second axes
         let svg_x2 = svg.selectAll('.x2axis_container'),
             svg_y2 = svg.selectAll('.y2axis_container');
         if (settings.ContextMenu) {
            svg_x2.on('contextmenu', evnt => this.showContextMenu('x2', evnt));
            svg_y2.on('contextmenu', evnt => this.showContextMenu('y2', evnt));
         }
         svg_x2.on('mousemove', evnt => this.showAxisStatus('x2', evnt));
         svg_y2.on('mousemove', evnt => this.showAxisStatus('y2', evnt));
         return this;
      }

      let svg_x = svg.selectAll('.xaxis_container'),
          svg_y = svg.selectAll('.yaxis_container');

      this.can_zoom_x = this.can_zoom_y = settings.Zooming;

      if (pp?.options) {
         if (pp.options.NoZoomX) this.can_zoom_x = false;
         if (pp.options.NoZoomY) this.can_zoom_y = false;
      }

      if (!svg.property('interactive_set')) {
         this.addFrameKeysHandler();

         this.last_touch = new Date(0);
         this.zoom_kind = 0; // 0 - none, 1 - XY, 2 - only X, 3 - only Y, (+100 for touches)
         this.zoom_rect = null;
         this.zoom_origin = null;  // original point where zooming started
         this.zoom_curr = null;    // current point for zooming
         this.touch_cnt = 0;
      }

      if (settings.Zooming && !this.projection) {
         if (settings.ZoomMouse) {
            svg.on('mousedown', this.startRectSel.bind(this));
            svg.on('dblclick', this.mouseDoubleClick.bind(this));
         }
         if (settings.ZoomWheel)
            svg.on('wheel', this.mouseWheel.bind(this));
      }

      if (browser$1.touches && ((settings.Zooming && settings.ZoomTouch && !this.projection) || settings.ContextMenu))
         svg.on('touchstart', this.startTouchZoom.bind(this));

      if (settings.ContextMenu) {
         if (browser$1.touches) {
            svg_x.on('touchstart', this.startTouchMenu.bind(this,'x'));
            svg_y.on('touchstart', this.startTouchMenu.bind(this,'y'));
         }
         svg.on('contextmenu', evnt => this.showContextMenu('', evnt));
         svg_x.on('contextmenu', evnt => this.showContextMenu('x', evnt));
         svg_y.on('contextmenu', evnt => this.showContextMenu('y', evnt));
      }

      svg_x.on('mousemove', evnt => this.showAxisStatus('x', evnt));
      svg_y.on('mousemove', evnt => this.showAxisStatus('y', evnt));

      svg.property('interactive_set', true);

      return this;
   },

   /** @summary Add keys handler */
   addFrameKeysHandler() {
      if (this.keys_handler || (typeof window == 'undefined')) return;

      this.keys_handler = evnt => this.processKeyPress(evnt);

      window.addEventListener('keydown', this.keys_handler, false);
   },

   /** @summary Handle key press */
   processKeyPress(evnt) {
      const allowed = ['PageUp', 'PageDown', 'ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown', 'PrintScreen', '*'];

      let main = this.selectDom(),
          key = evnt.key,
          pp = this.getPadPainter();

      if (!settings.HandleKeys || main.empty() || (this.enabledKeys === false) ||
          (getActivePad() !== pp) || (allowed.indexOf(key) < 0)) return false;

      if (evnt.shiftKey) key = 'Shift ' + key;
      if (evnt.altKey) key = 'Alt ' + key;
      if (evnt.ctrlKey) key = 'Ctrl ' + key;

      let zoom = { name: 'x', dleft: 0, dright: 0 };

      switch (key) {
         case 'ArrowLeft':  zoom.dleft = -1; zoom.dright = 1; break;
         case 'ArrowRight':  zoom.dleft = 1; zoom.dright = -1; break;
         case 'Ctrl ArrowLeft': zoom.dleft = zoom.dright = -1; break;
         case 'Ctrl ArrowRight': zoom.dleft = zoom.dright = 1; break;
         case 'ArrowUp':  zoom.name = 'y'; zoom.dleft = 1; zoom.dright = -1; break;
         case 'ArrowDown':  zoom.name = 'y'; zoom.dleft = -1; zoom.dright = 1; break;
         case 'Ctrl ArrowUp': zoom.name = 'y'; zoom.dleft = zoom.dright = 1; break;
         case 'Ctrl ArrowDown': zoom.name = 'y'; zoom.dleft = zoom.dright = -1; break;
      }

      if (zoom.dleft || zoom.dright) {
         if (!settings.Zooming) return false;
         // in 3dmode with orbit control ignore simple arrows
         if (this.mode3d && (key.indexOf('Ctrl') !== 0)) return false;
         this.analyzeMouseWheelEvent(null, zoom, 0.5);
         this.zoom(zoom.name, zoom.min, zoom.max);
         if (zoom.changed) this.zoomChangedInteractive(zoom.name, true);
         evnt.stopPropagation();
         evnt.preventDefault();
      } else {
         let func = pp?.findPadButton(key);
         if (func) {
            pp.clickPadButton(func);
            evnt.stopPropagation();
            evnt.preventDefault();
         }
      }

      return true; // just process any key press
   },

   /** @summary Function called when frame is clicked and object selection can be performed
     * @desc such event can be used to select */
   processFrameClick(pnt, dblckick) {

      let pp = this.getPadPainter();
      if (!pp) return;

      pnt.painters = true; // provide painters reference in the hints
      pnt.disabled = true; // do not invoke graphics

      // collect tooltips from pad painter - it has list of all drawn objects
      let hints = pp.processPadTooltipEvent(pnt), exact = null, res;
      for (let k = 0; (k < hints.length) && !exact; ++k)
         if (hints[k] && hints[k].exact)
            exact = hints[k];

      if (exact) {
         let handler = dblckick ? this._dblclick_handler : this._click_handler;
         if (handler) res = handler(exact.user_info, pnt);
      }

      if (!dblckick)
         pp.selectObjectPainter(exact ? exact.painter : this,
               { x: pnt.x + (this._frame_x || 0),  y: pnt.y + (this._frame_y || 0) });

      return res;
   },

   /** @summary Start mouse rect zooming */
   startRectSel(evnt) {
      // ignore when touch selection is activated

      if (this.zoom_kind > 100) return;

      // ignore all events from non-left button
      if ((evnt.which || evnt.button) !== 1) return;

      evnt.preventDefault();

      let frame = this.getFrameSvg(),
          pos = pointer(evnt, frame.node());

      this.clearInteractiveElements();

      let w = this.getFrameWidth(), h = this.getFrameHeight();

      this.zoom_lastpos = pos;
      this.zoom_curr = [ Math.max(0, Math.min(w, pos[0])),
                         Math.max(0, Math.min(h, pos[1])) ];

      this.zoom_origin = [0,0];
      this.zoom_second = false;

      if ((pos[0] < 0) || (pos[0] > w)) {
         this.zoom_second = (pos[0] > w) && this.y2_handle;
         this.zoom_kind = 3; // only y
         this.zoom_origin[1] = this.zoom_curr[1];
         this.zoom_curr[0] = w;
         this.zoom_curr[1] += 1;
      } else if ((pos[1] < 0) || (pos[1] > h)) {
         this.zoom_second = (pos[1] < 0) && this.x2_handle;
         this.zoom_kind = 2; // only x
         this.zoom_origin[0] = this.zoom_curr[0];
         this.zoom_curr[0] += 1;
         this.zoom_curr[1] = h;
      } else {
         this.zoom_kind = 1; // x and y
         this.zoom_origin[0] = this.zoom_curr[0];
         this.zoom_origin[1] = this.zoom_curr[1];
      }

      select(window).on('mousemove.zoomRect', this.moveRectSel.bind(this))
                       .on('mouseup.zoomRect', this.endRectSel.bind(this), true);

      this.zoom_rect = null;

      // disable tooltips in frame painter
      setPainterTooltipEnabled(this, false);

      evnt.stopPropagation();

      if (this.zoom_kind != 1)
         setTimeout(() => this.startLabelsMove(), 500);
   },

   /** @summary Starts labels move */
   startLabelsMove() {
      if (this.zoom_rect) return;

      let handle = (this.zoom_kind == 2) ? this.x_handle : this.y_handle;

      if (!handle || !isFunc(handle.processLabelsMove) || !this.zoom_lastpos) return;

      if (handle.processLabelsMove('start', this.zoom_lastpos))
         this.zoom_labels = handle;
   },

   /** @summary Process mouse rect zooming */
   moveRectSel(evnt) {

      if ((this.zoom_kind == 0) || (this.zoom_kind > 100)) return;

      evnt.preventDefault();
      let m = pointer(evnt, this.getFrameSvg().node());

      if (this.zoom_labels)
         return this.zoom_labels.processLabelsMove('move', m);

      this.zoom_lastpos[0] = m[0];
      this.zoom_lastpos[1] = m[1];

      m[0] = Math.max(0, Math.min(this.getFrameWidth(), m[0]));
      m[1] = Math.max(0, Math.min(this.getFrameHeight(), m[1]));

      switch (this.zoom_kind) {
         case 1: this.zoom_curr[0] = m[0]; this.zoom_curr[1] = m[1]; break;
         case 2: this.zoom_curr[0] = m[0]; break;
         case 3: this.zoom_curr[1] = m[1]; break;
      }

      let x = Math.min(this.zoom_origin[0], this.zoom_curr[0]),
          y = Math.min(this.zoom_origin[1], this.zoom_curr[1]),
          w = Math.abs(this.zoom_curr[0] - this.zoom_origin[0]),
          h = Math.abs(this.zoom_curr[1] - this.zoom_origin[1]);

      if (!this.zoom_rect) {
         // ignore small changes, can be switching to labels move
         if ((this.zoom_kind != 1) && ((w < 2) || (h < 2))) return;

         this.zoom_rect = this.getFrameSvg()
                              .append('rect')
                              .attr('class', 'zoom')
                              .style('pointer-events','none');
      }

      this.zoom_rect.attr('x', x).attr('y', y).attr('width', w).attr('height', h);
   },

   /** @summary Finish mouse rect zooming */
   endRectSel(evnt) {
      if ((this.zoom_kind == 0) || (this.zoom_kind > 100)) return;

      evnt.preventDefault();

      select(window).on('mousemove.zoomRect', null)
                       .on('mouseup.zoomRect', null);

      let m = pointer(evnt, this.getFrameSvg().node()), kind = this.zoom_kind;

      if (this.zoom_labels) {
         this.zoom_labels.processLabelsMove('stop', m);
      } else {
         let changed = [this.can_zoom_x, this.can_zoom_y];
         m[0] = Math.max(0, Math.min(this.getFrameWidth(), m[0]));
         m[1] = Math.max(0, Math.min(this.getFrameHeight(), m[1]));

         switch (this.zoom_kind) {
            case 1: this.zoom_curr[0] = m[0]; this.zoom_curr[1] = m[1]; break;
            case 2: this.zoom_curr[0] = m[0]; changed[1] = false; break; // only X
            case 3: this.zoom_curr[1] = m[1]; changed[0] = false; break; // only Y
         }

         let xmin, xmax, ymin, ymax, isany = false,
             idx = this.swap_xy ? 1 : 0, idy = 1 - idx,
             namex = 'x', namey = 'y';

         if (changed[idx] && (Math.abs(this.zoom_curr[idx] - this.zoom_origin[idx]) > 10)) {
            if (this.zoom_second && (this.zoom_kind == 2)) namex = 'x2';
            xmin = Math.min(this.revertAxis(namex, this.zoom_origin[idx]), this.revertAxis(namex, this.zoom_curr[idx]));
            xmax = Math.max(this.revertAxis(namex, this.zoom_origin[idx]), this.revertAxis(namex, this.zoom_curr[idx]));
            isany = true;
         }

         if (changed[idy] && (Math.abs(this.zoom_curr[idy] - this.zoom_origin[idy]) > 10)) {
            if (this.zoom_second && (this.zoom_kind == 3)) namey = 'y2';
            ymin = Math.min(this.revertAxis(namey, this.zoom_origin[idy]), this.revertAxis(namey, this.zoom_curr[idy]));
            ymax = Math.max(this.revertAxis(namey, this.zoom_origin[idy]), this.revertAxis(namey, this.zoom_curr[idy]));
            isany = true;
         }

         if (namex == 'x2') {
            this.zoomChangedInteractive(namex, true);
            this.zoomSingle(namex, xmin, xmax);
            kind = 0;
         } else if (namey == 'y2') {
            this.zoomChangedInteractive(namey, true);
            this.zoomSingle(namey, ymin, ymax);
            kind = 0;
         } else if (isany) {
            this.zoomChangedInteractive('x', true);
            this.zoomChangedInteractive('y', true);
            this.zoom(xmin, xmax, ymin, ymax);
            kind = 0;
         }
      }

      let pnt = (kind===1) ? { x: this.zoom_origin[0], y: this.zoom_origin[1] } : null;

      this.clearInteractiveElements();

      // if no zooming was done, select active object instead
      switch (kind) {
         case 1:
            this.processFrameClick(pnt);
            break;
         case 2:
            this.getPadPainter()?.selectObjectPainter(this, null, 'xaxis');
            break;
         case 3:
            this.getPadPainter()?.selectObjectPainter(this, null, 'yaxis');
            break;
      }

   },

   /** @summary Handle mouse double click on frame */
   mouseDoubleClick(evnt) {
      evnt.preventDefault();
      let m = pointer(evnt, this.getFrameSvg().node()),
          fw = this.getFrameWidth(), fh = this.getFrameHeight();
      this.clearInteractiveElements();

      let valid_x = (m[0] >= 0) && (m[0] <= fw),
          valid_y = (m[1] >= 0) && (m[1] <= fh);

      if (valid_x && valid_y && this._dblclick_handler)
         if (this.processFrameClick({ x: m[0], y: m[1] }, true)) return;

      let kind = (this.can_zoom_x ? 'x' : '') + (this.can_zoom_y ? 'y' : '') + 'z';
      if (!valid_x) {
         if (!this.can_zoom_y) return;
         kind = this.swap_xy ? 'x' : 'y';
         if ((m[0] > fw) && this[kind+'2_handle']) kind += '2'; // let unzoom second axis
      } else if (!valid_y) {
         if (!this.can_zoom_x) return;
         kind = this.swap_xy ? 'y' : 'x';
         if ((m[1] < 0) && this[kind+'2_handle']) kind += '2'; // let unzoom second axis
      }
      this.unzoom(kind).then(changed => {
         if (changed) return;
         let pp = this.getPadPainter(), rect = this.getFrameRect();
         if (pp) pp.selectObjectPainter(pp, { x: m[0] + rect.x, y: m[1] + rect.y, dbl: true });
      });
   },

   /** @summary Start touch zoom */
   startTouchZoom(evnt) {
      // in case when zooming was started, block any other kind of events
      // also prevent zooming together with active drggaing
      if ((this.zoom_kind != 0) || drag_kind) {
         evnt.preventDefault();
         evnt.stopPropagation();
         return;
      }

      let arr = pointers(evnt, this.getFrameSvg().node());
      this.touch_cnt+=1;

      // normally double-touch will be handled
      // touch with single click used for context menu
      if (arr.length == 1) {
         // this is touch with single element

         let now = new Date(), diff = now.getTime() - this.last_touch.getTime();
         this.last_touch = now;

         if ((diff < 300) && this.zoom_curr
             && (Math.abs(this.zoom_curr[0] - arr[0][0]) < 30)
             && (Math.abs(this.zoom_curr[1] - arr[0][1]) < 30)) {

            evnt.preventDefault();
            evnt.stopPropagation();

            this.clearInteractiveElements();
            this.unzoom('xyz');

            this.last_touch = new Date(0);

            this.getFrameSvg().on('touchcancel', null)
                              .on('touchend', null, true);
         } else if (settings.ContextMenu) {
            this.zoom_curr = arr[0];
            this.getFrameSvg().on('touchcancel', this.endTouchSel.bind(this))
                              .on('touchend', this.endTouchSel.bind(this));
            evnt.preventDefault();
            evnt.stopPropagation();
         }
      }

      if ((arr.length != 2) || !settings.Zooming || !settings.ZoomTouch) return;

      evnt.preventDefault();
      evnt.stopPropagation();

      this.clearInteractiveElements();

      this.getFrameSvg().on('touchcancel', null)
                        .on('touchend', null);

      let pnt1 = arr[0], pnt2 = arr[1], w = this.getFrameWidth(), h = this.getFrameHeight();

      this.zoom_curr = [ Math.min(pnt1[0], pnt2[0]), Math.min(pnt1[1], pnt2[1]) ];
      this.zoom_origin = [ Math.max(pnt1[0], pnt2[0]), Math.max(pnt1[1], pnt2[1]) ];
      this.zoom_second = false;

      if ((this.zoom_curr[0] < 0) || (this.zoom_curr[0] > w)) {
         this.zoom_second = (this.zoom_curr[0] > w) && this.y2_handle;
         this.zoom_kind = 103; // only y
         this.zoom_curr[0] = 0;
         this.zoom_origin[0] = w;
      } else if ((this.zoom_origin[1] > h) || (this.zoom_origin[1] < 0)) {
         this.zoom_second = (this.zoom_origin[1] < 0) && this.x2_handle;
         this.zoom_kind = 102; // only x
         this.zoom_curr[1] = 0;
         this.zoom_origin[1] = h;
      } else {
         this.zoom_kind = 101; // x and y
      }

      drag_kind = 'zoom'; // block other possible dragging

      setPainterTooltipEnabled(this, false);

      this.zoom_rect = this.getFrameSvg().append('rect')
            .attr('class', 'zoom')
            .attr('id', 'zoomRect')
            .attr('x', this.zoom_curr[0])
            .attr('y', this.zoom_curr[1])
            .attr('width', this.zoom_origin[0] - this.zoom_curr[0])
            .attr('height', this.zoom_origin[1] - this.zoom_curr[1]);

      select(window).on('touchmove.zoomRect', this.moveTouchZoom.bind(this))
                       .on('touchcancel.zoomRect', this.endTouchZoom.bind(this))
                       .on('touchend.zoomRect', this.endTouchZoom.bind(this));
   },

   /** @summary Move touch zooming */
   moveTouchZoom(evnt) {
      if (this.zoom_kind < 100) return;

      evnt.preventDefault();

      let arr = pointers(evnt, this.getFrameSvg().node());

      if (arr.length != 2)
         return this.clearInteractiveElements();

      let pnt1 = arr[0], pnt2 = arr[1];

      if (this.zoom_kind != 103) {
         this.zoom_curr[0] = Math.min(pnt1[0], pnt2[0]);
         this.zoom_origin[0] = Math.max(pnt1[0], pnt2[0]);
      }
      if (this.zoom_kind != 102) {
         this.zoom_curr[1] = Math.min(pnt1[1], pnt2[1]);
         this.zoom_origin[1] = Math.max(pnt1[1], pnt2[1]);
      }

      this.zoom_rect.attr('x', this.zoom_curr[0])
                     .attr('y', this.zoom_curr[1])
                     .attr('width', this.zoom_origin[0] - this.zoom_curr[0])
                     .attr('height', this.zoom_origin[1] - this.zoom_curr[1]);

      if ((this.zoom_origin[0] - this.zoom_curr[0] > 10)
           || (this.zoom_origin[1] - this.zoom_curr[1] > 10))
         setPainterTooltipEnabled(this, false);

      evnt.stopPropagation();
   },

   /** @summary End touch zooming handler */
   endTouchZoom(evnt) {

      this.getFrameSvg().on('touchcancel', null)
                        .on('touchend', null);

      if (this.zoom_kind === 0) {
         // special case - single touch can ends up with context menu

         evnt.preventDefault();

         let now = new Date();

         let diff = now.getTime() - this.last_touch.getTime();

         if ((diff > 500) && (diff < 2000) && !this.isTooltipShown()) {
            this.showContextMenu('main', { clientX: this.zoom_curr[0], clientY: this.zoom_curr[1] });
            this.last_touch = new Date(0);
         } else {
            this.clearInteractiveElements();
         }
      }

      if (this.zoom_kind < 100) return;

      drag_kind = ''; // reset global flag

      evnt.preventDefault();
      select(window).on('touchmove.zoomRect', null)
                       .on('touchend.zoomRect', null)
                       .on('touchcancel.zoomRect', null);

      let xmin, xmax, ymin, ymax, isany = false,
          xid = this.swap_xy ? 1 : 0, yid = 1 - xid,
          changed = [true, true], namex = 'x', namey = 'y';

      if (this.zoom_kind === 102) changed[1] = false;
      if (this.zoom_kind === 103) changed[0] = false;

      if (changed[xid] && (Math.abs(this.zoom_curr[xid] - this.zoom_origin[xid]) > 10)) {
         if (this.zoom_second && (this.zoom_kind == 102)) namex = 'x2';
         xmin = Math.min(this.revertAxis(namex, this.zoom_origin[xid]), this.revertAxis(namex, this.zoom_curr[xid]));
         xmax = Math.max(this.revertAxis(namex, this.zoom_origin[xid]), this.revertAxis(namex, this.zoom_curr[xid]));
         isany = true;
      }

      if (changed[yid] && (Math.abs(this.zoom_curr[yid] - this.zoom_origin[yid]) > 10)) {
         if (this.zoom_second && (this.zoom_kind == 103)) namey = 'y2';
         ymin = Math.min(this.revertAxis(namey, this.zoom_origin[yid]), this.revertAxis(namey, this.zoom_curr[yid]));
         ymax = Math.max(this.revertAxis(namey, this.zoom_origin[yid]), this.revertAxis(namey, this.zoom_curr[yid]));
         isany = true;
      }

      this.clearInteractiveElements();
      this.last_touch = new Date(0);

      if (namex == 'x2') {
         this.zoomChangedInteractive(namex, true);
         this.zoomSingle(namex, xmin, xmax);
      } else if (namey == 'y2') {
         this.zoomChangedInteractive(namey, true);
         this.zoomSingle(namey, ymin, ymax);
      } else if (isany) {
         this.zoomChangedInteractive('x', true);
         this.zoomChangedInteractive('y', true);
         this.zoom(xmin, xmax, ymin, ymax);
      }

      evnt.stopPropagation();
   },

   /** @summary Analyze zooming with mouse wheel */
   analyzeMouseWheelEvent(event, item, dmin, test_ignore, second_side) {
      // if there is second handle, use it
      let handle2 = second_side ? this[item.name + '2_handle'] : null;
      if (handle2) {
         item.second = Object.assign({}, item);
         return handle2.analyzeWheelEvent(event, dmin, item.second, test_ignore);
      }
      let handle = this[item.name + '_handle'];
      if (handle) return handle.analyzeWheelEvent(event, dmin, item, test_ignore);
      console.error(`Fail to analyze zooming event for ${item.name}`);
   },

    /** @summary return true if default Y zooming should be enabled
      * @desc it is typically for 2-Dim histograms or
      * when histogram not draw, defined by other painters */
   isAllowedDefaultYZooming() {

      if (this.self_drawaxes) return true;

      let pad_painter = this.getPadPainter();
      if (pad_painter?.painters)
         for (let k = 0; k < pad_painter.painters.length; ++k) {
            let subpainter = pad_painter.painters[k];
            if (subpainter?.wheel_zoomy !== undefined)
               return subpainter.wheel_zoomy;
         }

      return false;
   },

   /** @summary Handles mouse wheel event */
   mouseWheel(evnt) {
      evnt.stopPropagation();
      evnt.preventDefault();
      this.clearInteractiveElements();

      let itemx = { name: 'x', reverse: this.reverse_x },
          itemy = { name: 'y', reverse: this.reverse_y, ignore: !this.isAllowedDefaultYZooming() },
          cur = pointer(evnt, this.getFrameSvg().node()),
          w = this.getFrameWidth(), h = this.getFrameHeight();

      if (this.can_zoom_x)
         this.analyzeMouseWheelEvent(evnt, this.swap_xy ? itemy : itemx, cur[0] / w, (cur[1]  >= 0) && (cur[1] <= h), cur[1] < 0);

      if (this.can_zoom_y)
         this.analyzeMouseWheelEvent(evnt, this.swap_xy ? itemx : itemy, 1 - cur[1] / h, (cur[0] >= 0) && (cur[0] <= w), cur[0] > w);

      this.zoom(itemx.min, itemx.max, itemy.min, itemy.max);

      if (itemx.changed) this.zoomChangedInteractive('x', true);
      if (itemy.changed) this.zoomChangedInteractive('y', true);

      if (itemx.second) {
         this.zoomSingle('x2', itemx.second.min, itemx.second.max);
         if (itemx.second.changed) this.zoomChangedInteractive('x2', true);
      }
      if (itemy.second) {
         this.zoomSingle('y2', itemy.second.min, itemy.second.max);
         if (itemy.second.changed) this.zoomChangedInteractive('y2', true);
      }
   },

   /** @summary Show frame context menu */
   showContextMenu(kind, evnt, obj) {
      // ignore context menu when touches zooming is ongoing
      if (('zoom_kind' in this) && (this.zoom_kind > 100)) return;

      let menu_painter = this, exec_painter = null, frame_corner = false, fp = null; // object used to show context menu

      if (evnt.stopPropagation) {
         evnt.preventDefault();
         evnt.stopPropagation(); // disable main context menu

         if ((kind == 'painter') && obj) {
            menu_painter = obj;
            kind = '';
         } else if (!kind) {
            let ms = pointer(evnt, this.getFrameSvg().node()),
                tch = pointers(evnt, this.getFrameSvg().node()),
                pp = this.getPadPainter(),
                pnt = null, sel = null;

            fp = this;

            if (tch.length === 1)
               pnt = { x: tch[0][0], y: tch[0][1], touch: true };
            else if (ms.length === 2)
               pnt = { x: ms[0], y: ms[1], touch: false };

            if (pnt && pp) {
               pnt.painters = true; // assign painter for every tooltip
               let hints = pp.processPadTooltipEvent(pnt), bestdist = 1000;
               for (let n = 0; n < hints.length; ++n)
                  if (hints[n] && hints[n].menu) {
                     let dist = ('menu_dist' in hints[n]) ? hints[n].menu_dist : 7;
                     if (dist < bestdist) { sel = hints[n].painter; bestdist = dist; }
                  }
            }

            if (sel) menu_painter = sel; else kind = 'frame';

            if (pnt) frame_corner = (pnt.x > 0) && (pnt.x < 20) && (pnt.y > 0) && (pnt.y < 20);

            fp.setLastEventPos(pnt);
         } else if ((kind == 'x') || (kind == 'y') || (kind == 'z')) {
            exec_painter = this.getMainPainter(true); // histogram painter delivers items for axis menu

            if (this.v7_frame && isFunc(exec_painter?.v7EvalAttr))
               exec_painter = null;
         }
      } else if ((kind == 'painter') && obj) {
         // this is used in 3D context menu to show special painter
         menu_painter = obj;
         kind = '';
      }

      if (!exec_painter) exec_painter = menu_painter;

      if (!isFunc(menu_painter?.fillContextMenu)) return;

      this.clearInteractiveElements();

      createMenu$1(evnt, menu_painter).then(menu => {

         let domenu = menu.painter.fillContextMenu(menu, kind, obj);

         // fill frame menu by default - or append frame elements when activated in the frame corner
         if (fp && (!domenu || (frame_corner && (kind !== 'frame'))))
            domenu = fp.fillContextMenu(menu);

         if (domenu)
            exec_painter.fillObjectExecMenu(menu, kind).then(menu => {
                // suppress any running zooming
                setPainterTooltipEnabled(menu.painter, false);
                menu.show().then(() => setPainterTooltipEnabled(menu.painter, true));
            });
      });
   },

  /** @summary Activate context menu handler via touch events
    * @private */
   startTouchMenu(kind, evnt) {
      let arr = pointers(evnt, this.getFrameSvg().node());
      if (arr.length != 1) return;

      if (!kind) kind = 'main';
      let fld = 'touch_' + kind;

      evnt.sourceEvent.preventDefault();
      evnt.sourceEvent.stopPropagation();

      this[fld] = { dt: new Date(), pos: arr[0] };

      let handler = this.endTouchMenu.bind(this, kind);

      this.getFrameSvg().on('touchcancel', handler)
                        .on('touchend', handler);
   },

   /** @summary Process end-touch event, which can cause content menu to appear
    * @private */
   endTouchMenu(kind, evnt) {
      let fld = 'touch_' + kind;

      if (! (fld in this)) return;

      evnt.sourceEvent.preventDefault();
      evnt.sourceEvent.stopPropagation();

      let diff = new Date().getTime() - this[fld].dt.getTime();

      this.getFrameSvg().on('touchcancel', null)
                        .on('touchend', null);

      if (diff > 500) {
         let rect = this.getFrameSvg().node().getBoundingClientRect();
         this.showContextMenu(kind, { clientX: rect.left + this[fld].pos[0],
                                      clientY: rect.top + this[fld].pos[1] });
      }

      delete this[fld];
   },

   /** @summary Clear frame interactive elements */
   clearInteractiveElements() {
      closeMenu();
      this.zoom_kind = 0;
      if (this.zoom_rect) { this.zoom_rect.remove(); delete this.zoom_rect; }
      delete this.zoom_curr;
      delete this.zoom_origin;
      delete this.zoom_lastpos;
      delete this.zoom_labels;

      // enable tooltip in frame painter
      setPainterTooltipEnabled(this, true);
   },

   /** @summary Assign frame interactive methods */
   assign(painter) {
      Object.assign(painter, this);
   }

}; // FrameInterative



/**
 * @summary Painter class for TFrame, main handler for interactivity
 * @private
 */

class TFramePainter extends ObjectPainter {

   /** @summary constructor
     * @param {object|string} dom - DOM element for drawing or element id
     * @param {object} tframe - TFrame object */
   constructor(dom, tframe) {
      super(dom, (tframe && tframe.$dummy) ? null : tframe);
      this.zoom_kind = 0;
      this.mode3d = false;
      this.shrink_frame_left = 0.;
      this.xmin = this.xmax = 0; // no scale specified, wait for objects drawing
      this.ymin = this.ymax = 0; // no scale specified, wait for objects drawing
      this.ranges_set = false;
      this.axes_drawn = false;
      this.keys_handler = null;
      this.projection = 0; // different projections
   }

   /** @summary Returns frame painter - object itself */
   getFramePainter() { return this; }

   /** @summary Returns true if it is ROOT6 frame
     * @private */
   is_root6() { return true; }

   /** @summary Returns frame or sub-objects, used in GED editor */
   getObject(place) {
      if (place === 'xaxis') return this.xaxis;
      if (place === 'yaxis') return this.yaxis;
      return super.getObject();
   }

   /** @summary Set active flag for frame - can block some events
     * @private */
   setFrameActive(on) {
      this.enabledKeys = on && settings.HandleKeys ? true : false;
      // used only in 3D mode where control is used
      if (this.control)
         this.control.enableKeys = this.enabledKeys;
   }

   /** @summary Shrink frame size
     * @private */
   shrinkFrame(shrink_left, shrink_right) {
      this.fX1NDC += shrink_left;
      this.fX2NDC -= shrink_right;
   }

   /** @summary Set position of last context menu event */
   setLastEventPos(pnt) {
      this.fLastEventPnt = pnt;
   }

   /** @summary Return position of last event
     * @private */
   getLastEventPos() { return this.fLastEventPnt; }

   /** @summary Returns coordinates transformation func */
   getProjectionFunc() {
      switch (this.projection) {
         // Aitoff2xy
         case 1: return (l, b) => {
            const DegToRad = Math.PI/180,
                  alpha2 = (l/2)*DegToRad,
                  delta  = b*DegToRad,
                  r2     = Math.sqrt(2),
                  f      = 2*r2/Math.PI,
                  cdec   = Math.cos(delta),
                  denom  = Math.sqrt(1. + cdec*Math.cos(alpha2));
            return {
               x: cdec*Math.sin(alpha2)*2.*r2/denom/f/DegToRad,
               y: Math.sin(delta)*r2/denom/f/DegToRad
            };
         };
         // mercator
         case 2: return (l, b) => { return { x: l, y: Math.log(Math.tan((Math.PI/2 + b/180*Math.PI)/2)) }; };
         // sinusoidal
         case 3: return (l, b) => { return { x: l*Math.cos(b/180*Math.PI), y: b } };
         // parabolic
         case 4: return (l, b) => { return { x: l*(2.*Math.cos(2*b/180*Math.PI/3) - 1), y: 180*Math.sin(b/180*Math.PI/3) }; };
      }
   }

   /** @summary Rcalculate frame ranges using specified projection functions */
   recalculateRange(Proj) {
      this.projection = Proj || 0;

      if ((this.projection == 2) && ((this.scale_ymin <= -90 || this.scale_ymax >=90))) {
         console.warn(`Mercator Projection: Latitude out of range ${this.scale_ymin} ${this.scale_ymax}`);
         this.projection = 0;
      }

      let func = this.getProjectionFunc();
      if (!func) return;

      let pnts = [ func(this.scale_xmin, this.scale_ymin),
                   func(this.scale_xmin, this.scale_ymax),
                   func(this.scale_xmax, this.scale_ymax),
                   func(this.scale_xmax, this.scale_ymin) ];
      if (this.scale_xmin < 0 && this.scale_xmax > 0) {
         pnts.push(func(0, this.scale_ymin));
         pnts.push(func(0, this.scale_ymax));
      }
      if (this.scale_ymin < 0 && this.scale_ymax > 0) {
         pnts.push(func(this.scale_xmin, 0));
         pnts.push(func(this.scale_xmax, 0));
      }

      this.original_xmin = this.scale_xmin;
      this.original_xmax = this.scale_xmax;
      this.original_ymin = this.scale_ymin;
      this.original_ymax = this.scale_ymax;

      this.scale_xmin = this.scale_xmax = pnts[0].x;
      this.scale_ymin = this.scale_ymax = pnts[0].y;

      for (let n = 1; n < pnts.length; ++n) {
         this.scale_xmin = Math.min(this.scale_xmin, pnts[n].x);
         this.scale_xmax = Math.max(this.scale_xmax, pnts[n].x);
         this.scale_ymin = Math.min(this.scale_ymin, pnts[n].y);
         this.scale_ymax = Math.max(this.scale_ymax, pnts[n].y);
      }
   }

   /** @summary Configure frame axes ranges */
   setAxesRanges(xaxis, xmin, xmax, yaxis, ymin, ymax, zaxis, zmin, zmax, hpainter) {
      this.ranges_set = true;

      this.xaxis = xaxis;
      this.xmin = xmin;
      this.xmax = xmax;

      this.yaxis = yaxis;
      this.ymin = ymin;
      this.ymax = ymax;

      this.zaxis = zaxis;
      this.zmin = zmin;
      this.zmax = zmax;

      if (hpainter?.check_pad_range) {
         delete hpainter.check_pad_range;
         let ndim = hpainter.getDimension();
         this.applyAxisZoom('x');
         if (ndim > 1)
            this.applyAxisZoom('y');
         if (ndim > 2)
            this.applyAxisZoom('z');
      }

      if (hpainter && !hpainter._checked_zooming) {
         hpainter._checked_zooming = true;

         if (hpainter.options.minimum !== kNoZoom) {
            this.zoom_zmin = hpainter.options.minimum;
            this.zoom_zmax = this.zmax;
         }
         if (hpainter.options.maximum !== kNoZoom) {
            this.zoom_zmax = hpainter.options.maximum;
            if (this.zoom_zmin === undefined) this.zoom_zmin = this.zmin;
         }
      }

   }

   /** @summary Configure secondary frame axes ranges */
   setAxes2Ranges(second_x, xaxis, xmin, xmax, second_y, yaxis, ymin, ymax) {
      if (second_x) {
         this.x2axis = xaxis;
         this.x2min = xmin;
         this.x2max = xmax;
      }
      if (second_y) {
         this.y2axis = yaxis;
         this.y2min = ymin;
         this.y2max = ymax;
      }
   }

   /** @summary Retuns associated axis object */
   getAxis(name) {
      switch(name) {
         case 'x': return this.xaxis;
         case 'y': return this.yaxis;
         case 'z': return this.zaxis;
         case 'x2': return this.x2axis;
         case 'y2': return this.y2axis;
      }
      return null;
   }

   /** @summary Apply axis zooming from pad user range
     * @private */
   applyPadUserRange(pad, name) {
      if (!pad) return;

      // seems to be, not allways user range calculated
      let umin = pad[`fU${name}min`],
          umax = pad[`fU${name}max`],
          eps = 1e-7;

      if (name == 'x') {
         if ((Math.abs(pad.fX1) > eps) || (Math.abs(pad.fX2 - 1) > eps)) {
            let dx = pad.fX2 - pad.fX1;
            umin = pad.fX1 + dx*pad.fLeftMargin;
            umax = pad.fX2 - dx*pad.fRightMargin;
         }
      } else {
         if ((Math.abs(pad.fY1) > eps) || (Math.abs(pad.fY2 - 1) > eps)) {
            let dy = pad.fY2 - pad.fY1;
            umin = pad.fY1 + dy*pad.fBottomMargin;
            umax = pad.fY2 - dy*pad.fTopMargin;
         }
      }

      if ((umin >= umax) || (Math.abs(umin) < eps && Math.abs(umax-1) < eps)) return;

      if (pad[`fLog${name}`] > 0) {
         umin = Math.exp(umin * Math.log(10));
         umax = Math.exp(umax * Math.log(10));
      }

      let aname = name;
      if (this.swap_xy) aname = (name == 'x') ? 'y' : 'x';
      let smin = `scale_${aname}min`,
          smax = `scale_${aname}max`;

      eps = (this[smax] - this[smin]) * 1e-7;

      if ((Math.abs(umin - this[smin]) > eps) || (Math.abs(umax - this[smax]) > eps)) {
         this[`zoom_${aname}min`] = umin;
         this[`zoom_${aname}max`] = umax;
      }
   }

   /** @summary Apply zooming from TAxis attributes */
   applyAxisZoom(name) {
      if (this.zoomChangedInteractive(name)) return;
      this[`zoom_${name}min`] = this[`zoom_${name}max`] = 0;

      const axis = this.getAxis(name);

      if (axis?.TestBit(EAxisBits.kAxisRange)) {
         if ((axis.fFirst !== axis.fLast) && ((axis.fFirst > 1) || (axis.fLast < axis.fNbins))) {
            this[`zoom_${name}min`] = axis.fFirst > 1 ? axis.GetBinLowEdge(axis.fFirst) : axis.fXmin;
            this[`zoom_${name}max`] = axis.fLast < axis.fNbins ? axis.GetBinLowEdge(axis.fLast + 1) : axis.fXmax;
            // reset user range for main painter
            axis.InvertBit(EAxisBits.kAxisRange);
            axis.fFirst = 1; axis.fLast = axis.fNbins;
         }
      }
   }

   /** @summary Create x,y objects which maps user coordinates into pixels
     * @desc While only first painter really need such object, all others just reuse it
     * following functions are introduced
     *    this.GetBin[X/Y]  return bin coordinate
     *    this.[x,y]  these are d3.scale objects
     *    this.gr[x,y]  converts root scale into graphical value
     * @private */
   createXY(opts) {
      this.cleanXY(); // remove all previous configurations

      if (!opts) opts = { ndim: 1 };

      this.swap_xy = opts.swap_xy || false;
      this.reverse_x = opts.reverse_x || false;
      this.reverse_y = opts.reverse_y || false;

      this.logx = this.logy = 0;

      let w = this.getFrameWidth(), h = this.getFrameHeight(),
          pp = this.getPadPainter(),
          pad = pp.getRootPad();

      this.scale_xmin = this.xmin;
      this.scale_xmax = this.xmax;

      this.scale_ymin = this.ymin;
      this.scale_ymax = this.ymax;

      if (opts.extra_y_space) {
         let log_scale = this.swap_xy ? pad.fLogx : pad.fLogy;
         if (log_scale && (this.scale_ymax > 0))
            this.scale_ymax = Math.exp(Math.log(this.scale_ymax)*1.1);
         else
            this.scale_ymax += (this.scale_ymax - this.scale_ymin)*0.1;
      }

      if (opts.check_pad_range) {
         // take zooming out of pad or axis attributes
         this.applyAxisZoom('x');
         if (opts.ndim > 1) this.applyAxisZoom('y');
         if (opts.ndim > 2) this.applyAxisZoom('z');

         if (opts.check_pad_range === 'pad_range') {
            let canp = this.getCanvPainter();
            // ignore range set in the online canvas
            if (!canp || !canp.online_canvas) {
               this.applyPadUserRange(pad, 'x');
               this.applyPadUserRange(pad, 'y');
            }
         }
      }

      if ((opts.zoom_ymin != opts.zoom_ymax) && (this.zoom_ymin == this.zoom_ymax) && !this.zoomChangedInteractive('y')) {
         this.zoom_ymin = opts.zoom_ymin;
         this.zoom_ymax = opts.zoom_ymax;
      }

      if (this.zoom_xmin != this.zoom_xmax) {
         this.scale_xmin = this.zoom_xmin;
         this.scale_xmax = this.zoom_xmax;
      }

      if (this.zoom_ymin != this.zoom_ymax) {
         this.scale_ymin = this.zoom_ymin;
         this.scale_ymax = this.zoom_ymax;
      }

      // projection should be assigned
      this.recalculateRange(opts.Proj);

      this.x_handle = new TAxisPainter(this.getDom(), this.xaxis, true);
      this.x_handle.setPadName(this.getPadName());
      this.x_handle.setHistPainter(opts.hist_painter, 'x');

      this.x_handle.configureAxis('xaxis', this.xmin, this.xmax, this.scale_xmin, this.scale_xmax, this.swap_xy, this.swap_xy ? [0,h] : [0,w],
                                      { reverse: this.reverse_x,
                                        log: this.swap_xy ? pad.fLogy : pad.fLogx,
                                        symlog: this.swap_xy ? opts.symlog_y : opts.symlog_x,
                                        logcheckmin: this.swap_xy,
                                        logminfactor: 0.0001 });

      this.x_handle.assignFrameMembers(this, 'x');

      this.y_handle = new TAxisPainter(this.getDom(), this.yaxis, true);
      this.y_handle.setPadName(this.getPadName());
      this.y_handle.setHistPainter(opts.hist_painter, 'y');

      this.y_handle.configureAxis('yaxis', this.ymin, this.ymax, this.scale_ymin, this.scale_ymax, !this.swap_xy, this.swap_xy ? [0,w] : [0,h],
                                      { reverse: this.reverse_y,
                                        log: this.swap_xy ? pad.fLogx : pad.fLogy,
                                        symlog: this.swap_xy ? opts.symlog_x : opts.symlog_y,
                                        logcheckmin: (opts.ndim < 2) || this.swap_xy,
                                        log_min_nz: opts.ymin_nz && (opts.ymin_nz < 0.01*this.ymax) ? 0.3 * opts.ymin_nz : 0,
                                        logminfactor: 3e-4 });

      this.y_handle.assignFrameMembers(this, 'y');

      this.setRootPadRange(pad);
   }

   /** @summary Create x,y objects for drawing of second axes
     * @private */
   createXY2(opts) {

      if (!opts) opts = {};

      this.reverse_x2 = opts.reverse_x || false;
      this.reverse_y2 = opts.reverse_y || false;

      this.logx2 = this.logy2 = 0;

      let w = this.getFrameWidth(), h = this.getFrameHeight(),
          pp = this.getPadPainter(),
          pad = pp.getRootPad();

      if (opts.second_x) {
         this.scale_x2min = this.x2min;
         this.scale_x2max = this.x2max;
      }

      if (opts.second_y) {
         this.scale_y2min = this.y2min;
         this.scale_y2max = this.y2max;
      }

      if (opts.extra_y_space && opts.second_y) {
         let log_scale = this.swap_xy ? pad.fLogx : pad.fLogy;
         if (log_scale && (this.scale_y2max > 0))
            this.scale_y2max = Math.exp(Math.log(this.scale_y2max)*1.1);
         else
            this.scale_y2max += (this.scale_y2max - this.scale_y2min)*0.1;
      }

      if ((this.zoom_x2min != this.zoom_x2max) && opts.second_x) {
         this.scale_x2min = this.zoom_x2min;
         this.scale_x2max = this.zoom_x2max;
      }

      if ((this.zoom_y2min != this.zoom_y2max) && opts.second_y) {
         this.scale_y2min = this.zoom_y2min;
         this.scale_y2max = this.zoom_y2max;
      }

      if (opts.second_x) {
         this.x2_handle = new TAxisPainter(this.getDom(), this.x2axis, true);
         this.x2_handle.setPadName(this.getPadName());
         this.x2_handle.setHistPainter(opts.hist_painter, 'x');

         this.x2_handle.configureAxis('x2axis', this.x2min, this.x2max, this.scale_x2min, this.scale_x2max, this.swap_xy, this.swap_xy ? [0,h] : [0,w],
                                         { reverse: this.reverse_x2,
                                           log: this.swap_xy ? pad.fLogy : pad.fLogx,
                                           logcheckmin: this.swap_xy,
                                           logminfactor: 0.0001 });
         this.x2_handle.assignFrameMembers(this,'x2');
      }

      if (opts.second_y) {
         this.y2_handle = new TAxisPainter(this.getDom(), this.y2axis, true);
         this.y2_handle.setPadName(this.getPadName());
         this.y2_handle.setHistPainter(opts.hist_painter, 'y');

         this.y2_handle.configureAxis('y2axis', this.y2min, this.y2max, this.scale_y2min, this.scale_y2max, !this.swap_xy, this.swap_xy ? [0,w] : [0,h],
                                         { reverse: this.reverse_y2,
                                           log: this.swap_xy ? pad.fLogx : pad.fLogy,
                                           logcheckmin: (opts.ndim < 2) || this.swap_xy,
                                           log_min_nz: opts.ymin_nz && (opts.ymin_nz < 0.01*this.y2max) ? 0.3 * opts.ymin_nz : 0,
                                           logminfactor: 3e-4 });

         this.y2_handle.assignFrameMembers(this,'y2');
      }
   }

   /** @summary Return functions to create x/y points based on coordinates
     * @desc In default case returns frame painter itself
     * @private */
   getGrFuncs(second_x, second_y) {
      let use_x2 = second_x && this.grx2,
          use_y2 = second_y && this.gry2;
      if (!use_x2 && !use_y2) return this;

      return {
         use_x2: use_x2,
         grx: use_x2 ? this.grx2 : this.grx,
         logx: this.logx,
         x_handle: use_x2 ? this.x2_handle : this.x_handle,
         scale_xmin: use_x2 ? this.scale_x2min : this.scale_xmin,
         scale_xmax: use_x2 ? this.scale_x2max : this.scale_xmax,
         use_y2: use_y2,
         gry: use_y2 ? this.gry2 : this.gry,
         logy: this.logy,
         y_handle: use_y2 ? this.y2_handle : this.y_handle,
         scale_ymin: use_y2 ? this.scale_y2min : this.scale_ymin,
         scale_ymax: use_y2 ? this.scale_y2max : this.scale_ymax,
         swap_xy: this.swap_xy,
         fp: this,
         revertAxis(name, v) {
            if ((name == 'x') && this.use_x2) name = 'x2';
            if ((name == 'y') && this.use_y2) name = 'y2';
            return this.fp.revertAxis(name, v);
         },
         axisAsText(name, v) {
            if ((name == 'x') && this.use_x2) name = 'x2';
            if ((name == 'y') && this.use_y2) name = 'y2';
            return this.fp.axisAsText(name, v);
         }
      };
   }

   /** @summary Set selected range back to TPad object
     * @private */
   setRootPadRange(pad, is3d) {
      if (!pad || !this.ranges_set) return;

      if (is3d) {
         // this is fake values, algorithm should be copied from TView3D class of ROOT
         // pad.fLogx = pad.fLogy = 0;
         pad.fUxmin = pad.fUymin = -0.9;
         pad.fUxmax = pad.fUymax = 0.9;
      } else {
         pad.fLogx = this.swap_xy ? this.logy : this.logx;
         pad.fUxmin = pad.fLogx ? Math.log10(this.scale_xmin) : this.scale_xmin;
         pad.fUxmax = pad.fLogx ? Math.log10(this.scale_xmax) : this.scale_xmax;
         pad.fLogy = this.swap_xy ? this.logx : this.logy;
         pad.fUymin = pad.fLogy ? Math.log10(this.scale_ymin) : this.scale_ymin;
         pad.fUymax = pad.fLogy ? Math.log10(this.scale_ymax) : this.scale_ymax;
      }

      let rx = pad.fUxmax - pad.fUxmin,
          mx = 1 - pad.fLeftMargin - pad.fRightMargin,
          ry = pad.fUymax - pad.fUymin,
          my = 1 - pad.fBottomMargin - pad.fTopMargin;

      if (mx <= 0) mx = 0.01; // to prevent overflow
      if (my <= 0) my = 0.01;

      pad.fX1 = pad.fUxmin - rx/mx*pad.fLeftMargin;
      pad.fX2 = pad.fUxmax + rx/mx*pad.fRightMargin;
      pad.fY1 = pad.fUymin - ry/my*pad.fBottomMargin;
      pad.fY2 = pad.fUymax + ry/my*pad.fTopMargin;
   }


   /** @summary Draw axes grids
     * @desc Called immediately after axes drawing */
   drawGrids() {

      let layer = this.getFrameSvg().select('.grid_layer');

      layer.selectAll('.xgrid').remove();
      layer.selectAll('.ygrid').remove();

      let pp = this.getPadPainter(),
          pad = pp?.getRootPad(true),
          h = this.getFrameHeight(),
          w = this.getFrameWidth(),
          grid_style = gStyle.fGridStyle;

      // add a grid on x axis, if the option is set
      if (pad?.fGridx && this.x_handle) {
         let gridx = '';
         for (let n = 0; n < this.x_handle.ticks.length; ++n)
            if (this.swap_xy)
               gridx += `M0,${this.x_handle.ticks[n]}h${w}`;
            else
               gridx += `M${this.x_handle.ticks[n]},0v${h}`;

         let colid = (gStyle.fGridColor > 0) ? gStyle.fGridColor : (this.getAxis('x') ? this.getAxis('x').fAxisColor : 1),
             grid_color = this.getColor(colid) || 'black';

         if (gridx)
           layer.append('svg:path')
                .attr('class', 'xgrid')
                .attr('d', gridx)
                .style('stroke', grid_color)
                .style('stroke-width', gStyle.fGridWidth)
                .style('stroke-dasharray', getSvgLineStyle(grid_style));
      }

      // add a grid on y axis, if the option is set
      if (pad?.fGridy && this.y_handle) {
         let gridy = '';
         for (let n = 0; n < this.y_handle.ticks.length; ++n)
            if (this.swap_xy)
               gridy += `M${this.y_handle.ticks[n]},0v${h}`;
            else
               gridy += `M0,${this.y_handle.ticks[n]}h${w}`;

         let colid = (gStyle.fGridColor > 0) ? gStyle.fGridColor : (this.getAxis('y') ? this.getAxis('y').fAxisColor : 1),
             grid_color = this.getColor(colid) || 'black';

         if (gridy)
           layer.append('svg:path')
                .attr('class', 'ygrid')
                .attr('d', gridy)
                .style('stroke', grid_color)
                .style('stroke-width',gStyle.fGridWidth)
                .style('stroke-dasharray', getSvgLineStyle(grid_style));
      }
   }

   /** @summary Converts 'raw' axis value into text */
   axisAsText(axis, value) {
      let handle = this[axis+'_handle'];

      if (handle)
         return handle.axisAsText(value, settings[axis.toUpperCase() + 'ValuesFormat']);

      return value.toPrecision(4);
   }

   /** @summary Identify if requested axes are drawn
     * @desc Checks if x/y axes are drawn. Also if second side is already there */
   hasDrawnAxes(second_x, second_y) {
      return !second_x && !second_y ? this.axes_drawn : false;
   }

   /** @summary draw axes,
     * @return {Promise} which ready when drawing is completed  */
   async drawAxes(shrink_forbidden, disable_x_draw, disable_y_draw,
                  AxisPos, has_x_obstacle, has_y_obstacle) {

      this.cleanAxesDrawings();

      if ((this.xmin == this.xmax) || (this.ymin == this.ymax))
         return false;

      if (AxisPos === undefined) AxisPos = 0;

      let layer = this.getFrameSvg().select('.axis_layer'),
          w = this.getFrameWidth(),
          h = this.getFrameHeight(),
          pp = this.getPadPainter(),
          pad = pp.getRootPad(true);

      this.x_handle.invert_side = (AxisPos >= 10);
      this.x_handle.lbls_both_sides = !this.x_handle.invert_side && pad && (pad.fTickx > 1); // labels on both sides
      this.x_handle.has_obstacle = has_x_obstacle;

      this.y_handle.invert_side = ((AxisPos % 10) === 1);
      this.y_handle.lbls_both_sides = !this.y_handle.invert_side && pad && (pad.fTicky > 1); // labels on both sides
      this.y_handle.has_obstacle = has_y_obstacle;

      let draw_horiz = this.swap_xy ? this.y_handle : this.x_handle,
          draw_vertical = this.swap_xy ? this.x_handle : this.y_handle;

      if ((!disable_x_draw || !disable_y_draw) && pp._fast_drawing)
         disable_x_draw = disable_y_draw = true;

      let pr = Promise.resolve(true);

      if (!disable_x_draw || !disable_y_draw) {

         let can_adjust_frame = !shrink_forbidden && settings.CanAdjustFrame;

         let pr1 = draw_horiz.drawAxis(layer, w, h,
                                       draw_horiz.invert_side ? undefined : `translate(0,${h})`,
                                       pad?.fTickx ? -h : 0, disable_x_draw,
                                       undefined, false);

         let pr2 = draw_vertical.drawAxis(layer, w, h,
                                          draw_vertical.invert_side ? `translate(${w})` : undefined,
                                          pad?.fTicky ? w : 0, disable_y_draw,
                                          draw_vertical.invert_side ? 0 : this._frame_x, can_adjust_frame);

         pr = Promise.all([pr1,pr2]).then(() => {

            this.drawGrids();

            if (!can_adjust_frame) return;

            let shrink = 0., ypos = draw_vertical.position;

            if ((-0.2 * w < ypos) && (ypos < 0)) {
               shrink = -ypos / w + 0.001;
               this.shrink_frame_left += shrink;
            } else if ((ypos > 0) && (ypos < 0.3 * w) && (this.shrink_frame_left > 0) && (ypos / w > this.shrink_frame_left)) {
               shrink = -this.shrink_frame_left;
               this.shrink_frame_left = 0.;
            }

            if (!shrink) return;

            this.shrinkFrame(shrink, 0);
            return this.redraw().then(() => this.drawAxes(true));
         });
      }

     return pr.then(() => {
        if (!shrink_forbidden)
           this.axes_drawn = true;
        return true;
     });
   }

   /** @summary draw second axes (if any)  */
   drawAxes2(second_x, second_y) {

      let layer = this.getFrameSvg().select('.axis_layer'),
          w = this.getFrameWidth(),
          h = this.getFrameHeight(),
          pp = this.getPadPainter(),
          pad = pp.getRootPad(true);

      if (second_x) {
         this.x2_handle.invert_side = true;
         this.x2_handle.lbls_both_sides = false;
         this.x2_handle.has_obstacle = false;
      }

      if (second_y) {
         this.y2_handle.invert_side = true;
         this.y2_handle.lbls_both_sides = false;
      }

      let draw_horiz = this.swap_xy ? this.y2_handle : this.x2_handle,
          draw_vertical = this.swap_xy ? this.x2_handle : this.y2_handle;

      if ((draw_horiz || draw_vertical) && pp._fast_drawing)
         draw_horiz = draw_vertical = null;

      let pr1, pr2;

      if (draw_horiz)
         pr1 = draw_horiz.drawAxis(layer, w, h,
                                   draw_horiz.invert_side ? undefined : `translate(0,${h})`,
                                   pad?.fTickx ? -h : 0, false,
                                   undefined, false);

      if (draw_vertical)
         pr2 = draw_vertical.drawAxis(layer, w, h,
                                      draw_vertical.invert_side ? `translate(${w})` : undefined,
                                      pad?.fTicky ? w : 0, false,
                                      draw_vertical.invert_side ? 0 : this._frame_x, false);

       return Promise.all([pr1, pr2]);
   }


   /** @summary Update frame attributes
     * @private */
   updateAttributes(force) {
      let pp = this.getPadPainter(),
          pad = pp?.getRootPad(true),
          tframe = this.getObject();

      if ((this.fX1NDC === undefined) || (force && !this.modified_NDC)) {
         if (!pad) {
            Object.assign(this, settings.FrameNDC);
         } else {
            Object.assign(this, {
               fX1NDC: pad.fLeftMargin,
               fX2NDC: 1 - pad.fRightMargin,
               fY1NDC: pad.fBottomMargin,
               fY2NDC: 1 - pad.fTopMargin
            });
         }
      }

      if (this.fillatt === undefined) {
         if (tframe)
            this.createAttFill({ attr: tframe });
         else if (pad && pad.fFrameFillColor)
            this.createAttFill({ pattern: pad.fFrameFillStyle, color: pad.fFrameFillColor });
         else if (pad)
            this.createAttFill({ attr: pad });
         else
            this.createAttFill({ pattern: 1001, color: 0 });

         // force white color for the canvas frame
         if (!tframe && this.fillatt.empty() && pp?.iscan)
            this.fillatt.setSolidColor('white');
         else if ((pad?.fFillStyle === 4000) && !this.fillatt.empty()) // special case of transpad.C macro, which set transparent pad
            this.fillatt.setOpacity(0);
      }

      if (!tframe && (pad?.fFrameLineColor !== undefined))
         this.createAttLine({ color: pad.fFrameLineColor, width: pad.fFrameLineWidth, style: pad.fFrameLineStyle });
      else
         this.createAttLine({ attr: tframe, color: 'black' });
   }

   /** @summary Function called at the end of resize of frame
     * @desc One should apply changes to the pad
     * @private */
   sizeChanged() {

      let pad = this.getPadPainter()?.getRootPad(true);

      if (pad) {
         pad.fLeftMargin = this.fX1NDC;
         pad.fRightMargin = 1 - this.fX2NDC;
         pad.fBottomMargin = this.fY1NDC;
         pad.fTopMargin = 1 - this.fY2NDC;
         this.setRootPadRange(pad);
      }

      this.interactiveRedraw('pad', 'frame');
   }

    /** @summary Remove all kinds of X/Y function for axes transformation */
   cleanXY() {
      delete this.grx;
      delete this.gry;
      delete this.grz;

      if (this.x_handle) {
         this.x_handle.cleanup();
         delete this.x_handle;
      }

      if (this.y_handle) {
         this.y_handle.cleanup();
         delete this.y_handle;
      }

      if (this.z_handle) {
         this.z_handle.cleanup();
         delete this.z_handle;
      }

      // these are drawing of second axes
      delete this.grx2;
      delete this.gry2;

      if (this.x2_handle) {
         this.x2_handle.cleanup();
         delete this.x2_handle;
      }

      if (this.y2_handle) {
         this.y2_handle.cleanup();
         delete this.y2_handle;
      }

   }

   /** @summary remove all axes drawings */
   cleanAxesDrawings() {
      if (this.x_handle) this.x_handle.removeG();
      if (this.y_handle) this.y_handle.removeG();
      if (this.z_handle) this.z_handle.removeG();
      if (this.x2_handle) this.x2_handle.removeG();
      if (this.y2_handle) this.y2_handle.removeG();

      let g = this.getG();
      if (g) {
         g.select('.grid_layer').selectAll('*').remove();
         g.select('.axis_layer').selectAll('*').remove();
      }
      this.axes_drawn = false;
   }

   /** @summary Returns frame rectangle plus extra info for hint display */
   cleanFrameDrawings() {

      // cleanup all 3D drawings if any
      if (isFunc(this.create3DScene))
         this.create3DScene(-1);

      this.cleanAxesDrawings();
      this.cleanXY();

      this.ranges_set = false;

      this.xmin = this.xmax = 0;
      this.ymin = this.ymax = 0;
      this.zmin = this.zmax = 0;

      this.zoom_xmin = this.zoom_xmax = 0;
      this.zoom_ymin = this.zoom_ymax = 0;
      this.zoom_zmin = this.zoom_zmax = 0;

      this.scale_xmin = this.scale_xmax = 0;
      this.scale_ymin = this.scale_ymax = 0;
      this.scale_zmin = this.scale_zmax = 0;

      if (this.draw_g) {
         this.draw_g.select('.main_layer').selectAll('*').remove();
         this.draw_g.select('.upper_layer').selectAll('*').remove();
      }

      this.xaxis = null;
      this.yaxis = null;
      this.zaxis = null;

      if (this.draw_g) {
         this.draw_g.selectAll('*').remove();
         this.draw_g.on('mousedown', null)
                    .on('dblclick', null)
                    .on('wheel', null)
                    .on('contextmenu', null)
                    .property('interactive_set', null);
         this.draw_g.remove();
      }

      delete this.draw_g; // frame <g> element managet by the pad

      if (this.keys_handler) {
         window.removeEventListener('keydown', this.keys_handler, false);
         this.keys_handler = null;
      }
   }

   /** @summary Cleanup frame */
   cleanup() {
      this.cleanFrameDrawings();
      delete this._click_handler;
      delete this._dblclick_handler;
      delete this.enabledKeys;

      let pp = this.getPadPainter();
      if (pp?.frame_painter_ref === this)
         delete pp.frame_painter_ref;

      super.cleanup();
   }

   /** @summary Redraw TFrame */
   redraw(/* reason */) {
      let pp = this.getPadPainter();
      if (pp) pp.frame_painter_ref = this; // keep direct reference to the frame painter

      // first update all attributes from objects
      this.updateAttributes();

      let rect = pp?.getPadRect() ?? { width: 10, height: 10},
          lm = Math.round(rect.width * this.fX1NDC),
          w = Math.round(rect.width * (this.fX2NDC - this.fX1NDC)),
          tm = Math.round(rect.height * (1 - this.fY2NDC)),
          h = Math.round(rect.height * (this.fY2NDC - this.fY1NDC)),
          rotate = false, fixpos = false, trans;

      if (pp?.options) {
         if (pp.options.RotateFrame) rotate = true;
         if (pp.options.FixFrame) fixpos = true;
      }

      if (rotate) {
         trans = `rotate(-90,${lm},${tm}) translate(${lm-h},${tm})`;
         [w, h] = [h, w];
      } else {
         trans = `translate(${lm},${tm})`;
      }

      this._frame_x = lm;
      this._frame_y = tm;
      this._frame_width = w;
      this._frame_height = h;
      this._frame_rotate = rotate;
      this._frame_fixpos = fixpos;

      if (this.mode3d) return this; // no need to create any elements in 3d mode

      // this is svg:g object - container for every other items belonging to frame
      this.draw_g = this.getFrameSvg();

      let top_rect, main_svg;

      if (this.draw_g.empty()) {

         this.draw_g = this.getLayerSvg('primitives_layer').append('svg:g').attr('class', 'root_frame');

         // empty title on the frame required to suppress title of the canvas
         if (!isBatchMode())
            this.draw_g.append('svg:title').text('');

         top_rect = this.draw_g.append('svg:path');

         // append for the moment three layers - for drawing and axis
         this.draw_g.append('svg:g').attr('class','grid_layer');

         main_svg = this.draw_g.append('svg:svg')
                           .attr('class','main_layer')
                           .attr('x', 0)
                           .attr('y', 0)
                           .attr('overflow', 'hidden');

         this.draw_g.append('svg:g').attr('class', 'axis_layer');
         this.draw_g.append('svg:g').attr('class', 'upper_layer');
      } else {
         top_rect = this.draw_g.select('path');
         main_svg = this.draw_g.select('.main_layer');
      }

      this.axes_drawn = false;

      this.draw_g.attr('transform', trans);

      top_rect.attr('d', `M0,0H${w}V${h}H0Z`)
              .call(this.fillatt.func)
              .call(this.lineatt.func);

      main_svg.attr('width', w)
              .attr('height', h)
              .attr('viewBox', `0 0 ${w} ${h}`);

      if (!isBatchMode()) {
         top_rect.style('pointer-events', 'visibleFill'); // let process mouse events inside frame
         FrameInteractive.assign(this);
         this.addBasicInteractivity();
      }

      return this;
   }

   /** @summary Change log state of specified axis
     * @param {number} value - 0 (linear), 1 (log) or 2 (log2) */
   changeAxisLog(axis, value) {
      let pp = this.getPadPainter(),
          pad = pp?.getRootPad(true);
      if (!pad) return;

      pp._interactively_changed = true;

      let name = 'fLog' + axis;

      // do not allow log scale for labels
      if (!pad[name]) {
         if (this.swap_xy && axis === 'x')
            axis = 'y';
         else if (this.swap_xy && axis === 'y')
            axis = 'x';
         let handle = this[axis + '_handle'];
         if (handle?.kind === 'labels') return;
      }

      if ((value == 'toggle') || (value === undefined))
         value = pad[name] ? 0 : 1;

      // directly change attribute in the pad
      pad[name] = value;

      this.interactiveRedraw('pad', 'log'+axis);
   }

   /** @summary Toggle log state on the specified axis */
   toggleAxisLog(axis) {
      this.changeAxisLog(axis, 'toggle');
   }

   /** @summary Fill context menu for the frame
     * @desc It could be appended to the histogram menus */
   fillContextMenu(menu, kind, obj) {
      let main = this.getMainPainter(true),
          pp = this.getPadPainter(),
          pad = pp?.getRootPad(true);

      if ((kind == 'x') || (kind == 'y') || (kind == 'z') || (kind == 'x2') || (kind == 'y2')) {
         let faxis = obj || this[kind+'axis'];
         menu.add('header: ' + kind.toUpperCase() + ' axis');
         menu.add('Unzoom', () => this.unzoom(kind));
         if (pad) {
            menu.add('sub:SetLog '+kind[0]);
            menu.addchk(pad['fLog' + kind[0]] == 0, 'linear', () => this.changeAxisLog(kind[0], 0));
            menu.addchk(pad['fLog' + kind[0]] == 1, 'log', () => this.changeAxisLog(kind[0], 1));
            menu.addchk(pad['fLog' + kind[0]] == 2, 'log2', () => this.changeAxisLog(kind[0], 2));
            menu.add('endsub:');
         }
         menu.addchk(faxis.TestBit(EAxisBits.kMoreLogLabels), 'More log',
               flag => {
                  faxis.InvertBit(EAxisBits.kMoreLogLabels);
                  if (main?.snapid && (kind.length == 1))
                     main.interactiveRedraw('pad', `exec:SetMoreLogLabels(${flag})`, kind);
                  else
                     this.interactiveRedraw('pad');
               });
         menu.addchk(faxis.TestBit(EAxisBits.kNoExponent), 'No exponent',
               flag => {
                  faxis.InvertBit(EAxisBits.kNoExponent);
                  if (main?.snapid && (kind.length == 1))
                     main.interactiveRedraw('pad', `exec:SetNoExponent(${flag})`, kind);
                  else
                     this.interactiveRedraw('pad');
               });

         if ((kind === 'z') && main?.options?.Zscale && isFunc(main?.fillPaletteMenu))
            main.fillPaletteMenu(menu);

         if (faxis) {
            let handle = this[kind+'_handle'];

            if ((handle?.kind == 'labels') && (faxis.fNbins > 20))
               menu.add('Find label', () => menu.input('Label id').then(id => {
                  if (!id) return;
                  for (let bin = 0; bin < faxis.fNbins; ++bin) {
                     let lbl = handle.formatLabels(bin);
                     if (lbl == id)
                        return this.zoom(kind, Math.max(0, bin - 4), Math.min(faxis.fNbins, bin+5));
                   }
               }));

            menu.addTAxisMenu(EAxisBits, main || this, faxis, kind);
         }
         return true;
      }

      const alone = menu.size() == 0;

      if (alone)
         menu.add('header:Frame');
      else
         menu.add('separator');

      if (this.zoom_xmin !== this.zoom_xmax)
         menu.add('Unzoom X', () => this.unzoom('x'));
      if (this.zoom_ymin !== this.zoom_ymax)
         menu.add('Unzoom Y', () => this.unzoom('y'));
      if (this.zoom_zmin !== this.zoom_zmax)
         menu.add('Unzoom Z', () => this.unzoom('z'));
      if (this.zoom_x2min !== this.zoom_x2max)
         menu.add('Unzoom X2', () => this.unzoom('x2'));
      if (this.zoom_y2min !== this.zoom_y2max)
         menu.add('Unzoom Y2', () => this.unzoom('y2'));
      menu.add('Unzoom all', () => this.unzoom('all'));

      if (pad) {
         menu.addchk(pad.fLogx, 'SetLogx', () => this.toggleAxisLog('x'));
         menu.addchk(pad.fLogy, 'SetLogy', () => this.toggleAxisLog('y'));

         if (isFunc(main?.getDimension) && (main.getDimension() > 1))
            menu.addchk(pad.fLogz, 'SetLogz', () => this.toggleAxisLog('z'));
         menu.add('separator');
      }

      menu.addchk(this.isTooltipAllowed(), 'Show tooltips', () => this.setTooltipAllowed('toggle'));
      menu.addAttributesMenu(this, alone ? '' : 'Frame ');
      menu.add('Save to gStyle', function() {
         gStyle.fPadBottomMargin = this.fY1NDC;
         gStyle.fPadTopMargin = 1 - this.fY2NDC;
         gStyle.fPadLeftMargin = this.fX1NDC;
         gStyle.fPadRightMargin = 1 - this.fX2NDC;
         if (this.fillatt) this.fillatt.saveToStyle('fFrameFillColor', 'fFrameFillStyle');
         if (this.lineatt) this.lineatt.saveToStyle('fFrameLineColor', 'fFrameLineWidth', 'fFrameLineStyle');
      }, 'Store frame position and graphical attributes to gStyle');

      menu.add('separator');
      menu.add('Save as frame.png', () => pp.saveAs('png', 'frame', 'frame.png'));
      menu.add('Save as frame.svg', () => pp.saveAs('svg', 'frame', 'frame.svg'));

      return true;
   }

   /** @summary Fill option object used in TWebCanvas
     * @private */
   fillWebObjectOptions(res) {
      if (!res) {
         if (!this.snapid) return null;
         res = { _typename: 'TWebObjectOptions', snapid: this.snapid.toString(), opt: this.getDrawOpt(), fcust: '', fopt: [] };
       }

      res.fcust = 'frame';
      res.fopt = [this.scale_xmin || 0, this.scale_ymin || 0, this.scale_xmax || 0, this.scale_ymax || 0];
      return res;
   }

   /** @summary Returns frame width */
   getFrameWidth() { return this._frame_width || 0; }

   /** @summary Returns frame height */
   getFrameHeight() { return this._frame_height || 0; }

   /** @summary Returns frame rectangle plus extra info for hint display */
   getFrameRect() {
      return {
         x: this._frame_x || 0,
         y: this._frame_y || 0,
         width: this.getFrameWidth(),
         height: this.getFrameHeight(),
         transform: this.draw_g ? this.draw_g.attr('transform') : '',
         hint_delta_x: 0,
         hint_delta_y: 0
      }
   }

   /** @summary Configure user-defined click handler
     * @desc Function will be called every time when frame click was perfromed
     * As argument, tooltip object with selected bins will be provided
     * If handler function returns true, default handling of click will be disabled */
   configureUserClickHandler(handler) {
      this._click_handler = isFunc(handler) ? handler : null;
   }

   /** @summary Configure user-defined dblclick handler
     * @desc Function will be called every time when double click was called
     * As argument, tooltip object with selected bins will be provided
     * If handler function returns true, default handling of dblclick (unzoom) will be disabled */
   configureUserDblclickHandler(handler) {
      this._dblclick_handler = isFunc(handler) ? handler : null;
   }

    /** @summary Function can be used for zooming into specified range
      * @desc if both limits for each axis 0 (like xmin == xmax == 0), axis will be unzoomed
      * @param {number} xmin
      * @param {number} xmax
      * @param {number} [ymin]
      * @param {number} [ymax]
      * @param {number} [zmin]
      * @param {number} [zmax]
      * @return {Promise} with boolean flag if zoom operation was performed */
   async zoom(xmin, xmax, ymin, ymax, zmin, zmax) {

      // disable zooming when axis conversion is enabled
      if (this.projection) return false;

      if (xmin === 'x') { xmin = xmax; xmax = ymin; ymin = undefined; } else
      if (xmin === 'y') { ymax = ymin; ymin = xmax; xmin = xmax = undefined; } else
      if (xmin === 'z') { zmin = xmax; zmax = ymin; xmin = xmax = ymin = undefined; }

      let zoom_x = (xmin !== xmax), zoom_y = (ymin !== ymax), zoom_z = (zmin !== zmax),
          unzoom_x = false, unzoom_y = false, unzoom_z = false;

      if (zoom_x) {
         let cnt = 0;
         if (xmin <= this.xmin) { xmin = this.xmin; cnt++; }
         if (xmax >= this.xmax) { xmax = this.xmax; cnt++; }
         if (cnt === 2) { zoom_x = false; unzoom_x = true; }
      } else {
         unzoom_x = (xmin === xmax) && (xmin === 0);
      }

      if (zoom_y) {
         let cnt = 0;
         if (ymin <= this.ymin) { ymin = this.ymin; cnt++; }
         if (ymax >= this.ymax) { ymax = this.ymax; cnt++; }
         if (cnt === 2) { zoom_y = false; unzoom_y = true; }
      } else {
         unzoom_y = (ymin === ymax) && (ymin === 0);
      }

      if (zoom_z) {
         let cnt = 0;
         if (zmin <= this.zmin) { zmin = this.zmin; cnt++; }
         if (zmax >= this.zmax) { zmax = this.zmax; cnt++; }
         if (cnt === 2) { zoom_z = false; unzoom_z = true; }
      } else {
         unzoom_z = (zmin === zmax) && (zmin === 0);
      }

      let changed = false;

      // first process zooming (if any)
      if (zoom_x || zoom_y || zoom_z)
         this.forEachPainter(obj => {
            if (!isFunc(obj.canZoomInside)) return;
            if (zoom_x && obj.canZoomInside('x', xmin, xmax)) {
               this.zoom_xmin = xmin;
               this.zoom_xmax = xmax;
               changed = true;
               zoom_x = false;
            }
            if (zoom_y && obj.canZoomInside('y', ymin, ymax)) {
               this.zoom_ymin = ymin;
               this.zoom_ymax = ymax;
               changed = true;
               zoom_y = false;
            }
            if (zoom_z && obj.canZoomInside('z', zmin, zmax)) {
               this.zoom_zmin = zmin;
               this.zoom_zmax = zmax;
               changed = true;
               zoom_z = false;
            }
         });

      // and process unzoom, if any
      if (unzoom_x || unzoom_y || unzoom_z) {
         if (unzoom_x) {
            if (this.zoom_xmin !== this.zoom_xmax) changed = true;
            this.zoom_xmin = this.zoom_xmax = 0;
         }
         if (unzoom_y) {
            if (this.zoom_ymin !== this.zoom_ymax) changed = true;
            this.zoom_ymin = this.zoom_ymax = 0;
         }
         if (unzoom_z) {
            if (this.zoom_zmin !== this.zoom_zmax) changed = true;
            this.zoom_zmin = this.zoom_zmax = 0;
         }

         // than try to unzoom all overlapped objects
         if (!changed)
            this.getPadPainter()?.painters?.forEach(painter => {
               if (isFunc(painter?.unzoomUserRange))
                  if (painter.unzoomUserRange(unzoom_x, unzoom_y, unzoom_z))
                     changed = true;
            });
      }

      return changed ? this.interactiveRedraw('pad', 'zoom').then(() => true) : false;
   }

   /** @summary Provide zooming of single axis
     * @desc One can specify names like x/y/z but also second axis x2 or y2
     * @private */
   async zoomSingle(name, vmin, vmax) {
      // disable zooming when axis conversion is enabled
      if (this.projection || !this[name+'_handle'])
         return false;

      let zoom_v = (vmin !== vmax), unzoom_v = false;

      if (zoom_v) {
         let cnt = 0;
         if (vmin <= this[name+'min']) { vmin = this[name+'min']; cnt++; }
         if (vmax >= this[name+'max']) { vmax = this[name+'max']; cnt++; }
         if (cnt === 2) { zoom_v = false; unzoom_v = true; }
      } else {
         unzoom_v = (vmin === vmax) && (vmin === 0);
      }

      let changed = false;

      // first process zooming
      if (zoom_v)
         this.forEachPainter(obj => {
            if (!isFunc(obj.canZoomInside)) return;
            if (zoom_v && obj.canZoomInside(name[0], vmin, vmax)) {
               this['zoom_' + name + 'min'] = vmin;
               this['zoom_' + name + 'max'] = vmax;
               changed = true;
               zoom_v = false;
            }
         });

      // and process unzoom, if any
      if (unzoom_v) {
         if (this['zoom_' + name + 'min'] !== this['zoom_' + name + 'max']) changed = true;
         this['zoom_' + name + 'min'] = this['zoom_' + name + 'max'] = 0;
      }

      if (!changed) return false;

      return this.interactiveRedraw('pad', 'zoom').then(() => true);
   }

   /** @summary Checks if specified axis zoomed */
   isAxisZoomed(axis) {
      return this['zoom_'+axis+'min'] !== this['zoom_'+axis+'max'];
   }

   /** @summary Unzoom speicified axes
     * @return {Promise} with boolean flag if zooming changed */
   async unzoom(dox, doy, doz) {
      if (dox == 'all')
         return this.unzoom('x2').then(() => this.unzoom('y2')).then(() => this.unzoom('xyz'));

      if ((dox == 'x2') || (dox == 'y2'))
         return this.zoomSingle(dox, 0, 0).then(changed => {
            if (changed) this.zoomChangedInteractive(dox, 'unzoom');
            return changed;
         });

      if (typeof dox === 'undefined') { dox = doy = doz = true; } else
      if (isStr(dox)) { doz = dox.indexOf('z') >= 0; doy = dox.indexOf('y') >= 0; dox = dox.indexOf('x') >= 0; }

      return this.zoom(dox ? 0 : undefined, dox ? 0 : undefined,
                       doy ? 0 : undefined, doy ? 0 : undefined,
                       doz ? 0 : undefined, doz ? 0 : undefined).then(changed => {

         if (changed && dox) this.zoomChangedInteractive('x', 'unzoom');
         if (changed && doy) this.zoomChangedInteractive('y', 'unzoom');
         if (changed && doz) this.zoomChangedInteractive('z', 'unzoom');

         return changed;
      });
   }

   /** @summary Mark/check if zoom for specific axis was changed interactively
     * @private */
   zoomChangedInteractive(axis, value) {
      if (axis == 'reset') {
         this.zoom_changed_x = this.zoom_changed_y = this.zoom_changed_z = undefined;
         return;
      }
      if (!axis || axis == 'any')
         return this.zoom_changed_x || this.zoom_changed_y  || this.zoom_changed_z;

      if ((axis !== 'x') && (axis !== 'y') && (axis !== 'z')) return;

      let fld = 'zoom_changed_' + axis;
      if (value === undefined)
         return this[fld] ? true : false;

      if (value === 'unzoom') {
         // special handling of unzoom, only if was never changed before flag set to true
         this[fld] = (this[fld] === undefined);
         return;
      }

      if (value)
         this[fld] = true;
   }

   /** @summary Convert graphical coordinate into axis value */
   revertAxis(axis, pnt) {
      let handle = this[axis+'_handle'];
      return handle ? handle.revertPoint(pnt) : 0;
   }

   /** @summary Show axis status message
    * @desc method called normally when mouse enter main object element
    * @private */
   showAxisStatus(axis_name, evnt) {
      let taxis = this.getAxis(axis_name), hint_name = axis_name, hint_title = clTAxis,
          m = pointer(evnt, this.getFrameSvg().node()), id = (axis_name == 'x') ? 0 : 1;

      if (taxis) {
         hint_name = taxis.fName;
         hint_title = taxis.fTitle || `TAxis object for ${axis_name}`;
      }
      if (this.swap_xy) id = 1-id;

      let axis_value = this.revertAxis(axis_name, m[id]);

      this.showObjectStatus(hint_name, hint_title, axis_name + ' : ' + this.axisAsText(axis_name, axis_value), m[0] + ',' + m[1]);
   }

   /** @summary Add interactive keys handlers
    * @private */
   addKeysHandler() {
      if (isBatchMode()) return;
      FrameInteractive.assign(this);
      this.addFrameKeysHandler();
   }

   /** @summary Add interactive functionality to the frame
     * @private */
   addInteractivity(for_second_axes) {
      if (isBatchMode() || (!settings.Zooming && !settings.ContextMenu))
         return false;

      FrameInteractive.assign(this);
      return this.addFrameInteractivity(for_second_axes);
   }

} // class TFramePainter

/** @summary Current hierarchy painter
  * @desc Instance of {@link HierarchyPainter} object
  * @private */
let first_hpainter = null;

/** @summary Returns current hierarchy painter object
  * @private */
function getHPainter() { return first_hpainter; }

/** @summary Set hierarchy painter object
  * @private */
function setHPainter(hp) { first_hpainter = hp; }

/**
 * @summary Base class to manage multiple document interface for drawings
 *
 * @private
 */

class MDIDisplay extends BasePainter {
   /** @summary constructor */
   constructor(frameid) {
      super();
      this.frameid = frameid;
      if (frameid != '$batch$') {
         this.setDom(frameid);
         this.selectDom().property('mdi', this);
      }
      this.cleanupFrame = cleanup; // use standard cleanup function by default
      this.active_frame_title = ''; // keep title of active frame
   }

   /** @summary Assign func which called for each newly created frame */
   setInitFrame(func) {
      this.initFrame = func;
      this.forEachFrame(frame => func(frame));
   }

   /** @summary method called before new frame is created */
   beforeCreateFrame(title) { this.active_frame_title = title; }

   /** @summary method called after new frame is created
     * @private */
   afterCreateFrame(frame) {
      if (isFunc(this.initFrame))
         this.initFrame(frame);
      return frame;
   }

   /** @summary method dedicated to iterate over existing panels
     * @param {function} userfunc is called with arguments (frame)
     * @param {boolean} only_visible let select only visible frames */
   forEachFrame(userfunc, only_visible) {
      console.warn(`forEachFrame not implemented in MDIDisplay ${typeof userfunc} ${only_visible}`);
   }

   /** @summary method dedicated to iterate over existing panles
     * @param {function} userfunc is called with arguments (painter, frame)
     * @param {boolean} only_visible let select only visible frames */
   forEachPainter(userfunc, only_visible) {
      this.forEachFrame(frame => {
         new ObjectPainter(frame).forEachPainter(painter => userfunc(painter, frame));
      }, only_visible);
   }

   /** @summary Returns total number of drawings */
   numDraw() {
      let cnt = 0;
      this.forEachFrame(() => ++cnt);
      return cnt;
   }

   /** @summary Serach for the frame using item name */
   findFrame(searchtitle, force) {
      let found_frame = null;

      this.forEachFrame(frame => {
         if (select(frame).attr('frame_title') == searchtitle)
            found_frame = frame;
      });

      if (!found_frame && force)
         found_frame = this.createFrame(searchtitle);

      return found_frame;
   }

   /** @summary Activate frame */
   activateFrame(frame) { this.active_frame_title = frame ? select(frame).attr('frame_title') : ''; }

   /** @summary Return active frame */
   getActiveFrame() { return this.findFrame(this.active_frame_title); }

   /** @summary perform resize for each frame
     * @protected */
   checkMDIResize(only_frame_id, size) {

      let resized_frame = null;

      this.forEachPainter((painter, frame) => {

         if (only_frame_id && (select(frame).attr('id') != only_frame_id)) return;

         if ((painter.getItemName() !== null) && isFunc(painter.checkResize)) {
            // do not call resize for many painters on the same frame
            if (resized_frame === frame) return;
            painter.checkResize(size);
            resized_frame = frame;
         }
      });
   }

   /** @summary Cleanup all drawings */
   cleanup() {
      this.active_frame_title = '';

      this.forEachFrame(this.cleanupFrame);

      this.selectDom().html('').property('mdi', null);
   }

} // class MDIDisplay


/**
 * @summary Custom MDI display
 *
 * @desc All HTML frames should be created before and add via {@link CustomDisplay#addFrame} calls
 * @private
 */

class CustomDisplay extends MDIDisplay {
   constructor() {
      super('dummy');
      this.frames = {}; // array of configured frames
   }

   addFrame(divid, itemname) {
      let prev = this.frames[divid] || '';
      this.frames[divid] = prev + (itemname + ';');
   }

   forEachFrame(userfunc) {
      let ks = Object.keys(this.frames);
      for (let k = 0; k < ks.length; ++k) {
         let node = select('#'+ks[k]);
         if (!node.empty())
            userfunc(node.node());
      }
   }

   createFrame(title) {
      this.beforeCreateFrame(title);

      let ks = Object.keys(this.frames);
      for (let k = 0; k < ks.length; ++k) {
         let items = this.frames[ks[k]];
         if (items.indexOf(title+';') >= 0)
            return select('#'+ks[k]).node();
      }
      return null;
   }

   cleanup() {
      super.cleanup();
      this.forEachFrame(frame => select(frame).html(''));
   }

} // class CustomDisplay

/**
 * @summary Generic grid MDI display
 *
 * @private
 */

class GridDisplay extends MDIDisplay {

 /** @summary Create GridDisplay instance
   * @param {string} frameid - where grid display is created
   * @param {string} kind - kind of grid
   * @desc  following kinds are supported
   *    - vertical or horizontal - only first letter matters, defines basic orientation
   *    - 'x' in the name disable interactive separators
   *    - v4 or h4 - 4 equal elements in specified direction
   *    - v231 -  created 3 vertical elements, first divided on 2, second on 3 and third on 1 part
   *    - v23_52 - create two vertical elements with 2 and 3 subitems, size ratio 5:2
   *    - gridNxM - normal grid layout without interactive separators
   *    - gridiNxM - grid layout with interactive separators
   *    - simple - no layout, full frame used for object drawings */
   constructor(frameid, kind, kind2) {

      super(frameid);

      this.framecnt = 0;
      this.getcnt = 0;
      this.groups = [];
      this.vertical = kind && (kind[0] == 'v');
      this.use_separarators = !kind || (kind.indexOf('x') < 0);
      this.simple_layout = false;

      let dom = this.selectDom();
      dom.style('overflow','hidden');

      if (kind === 'simple') {
         this.simple_layout = true;
         this.use_separarators = false;
         this.framecnt = 1;
         return;
      }

      let num = 2, arr = undefined, sizes = undefined;

      if ((kind.indexOf('grid') == 0) || kind2) {
         if (kind2) kind = kind + 'x' + kind2;
               else kind = kind.slice(4).trim();
         this.use_separarators = false;
         if (kind[0] === 'i') {
            this.use_separarators = true;
            kind = kind.slice(1);
         }

         let separ = kind.indexOf('x'), sizex, sizey;

         if (separ > 0) {
            sizey = parseInt(kind.slice(separ + 1));
            sizex = parseInt(kind.slice(0, separ));
         } else {
            sizex = sizey = parseInt(kind);
         }

         if (!Number.isInteger(sizex)) sizex = 3;
         if (!Number.isInteger(sizey)) sizey = 3;

         if (sizey > 1) {
            this.vertical = true;
            num = sizey;
            if (sizex > 1)
               arr = new Array(num).fill(sizex);
         } else if (sizex > 1) {
            this.vertical = false;
            num = sizex;
         } else {
            this.simple_layout = true;
            this.use_separarators = false;
            this.framecnt = 1;
            return;
         }
         kind = '';
      }

      if (kind && kind.indexOf('_') > 0) {
         let arg = parseInt(kind.slice(kind.indexOf('_')+1), 10);
         if (Number.isInteger(arg) && (arg > 10)) {
            kind = kind.slice(0, kind.indexOf('_'));
            sizes = [];
            while (arg > 0) {
               sizes.unshift(Math.max(arg % 10, 1));
               arg = Math.round((arg-sizes[0])/10);
               if (sizes[0] === 0) sizes[0] = 1;
            }
         }
      }

      kind = kind ? parseInt(kind.replace( /^\D+/g, ''), 10) : 0;
      if (Number.isInteger(kind) && (kind > 1)) {
         if (kind < 10) {
            num = kind;
         } else {
            arr = [];
            while (kind > 0) {
               arr.unshift(kind % 10);
               kind = Math.round((kind-arr[0])/10);
               if (arr[0] === 0) arr[0] = 1;
            }
            num = arr.length;
         }
      }

      if (sizes && (sizes.length!==num)) sizes = undefined;

      if (!this.simple_layout) {
         injectStyle(
            `.jsroot_vline:after { content:""; position: absolute; top: 0; bottom: 0; left: 50%; border-left: 1px dotted #ff0000; }
             .jsroot_hline:after { content:""; position: absolute; left: 0; right: 0; top: 50%; border-top: 1px dotted #ff0000; }
             .jsroot_separator { pointer-events: all; border: 0; margin: 0; padding: 0; }`, dom.node(), 'grid_style');
         this.createGroup(this, dom, num, arr, sizes);
      }
   }

   /** @summary Create frames group
     * @private */
   createGroup(handle, main, num, childs, sizes) {

      if (!sizes) sizes = new Array(num);
      let sum1 = 0, sum2 = 0;
      for (let n = 0; n < num; ++n)
         sum1 += (sizes[n] || 1);
      for (let n = 0; n < num; ++n) {
         sizes[n] = Math.round(100 * (sizes[n] || 1) / sum1);
         sum2 += sizes[n];
         if (n==num-1) sizes[n] += (100-sum2); // make 100%
      }

      for (let cnt = 0; cnt < num; ++cnt) {
         let group = { id: cnt, drawid: -1, position: 0, size: sizes[cnt] };
         if (cnt > 0) group.position = handle.groups[cnt-1].position + handle.groups[cnt-1].size;
         group.position0 = group.position;

         if (!childs || !childs[cnt] || childs[cnt]<2) group.drawid = this.framecnt++;

         handle.groups.push(group);

         let elem = main.append('div').attr('groupid', group.id);

         if (handle.vertical)
            elem.style('float', 'bottom').style('height',group.size+'%').style('width','100%');
         else
            elem.style('float', 'left').style('width',group.size+'%').style('height','100%');

         if (group.drawid >= 0) {
            elem.classed('jsroot_newgrid', true);
            if (isStr(this.frameid))
               elem.attr('id', `${this.frameid}_${group.drawid}`);
         } else {
            elem.style('display','flex').style('flex-direction', handle.vertical ? 'row' : 'column');
         }

         if (childs && (childs[cnt]>1)) {
            group.vertical = !handle.vertical;
            group.groups = [];
            elem.style('overflow','hidden');
            this.createGroup(group, elem, childs[cnt]);
         }
      }

      if (this.use_separarators && this.createSeparator)
         for (let cnt = 1; cnt < num; ++cnt)
            this.createSeparator(handle, main, handle.groups[cnt]);
   }

   /** @summary Handle interactive sepearator movement
     * @private */
   handleSeparator(elem, action) {
      let separ = select(elem),
          parent = elem.parentNode,
          handle = separ.property('handle'),
          id = separ.property('separator_id'),
          group = handle.groups[id];

       const findGroup = grid => {
         let chld = parent.firstChild;
         while (chld) {
            if (chld.getAttribute('groupid') == grid)
               return select(chld);
            chld = chld.nextSibling;
         }
         // should never happen, but keep it here like
         return select(parent).select(`[groupid='${grid}']`);
       }, setGroupSize = grid => {
          let name = handle.vertical ? 'height' : 'width',
              size = handle.groups[grid].size+'%';
          findGroup(grid).style(name, size)
                         .selectAll('.jsroot_separator').style(name, size);
       }, resizeGroup = grid => {
          let sel = findGroup(grid);
          if (!sel.classed('jsroot_newgrid')) sel = sel.select('.jsroot_newgrid');
          sel.each(function() { resize(this); });
       };

      if (action == 'start') {
         group.startpos = group.position;
         group.acc_drag = 0;
         return;
      }

      if (action == 'end') {
         if (Math.abs(group.startpos - group.position) >= 0.5) {
            resizeGroup(id-1);
            resizeGroup(id);
          }
          return;
      }

      let pos;
      if (action == 'restore') {
          pos = group.position0;
      } else if (handle.vertical) {
          group.acc_drag += action.dy;
          pos = group.startpos + ((group.acc_drag + 2) / parent.clientHeight) * 100;
      } else {
          group.acc_drag += action.dx;
          pos = group.startpos + ((group.acc_drag + 2) / parent.clientWidth) * 100;
      }

      let diff = group.position - pos;

      if (Math.abs(diff) < 0.3) return; // if no significant change, do nothing

      // do not change if size too small
      if (Math.min(handle.groups[id-1].size-diff, group.size+diff) < 3) return;

      handle.groups[id-1].size -= diff;
      group.size += diff;
      group.position = pos;

      separ.style(handle.vertical ? 'top' : 'left', `calc(${pos}% - 2px)`);

      setGroupSize(id-1);
      setGroupSize(id);

      if (action == 'restore') {
          resizeGroup(id-1);
          resizeGroup(id);
      }
   }

   /** @summary Create group separator
     * @private */
   createSeparator(handle, main, group) {
      let separ = main.append('div');

      separ.classed('jsroot_separator', true)
           .classed(handle.vertical ? 'jsroot_hline' : 'jsroot_vline', true)
           .property('handle', handle)
           .property('separator_id', group.id)
           .style('position', 'absolute')
           .style(handle.vertical ? 'top' : 'left', `calc(${group.position}% - 2px)`)
           .style(handle.vertical ? 'width' : 'height', (handle.size || 100)+'%')
           .style(handle.vertical ? 'height' : 'width', '5px')
           .style('cursor', handle.vertical ? 'ns-resize' : 'ew-resize');

      let pthis = this, drag_move =
        drag().on('start', function() { pthis.handleSeparator(this, 'start'); })
                 .on('drag', function(evnt) { pthis.handleSeparator(this, evnt); })
                 .on('end', function() { pthis.handleSeparator(this, 'end'); });

      separ.call(drag_move).on('dblclick', function() { pthis.handleSeparator(this, 'restore'); });

      // need to get touches events handling in drag
      if (browser$1.touches && !main.on('touchmove'))
         main.on('touchmove', function() { });
   }


   /** @summary Call function for each frame */
   forEachFrame(userfunc) {
      if (this.simple_layout)
         userfunc(this.getGridFrame());
      else
         this.selectDom().selectAll('.jsroot_newgrid').each(function() {
            userfunc(this);
         });
   }

   /** @summary Returns active frame */
   getActiveFrame() {
      if (this.simple_layout)
         return this.getGridFrame();

      let found = super.getActiveFrame();
      if (found) return found;

      this.forEachFrame(frame => { if (!found) found = frame; });

      return found;
   }

   /** @summary Returns number of frames in grid layout */
   numGridFrames() { return this.framecnt; }

   /** @summary Return grid frame by its id */
   getGridFrame(id) {
      if (this.simple_layout)
         return this.selectDom('origin').node();
      let res = null;
      this.selectDom().selectAll('.jsroot_newgrid').each(function() {
         if (id-- === 0) res = this;
      });
      return res;
   }

   /** @summary Create new frame */
   createFrame(title) {
      this.beforeCreateFrame(title);

      let frame = null, maxloop = this.framecnt || 2;

      while (!frame && maxloop--) {
         frame = this.getGridFrame(this.getcnt);
         if (!this.simple_layout && this.framecnt)
            this.getcnt = (this.getcnt+1) % this.framecnt;

         if (select(frame).classed('jsroot_fixed_frame')) frame = null;
      }

      if (frame) {
         this.cleanupFrame(frame);
         select(frame).attr('frame_title', title);
      }

      return this.afterCreateFrame(frame);
   }

} // class GridDisplay


// ================================================

/**
 * @summary Tabs-based display
 *
 * @private
 */

class TabsDisplay extends MDIDisplay {

   constructor(frameid) {
      super(frameid);
      this.cnt = 0; // use to count newly created frames
      this.selectDom().style('overflow', 'hidden');
   }

   /** @summary Cleanup all drawings */
   cleanup() {
      this.selectDom().style('overflow', null);
      this.cnt = 0;
      super.cleanup();
   }

   /** @summary call function for each frame */
   forEachFrame(userfunc,  only_visible) {
      if (!isFunc(userfunc)) return;

      if (only_visible) {
         let active = this.getActiveFrame();
         if (active) userfunc(active);
         return;
      }

      let main = this.selectDom().select('.jsroot_tabs_main');

      main.selectAll('.jsroot_tabs_draw').each(function() {
         userfunc(this);
      });
   }

   /** @summary modify tab state by id */
   modifyTabsFrame(frame_id, action) {
      let top = this.selectDom().select('.jsroot_tabs'),
          labels = top.select('.jsroot_tabs_labels'),
          main = top.select('.jsroot_tabs_main');

      labels.selectAll('.jsroot_tabs_label').each(function() {
         let id = select(this).property('frame_id'),
             is_same = (id == frame_id);
         if (action == 'activate')
            select(this).style('background', is_same ? (settings.DarkMode ? 'black' : 'white') : null);
         else if ((action == 'close') && is_same)
            this.parentNode.remove();
      });

      let selected_frame, other_frame;

      main.selectAll('.jsroot_tabs_draw').each(function() {
         if (select(this).property('frame_id') === frame_id)
            selected_frame = this;
         else
            other_frame = this;
      });

      if (!selected_frame) return;

      if (action == 'activate') {
         selected_frame.parentNode.appendChild(selected_frame);
         // super.activateFrame(selected_frame);
      } else if (action == 'close') {
         let was_active = (selected_frame === this.getActiveFrame());
         cleanup(selected_frame);
         selected_frame.remove();

         if (was_active)
            this.activateFrame(other_frame);
      }
   }

   /** @summary actiavte frame */
   activateFrame(frame) {
      if (frame)
         this.modifyTabsFrame(select(frame).property('frame_id'), 'activate');
      super.activateFrame(frame);
   }

   /** @summary create new frame */
   createFrame(title) {

      this.beforeCreateFrame(title);

      let dom = this.selectDom(),
          top = dom.select('.jsroot_tabs'), labels, main;

      if (top.empty()) {
         top = dom.append('div').classed('jsroot_tabs', true);
         labels = top.append('div').classed('jsroot_tabs_labels', true);
         main = top.append('div').classed('jsroot_tabs_main', true);
      } else {
         labels = top.select('.jsroot_tabs_labels');
         main = top.select('.jsroot_tabs_main');
      }

      let bkgr_color = settings.DarkMode ? 'black' : 'white',
          lbl_color = settings.DarkMode ? '#111': '#eee',
          lbl_border = settings.DarkMode ? '#333' : '#ccc',
          text_color = settings.DarkMode ? '#ddd' : 'inherit';

      injectStyle(
         `.jsroot_tabs { display: flex; flex-direction: column; position: absolute; overflow: hidden; inset: 0px 0px 0px 0px; }
          .jsroot_tabs_labels { white-space: nowrap; position: relative; overflow-x: auto; }
          .jsroot_tabs_labels .jsroot_tabs_label {
             color: ${text_color}; background: ${lbl_color}; border: 1px solid ${lbl_border}; display: inline-block; font-size: 1rem; left: 1px;
             margin-left: 3px; padding: 0px 5px 1px 5px; position: relative; vertical-align: bottom;
          }
          .jsroot_tabs_main { margin: 0; flex: 1 1 0%; position: relative; }
          .jsroot_tabs_main .jsroot_tabs_draw { overflow: hidden; background: ${bkgr_color}; position: absolute; top: 0px; bottom: 0px; left: 0px; right: 0px; }`,
          dom.node(), 'tabs_style');

      let frame_id = this.cnt++, mdi = this, lbl = title;

      if (!lbl || !isStr(lbl)) lbl = `frame_${frame_id}`;

      if (lbl.length > 15) {
         let p = lbl.lastIndexOf('/');
         if (p == lbl.length-1) p = lbl.lastIndexOf('/', p-1);
         if ((p > 0) && (lbl.length - p < 20) && (lbl.length - p > 1))
            lbl = lbl.slice(p+1);
         else
            lbl = '...' + lbl.slice(lbl.length-17);
      }

      labels.append('span')
         .attr('tabindex', 0)
         .append('label')
         .attr('class', 'jsroot_tabs_label')
         .style('background', 'white')
         .property('frame_id', frame_id)
         .text(lbl)
         .attr('title', title)
         .on('click', function(evnt) {
            evnt.preventDefault(); // prevent handling in close button
            mdi.modifyTabsFrame(select(this).property('frame_id'), 'activate');
         }).append('button')
         .attr('title', 'close')
         .attr('style', 'margin-left: .5em; padding: 0; font-size: 0.5em; width: 1.8em; height: 1.8em; vertical-align: center;')
         .html('&#x2715;')
         .on('click', function() {
            mdi.modifyTabsFrame(select(this.parentNode).property('frame_id'), 'close');
         });

      let draw_frame = main.append('div')
                           .attr('frame_title', title)
                           .attr('class', 'jsroot_tabs_draw')
                           .property('frame_id', frame_id);

      this.modifyTabsFrame(frame_id, 'activate');

      return this.afterCreateFrame(draw_frame.node());
   }

} // class TabsDisplay


/**
 * @summary Generic flexible MDI display
 *
 * @private
 */

class FlexibleDisplay extends MDIDisplay {

   constructor(frameid) {
      super(frameid);
      this.cnt = 0; // use to count newly created frames
      this.selectDom().on('contextmenu', evnt => this.showContextMenu(evnt))
                      .style('overflow', 'auto');
   }

   /** @summary Cleanup all drawings */
   cleanup() {
      this.selectDom().style('overflow', null)
                      .on('contextmenu', null);
      this.cnt = 0;
      super.cleanup();
   }

   /** @summary call function for each frame */
   forEachFrame(userfunc,  only_visible) {
      if (!isFunc(userfunc)) return;

      let mdi = this, top = this.selectDom().select('.jsroot_flex_top');

      top.selectAll('.jsroot_flex_draw').each(function() {
         // check if only visible specified
         if (only_visible && (mdi.getFrameState(this) == 'min')) return;

         userfunc(this);
      });
   }

   /** @summary return active frame */
   getActiveFrame() {
      let found = super.getActiveFrame();
      if (found && select(found.parentNode).property('state') != 'min') return found;

      found = null;
      this.forEachFrame(frame => { found = frame; }, true);
      return found;
   }

   /** @summary actiavte frame */
   activateFrame(frame) {
      if ((frame === 'first') || (frame === 'last')) {
         let res = null;
         this.forEachFrame(f => { if (frame == 'last' || !res) res = f; }, true);
         frame = res;
      }
      if (!frame) return;
      if (frame.getAttribute('class') != 'jsroot_flex_draw') return;

      if (this.getActiveFrame() === frame) return;

      super.activateFrame(frame);

      let main = frame.parentNode;
      main.parentNode.append(main);

      if (this.getFrameState(frame) != 'min') {
         selectActivePad({ pp: getElementCanvPainter(frame), active: true });
         resize(frame);
      }
   }

   /** @summary get frame state */
   getFrameState(frame) {
      let main = select(frame.parentNode);
      return main.property('state');
   }

   /** @summary returns frame rect */
   getFrameRect(frame) {
      if (this.getFrameState(frame) == 'max') {
         let top = this.selectDom().select('.jsroot_flex_top');
         return { x: 0, y: 0, w: top.node().clientWidth, h: top.node().clientHeight };
      }

      let main = select(frame.parentNode), left = main.style('left'), top = main.style('top');

      return { x: parseInt(left.slice(0, left.length-2)), y: parseInt(top.slice(0, top.length-2)),
               w: main.node().clientWidth, h: main.node().clientHeight };
   }

   /** @summary change frame state */
   changeFrameState(frame, newstate,no_redraw) {
      let main = select(frame.parentNode),
          state = main.property('state'),
          top = this.selectDom().select('.jsroot_flex_top');

      if (state == newstate)
         return false;

      if (state == 'normal')
          main.property('original_style', main.attr('style'));

      // clear any previous settings
      top.style('overflow', null);

      switch (newstate) {
         case 'min':
            main.style('height','auto').style('width', 'auto');
            main.select('.jsroot_flex_draw').style('display','none');
            break;
         case 'max':
            main.style('height','100%').style('width', '100%').style('left','').style('top','');
            main.select('.jsroot_flex_draw').style('display', null);
            top.style('overflow', 'hidden');
            break;
         default:
            main.select('.jsroot_flex_draw').style('display', null);
            main.attr('style', main.property('original_style'));
      }

      main.select('.jsroot_flex_header').selectAll('button').each(function(d) {
         let btn = select(this);
         if (((d.t == 'minimize') && (newstate == 'min')) ||
             ((d.t == 'maximize') && (newstate == 'max')))
               btn.html('&#x259E;').attr('title', 'restore');
         else
            btn.html(d.n).attr('title', d.t);
      });

      main.property('state', newstate);
      main.select('.jsroot_flex_resize').style('display', (newstate == 'normal') ? null : 'none');

      // adjust position of new minified rect
      if (newstate == 'min') {
         const rect = this.getFrameRect(frame),
               top = this.selectDom().select('.jsroot_flex_top'),
               ww = top.node().clientWidth,
               hh = top.node().clientHeight,
               arr = [], step = 4,
               crossX = (r1,r2) => ((r1.x <= r2.x) && (r1.x + r1.w >= r2.x)) || ((r2.x <= r1.x) && (r2.x + r2.w >= r1.x)),
               crossY = (r1,r2) => ((r1.y <= r2.y) && (r1.y + r1.h >= r2.y)) || ((r2.y <= r1.y) && (r2.y + r2.h >= r1.y));

         this.forEachFrame(f => { if ((f!==frame) && (this.getFrameState(f) == 'min')) arr.push(this.getFrameRect(f)); });

         rect.y = hh;
         do {
            rect.x = step;
            rect.y -= rect.h + step;
            let maxx = step, iscrossed = false;
            arr.forEach(r => {
               if (crossY(r,rect)) {
                  maxx = Math.max(maxx, r.x + r.w + step);
                  if (crossX(r,rect)) iscrossed = true;
               }
            });
            if (iscrossed) rect.x = maxx;
         } while ((rect.x + rect.w > ww - step) && (rect.y > 0));
         if (rect.y < 0) { rect.x = step; rect.y = hh - rect.h - step; }

         main.style('left', rect.x + 'px').style('top', rect.y + 'px');
      } else if (!no_redraw) {
         resize(frame);
      }

      return true;
   }

   /** @summary handle button click
     * @private */
   _clickButton(btn) {
      let kind = select(btn).datum(),
          main = select(btn.parentNode.parentNode),
          frame = main.select('.jsroot_flex_draw').node();

      if (kind.t == 'close') {
         this.cleanupFrame(frame);
         main.remove();
         this.activateFrame('last'); // set active as last non-minfied window
         return;
      }

      let state = main.property('state'), newstate;
      if (kind.t == 'maximize')
         newstate = (state == 'max') ? 'normal' : 'max';
      else
         newstate = (state == 'min') ? 'normal' : 'min';

      if (this.changeFrameState(frame, newstate))
         this.activateFrame(newstate != 'min' ? frame : 'last');
   }

   /** @summary create new frame */
   createFrame(title) {

      this.beforeCreateFrame(title);

      let mdi = this,
          dom = this.selectDom(),
          top = dom.select('.jsroot_flex_top');

      injectStyle(
         `.jsroot_flex_top { overflow: auto; position: relative; height: 100%; width: 100%; }
          .jsroot_flex_btn { float: right; padding: 0; width: 1.4em; text-align: center; font-size: 10px; margin-top: 2px; margin-right: 4px; }
          .jsroot_flex_header { height: 23px; overflow: hidden; background-color: lightblue; }
          .jsroot_flex_header p { margin: 1px; float: left; font-size: 14px; padding-left: 5px; }
          .jsroot_flex_draw { overflow: hidden; width: 100%; height: calc(100% - 24px); }
          .jsroot_flex_frame { border: 1px solid black; box-shadow: 1px 1px 2px 2px #aaa; background: white; }
          .jsroot_flex_resize { position: absolute; right: 2px; bottom: 2px; overflow: hidden; cursor: nwse-resize; }
          .jsroot_flex_resizable_helper { border: 2px dotted #00F; }`, dom.node(), 'flex_style');

      if (top.empty())
         top = dom.append('div').classed('jsroot_flex_top', true);

      let w = top.node().clientWidth,
          h = top.node().clientHeight,
          main = top.append('div');

      main.html(`<div class='jsroot_flex_header'><p>${title}</p></div>`+
                `<div id='${this.frameid}_cont${this.cnt}' class='jsroot_flex_draw'></div>`+
                `<div class='jsroot_flex_resize'>&#x25FF;</div>`);

      main.attr('class', 'jsroot_flex_frame')
         .style('position', 'absolute')
         .style('left', Math.round(w * (this.cnt % 5)/10) + 'px')
         .style('top', Math.round(h * (this.cnt % 5)/10) + 'px')
         .style('width', Math.round(w * 0.58) + 'px')
         .style('height', Math.round(h * 0.58) + 'px')
         .property('state', 'normal')
         .select('.jsroot_flex_header')
         .on('click', function() { mdi.activateFrame(select(this.parentNode).select('.jsroot_flex_draw').node()); })
         .selectAll('button')
         .data([{ n: '&#x2715;', t: 'close' }, { n: '&#x2594;', t: 'maximize' }, { n: '&#x2581;', t: 'minimize' }])
         .enter()
         .append('button')
         .attr('type', 'button')
         .attr('class', 'jsroot_flex_btn')
         .attr('title', d => d.t)
         .html(d => d.n)
         .on('click', function() { mdi._clickButton(this); });

      let moving_frame = null, moving_div = null, doing_move = false,
          drag_object = drag().subject(Object), current = [];
      drag_object.on('start', function(evnt) {
         if (evnt.sourceEvent.target.type == 'button')
            return mdi._clickButton(evnt.sourceEvent.target);

         if (detectRightButton(evnt.sourceEvent)) return;

         let main = select(this.parentNode);
         if(!main.classed('jsroot_flex_frame') || (main.property('state') == 'max')) return;

         doing_move = !select(this).classed('jsroot_flex_resize');
         if (!doing_move && (main.property('state') == 'min')) return;

         mdi.activateFrame(main.select('.jsroot_flex_draw').node());

         moving_div = top.append('div').classed('jsroot_flex_resizable_helper', true);

         moving_div.attr('style', main.attr('style'));

         if (main.property('state') == 'min')
            moving_div.style('width', main.node().clientWidth + 'px')
                      .style('height', main.node().clientHeight + 'px');

         evnt.sourceEvent.preventDefault();
         evnt.sourceEvent.stopPropagation();

         moving_frame = main;
         current = [];

      }).on('drag', function(evnt) {
         if (!moving_div) return;
         evnt.sourceEvent.preventDefault();
         evnt.sourceEvent.stopPropagation();
         let changeProp = (i,name,dd) => {
            if (i >= current.length) {
               let v = moving_div.style(name);
               current[i] = parseInt(v.slice(0,v.length-2));
            }
            current[i] += dd;
            moving_div.style(name, Math.max(0, current[i])+'px');
         };
         if (doing_move) {
            changeProp(0, 'left', evnt.dx);
            changeProp(1, 'top', evnt.dy);
         } else {
            changeProp(0, 'width', evnt.dx);
            changeProp(1, 'height', evnt.dy);
         }
      }).on('end', function(evnt) {
         if (!moving_div) return;
         evnt.sourceEvent.preventDefault();
         evnt.sourceEvent.stopPropagation();
         if (doing_move) {
            moving_frame.style('left', moving_div.style('left'));
            moving_frame.style('top', moving_div.style('top'));
         } else {
            moving_frame.style('width', moving_div.style('width'));
            moving_frame.style('height', moving_div.style('height'));
         }
         moving_div.remove();
         moving_div = null;
         if (!doing_move)
            resize(moving_frame.select('.jsroot_flex_draw').node());
      });

      main.select('.jsroot_flex_header').call(drag_object);
      main.select('.jsroot_flex_resize').call(drag_object);

      let draw_frame = main.select('.jsroot_flex_draw')
                           .attr('frame_title', title)
                           .property('frame_cnt', this.cnt++)
                           .node();

      return this.afterCreateFrame(draw_frame);
   }

   /** @summary minimize all frames */
   minimizeAll() {
      this.forEachFrame(frame => this.changeFrameState(frame, 'min'));
   }

   /** @summary show all frames which are minimized */
   showAll() {
      this.forEachFrame(frame => {
         if (this.getFrameState(frame) == 'min')
            this.changeFrameState(frame, 'normal');
      });
   }

   /** @summary close all frames */
   closeAllFrames() {
      let arr = [];
      this.forEachFrame(frame => arr.push(frame));
      arr.forEach(frame => {
         this.cleanupFrame(frame);
         select(frame.parentNode).remove();
      });
   }

   /** @summary cascade frames */
   sortFrames(kind) {
      let arr = [];
      this.forEachFrame(frame => {
         let state = this.getFrameState(frame);
         if (state == 'min') return;
         if (state == 'max') this.changeFrameState(frame, 'normal', true);
         arr.push(frame);
      });

      if (arr.length == 0) return;

      let top = this.selectDom(),
          w = top.node().clientWidth,
          h = top.node().clientHeight,
          dx = Math.min(40, Math.round(w*0.4/arr.length)),
          dy = Math.min(40, Math.round(h*0.4/arr.length)),
          nx = Math.ceil(Math.sqrt(arr.length)), ny = nx;

      // calculate number of divisions for 'tile' sorting
      if ((nx > 1) && (nx*(nx-1) >= arr.length))
        if (w > h) ny--; else nx--;

      arr.forEach((frame,i) => {
         let main = select(frame.parentNode);
         if (kind == 'cascade')
            main.style('left', (i*dx) + 'px')
                .style('top', (i*dy) + 'px')
                .style('width', Math.round(w * 0.58) + 'px')
                .style('height', Math.round(h * 0.58) + 'px');
         else
            main.style('left', Math.round(w/nx*(i%nx)) + 'px')
                .style('top', Math.round(h/ny*((i-i%nx)/nx)) + 'px')
                .style('width', Math.round(w/nx - 4) + 'px')
                .style('height', Math.round(h/ny - 4) + 'px');
         resize(frame);
      });
   }

   /** @summary context menu */
   showContextMenu(evnt) {
      // handle context menu only for MDI area
      if ((evnt.target.getAttribute('class') != 'jsroot_flex_top') || (this.numDraw() == 0)) return;

      evnt.preventDefault();

      let arr = [], nummin = 0;
      this.forEachFrame(f => {
         arr.push(f);
         if (this.getFrameState(f) == 'min') nummin++;
      });
      let active = this.getActiveFrame();

      arr.sort((f1,f2) => (select(f1).property('frame_cnt') < select(f2).property('frame_cnt') ? -1 : 1));

      createMenu$1(evnt, this).then(menu => {
         menu.add('header:Flex');
         menu.add('Cascade', () => this.sortFrames('cascade'), 'Cascade frames');
         menu.add('Tile', () => this.sortFrames('tile'), 'Tile all frames');
         if (nummin < arr.length)
            menu.add('Minimize all', () => this.minimizeAll(), 'Minimize all frames');
         if (nummin > 0)
            menu.add('Show all', () => this.showAll(), 'Restore minimized frames');
         menu.add('Close all', () => this.closeAllFrames());
         menu.add('separator');

         arr.forEach((f,i) => menu.addchk((f===active), ((this.getFrameState(f) == 'min') ? '[min] ' : '') + select(f).attr('frame_title'), i,
                      arg => {
                        let frame = arr[arg];
                        if (this.getFrameState(frame) == 'min')
                           this.changeFrameState(frame, 'normal');
                        this.activateFrame(frame);
                      }));

         menu.show();
      });
   }

} // class FlexibleDisplay


/**
 * @summary Batch MDI display
 *
 * @desc Can be used together with hierarchy painter in node.js
 * @private
 */

class BatchDisplay extends MDIDisplay {

   constructor(width, height, jsdom_body) {
      super('$batch$');
      this.frames = []; // array of configured frames
      this.width = width || 1200;
      this.height = height || 800;
      this.jsdom_body = jsdom_body || select('body'); // d3 body handle
   }

   forEachFrame(userfunc) {
      this.frames.forEach(userfunc);
   }

   createFrame(title) {
      this.beforeCreateFrame(title);

      let frame =
         this.jsdom_body.append('div')
             .style('visible', 'hidden')
             .attr('width', this.width).attr('height', this.height)
             .style('width', this.width + 'px').style('height', this.height + 'px')
             .attr('id','jsroot_batch_' + this.frames.length)
             .attr('frame_title', title);

      if (this.frames.length == 0)
         internals.svg_3ds = undefined;

      this.frames.push(frame.node());

      return this.afterCreateFrame(frame.node());
   }

   /** @summary Returns number of created frames */
   numFrames() { return this.frames.length; }

   /** @summary returns JSON representation if any
     * @desc Now works only for inspector, can be called once */
   makeJSON(id, spacing) {
      let frame = this.frames[id];
      if (!frame) return;
      let obj = select(frame).property('_json_object_');
      if (obj) {
         select(frame).property('_json_object_', null);
         return toJSON(obj, spacing);
      }
   }

   /** @summary Create SVG for specified frame id */
   makeSVG(id) {
      let frame = this.frames[id];
      if (!frame) return;
      let main = select(frame);
      let has_workarounds = internals.svg_3ds && internals.processSvgWorkarounds;
      main.select('svg')
          .attr('xmlns', 'http://www.w3.org/2000/svg')
          .attr('xmlns:xlink', 'http://www.w3.org/1999/xlink')
          .attr('width', this.width)
          .attr('height', this.height)
          .attr('title', null).attr('style', null).attr('class', null).attr('x', null).attr('y', null);

      let svg = main.html();
      if (has_workarounds)
         svg = internals.processSvgWorkarounds(svg, id != this.frames.length-1);

      svg = compressSVG(svg);

      main.remove();
      return svg;
   }

} // class BatchDisplay


/**
  * @summary Special browser layout
  *
  * @desc Contains three different areas for browser (left), status line (bottom) and central drawing
  * Main application is normal browser, but also used in other applications like ROOT6 canvas
  * @private
  */

class BrowserLayout {

   /** @summary Constructor */
   constructor(id, hpainter, objpainter) {
      this.gui_div = id;
      this.hpainter = hpainter; // painter for brwoser area (if any)
      this.objpainter = objpainter; // painter for object area (if any)
      this.browser_kind = null; // should be 'float' or 'fix'
   }

   /** @summary Selects main element */
   main() { return select('#' + this.gui_div); }

   /** @summary Selects browser div */
   browser() { return this.main().select('.jsroot_browser'); }

   /** @summary Selects drawing div */
   drawing() { return select(`#${this.gui_div}_drawing`); }

   /** @summary Selects drawing div */
   status() { return select(`#${this.gui_div}_status`); }

   /** @summary Returns drawing divid */
   drawing_divid() { return this.gui_div + '_drawing'; }

   /** @summary Check resize action */
   checkResize() {
      if (isFunc(this.hpainter?.checkResize))
         this.hpainter.checkResize();
      else if (isFunc(this.objpainter?.checkResize)) {
         this.objpainter.checkResize(true);
      }
   }

   /** @summary Create or update CSS style */
   createStyle() {
      let bkgr_color = settings.DarkMode ? 'black' : '#E6E6FA',
          title_color = settings.DarkMode ? '#ccc' : 'inherit',
          text_color = settings.DarkMode ? '#ddd' : 'inherit',
          input_style = settings.DarkMode ? `background-color: #222; color: ${text_color}` : '';

      injectStyle(
         `.jsroot_browser { pointer-events: none; position: absolute; left: 0; top: 0; bottom: 0; right:0; margin: 0; border: 0; overflow: hidden; }
          .jsroot_draw_area { background-color: ${bkgr_color}; overflow: hidden; margin: 0; border: 0; }
          .jsroot_browser_area { color: ${text_color}; background-color: ${bkgr_color}; font-size: 12px; font-family: Verdana; pointer-events: all; box-sizing: initial; }
          .jsroot_browser_area input { ${input_style} }
          .jsroot_browser_area select { ${input_style} }
          .jsroot_browser_title { font-family: Verdana; font-size: 20px; color: ${title_color}; }
          .jsroot_browser_btns { pointer-events: all; opacity: 0; display:flex; flex-direction: column; }
          .jsroot_browser_btns:hover { opacity: 0.3; }
          .jsroot_browser_area p { margin-top: 5px; margin-bottom: 5px; white-space: nowrap; }
          .jsroot_browser_hierarchy { flex: 1; margin-top: 2px; }
          .jsroot_status_area { background-color: ${bkgr_color}; overflow: hidden; font-size: 12px; font-family: Verdana; pointer-events: all; }
          .jsroot_float_browser { border: solid 3px white; }
          .jsroot_browser_resize { position: absolute; right: 3px; bottom: 3px; margin-bottom: 0px; margin-right: 0px; opacity: 0.5; cursor: se-resize; z-index: 1; }
          .jsroot_status_label { margin: 3px; margin-left: 5px; font-size: 14px; vertical-align: middle; white-space: nowrap; }
          .jsroot_separator { pointer-events: all; border: 0; margin: 0; padding: 0; }
          .jsroot_h_separator { cursor: ns-resize; background-color: azure; }
          .jsroot_v_separator { cursor: ew-resize; background-color: azure; }`, this.main().node(), 'browser_layout_style');
   }

   /** @summary method used to create basic elements
     * @desc should be called only once */
   create(with_browser) {
      let main = this.main();

      main.append('div').attr('id', this.drawing_divid())
                        .classed('jsroot_draw_area', true)
                        .style('position','absolute').style('left',0).style('top',0).style('bottom',0).style('right',0);

      if (with_browser) main.append('div').classed('jsroot_browser', true);

      this.createStyle();
   }

   /** @summary Create buttons in the layout */
   createBrowserBtns() {
      let br = this.browser();
      if (br.empty()) return;
      let btns = br.append('div').classed('jsroot_browser_btns', true).classed('jsroot', true);
      btns.style('position','absolute').style('left','7px').style('top','7px');
      if (browser$1.touches) btns.style('opacity','0.2'); // on touch devices should be always visible
      return btns;
   }

   /** @summary Remove browser buttons */
   removeBrowserBtns() {
      this.browser().select('.jsroot_browser_btns').remove();
   }

   /** @summary Set browser content */
   setBrowserContent(guiCode) {
      let main = this.browser();
      if (main.empty()) return;

      main.insert('div', '.jsroot_browser_btns').classed('jsroot_browser_area', true)
          .style('position','absolute').style('left',0).style('top',0).style('bottom',0).style('width','250px')
          .style('overflow', 'hidden')
          .style('padding-left','5px')
          .style('display','flex').style('flex-direction', 'column')   /* use the flex model */
          .html(`<p class='jsroot_browser_title'>title</p><div class='jsroot_browser_resize' style='display:none'>&#9727</div>${guiCode}`);
   }

   /** @summary Check if there is browser content */
   hasContent() {
      let main = this.browser();
      return main.empty() ? false : !main.select('.jsroot_browser_area').empty();
   }

   /** @summary Delete content */
   deleteContent(keep_status) {
      let main = this.browser();
      if (main.empty()) return;

      if (!keep_status)
         this.createStatusLine(0, 'delete');

      this.toggleBrowserVisisbility(true);

      if (keep_status) {
         // try to delete only content, not status
         main.select('.jsroot_browser_area').remove();
         main.select('.jsroot_browser_btns').remove();
         main.select('.jsroot_v_separator').remove();
      } else {
         main.selectAll('*').remove();
      }
      delete this.browser_visible;
      delete this.browser_kind;

      this.checkResize();
   }

   /** @summary Returns true when status line exists */
   hasStatus() {
      let main = this.browser();
      return main.empty() ? false : !this.status().empty();
   }

   /** @summary Set browser title text
     * @desc Title also used for dragging of the float browser */
   setBrowserTitle(title) {
      let main = this.browser(),
          elem = !main.empty() ? main.select('.jsroot_browser_title') : null;
      if (elem) elem.text(title).style('cursor',this.browser_kind == 'flex' ? 'move' : null);
      return elem;
   }

   /** @summary Toggle browser kind
     * @desc used together with browser buttons */
   toggleKind(browser_kind) {
      if (this.browser_visible !== 'changing') {
         if (browser_kind === this.browser_kind) this.toggleBrowserVisisbility();
                                            else this.toggleBrowserKind(browser_kind);
      }
   }

   /** @summary Creates status line */
   async createStatusLine(height, mode) {

      let main = this.browser();
      if (main.empty())
         return '';

      let id = this.gui_div + '_status',
          line = select('#'+id),
          is_visible = !line.empty();

      if (mode === 'toggle') {
         mode = !is_visible;
      } else if (mode === 'delete') {
         mode = false; height = 0; delete this.status_layout;
      } else if (mode === undefined) {
         mode = true; this.status_layout = 'app';
      }

      if (is_visible) {
         if (mode === true)
            return id;

         let hsepar = main.select('.jsroot_h_separator');

         hsepar.remove();
         line.remove();

         if (this.status_layout !== 'app')
            delete this.status_layout;

         if (this.status_handler && (internals.showStatus === this.status_handler)) {
            delete internals.showStatus;
            delete this.status_handler;
         }

         this.adjustSeparators(null, 0, true);
         return '';
      }

      if (mode === false)
         return '';

      let left_pos = this.drawing().style('left');

      main.insert('div','.jsroot_browser_area')
          .attr('id',id)
          .classed('jsroot_status_area', true)
          .style('position','absolute').style('left',left_pos).style('height','20px').style('bottom',0).style('right',0)
          .style('margin',0).style('border',0);

      let hsepar = main.insert('div','.jsroot_browser_area')
                       .classed('jsroot_separator', true).classed('jsroot_h_separator', true)
                       .style('position','absolute').style('left',left_pos).style('right',0).style('bottom','20px').style('height','5px');

      let drag_move = drag().on('start', () => {
          this._hsepar_move = this._hsepar_position;
          hsepar.style('background-color', 'grey');
      }).on('drag', evnt => {
          this._hsepar_move -= evnt.dy; // hsepar is position from bottom
          this.adjustSeparators(null, Math.max(5, Math.round(this._hsepar_move)));
      }).on('end', () => {
          delete this._hsepar_move;
          hsepar.style('background-color', null);
          this.checkResize();
      });

      hsepar.call(drag_move);

      // need to get touches events handling in drag
      if (browser$1.touches && !main.on('touchmove'))
         main.on('touchmove', function() { });

      if (!height || isStr(height)) height = this.last_hsepar_height || 20;

      this.adjustSeparators(null, height, true);

      if (this.status_layout == 'app')
         return id;

      this.status_layout = new GridDisplay(id, 'horizx4_1213');

      let frame_titles = ['object name', 'object title', 'mouse coordinates', 'object info'];
      for (let k = 0; k < 4; ++k)
         select(this.status_layout.getGridFrame(k))
           .attr('title', frame_titles[k]).style('overflow', 'hidden')
           .append('label').attr('class', 'jsroot_status_label');

      internals.showStatus = this.status_handler = this.showStatus.bind(this);

      return id;
   }

   /** @summary Adjust separator positions */
   adjustSeparators(vsepar, hsepar, redraw, first_time) {

      if (!this.gui_div) return;

      let main = this.browser(), w = 5;

      if ((hsepar === null) && first_time && !main.select('.jsroot_h_separator').empty()) {
         // if separator set for the first time, check if status line present
         hsepar = main.select('.jsroot_h_separator').style('bottom');
         if (isStr(hsepar) && (hsepar.length > 2) && (hsepar.indexOf('px') == hsepar.length-2))
            hsepar = hsepar.slice(0,hsepar.length-2);
         else
            hsepar = null;
      }

      if (hsepar !== null) {
         hsepar = parseInt(hsepar);
         let elem = main.select('.jsroot_h_separator'), hlimit = 0;

         if (!elem.empty()) {
            if (hsepar < 5) hsepar = 5;

            let maxh = main.node().clientHeight - w;
            if (maxh > 0) {
               if (hsepar < 0) hsepar += maxh;
               if (hsepar > maxh) hsepar = maxh;
            }

            this.last_hsepar_height = hsepar;
            elem.style('bottom', hsepar+'px').style('height', w+'px');
            this.status().style('height', hsepar+'px');
            hlimit = (hsepar+w) + 'px';
         }

         this._hsepar_position = hsepar;

         this.drawing().style('bottom', hlimit);
      }

      if (vsepar !== null) {
         vsepar = parseInt(vsepar);
         if (vsepar < 50) vsepar = 50;
         this._vsepar_position = vsepar;
         main.select('.jsroot_browser_area').style('width', (vsepar-5)+'px');
         this.drawing().style('left', (vsepar+w)+'px');
         main.select('.jsroot_h_separator').style('left', (vsepar+w)+'px');
         this.status().style('left', (vsepar+w)+'px');
         main.select('.jsroot_v_separator').style('left', vsepar+'px').style('width', w+'px');
      }

      if (redraw) this.checkResize();
   }

   /** @summary Show status information inside special fields of browser layout */
   showStatus(...msgs) {
      if (!this.status_layout) return;

      let maxh = 0;
      for (let n = 0; n < 4; ++n) {
         let lbl = this.status_layout.getGridFrame(n).querySelector('label');
         maxh = Math.max(maxh, lbl.clientHeight);
         lbl.innerHTML = msgs[n] || '';
      }

      if (!this.status_layout.first_check) {
         this.status_layout.first_check = true;
         if ((maxh > 5) && ((maxh > this.last_hsepar_height) || (maxh < this.last_hsepar_height+5)))
            this.adjustSeparators(null, maxh, true);
      }
   }

   /** @summary Toggle browser visibility */
   toggleBrowserVisisbility(fast_close) {
      if (!this.gui_div || isStr(this.browser_visible)) return;

      let main = this.browser(), area = main.select('.jsroot_browser_area');

      if (area.empty()) return;

      let vsepar = main.select('.jsroot_v_separator'),
          drawing = select(`#${this.gui_div}_drawing`),
          tgt = area.property('last_left'),
          tgt_separ = area.property('last_vsepar'),
          tgt_drawing = area.property('last_drawing');

      if (!this.browser_visible) {
         if (fast_close) return;
         area.property('last_left', null).property('last_vsepar',null).property('last_drawing', null);
      } else {
         area.property('last_left', area.style('left'));
         if (!vsepar.empty()) {
            area.property('last_vsepar', vsepar.style('left'));
            area.property('last_drawing', drawing.style('left'));
         }

         tgt = (-area.node().clientWidth - 10) + 'px';
         let mainw = main.node().clientWidth;

         if (vsepar.empty() && (area.node().offsetLeft > mainw/2))
            tgt = (mainw+10) + 'px';

         tgt_separ = '-10px';
         tgt_drawing = '0px';
      }

      let visible_at_the_end  = !this.browser_visible, _duration = fast_close ? 0 : 700;

      this.browser_visible = 'changing';

      area.transition().style('left', tgt).duration(_duration).on('end', () => {
         if (fast_close) return;
         this.browser_visible = visible_at_the_end;
         if (visible_at_the_end) this.setButtonsPosition();
      });

      if (!visible_at_the_end)
         main.select('.jsroot_browser_btns').transition().style('left', '7px').style('top', '7px').duration(_duration);

      if (!vsepar.empty()) {
         vsepar.transition().style('left', tgt_separ).duration(_duration);
         drawing.transition().style('left', tgt_drawing).duration(_duration).on('end', this.checkResize.bind(this));
      }

      if (this.status_layout && (this.browser_kind == 'fix')) {
         main.select('.jsroot_h_separator').transition().style('left', tgt_drawing).duration(_duration);
         main.select('.jsroot_status_area').transition().style('left', tgt_drawing).duration(_duration);
      }
   }

   /** @summary Adjust browser size */
   adjustBrowserSize(onlycheckmax) {
      if (!this.gui_div || (this.browser_kind !== 'float')) return;

      let main = this.browser();
      if (main.empty()) return;

      let area = main.select('.jsroot_browser_area'),
          cont = main.select('.jsroot_browser_hierarchy'),
          chld = select(cont.node().firstChild);

      if (onlycheckmax) {
         if (area.node().parentNode.clientHeight - 10 < area.node().clientHeight)
            area.style('bottom', '0px').style('top','0px');
         return;
      }

      if (chld.empty()) return;
      let h1 = cont.node().clientHeight,
          h2 = chld.node().clientHeight;

      if ((h2 !== undefined) && (h2 < h1*0.7)) area.style('bottom', '');
   }

   /** @summary Set buttons position */
   setButtonsPosition() {
      if (!this.gui_div) return;

      let main = this.browser(),
          btns = main.select('.jsroot_browser_btns'),
          top = 7, left = 7;

      if (btns.empty()) return;

      if (this.browser_visible) {
         let area = main.select('.jsroot_browser_area');

         top = area.node().offsetTop + 7;

         left = area.node().offsetLeft - main.node().offsetLeft + area.node().clientWidth - 27;
      }

      btns.style('left', left+'px').style('top', top+'px');
   }

   /** @summary Toggle browser kind */
   async toggleBrowserKind(kind) {

      if (!this.gui_div)
         return null;

      if (!kind) {
         if (!this.browser_kind)
            return null;
         kind = (this.browser_kind === 'float') ? 'fix' : 'float';
      }

      let main = this.browser(),
          area = main.select('.jsroot_browser_area');

      if (this.browser_kind === 'float') {
          area.style('bottom', '0px')
              .style('top', '0px')
              .style('width','').style('height','')
              .classed('jsroot_float_browser', false);

           //jarea.resizable('destroy')
           //     .draggable('destroy');
      } else if (this.browser_kind === 'fix') {
         main.select('.jsroot_v_separator').remove();
         area.style('left', '0px');
         this.drawing().style('left','0px'); // reset size
         main.select('.jsroot_h_separator').style('left','0px');
         this.status().style('left','0px'); // reset left
         this.checkResize();
      }

      this.browser_kind = kind;
      this.browser_visible = true;

      main.select('.jsroot_browser_resize').style('display', (kind === 'float') ? null : 'none');
      main.select('.jsroot_browser_title').style('cursor', (kind === 'float') ? 'move' : null);

      if (kind === 'float') {
         area.style('bottom', '40px').classed('jsroot_float_browser', true);
        let drag_move = drag().on('start', () => {
           let sl = area.style('left'), st = area.style('top');
           this._float_left = parseInt(sl.slice(0,sl.length-2));
           this._float_top = parseInt(st.slice(0,st.length-2));
           this._max_left = main.node().clientWidth - area.node().offsetWidth - 1;
           this._max_top = main.node().clientHeight - area.node().offsetHeight - 1;

        }).filter(evnt => {
            return main.select('.jsroot_browser_title').node() === evnt.target;
        }).on('drag', evnt => {
           this._float_left += evnt.dx;
           this._float_top += evnt.dy;

           area.style('left', Math.min(Math.max(0, this._float_left), this._max_left) + 'px')
               .style('top', Math.min(Math.max(0, this._float_top), this._max_top) + 'px');

           this.setButtonsPosition();
        });

        let drag_resize = drag().on('start', () => {
           let sw = area.style('width');
           this._float_width = parseInt(sw.slice(0,sw.length-2));
           this._float_height = area.node().clientHeight;
           this._max_width = main.node().clientWidth - area.node().offsetLeft - 1;
           this._max_height = main.node().clientHeight - area.node().offsetTop - 1;
        }).on('drag', evnt => {
           this._float_width += evnt.dx;
           this._float_height += evnt.dy;

           area.style('width', Math.min(Math.max(100, this._float_width), this._max_width) + 'px')
               .style('height', Math.min(Math.max(100, this._float_height), this._max_height) + 'px');

           this.setButtonsPosition();
        });

        main.call(drag_move);
        main.select('.jsroot_browser_resize').call(drag_resize);

        this.adjustBrowserSize();

     } else {

        area.style('left', 0).style('top', 0).style('bottom', 0).style('height', null);

        let vsepar =
           main.append('div')
               .classed('jsroot_separator', true).classed('jsroot_v_separator', true)
               .style('position', 'absolute').style('top',0).style('bottom',0);

        let drag_move = drag().on('start', () => {
            this._vsepar_move = this._vsepar_position;
            vsepar.style('background-color', 'grey');
        }).on('drag', evnt => {
            this._vsepar_move += evnt.dx;
            this.setButtonsPosition();
            this.adjustSeparators(Math.round(this._vsepar_move), null);
        }).on('end', () => {
            delete this._vsepar_move;
            vsepar.style('background-color', null);
            this.checkResize();
        });

        vsepar.call(drag_move);

        // need to get touches events handling in drag
        if (browser$1.touches && !main.on('touchmove'))
           main.on('touchmove', function() { });

        this.adjustSeparators(250, null, true, true);
     }

      this.setButtonsPosition();

      return this;
   }

} // class BrowserLayout

const clTButton = 'TButton';

function getButtonSize(handler, fact) {
   return Math.round((fact || 1) * (handler.iscan || !handler.has_canvas ? 16 : 12));
}

function toggleButtonsVisibility(handler, action) {
   let group = handler.getLayerSvg('btns_layer', handler.this_pad_name),
       btn = group.select("[name='Toggle']");

   if (btn.empty()) return;

   let state = btn.property('buttons_state');

   if (btn.property('timout_handler')) {
      if (action !== 'timeout') clearTimeout(btn.property('timout_handler'));
      btn.property('timout_handler', null);
   }

   let is_visible = false;
   switch(action) {
      case 'enable': is_visible = true; break;
      case 'enterbtn': return; // do nothing, just cleanup timeout
      case 'timeout': is_visible = false; break;
      case 'toggle':
         state = !state;
         btn.property('buttons_state', state);
         is_visible = state;
         break;
      case 'disable':
      case 'leavebtn':
         if (!state) btn.property('timout_handler', setTimeout(() => toggleButtonsVisibility(handler, 'timeout'), 1200));
         return;
   }

   group.selectAll('svg').each(function() {
      if (this !== btn.node())
         select(this).style('display', is_visible ? '' : 'none');
   });
}

let PadButtonsHandler = {

   alignButtons(btns, width, height) {
      let sz0 = getButtonSize(this, 1.25), nextx = (btns.property('nextx') || 0) + sz0, btns_x, btns_y;

      if (btns.property('vertical')) {
         btns_x = btns.property('leftside') ? 2 : (width - sz0);
         btns_y = height - nextx;
      } else {
         btns_x = btns.property('leftside') ? 2 : (width - nextx);
         btns_y = height - sz0;
      }

      btns.attr('transform', `translate(${btns_x},${btns_y})`);
   },

   findPadButton(keyname) {
      let group = this.getLayerSvg('btns_layer', this.this_pad_name), found_func = '';
      if (!group.empty())
         group.selectAll('svg').each(function() {
            if (select(this).attr('key') === keyname)
               found_func = select(this).attr('name');
         });

      return found_func;
   },

   removePadButtons() {
      let group = this.getLayerSvg('btns_layer', this.this_pad_name);
      if (!group.empty()) {
         group.selectAll('*').remove();
         group.property('nextx', null);
      }
   },

   showPadButtons() {
      let group = this.getLayerSvg('btns_layer', this.this_pad_name);
      if (group.empty()) return;

      // clean all previous buttons
      group.selectAll('*').remove();
      if (!this._buttons) return;

      let iscan = this.iscan || !this.has_canvas, ctrl,
          x = group.property('leftside') ? getButtonSize(this, 1.25) : 0, y = 0;

      if (this._fast_drawing) {
         ctrl = ToolbarIcons.createSVG(group, ToolbarIcons.circle, getButtonSize(this), 'enlargePad');
         ctrl.attr('name', 'Enlarge').attr('x', 0).attr('y', 0)
             .on('click', evnt => this.clickPadButton('enlargePad', evnt));
      } else {
         ctrl = ToolbarIcons.createSVG(group, ToolbarIcons.rect, getButtonSize(this), 'Toggle tool buttons');

         ctrl.attr('name', 'Toggle').attr('x', 0).attr('y', 0)
             .property('buttons_state', (settings.ToolBar !== 'popup'))
             .on('click', () => toggleButtonsVisibility(this, 'toggle'))
             .on('mouseenter', () => toggleButtonsVisibility(this, 'enable'))
             .on('mouseleave', () => toggleButtonsVisibility(this, 'disable'));

         for (let k = 0; k < this._buttons.length; ++k) {
            let item = this._buttons[k], btn = item.btn;

            if (isStr(btn))
               btn = ToolbarIcons[btn];
            if (!btn)
               btn = ToolbarIcons.circle;

            let svg = ToolbarIcons.createSVG(group, btn, getButtonSize(this),
                        item.tooltip + (iscan ? '' : (' on pad ' + this.this_pad_name)) + (item.keyname ? ' (keyshortcut ' + item.keyname + ')' : ''));

            if (group.property('vertical'))
                svg.attr('x', y).attr('y', x);
            else
               svg.attr('x', x).attr('y', y);

            svg.attr('name', item.funcname)
               .style('display', ctrl.property('buttons_state') ? '' : 'none')
               .on('mouseenter', () => toggleButtonsVisibility(this, 'enterbtn'))
               .on('mouseleave', () => toggleButtonsVisibility(this, 'leavebtn'));

            if (item.keyname) svg.attr('key', item.keyname);

            svg.on('click', evnt => this.clickPadButton(item.funcname, evnt));

            x += getButtonSize(this, 1.25);
         }
      }

      group.property('nextx', x);

      this.alignButtons(group, this.getPadWidth(), this.getPadHeight());

      if (group.property('vertical'))
         ctrl.attr('y', x);
      else if (!group.property('leftside'))
         ctrl.attr('x', x);
   },

   assign(painter) {
      Object.assign(painter, this);
   }

}; // PadButtonsHandler



// identifier used in TWebCanvas painter
const webSnapIds = { kNone: 0,  kObject: 1, kSVG: 2, kSubPad: 3, kColors: 4, kStyle: 5 };

/**
  * @summary Painter for TPad object
  * @private
  */

class TPadPainter extends ObjectPainter {

   /** @summary constructor
     * @param {object|string} dom - DOM element for drawing or element id
     * @param {object} pad - TPad object to draw
     * @param {boolean} [iscan] - if TCanvas object */
   constructor(dom, pad, iscan) {
      super(dom, pad);
      this.pad = pad;
      this.iscan = iscan; // indicate if working with canvas
      this.this_pad_name = '';
      if (!this.iscan && pad?.fName) {
         this.this_pad_name = pad.fName.replace(' ', '_'); // avoid empty symbol in pad name
         let regexp = new RegExp('^[A-Za-z][A-Za-z0-9_]*$');
         if (!regexp.test(this.this_pad_name) || ((this.this_pad_name == 'button') && (pad._typename == clTButton)))
            this.this_pad_name = 'jsroot_pad_' + internals.id_counter++;
      }
      this.painters = []; // complete list of all painters in the pad
      this.has_canvas = true;
      this.forEachPainter = this.forEachPainterInPad;
   }

   /** @summary Indicates that is is Root6 pad painter
    * @private */
   isRoot6() { return true; }

   /** @summary Returns SVG element for the pad itself
    * @private */
   svg_this_pad() {
      return this.getPadSvg(this.this_pad_name);
   }

   /** @summary Returns main painter on the pad
     * @desc Typically main painter is TH1/TH2 object which is drawing axes
    * @private */
   getMainPainter() {
      return this.main_painter_ref || null;
   }

   /** @summary Assign main painter on the pad
     * @desc Typically main painter is TH1/TH2 object which is drawing axes
    * @private */
   setMainPainter(painter, force) {
      if (!this.main_painter_ref || force)
         this.main_painter_ref = painter;
   }

   /** @summary cleanup pad and all primitives inside */
   cleanup() {
      if (this._doing_draw)
         console.error('pad drawing is not completed when cleanup is called');

      this.painters.forEach(p => p.cleanup());

      let svg_p = this.svg_this_pad();
      if (!svg_p.empty()) {
         svg_p.property('pad_painter', null);
         if (!this.iscan) svg_p.remove();
      }

      delete this.main_painter_ref;
      delete this.frame_painter_ref;
      delete this.pads_cache;
      delete this.custom_palette;
      delete this._pad_x;
      delete this._pad_y;
      delete this._pad_width;
      delete this._pad_height;
      delete this._doing_draw;
      delete this._interactively_changed;

      this.painters = [];
      this.pad = null;
      this.this_pad_name = undefined;
      this.has_canvas = false;

      selectActivePad({ pp: this, active: false });

      super.cleanup();
   }

   /** @summary Returns frame painter inside the pad
     * @private */
   getFramePainter() { return this.frame_painter_ref; }

   /** @summary get pad width */
   getPadWidth() { return this._pad_width || 0; }

   /** @summary get pad height */
   getPadHeight() { return this._pad_height || 0; }

   /** @summary get pad rect */
   getPadRect() {
      return {
         x: this._pad_x || 0,
         y: this._pad_y || 0,
         width: this.getPadWidth(),
         height: this.getPadHeight()
      }
   }

   /** @summary Returns frame coordiantes - also when frame is not drawn */
   getFrameRect() {
      let fp = this.getFramePainter();
      if (fp) return fp.getFrameRect();

      let w = this.getPadWidth(),
          h = this.getPadHeight(),
          rect = {};

      if (this.pad) {
         rect.szx = Math.round(Math.max(0.0, 0.5 - Math.max(this.pad.fLeftMargin, this.pad.fRightMargin))*w);
         rect.szy = Math.round(Math.max(0.0, 0.5 - Math.max(this.pad.fBottomMargin, this.pad.fTopMargin))*h);
      } else {
         rect.szx = Math.round(0.5*w);
         rect.szy = Math.round(0.5*h);
      }

      rect.width = 2*rect.szx;
      rect.height = 2*rect.szy;
      rect.x = Math.round(w/2 - rect.szx);
      rect.y = Math.round(h/2 - rect.szy);
      rect.hint_delta_x = rect.szx;
      rect.hint_delta_y = rect.szy;
      rect.transform = `translate(${rect.x},${rect.y})`;

      return rect;
   }

   /** @summary return RPad object */
   getRootPad(is_root6) {
      return (is_root6 === undefined) || is_root6 ? this.pad : null;
   }

   /** @summary Cleanup primitives from pad - selector lets define which painters to remove */
   cleanPrimitives(selector) {
      if (!isFunc(selector)) return;

      for (let k = this.painters.length-1; k >= 0; --k)
         if (selector(this.painters[k])) {
            this.painters[k].cleanup();
            this.painters.splice(k, 1);
         }
   }

  /** @summary returns custom palette associated with pad or top canvas
    * @private */
   getCustomPalette() {
      return this.custom_palette || this.getCanvPainter()?.custom_palette;
   }

   /** @summary Returns number of painters
     * @private */
   getNumPainters() { return this.painters.length; }

   /** @summary Call function for each painter in pad
     * @param {function} userfunc - function to call
     * @param {string} kind - 'all' for all objects (default), 'pads' only pads and subpads, 'objects' only for object in current pad
     * @private */
   forEachPainterInPad(userfunc, kind) {
      if (!kind) kind = 'all';
      if (kind != 'objects') userfunc(this);
      for (let k = 0; k < this.painters.length; ++k) {
         let sub = this.painters[k];
         if (isFunc(sub.forEachPainterInPad)) {
            if (kind != 'objects') sub.forEachPainterInPad(userfunc, kind);
         } else if (kind != 'pads') {
            userfunc(sub);
         }
      }
   }

   /** @summary register for pad events receiver
     * @desc in pad painter, while pad may be drawn without canvas */
   registerForPadEvents(receiver) {
      this.pad_events_receiver = receiver;
   }

   /** @summary Generate pad events, normally handled by GED
    * @desc in pad painter, while pad may be drawn without canvas
     * @private */
   producePadEvent(what, padpainter, painter, position, place) {

      if ((what == 'select') && isFunc(this.selectActivePad))
         this.selectActivePad(padpainter, painter, position);

      if (isFunc(this.pad_events_receiver))
         this.pad_events_receiver({ what, padpainter, painter, position, place });
   }

   /** @summary method redirect call to pad events receiver */
   selectObjectPainter(painter, pos, place) {
      let istoppad = this.iscan || !this.has_canvas,
          canp = istoppad ? this : this.getCanvPainter();

      if (painter === undefined) painter = this;

      if (pos && !istoppad)
         pos = getAbsPosInCanvas(this.svg_this_pad(), pos);

      selectActivePad({ pp: this, active: true });

      canp?.producePadEvent('select', this, painter, pos, place);
   }

   /** @summary Draw pad active border
    * @private */
   drawActiveBorder(svg_rect, is_active) {
      if (is_active !== undefined) {
         if (this.is_active_pad === is_active) return;
         this.is_active_pad = is_active;
      }

      if (this.is_active_pad === undefined) return;

      if (!svg_rect)
         svg_rect = this.iscan ? this.getCanvSvg().select('.canvas_fillrect') :
                                 this.svg_this_pad().select('.root_pad_border');

      let lineatt = this.is_active_pad ? new TAttLineHandler({ style: 1, width: 1, color: 'red' }) : this.lineatt;

      if (!lineatt) lineatt = new TAttLineHandler({ color: 'none' });

      svg_rect.call(lineatt.func);
   }

   /** @summary Create SVG element for canvas */
   createCanvasSvg(check_resize, new_size) {

      let factor = null, svg = null, lmt = 5, rect = null, btns, info, frect;

      if (check_resize > 0) {

         if (this._fixed_size) return (check_resize > 1); // flag used to force re-drawing of all subpads

         svg = this.getCanvSvg();

         if (svg.empty()) return false;

         factor = svg.property('height_factor');

         rect = this.testMainResize(check_resize, null, factor);

         if (!rect.changed) return false;

         if (!isBatchMode())
            btns = this.getLayerSvg('btns_layer', this.this_pad_name);

         info = this.getLayerSvg('info_layer', this.this_pad_name);
         frect = svg.select('.canvas_fillrect');

      } else {

         let render_to = this.selectDom();

         if (render_to.style('position') == 'static')
            render_to.style('position','relative');

         svg = render_to.append('svg')
             .attr('class', 'jsroot root_canvas')
             .property('pad_painter', this) // this is custom property
             .property('current_pad', '') // this is custom property
             .property('redraw_by_resize', false); // could be enabled to force redraw by each resize

         this.setTopPainter(); //assign canvas as top painter of that element

         if (isBatchMode()) {
            svg.attr('xmlns', 'http://www.w3.org/2000/svg');
            svg.attr('xmlns:xlink', 'http://www.w3.org/1999/xlink');
         } else if (!this.online_canvas) {
            svg.append('svg:title').text('ROOT canvas');
         }

         if (!isBatchMode() || (this.pad.fFillStyle > 0))
            frect = svg.append('svg:path').attr('class','canvas_fillrect');

         if (!isBatchMode())
            frect.style('pointer-events', 'visibleFill')
                 .on('dblclick', evnt => this.enlargePad(evnt))
                 .on('click', () => this.selectObjectPainter())
                 .on('mouseenter', () => this.showObjectStatus())
                 .on('contextmenu', settings.ContextMenu ? evnt => this.padContextMenu(evnt) : null);

         svg.append('svg:g').attr('class','primitives_layer');
         info = svg.append('svg:g').attr('class', 'info_layer');
         if (!isBatchMode())
            btns = svg.append('svg:g')
                      .attr('class','btns_layer')
                      .property('leftside', settings.ToolBarSide == 'left')
                      .property('vertical', settings.ToolBarVert);

         factor = 0.66;
         if (this.pad?.fCw && this.pad?.fCh && (this.pad?.fCw > 0)) {
            factor = this.pad.fCh / this.pad.fCw;
            if ((factor < 0.1) || (factor > 10)) factor = 0.66;
         }

         if (this._fixed_size) {
            render_to.style('overflow','auto');
            rect = { width: this.pad.fCw, height: this.pad.fCh };
            if (!rect.width || !rect.height)
               rect = getElementRect(render_to);
         } else {
            rect = this.testMainResize(2, new_size, factor);
         }
      }

      this.createAttFill({ attr: this.pad });

      if ((rect.width <= lmt) || (rect.height <= lmt)) {
         svg.style('display', 'none');
         console.warn(`Hide canvas while geometry too small w=${rect.width} h=${rect.height}`);
         rect.width = 200; rect.height = 100; // just to complete drawing
      } else {
         svg.style('display', null);
      }

      svg.attr('x', 0).attr('y', 0).style('position', 'absolute');

      if (this._fixed_size)
         svg.attr('width', rect.width).attr('height', rect.height);
      else
        svg.style('width', '100%').style('height', '100%')
           .style('left', 0).style('top', 0).style('right', 0).style('bottom', 0);

      svg.style('filter', settings.DarkMode || this.pad?.$dark ? 'invert(100%)' : null);

      svg.attr('viewBox', `0 0 ${rect.width} ${rect.height}`)
         .attr('preserveAspectRatio', 'none')  // we do not preserve relative ratio
         .property('height_factor', factor)
         .property('draw_x', 0)
         .property('draw_y', 0)
         .property('draw_width', rect.width)
         .property('draw_height', rect.height);

      this._pad_x = 0;
      this._pad_y = 0;
      this._pad_width = rect.width;
      this._pad_height = rect.height;

      if (frect) {
         frect.attr('d', `M0,0H${rect.width}V${rect.height}H0Z`)
              .call(this.fillatt.func);
         this.drawActiveBorder(frect);
      }

      this._fast_drawing = settings.SmallPad && ((rect.width < settings.SmallPad.width) || (rect.height < settings.SmallPad.height));

      if (this.alignButtons && btns)
         this.alignButtons(btns, rect.width, rect.height);

      let dt = info.select('.canvas_date');
      if (!gStyle.fOptDate) {
         dt.remove();
      } else {
         if (dt.empty()) dt = info.append('text').attr('class', 'canvas_date');
         let date = new Date(),
             posx = Math.round(rect.width * gStyle.fDateX),
             posy = Math.round(rect.height * (1 - gStyle.fDateY));
         if (!isBatchMode() && (posx < 25)) posx = 25;
         if (gStyle.fOptDate > 1) date.setTime(gStyle.fOptDate*1000);
         dt.attr('transform', `translate(${posx}, ${posy})`)
           .style('text-anchor', 'start')
           .text(date.toLocaleString('en-GB'));
      }

      if (!gStyle.fOptFile || !this.getItemName())
         info.select('.canvas_item').remove();
      else
         this.drawItemNameOnCanvas(this.getItemName());

      return true;
   }

   /** @summary Draw item name on canvas if gStyle.fOptFile is configured
     * @private */
   drawItemNameOnCanvas(item_name) {
      let info = this.getLayerSvg('info_layer', this.this_pad_name),
          df = info.select('.canvas_item');
      if (!gStyle.fOptFile || !item_name) {
         df.remove();
      } else {
         if (df.empty()) df = info.append('text').attr('class', 'canvas_item');
         let rect = this.getPadRect(),
             posx = Math.round(rect.width * (1 - gStyle.fDateX)),
             posy = Math.round(rect.height * (1 - gStyle.fDateY));
         df.attr('transform', `translate(${posx}, ${posy})`)
           .style('text-anchor', 'end')
           .text(item_name);
      }
   }

   /** @summary Enlarge pad draw element when possible */
   enlargePad(evnt) {

      if (evnt) {
         evnt.preventDefault();
         evnt.stopPropagation();
      }

      let svg_can = this.getCanvSvg(),
          pad_enlarged = svg_can.property('pad_enlarged');

      if (this.iscan || !this.has_canvas || (!pad_enlarged && !this.hasObjectsToDraw() && !this.painters)) {
         if (this._fixed_size) return; // canvas cannot be enlarged in such mode
         if (!this.enlargeMain('toggle')) return;
         if (this.enlargeMain('state') == 'off') svg_can.property('pad_enlarged', null);
      } else if (!pad_enlarged) {
         this.enlargeMain(true, true);
         svg_can.property('pad_enlarged', this.pad);
      } else if (pad_enlarged === this.pad) {
         this.enlargeMain(false);
         svg_can.property('pad_enlarged', null);
      } else {
         console.error('missmatch with pad double click events');
      }

      let was_fast = this._fast_drawing;

      this.checkResize(true);

      if (this._fast_drawing != was_fast)
         this.showPadButtons();
   }

   /** @summary Create main SVG element for pad
     * @return true when pad is displayed and all its items should be redrawn */
   createPadSvg(only_resize) {

      if (!this.has_canvas) {
         this.createCanvasSvg(only_resize ? 2 : 0);
         return true;
      }

      let svg_can = this.getCanvSvg(),
          width = svg_can.property('draw_width'),
          height = svg_can.property('draw_height'),
          pad_enlarged = svg_can.property('pad_enlarged'),
          pad_visible = !this.pad_draw_disabled && (!pad_enlarged || (pad_enlarged === this.pad)),
          w = Math.round(this.pad.fAbsWNDC * width),
          h = Math.round(this.pad.fAbsHNDC * height),
          x = Math.round(this.pad.fAbsXlowNDC * width),
          y = Math.round(height * (1 - this.pad.fAbsYlowNDC)) - h,
          svg_pad = null, svg_rect = null, btns = null;

      if (pad_enlarged === this.pad) { w = width; h = height; x = y = 0; }

      if (only_resize) {
         svg_pad = this.svg_this_pad();
         svg_rect = svg_pad.select('.root_pad_border');
         if (!isBatchMode())
            btns = this.getLayerSvg('btns_layer', this.this_pad_name);
      } else {
         svg_pad = svg_can.select('.primitives_layer')
             .append('svg:svg') // svg used to blend all drawings outside
             .classed('__root_pad_' + this.this_pad_name, true)
             .attr('pad', this.this_pad_name) // set extra attribute  to mark pad name
             .property('pad_painter', this); // this is custom property

         if (!isBatchMode())
            svg_pad.append('svg:title').text('subpad ' + this.this_pad_name);

         // need to check attributes directly while attributes objects will be created later
         if (!isBatchMode() || (this.pad.fFillStyle > 0) || ((this.pad.fLineStyle > 0) && (this.pad.fLineColor > 0)))
            svg_rect = svg_pad.append('svg:path').attr('class', 'root_pad_border');

         if (!isBatchMode())
            svg_rect.style('pointer-events', 'visibleFill') // get events also for not visible rect
                    .on('dblclick', evnt => this.enlargePad(evnt))
                    .on('click', () => this.selectObjectPainter())
                    .on('mouseenter', () => this.showObjectStatus())
                    .on('contextmenu', settings.ContextMenu ? evnt => this.padContextMenu(evnt) : null);

         svg_pad.append('svg:g').attr('class','primitives_layer');
         if (!isBatchMode())
            btns = svg_pad.append('svg:g')
                          .attr('class','btns_layer')
                          .property('leftside', settings.ToolBarSide != 'left')
                          .property('vertical', settings.ToolBarVert);
      }

      this.createAttFill({ attr: this.pad });
      this.createAttLine({ attr: this.pad, color0: this.pad.fBorderMode == 0 ? 'none' : '' });

      svg_pad.style('display', pad_visible ? null : 'none')
             .attr('viewBox', `0 0 ${w} ${h}`) // due to svg
             .attr('preserveAspectRatio', 'none')   // due to svg, we do not preserve relative ratio
             .attr('x', x)        // due to svg
             .attr('y', y)        // due to svg
             .attr('width', w)    // due to svg
             .attr('height', h)   // due to svg
             .property('draw_x', x) // this is to make similar with canvas
             .property('draw_y', y)
             .property('draw_width', w)
             .property('draw_height', h);

      this._pad_x = x;
      this._pad_y = y;
      this._pad_width = w;
      this._pad_height = h;

      if (svg_rect) {
         svg_rect.attr('d', `M0,0H${w}V${h}H0Z`)
                 .call(this.fillatt.func)
                 .call(this.lineatt.func);

         this.drawActiveBorder(svg_rect);
      }

      this._fast_drawing = settings.SmallPad && ((w < settings.SmallPad.width) || (h < settings.SmallPad.height));

      // special case of 3D canvas overlay
      if (svg_pad.property('can3d') === constants$1.Embed3D.Overlay)
          this.selectDom().select('.draw3d_' + this.this_pad_name)
              .style('display', pad_visible ? '' : 'none');

      if (this.alignButtons && btns)
         this.alignButtons(btns, w, h);

      return pad_visible;
   }

   /** @summary Disable pad drawing
     * @desc Complete SVG element will be hidden */
   disablePadDrawing() {
      if (!this.pad_draw_disabled && this.has_canvas && !this.iscan) {
         this.pad_draw_disabled = true;
         this.createPadSvg(true);
      }
   }

   /** @summary Check if it is special object, which should be handled separately
     * @desc It can be TStyle or list of colors or palette object
     * @return {boolean} tru if any */
   checkSpecial(obj) {

      if (!obj) return false;

      if (obj._typename == clTStyle) {
         Object.assign(gStyle, obj);
         return true;
      }

      if ((obj._typename == clTObjArray) && (obj.name == 'ListOfColors')) {

         if (this.options && this.options.CreatePalette) {
            let arr = [];
            for (let n = obj.arr.length - this.options.CreatePalette; n<obj.arr.length; ++n) {
               let col = getRGBfromTColor(obj.arr[n]);
               if (!col) { console.log('Fail to create color for palette'); arr = null; break; }
               arr.push(col);
            }
            if (arr) this.custom_palette = new ColorPalette(arr);
         }

         if (!this.options || this.options.GlobalColors) // set global list of colors
            adoptRootColors(obj);

         // copy existing colors and extend with new values
         if (this.options && this.options.LocalColors)
            this.root_colors = extendRootColors(null, obj);
         return true;
      }

      if ((obj._typename == clTObjArray) && (obj.name == 'CurrentColorPalette')) {
         let arr = [], missing = false;
         for (let n = 0; n < obj.arr.length; ++n) {
            let col = obj.arr[n];
            if (col?._typename == clTColor) {
               arr[n] = getRGBfromTColor(col);
            } else {
               console.log(`Missing color with index ${n}`); missing = true;
            }
         }
         if (!this.options || (!missing && !this.options.IgnorePalette))
            this.custom_palette = new ColorPalette(arr);
         return true;
      }

      return false;
   }

   /** @summary Check if special objects appears in primitives
     * @desc it could be list of colors or palette */
   checkSpecialsInPrimitives(can) {
      let lst = can?.fPrimitives;
      if (!lst) return;
      for (let i = 0; i < lst.arr.length; ++i) {
         if (this.checkSpecial(lst.arr[i])) {
            lst.arr.splice(i,1);
            lst.opt.splice(i,1);
            i--;
         }
      }
   }

   /** @summary try to find object by name in list of pad primitives
     * @desc used to find title drawing
     * @private */
   findInPrimitives(objname, objtype) {
      let arr = this.pad?.fPrimitives?.arr;

      return arr ? arr.find(obj => (obj.fName == objname) && (objtype ? (obj.typename == objtype) : true)) : null;
   }

   /** @summary Try to find painter for specified object
     * @desc can be used to find painter for some special objects, registered as
     * histogram functions
     * @param {object} selobj - object to which painter should be search, set null to ignore parameter
     * @param {string} [selname] - object name, set to null to ignore
     * @param {string} [seltype] - object type, set to null to ignore
     * @return {object} - painter for specified object (if any)
     * @private */
   findPainterFor(selobj, selname, seltype) {
      return this.painters.find(p => {
         let pobj = p.getObject();
         if (!pobj) return;

         if (selobj && (pobj === selobj)) return true;
         if (!selname && !seltype) return;
         if (selname && (pobj.fName !== selname)) return;
         if (seltype && (pobj._typename !== seltype)) return;
         return true;
      });
   }

   /** @summary Return true if any objects beside sub-pads exists in the pad */
   hasObjectsToDraw() {
      let arr = this.pad?.fPrimitives?.arr;
      return arr && arr.find(obj => obj._typename != clTPad) ? true : false;
   }

   /** @summary sync drawing/redrawing/resize of the pad
     * @param {string} kind - kind of draw operation, if true - always queued
     * @return {Promise} when pad is ready for draw operation or false if operation already queued
     * @private */
   syncDraw(kind) {
      let entry = { kind : kind || 'redraw' };
      if (this._doing_draw === undefined) {
         this._doing_draw = [ entry ];
         return Promise.resolve(true);
      }
      // if queued operation registered, ignore next calls, indx == 0 is running operation
      if ((entry.kind !== true) && (this._doing_draw.findIndex((e,i) => (i > 0) && (e.kind == entry.kind)) > 0))
         return false;
      this._doing_draw.push(entry);
      return new Promise(resolveFunc => {
         entry.func = resolveFunc;
      });
   }

   /** @summary indicates if painter performing objects draw
     * @private */
   doingDraw() {
      return this._doing_draw !== undefined;
   }

   /** @summary confirms that drawing is completed, may trigger next drawing immediately
     * @private */
   confirmDraw() {
      if (this._doing_draw === undefined)
         return console.warn('failure, should not happen');
      this._doing_draw.shift();
      if (this._doing_draw.length == 0) {
         delete this._doing_draw;
      } else {
         let entry = this._doing_draw[0];
         if(entry.func) { entry.func(); delete entry.func; }
      }
   }

   /** @summary Draw single primitive */
   async drawObject(/* dom, obj, opt */) {
      console.log('Not possible to draw object without loading of draw.mjs');
      return null;
   }

   /** @summary Draw pad primitives
     * @return {Promise} when drawing completed
     * @private */
   async drawPrimitives(indx) {

      if (indx === undefined) {
         if (this.iscan)
            this._start_tm = new Date().getTime();

         // set number of primitves
         this._num_primitives = this.pad?.fPrimitives?.arr?.length || 0;

         // sync to prevent immediate pad redraw during normal drawing sequence
         return this.syncDraw(true).then(() => this.drawPrimitives(0));
      }

      if (indx >= this._num_primitives) {
         if (this._start_tm) {
            let spenttm = new Date().getTime() - this._start_tm;
            if (spenttm > 1000) console.log(`Canvas ${this.pad?.fName || '---'} drawing took ${(spenttm*1e-3).toFixed(2)}s`);
            delete this._start_tm;
         }

         this.confirmDraw();
         return;
      }

      // use of Promise should avoid large call-stack depth when many primitives are drawn
      return this.drawObject(this.getDom(), this.pad.fPrimitives.arr[indx], this.pad.fPrimitives.opt[indx]).then(op => {
         if (isObject(op))
            op._primitive = true; // mark painter as belonging to primitives

         return this.drawPrimitives(indx+1);
      });
   }

   /** @summary Divide pad on subpads
     * @return {Promise} when finished
     * @private */
   async divide(nx, ny) {
      if (!ny) {
         let ndiv = nx;
         if (ndiv < 2) return this;
         nx = ny = Math.round(Math.sqrt(ndiv));
         if (nx*ny < ndiv) nx += 1;
      }

      if (nx*ny < 2) return this;

      let xmargin = 0.01, ymargin = 0.01,
          dy = 1/ny, dx = 1/nx, n = 0, subpads = [];
      for (let iy = 0; iy < ny; iy++) {
         let y2 = 1 - iy*dy - ymargin,
             y1 = y2 - dy + 2*ymargin;
         if (y1 < 0) y1 = 0;
         if (y1 > y2) continue;
         for (let ix = 0; ix < nx; ix++) {
            let x1 = ix*dx + xmargin,
                x2 = x1 +dx -2*xmargin;
            if (x1 > x2) continue;
            n++;
            let pad = create$1(clTPad);
            pad.fName = pad.fTitle = `${this.pad.fName}_${n}`;
            pad.fNumber = n;
            if (!this.iscan) {
               pad.fAbsWNDC = (x2-x1) * this.pad.fAbsWNDC;
               pad.fAbsHNDC = (y2-y1) * this.pad.fAbsHNDC;
               pad.fAbsXlowNDC = this.pad.fAbsXlowNDC + x1 * this.pad.fAbsWNDC;
               pad.fAbsYlowNDC = this.pad.fAbsYlowNDC + y1 * this.pad.fAbsWNDC;
            } else {
               pad.fAbsWNDC = x2 - x1;
               pad.fAbsHNDC = y2 - y1;
               pad.fAbsXlowNDC = x1;
               pad.fAbsYlowNDC = y1;
            }

            subpads.push(pad);
         }
      }

      const drawNext = () => {
         if (subpads.length == 0)
            return this;
         return this.drawObject(this.getDom(), subpads.shift()).then(drawNext);
      };

      return drawNext();
   }

   /** @summary Return sub-pads painter, only direct childs are checked
     * @private */
   getSubPadPainter(n) {
      for (let k = 0; k < this.painters.length; ++k) {
         let sub = this.painters[k];
         if (sub.pad && isFunc(sub.forEachPainterInPad) && (sub.pad.fNumber === n)) return sub;
      }
      return null;
   }


   /** @summary Process tooltip event in the pad
     * @private */
   processPadTooltipEvent(pnt) {
      let painters = [], hints = [];

      // first count - how many processors are there
      if (this.painters !== null)
         this.painters.forEach(obj => {
            if (isFunc(obj.processTooltipEvent))
               painters.push(obj);
         });

      if (pnt) pnt.nproc = painters.length;

      painters.forEach(obj => {
         let hint = obj.processTooltipEvent(pnt);
         if (!hint) hint = { user_info: null };
         hints.push(hint);
         if (pnt && pnt.painters) hint.painter = obj;
      });

      return hints;
   }

   /** @summary Changes canvas dark mode
     * @private */
   changeDarkMode(mode) {
      this.getCanvSvg().style('filter', (mode ?? settings.DarkMode) ? 'invert(100%)' : null);
   }

   /** @summary Fill pad context menu
     * @private */
   fillContextMenu(menu) {

      if (this.pad)
         menu.add(`header:${this.pad._typename}::${this.pad.fName}`);
      else
         menu.add('header:Canvas');

      menu.addchk(this.isTooltipAllowed(), 'Show tooltips', () => this.setTooltipAllowed('toggle'));

      if (!this._websocket) {

         function SetPadField(arg) {
            this.pad[arg.slice(1)] = parseInt(arg[0]);
            this.interactiveRedraw('pad', arg.slice(1));
         }

         menu.addchk(this.pad.fGridx, 'Grid x', (this.pad.fGridx ? '0' : '1') + 'fGridx', SetPadField);
         menu.addchk(this.pad.fGridy, 'Grid y', (this.pad.fGridy ? '0' : '1') + 'fGridy', SetPadField);
         menu.add('sub:Ticks x');
         menu.addchk(this.pad.fTickx == 0, 'normal', '0fTickx', SetPadField);
         menu.addchk(this.pad.fTickx == 1, 'ticks on both sides', '1fTickx', SetPadField);
         menu.addchk(this.pad.fTickx == 2, 'labels on both sides', '2fTickx', SetPadField);
         menu.add('endsub:');
         menu.add('sub:Ticks y');
         menu.addchk(this.pad.fTicky == 0, 'normal', '0fTicky', SetPadField);
         menu.addchk(this.pad.fTicky == 1, 'ticks on both sides', '1fTicky', SetPadField);
         menu.addchk(this.pad.fTicky == 2, 'labels on both sides', '2fTicky', SetPadField);
         menu.add('endsub:');

         menu.addAttributesMenu(this);
         menu.add('Save to gStyle', function() {
            if (this.fillatt) this.fillatt.saveToStyle(this.iscan ? 'fCanvasColor' : 'fPadColor');
            gStyle.fPadGridX = this.pad.fGridX;
            gStyle.fPadGridY = this.pad.fGridX;
            gStyle.fPadTickX = this.pad.fTickx;
            gStyle.fPadTickY = this.pad.fTicky;
            gStyle.fOptLogx = this.pad.fLogx;
            gStyle.fOptLogy = this.pad.fLogy;
            gStyle.fOptLogz = this.pad.fLogz;
         }, 'Store pad fill attributes, grid, tick and log scale settings to gStyle');

         if (this.iscan)
            menu.addSettingsMenu(false, false, arg => {
               if (arg == 'dark') this.changeDarkMode();
            });
      }

      menu.add('separator');

      if (isFunc(this.hasMenuBar) && isFunc(this.actiavteMenuBar))
         menu.addchk(this.hasMenuBar(), 'Menu bar', flag => this.actiavteMenuBar(flag));

      if (isFunc(this.hasEventStatus) && isFunc(this.activateStatusBar))
         menu.addchk(this.hasEventStatus(), 'Event status', () => this.activateStatusBar('toggle'));

      if (this.enlargeMain() || (this.has_canvas && this.hasObjectsToDraw()))
         menu.addchk(this.enlargeMain('state') == 'on', 'Enlarge ' + (this.iscan ? 'canvas' : 'pad'), () => this.enlargePad());

      let fname = this.this_pad_name || (this.iscan ? 'canvas' : 'pad');
      menu.add(`Save as ${fname}.png`, fname+'.png', arg => this.saveAs('png', this.iscan, arg));
      menu.add(`Save as ${fname}.svg`, fname+'.svg', arg => this.saveAs('svg', this.iscan, arg));

      return true;
   }

   /** @summary Show pad context menu
     * @private */
   padContextMenu(evnt) {

      if (evnt.stopPropagation) { // this is normal event processing and not emulated jsroot event

         // for debug purposes keep original context menu for small region in top-left corner
         let pos = pointer(evnt, this.svg_this_pad().node());

         if ((pos.length == 2) && (pos[0] >= 0) && (pos[0] < 10) && (pos[1] >= 0) && (pos[1] < 10)) return;

         evnt.stopPropagation(); // disable main context menu
         evnt.preventDefault();  // disable browser context menu

         this.getFramePainter()?.setLastEventPos();
      }

      createMenu$1(evnt, this).then(menu => {
         this.fillContextMenu(menu);
         return this.fillObjectExecMenu(menu, '');
      }).then(menu => menu.show());
   }

   /** @summary Redraw pad means redraw ourself
     * @return {Promise} when redrawing ready */
   async redrawPad(reason) {

      let sync_promise = this.syncDraw(reason);
      if (sync_promise === false) {
         console.log(`Prevent redrawing of ${this.pad.fName}`);
         return false;
      }

      let showsubitems = true;
      const redrawNext = indx => {
         while (indx < this.painters.length) {
            let sub = this.painters[indx++], res = 0;
            if (showsubitems || sub.this_pad_name)
               res = sub.redraw(reason);

            if (isPromise(res))
               return res.then(() => redrawNext(indx));
         }
         return true;
      };

      return sync_promise.then(() => {
         if (this.iscan)
            this.createCanvasSvg(2);
         else
            showsubitems = this.createPadSvg(true);
         return redrawNext(0);
      }).then(() => {
         this.confirmDraw();
         if (getActivePad() === this)
            this.getCanvPainter()?.producePadEvent('padredraw', this);
         return true;
      });
   }

   /** @summary redraw pad */
   redraw(reason) {
      // intentially do not return Promise to let re-draw sub-pads in parallel
      this.redrawPad(reason);
   }

   /** @summary Checks if pad should be redrawn by resize
     * @private */
   needRedrawByResize() {
      let elem = this.svg_this_pad();
      if (!elem.empty() && elem.property('can3d') === constants$1.Embed3D.Overlay) return true;

      return this.painters.findIndex(objp => {
         if (isFunc(objp.needRedrawByResize))
            return objp.needRedrawByResize();
      }) >= 0;
   }

   /** @summary Check resize of canvas
     * @return {Promise} with result */
   checkCanvasResize(size, force) {

      if (!this.iscan && this.has_canvas) return false;

      let sync_promise = this.syncDraw('canvas_resize');
      if (sync_promise === false) return false;

      if ((size === true) || (size === false)) { force = size; size = null; }

      if (isObject(size) && size.force) force = true;

      if (!force) force = this.needRedrawByResize();

      let changed = false,
          redrawNext = indx => {
             if (!changed || (indx >= this.painters.length)) {
                this.confirmDraw();
                return changed;
             }

             return getPromise(this.painters[indx].redraw(force ? 'redraw' : 'resize')).then(() => redrawNext(indx+1));
          };

      return sync_promise.then(() => {

         changed = this.createCanvasSvg(force ? 2 : 1, size);

         // if canvas changed, redraw all its subitems.
         // If redrawing was forced for canvas, same applied for sub-elements
         return redrawNext(0);
      });
   }

   /** @summary Update TPad object */
   updateObject(obj) {
      if (!obj) return false;

      this.pad.fBits = obj.fBits;
      this.pad.fTitle = obj.fTitle;

      this.pad.fGridx = obj.fGridx;
      this.pad.fGridy = obj.fGridy;
      this.pad.fTickx = obj.fTickx;
      this.pad.fTicky = obj.fTicky;
      this.pad.fLogx  = obj.fLogx;
      this.pad.fLogy  = obj.fLogy;
      this.pad.fLogz  = obj.fLogz;

      this.pad.fUxmin = obj.fUxmin;
      this.pad.fUxmax = obj.fUxmax;
      this.pad.fUymin = obj.fUymin;
      this.pad.fUymax = obj.fUymax;

      this.pad.fX1 = obj.fX1;
      this.pad.fX2 = obj.fX2;
      this.pad.fY1 = obj.fY1;
      this.pad.fY2 = obj.fY2;

      this.pad.fLeftMargin   = obj.fLeftMargin;
      this.pad.fRightMargin  = obj.fRightMargin;
      this.pad.fBottomMargin = obj.fBottomMargin;
      this.pad.fTopMargin    = obj.fTopMargin;

      this.pad.fFillColor = obj.fFillColor;
      this.pad.fFillStyle = obj.fFillStyle;
      this.pad.fLineColor = obj.fLineColor;
      this.pad.fLineStyle = obj.fLineStyle;
      this.pad.fLineWidth = obj.fLineWidth;

      this.pad.fPhi = obj.fPhi;
      this.pad.fTheta = obj.fTheta;

      if (this.iscan) this.checkSpecialsInPrimitives(obj);

      let fp = this.getFramePainter();
      if (fp) fp.updateAttributes(!fp.modified_NDC);

      if (!obj.fPrimitives) return false;

      let isany = false, p = 0;
      for (let n = 0; n < obj.fPrimitives.arr.length; ++n) {
         while (p < this.painters.length) {
            let pp = this.painters[p++];
            if (!pp._primitive) continue;
            if (pp.updateObject(obj.fPrimitives.arr[n])) isany = true;
            break;
         }
      }

      return isany;
   }

   /** @summary Add object painter to list of primitives
     * @private */
   addObjectPainter(objpainter, lst, indx) {
      if (objpainter && lst && lst[indx] && (objpainter.snapid === undefined)) {
         // keep snap id in painter, will be used for the
         if (this.painters.indexOf(objpainter) < 0)
            this.painters.push(objpainter);

         if (isFunc(objpainter.setSnapId))
            objpainter.setSnapId(lst[indx].fObjectID);
         else
            objpainter.snapid = lst[indx].fObjectID;

         if (objpainter.$primary)
            this.painters.forEach(sub => {
               if ((sub !== objpainter) && (sub.$secondary === 'hist')) {
                  sub.snapid = objpainter.snapid + '#hist';
                  console.log(`ASSIGN SECONDARY HIST ID ${sub.snapid}`);
               }
            });
      }
   }

   /** @summary Function called when drawing next snapshot from the list
     * @return {Promise} for drawing of the snap
     * @private */
   async drawNextSnap(lst, indx) {

      if (indx === undefined) {
         indx = -1;
         this._snaps_map = {}; // to control how much snaps are drawn
         this._num_primitives = lst ? lst.length : 0;
      }

      ++indx; // change to the next snap

      if (!lst || (indx >= lst.length)) {
         delete this._snaps_map;
         return this;
      }

      let snap = lst[indx];

      // gStyle object
      if (snap.fKind === webSnapIds.kStyle) {
         Object.assign(gStyle, snap.fSnapshot);
         return this.drawNextSnap(lst, indx); // call next
      }

      // list of colors
      if (snap.fKind === webSnapIds.kColors) {

         let ListOfColors = [], arr = snap.fSnapshot.fOper.split(';');
         for (let n = 0; n < arr.length; ++n) {
            let name = arr[n], p = name.indexOf(':');
            if (p > 0) {
               ListOfColors[parseInt(name.slice(0,p))] = color$1(`rgb(${name.slice(p+1)})`).formatHex();
            } else {
               p = name.indexOf('=');
               ListOfColors[parseInt(name.slice(0,p))] = color$1(`rgba(${name.slice(p+1)})`).formatHex8();
            }
         }

         // set global list of colors
         if (!this.options || this.options.GlobalColors)
            adoptRootColors(ListOfColors);

         // copy existing colors and extend with new values
         if (this.options && this.options.LocalColors)
            this.root_colors = extendRootColors(null, ListOfColors);

         // set palette
         if (snap.fSnapshot.fBuf && (!this.options || !this.options.IgnorePalette)) {
            let palette = [];
            for (let n = 0; n < snap.fSnapshot.fBuf.length; ++n)
               palette[n] = ListOfColors[Math.round(snap.fSnapshot.fBuf[n])];

            this.custom_palette = new ColorPalette(palette);
         }

         return this.drawNextSnap(lst, indx); // call next
      }

      let snapid = snap.fObjectID,
          cnt = (this._snaps_map[snapid] || 0) + 1,
          objpainter = null;

      this._snaps_map[snapid] = cnt; // check how many objects with same snapid drawn, use them again

      // first appropriate painter for the object
      // if same object drawn twice, two painters will exists
      for (let k = 0;  k < this.painters.length; ++k) {
         if (this.painters[k].snapid === snapid)
            if (--cnt === 0) { objpainter = this.painters[k]; break; }
      }

      if (objpainter) {

         if (snap.fKind === webSnapIds.kSubPad) // subpad
            return objpainter.redrawPadSnap(snap).then(() => this.drawNextSnap(lst, indx));

         let promise;

         if (snap.fKind === webSnapIds.kObject) { // object itself
            if (objpainter.updateObject(snap.fSnapshot, snap.fOption, true))
               promise = objpainter.redraw();
         } else if (snap.fKind === webSnapIds.kSVG) { // update SVG
            if (objpainter.updateObject(snap.fSnapshot))
               promise = objpainter.redraw();
         }

         return getPromise(promise).then(() => this.drawNextSnap(lst, indx)); // call next
      }

      if (snap.fKind === webSnapIds.kSubPad) { // subpad

         let subpad = snap.fSnapshot;

         subpad.fPrimitives = null; // clear primitives, they just because of I/O

         let padpainter = new TPadPainter(this.getDom(), subpad, false);
         padpainter.decodeOptions(snap.fOption);
         padpainter.addToPadPrimitives(this.this_pad_name);
         padpainter.snapid = snap.fObjectID;
         padpainter.is_active_pad = !!snap.fActive; // enforce boolean flag
         padpainter._readonly = snap.fReadOnly ?? false; // readonly flag

         padpainter.createPadSvg();

         if (padpainter.matchObjectType(clTPad) && (snap.fPrimitives.length > 0))
            padpainter.addPadButtons(true);

         // we select current pad, where all drawing is performed
         let prev_name = padpainter.selectCurrentPad(padpainter.this_pad_name);
         return padpainter.drawNextSnap(snap.fPrimitives).then(() => {
            padpainter.selectCurrentPad(prev_name);
            return this.drawNextSnap(lst, indx); // call next
         });
      }

      // here the case of normal drawing, will be handled in promise
      if ((snap.fKind === webSnapIds.kObject) || (snap.fKind === webSnapIds.kSVG))
         return this.drawObject(this.getDom(), snap.fSnapshot, snap.fOption).then(objpainter => {
            this.addObjectPainter(objpainter, lst, indx);
            return this.drawNextSnap(lst, indx);
         });


      return this.drawNextSnap(lst, indx);
   }

   /** @summary Return painter with specified id
     * @private */
   findSnap(snapid) {

      if (this.snapid === snapid)
         return this;

      if (!this.painters)
         return null;

      for (let k = 0; k < this.painters.length; ++k) {
         let sub = this.painters[k];

         if (isFunc(sub.findSnap))
            sub = sub.findSnap(snapid);
         else if (sub.snapid !== snapid)
            sub = null;

         if (sub) return sub;
      }

      return null;
   }

   /** @summary Redraw pad snap
     * @desc Online version of drawing pad primitives
     * for the canvas snapshot contains list of objects
     * as first entry, graphical properties of canvas itself is provided
     * in ROOT6 it also includes primitives, but we ignore them
     * @return {Promise} with pad painter when drawing completed
     * @private */
   async redrawPadSnap(snap) {
      if (!snap || !snap.fPrimitives)
         return this;

      this.is_active_pad = !!snap.fActive; // enforce boolean flag
      this._readonly = snap.fReadOnly ?? false; // readonly flag

      let first = snap.fSnapshot;
      first.fPrimitives = null; // primitives are not interesting, they are disabled in IO

      // if there are execs in the pad, deliver events to the server
      this._deliver_webcanvas_events = first.fExecs?.arr?.length ? true : false;

      if (this.snapid === undefined) {
         // first time getting snap, create all gui elements first

         this.snapid = snap.fObjectID;

         this.draw_object = first;
         this.pad = first;

         // this._fixed_size = true;

         // if canvas size not specified in batch mode, temporary use 900x700 size
         if (this.batch_mode && (!first.fCw || !first.fCh)) { first.fCw = 900; first.fCh = 700; }

         // case of ROOT7 with always dummy TPad as first entry
         if (!first.fCw || !first.fCh) this._fixed_size = false;

         let mainid = this.selectDom().attr('id');

         if (!this.batch_mode && !this.use_openui && !this.brlayout && mainid && isStr(mainid)) {
            this.brlayout = new BrowserLayout(mainid, null, this);
            this.brlayout.create(mainid, true);
            // this.brlayout.toggleBrowserKind('float');
            this.setDom(this.brlayout.drawing_divid()); // need to create canvas
            registerForResize(this.brlayout);
         }

         this.createCanvasSvg(0);

         if (!this.batch_mode)
            this.addPadButtons(true);

         if (typeof snap.fHighlightConnect !== 'undefined')
            this._highlight_connect = snap.fHighlightConnect;

         let pr = Promise.resolve(true);

         if (isStr(snap.fScripts) && snap.fScripts) {
            let src = '';

            if (snap.fScripts.indexOf('load:') == 0)
               src = snap.fScripts.slice(5).split(';');
            else if (snap.fScripts.indexOf('assert:') == 0)
               src = snap.fScripts.slice(7);

            pr = src ? loadScript(src) : injectCode(snap.fScripts);
         }

         return pr.then(() => this.drawNextSnap(snap.fPrimitives));
      }

      this.updateObject(first); // update only object attributes

      // apply all changes in the object (pad or canvas)
      if (this.iscan) {
         this.createCanvasSvg(2);
      } else {
         this.createPadSvg(true);
      }

      const MatchPrimitive = (painters, primitives, class_name, obj_name) => {
         let painter = painters.find(p => {
            if (p.snapid === undefined) return;
            if (!p.matchObjectType(class_name)) return;
            if (obj_name && (!p.getObject() || (p.getObject().fName !== obj_name))) return;
            return true;
         });
         if (!painter) return;
         let primitive = primitives.find(pr => {
            if ((pr.fKind !== 1) || !pr.fSnapshot || (pr.fSnapshot._typename !== class_name)) return;
            if (obj_name && (pr.fSnapshot.fName !== obj_name)) return;
            return true;
         });
         if (!primitive) return;

         // force painter to use new object id
         if (painter.snapid !== primitive.fObjectID)
            painter.snapid = primitive.fObjectID;
      };

      // check if frame or title was recreated, we could reassign handlers for them directly
      // while this is temporary objects, which can be recreated very often, try to catch such situation ourselfs
      if (!snap.fWithoutPrimitives) {
         MatchPrimitive(this.painters, snap.fPrimitives, 'TFrame');
         MatchPrimitive(this.painters, snap.fPrimitives, clTPaveText, 'title');
      }

      let isanyfound = false, isanyremove = false;

      // find and remove painters which no longer exists in the list
      if (!snap.fWithoutPrimitives)
      for (let k = 0; k < this.painters.length; ++k) {
         let sub = this.painters[k];

         if (!isStr(sub.snapid)) continue; // look only for painters with snapid

         let snapid = sub.snapid, p = snapid.indexOf('#');
         if (p > 0) snapid = snapid.slice(0, p);

         for (let i = 0; i < snap.fPrimitives.length; ++i)
            if (snap.fPrimitives[i].fObjectID === snapid) { sub = null; isanyfound = true; break; }

         if (sub) {
            // remove painter which does not found in the list of snaps
            this.painters.splice(k--, 1);
            sub.cleanup(); // cleanup such painter
            isanyremove = true;
            if (this.main_painter_ref === sub)
               delete this.main_painter_ref;
         }
      }

      if (isanyremove)
         delete this.pads_cache;

      if (!isanyfound && !snap.fWithoutPrimitives) {
         // TODO: maybe just remove frame painter?
         let fp = this.getFramePainter();
         this.painters.forEach(objp => {
            if (fp !== objp) objp.cleanup();
         });
         delete this.main_painter_ref;
         this.painters = [];
         if (fp) {
            this.painters.push(fp);
            fp.cleanFrameDrawings();
            fp.redraw();
         }
         if (this.removePadButtons) this.removePadButtons();
         this.addPadButtons(true);
      }

      let prev_name = this.selectCurrentPad(this.this_pad_name);

      return this.drawNextSnap(snap.fPrimitives).then(() => {
         // redraw secondaries like stat box
         let promises = [];
         if (!snap.fWithoutPrimitives)
            this.painters.forEach(sub => {
               if ((sub.snapid === undefined) || sub.$secondary)
                  promises.push(sub.redraw());
            });
         return Promise.all(promises);
      }).then(() => {
         this.selectCurrentPad(prev_name);
         if (getActivePad() === this)
            this.getCanvPainter()?.producePadEvent('padredraw', this);
         return this;
      });
   }

   /** @summary Deliver mouse move or click event to the web canvas
     * @private */
   deliverWebCanvasEvent(kind, x, y, hints) {
      if (!this._deliver_webcanvas_events || !this.is_active_pad || this.doingDraw() || x === undefined || y === undefined) return;
      let cp = this.getCanvPainter();
      if (!cp || !cp._websocket || !cp._websocket.canSend(2) || cp._readonly) return;

      let selobj_snapid = '';
      if (hints && hints[0] && hints[0].painter?.snapid)
         selobj_snapid = hints[0].painter.snapid.toString();

      let msg = JSON.stringify([this.snapid, kind, x.toString(), y.toString(), selobj_snapid]);

      cp.sendWebsocket(`EVENT:${msg}`);
   }

   /** @summary Create image for the pad
     * @desc Used with web-based canvas to create images for server side
     * @return {Promise} with image data, coded with btoa() function
     * @private */
   async createImage(format) {
      // use https://github.com/MrRio/jsPDF in the future here
      if (format == 'pdf')
         return btoa_func('dummy PDF file');

      if ((format == 'png') || (format == 'jpeg') || (format == 'svg'))
         return this.produceImage(true, format).then(res => {
            if (!res || (format == 'svg')) return res;
            let separ = res.indexOf('base64,');
            return (separ > 0) ? res.slice(separ+7) : '';
         });

      return '';
   }

   /** @summary Collects pad information for TWebCanvas
     * @desc need to update different states
     * @private */
   getWebPadOptions(arg, cp) {
      let is_top = (arg === undefined), elem = null, scan_subpads = true;
      // no any options need to be collected in readonly mode
      if (is_top && this._readonly) return '';
      if (arg === 'only_this') { is_top = true; scan_subpads = false; }
      if (is_top) arg = [];
      if (!cp) cp = this.iscan ? this : this.getCanvPainter();

      if (this.snapid) {
         elem = { _typename: 'TWebPadOptions', snapid: this.snapid.toString(),
                  active: !!this.is_active_pad,
                  cw: 0, ch: 0,
                  bits: 0, primitives: [],
                  logx: this.pad.fLogx, logy: this.pad.fLogy, logz: this.pad.fLogz,
                  gridx: this.pad.fGridx, gridy: this.pad.fGridy,
                  tickx: this.pad.fTickx, ticky: this.pad.fTicky,
                  mleft: this.pad.fLeftMargin, mright: this.pad.fRightMargin,
                  mtop: this.pad.fTopMargin, mbottom: this.pad.fBottomMargin,
                  xlow: 0, ylow: 0, xup: 1, yup: 1,
                  zx1: 0, zx2: 0, zy1: 0, zy2: 0, zz1: 0, zz2: 0 };

         if (this.iscan) {
            elem.bits = this.getStatusBits();
            elem.cw = this.getPadWidth();
            elem.ch = this.getPadHeight();
         } else if (cp) {
            let cw = cp.getPadWidth(), ch = cp.getPadHeight(), rect = this.getPadRect();
            elem.cw = cw;
            elem.ch = ch;
            elem.xlow = rect.x / cw;
            elem.ylow = 1 - (rect.y + rect.height) / ch;
            elem.xup = elem.xlow + rect.width / cw;
            elem.yup = elem.ylow + rect.height / ch;
         }

         if (this.getPadRanges(elem))
            arg.push(elem);
         else
            console.log(`fail to get ranges for pad ${this.pad.fName}`);
      }

      this.painters.forEach(sub => {
         if (isFunc(sub.getWebPadOptions)) {
            if (scan_subpads) sub.getWebPadOptions(arg, cp);
         } else if (sub.snapid) {
            let opt = { _typename: 'TWebObjectOptions', snapid: sub.snapid.toString(), opt: sub.getDrawOpt(), fcust: '', fopt: [] };
            if (isFunc(sub.fillWebObjectOptions))
               opt = sub.fillWebObjectOptions(opt);
            elem.primitives.push(opt);
         }
      });

      if (is_top) return toJSON(arg);
   }

   /** @summary returns actual ranges in the pad, which can be applied to the server
     * @private */
   getPadRanges(r) {

      if (!r) return false;

      let main = this.getFramePainter(),
          p = this.svg_this_pad();

      r.ranges = main?.ranges_set ? true : false; // indicate that ranges are assigned

      r.ux1 = r.px1 = r.ranges ? main.scale_xmin : 0; // need to initialize for JSON reader
      r.uy1 = r.py1 = r.ranges ? main.scale_ymin : 0;
      r.ux2 = r.px2 = r.ranges ? main.scale_xmax : 0;
      r.uy2 = r.py2 = r.ranges ? main.scale_ymax : 0;
      r.uz1 = r.ranges ? (main.scale_zmin ?? 0) : 0;
      r.uz2 = r.ranges ? (main.scale_zmax ?? 0) : 0;

      if (main) {
         if (main.zoom_xmin !== main.zoom_xmax) {
            r.zx1 = main.zoom_xmin; r.zx2 = main.zoom_xmax;
         }

         if (main.zoom_ymin !== main.zoom_ymax) {
            r.zy1 = main.zoom_ymin; r.zy2 = main.zoom_ymax;
         }

         if (main.zoom_zmin !== main.zoom_zmax) {
            r.zz1 = main.zoom_zmin; r.zz2 = main.zoom_zmax;
         }
      }

      if (!r.ranges || p.empty()) return true;

      // calculate user range for full pad
      const func = (log, value, err) => {
         if (!log) return value;
         if (value <= 0) return err;
         value = Math.log10(value);
         if (log > 1) value = value/Math.log10(log);
         return value;
      }, frect = main.getFrameRect();

      r.ux1 = func(main.logx, r.ux1, 0);
      r.ux2 = func(main.logx, r.ux2, 1);

      let k = (r.ux2 - r.ux1)/(frect.width || 10);
      r.px1 = r.ux1 - k*frect.x;
      r.px2 = r.px1 + k*this.getPadWidth();

      r.uy1 = func(main.logy, r.uy1, 0);
      r.uy2 = func(main.logy, r.uy2, 1);

      k = (r.uy2 - r.uy1)/(frect.height || 10);
      r.py1 = r.uy1 - k*frect.y;
      r.py2 = r.py1 + k*this.getPadHeight();

      return true;
   }

   /** @summary Show context menu for specified item
     * @private */
   itemContextMenu(name) {
       let rrr = this.svg_this_pad().node().getBoundingClientRect(),
           evnt = { clientX: rrr.left+10, clientY: rrr.top + 10 };

       // use timeout to avoid conflict with mouse click and automatic menu close
       if (name == 'pad')
          return setTimeout(() => this.padContextMenu(evnt), 50);

       let selp = null, selkind;

       switch(name) {
          case 'xaxis':
          case 'yaxis':
          case 'zaxis':
             selp = this.getFramePainter();
             selkind = name[0];
             break;
          case 'frame':
             selp = this.getFramePainter();
             break;
          default: {
             let indx = parseInt(name);
             if (Number.isInteger(indx)) selp = this.painters[indx];
          }
       }

       if (!isFunc(selp?.fillContextMenu)) return;

       createMenu$1(evnt, selp).then(menu => {
          if (selp.fillContextMenu(menu, selkind))
             selp.fillObjectExecMenu(menu, selkind).then(() => setTimeout(() => menu.show(), 50));
       });
   }

   /** @summary Save pad in specified format
     * @desc Used from context menu */
   saveAs(kind, full_canvas, filename) {
      if (!filename)
         filename = (this.this_pad_name || (this.iscan ? 'canvas' : 'pad')) + '.' + kind;

      this.produceImage(full_canvas, kind).then(imgdata => {
         if (!imgdata)
            return console.error(`Fail to produce image ${filename}`);

         saveFile(filename, (kind != 'svg') ? imgdata : 'data:image/svg+xml;charset=utf-8,'+encodeURIComponent(imgdata));
      });
   }

   /** @summary Search active pad
     * @return {Object} pad painter for active pad */
   findActivePad() {
      let active_pp;
      this.forEachPainterInPad(pp => {
         if (pp.is_active_pad && !active_pp)
            active_pp = pp;
      }, 'pads');
      return active_pp;
   }

   /** @summary Prodce image for the pad
     * @return {Promise} with created image */
   async produceImage(full_canvas, file_format) {

      let use_frame = (full_canvas === 'frame'),
          elem = use_frame ? this.getFrameSvg(this.this_pad_name) : (full_canvas ? this.getCanvSvg() : this.svg_this_pad()),
          painter = (full_canvas && !use_frame) ? this.getCanvPainter() : this,
          items = [], // keep list of replaced elements, which should be moved back at the end
          active_pp = null;

      if (elem.empty())
         return '';

      painter.forEachPainterInPad(pp => {

         if (pp.is_active_pad && !active_pp) {
            active_pp = pp;
            active_pp.drawActiveBorder(null, false);
         }

         if (use_frame) return; // do not make transformations for the frame

         let item = { prnt: pp.svg_this_pad() };
         items.push(item);

         // remove buttons from each subpad
         let btns = pp.getLayerSvg('btns_layer', pp.this_pad_name);
         item.btns_node = btns.node();
         if (item.btns_node) {
            item.btns_prnt = item.btns_node.parentNode;
            item.btns_next = item.btns_node.nextSibling;
            btns.remove();
         }

         let main = pp.getFramePainter();
         if (!isFunc(main?.render3D) || !isFunc(main?.access3dKind)) return;

         let can3d = main.access3dKind();

         if ((can3d !== constants$1.Embed3D.Overlay) && (can3d !== constants$1.Embed3D.Embed)) return;

         let sz2 = main.getSizeFor3d(constants$1.Embed3D.Embed); // get size and position of DOM element as it will be embed

         let canvas = main.renderer.domElement;
         main.render3D(0); // WebGL clears buffers, therefore we should render scene and convert immediately
         let dataUrl = canvas.toDataURL('image/png');

         // remove 3D drawings
         if (can3d === constants$1.Embed3D.Embed) {
            item.foreign = item.prnt.select('.' + sz2.clname);
            item.foreign.remove();
         }

         let svg_frame = main.getFrameSvg();
         item.frame_node = svg_frame.node();
         if (item.frame_node) {
            item.frame_next = item.frame_node.nextSibling;
            svg_frame.remove();
         }

         // add svg image
         item.img = item.prnt.insert('image','.primitives_layer')     // create image object
                        .attr('x', sz2.x)
                        .attr('y', sz2.y)
                        .attr('width', canvas.width)
                        .attr('height', canvas.height)
                        .attr('href', dataUrl);

      }, 'pads');

      const reEncode = data => {
         data = encodeURIComponent(data);
         data = data.replace(/%([0-9A-F]{2})/g, (match, p1) => {
           let c = String.fromCharCode('0x'+p1);
           return c === '%' ? '%25' : c;
         });
         return decodeURIComponent(data);
      }, reconstruct = () => {
         // reactivate border
         if (active_pp)
            active_pp.drawActiveBorder(null, true);

         for (let k = 0; k < items.length; ++k) {
            let item = items[k];

            if (item.img)
               item.img.remove(); // delete embed image

            let prim = item.prnt.select('.primitives_layer');

            if (item.foreign) // reinsert foreign object
               item.prnt.node().insertBefore(item.foreign.node(), prim.node());

            if (item.frame_node) // reinsert frame as first in list of primitives
               prim.node().insertBefore(item.frame_node, item.frame_next);

            if (item.btns_node) // reinsert buttons
               item.btns_prnt.insertBefore(item.btns_node, item.btns_next);
         }
      };

      let width = elem.property('draw_width'), height = elem.property('draw_height');
      if (use_frame) {
         let fp = this.getFramePainter();
         width = fp.getFrameWidth();
         height = fp.getFrameHeight();
      }

      let svg = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">${elem.node().innerHTML}</svg>`;

      if (internals.processSvgWorkarounds)
         svg = internals.processSvgWorkarounds(svg);

      svg = compressSVG(svg);

      if (file_format == 'svg') {
         reconstruct();
         return svg; // return SVG file as is
      }

      let doctype = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">',
          image = new Image();

      return new Promise(resolveFunc => {
         image.onload = function() {
            let canvas = document.createElement('canvas');
            canvas.width = image.width;
            canvas.height = image.height;
            let context = canvas.getContext('2d');
            context.drawImage(image, 0, 0);

            reconstruct();
            resolveFunc(canvas.toDataURL('image/' + file_format));
         };

         image.onerror = function(arg) {
            console.log(`IMAGE ERROR ${arg}`);
            reconstruct();
            resolveFunc(null);
         };

         image.src = 'data:image/svg+xml;base64,' + btoa_func(reEncode(doctype + svg));
      });
   }

   /** @summary Process pad button click */
   clickPadButton(funcname, evnt) {

      if (funcname == 'CanvasSnapShot')
         return this.saveAs('png', true);

      if (funcname == 'enlargePad')
         return this.enlargePad();

      if (funcname == 'PadSnapShot')
         return this.saveAs('png', false);

      if (funcname == 'PadContextMenus') {

         if (evnt) {
            evnt.preventDefault();
            evnt.stopPropagation();
         }

         if (closeMenu()) return;

         createMenu$1(evnt, this).then(menu => {
            menu.add('header:Menus');

            if (this.iscan)
               menu.add('Canvas', 'pad', this.itemContextMenu);
            else
               menu.add('Pad', 'pad', this.itemContextMenu);

            if (this.getFramePainter())
               menu.add('Frame', 'frame', this.itemContextMenu);

            let main = this.getMainPainter(); // here pad painter method

            if (main) {
               menu.add('X axis', 'xaxis', this.itemContextMenu);
               menu.add('Y axis', 'yaxis', this.itemContextMenu);
               if (isFunc(main.getDimension) && (main.getDimension() > 1))
                  menu.add('Z axis', 'zaxis', this.itemContextMenu);
            }

            if (this.painters && (this.painters.length > 0)) {
               menu.add('separator');
               let shown = [];
               this.painters.forEach((pp,indx) => {
                  let obj = pp ? pp.getObject() : null;
                  if (!obj || (shown.indexOf(obj) >= 0)) return;
                  if (pp.$secondary) return;
                  let name = ('_typename' in obj) ? (obj._typename + '::') : '';
                  if ('fName' in obj) name += obj.fName;
                  if (!name.length) name = 'item' + indx;
                  menu.add(name, indx, this.itemContextMenu);
               });
            }

            menu.show();
         });

         return;
      }

      // click automatically goes to all sub-pads
      // if any painter indicates that processing completed, it returns true
      let done = false;

      this.painters.forEach(pp => {
         if (isFunc(pp.clickPadButton))
            pp.clickPadButton(funcname);

         if (!done && isFunc(pp.clickButton))
            done = pp.clickButton(funcname);
      });
   }

   /** @summary Add button to the pad
     * @private */
   addPadButton(btn, tooltip, funcname, keyname) {
      if (!settings.ToolBar || isBatchMode() || this.batch_mode) return;

      if (!this._buttons) this._buttons = [];
      // check if there are duplications

      for (let k = 0; k < this._buttons.length; ++k)
         if (this._buttons[k].funcname == funcname) return;

      this._buttons.push({ btn, tooltip, funcname, keyname });

      let iscan = this.iscan || !this.has_canvas;
      if (!iscan && (funcname.indexOf('Pad')!=0) && (funcname !== 'enlargePad')) {
         let cp = this.getCanvPainter();
         if (cp && (cp !== this)) cp.addPadButton(btn, tooltip, funcname);
      }
   }

   /** @summary Show pad buttons
     * @private */
   showPadButtons() {
      if (!this._buttons) return;

       PadButtonsHandler.assign(this);
       this.showPadButtons();
   }

   /** @summary Add buttons for pad or canvas
     * @private */
   addPadButtons(is_online) {

      this.addPadButton('camera', 'Create PNG', this.iscan ? 'CanvasSnapShot' : 'PadSnapShot', 'Ctrl PrintScreen');

      if (settings.ContextMenu)
         this.addPadButton('question', 'Access context menus', 'PadContextMenus');

      let add_enlarge = !this.iscan && this.has_canvas && this.hasObjectsToDraw();

      if (add_enlarge || this.enlargeMain('verify'))
         this.addPadButton('circle', 'Enlarge canvas', 'enlargePad');

      if (is_online && this.brlayout) {
         this.addPadButton('diamand', 'Toggle Ged', 'ToggleGed');
         this.addPadButton('three_circles', 'Toggle Status', 'ToggleStatus');
      }
   }

   /** @summary Decode pad draw options
     * @private */
   decodeOptions(opt) {
      let pad = this.getObject();
      if (!pad) return;

      let d = new DrawOptions(opt);

      if (!this.options) this.options = {};

      Object.assign(this.options, { GlobalColors: true, LocalColors: false, CreatePalette: 0, IgnorePalette: false, RotateFrame: false, FixFrame: false });

      if (d.check('NOCOLORS') || d.check('NOCOL')) this.options.GlobalColors = this.options.LocalColors = false;
      if (d.check('LCOLORS') || d.check('LCOL')) { this.options.GlobalColors = false; this.options.LocalColors = true; }
      if (d.check('NOPALETTE') || d.check('NOPAL')) this.options.IgnorePalette = true;
      if (d.check('ROTATE')) this.options.RotateFrame = true;
      if (d.check('FIXFRAME')) this.options.FixFrame = true;

      if (d.check('CP',true)) this.options.CreatePalette = d.partAsInt(0,0);

      if (d.check('NOZOOMX')) this.options.NoZoomX = true;
      if (d.check('NOZOOMY')) this.options.NoZoomY = true;

      if (d.check('NOMARGINS')) pad.fLeftMargin = pad.fRightMargin = pad.fBottomMargin = pad.fTopMargin = 0;
      if (d.check('WHITE')) pad.fFillColor = 0;
      if (d.check('LOG2X')) { pad.fLogx = 2; pad.fUxmin = 0; pad.fUxmax = 1; pad.fX1 = 0; pad.fX2 = 1; }
      if (d.check('LOGX')) { pad.fLogx = 1; pad.fUxmin = 0; pad.fUxmax = 1; pad.fX1 = 0; pad.fX2 = 1; }
      if (d.check('LOG2Y')) { pad.fLogy = 2; pad.fUymin = 0; pad.fUymax = 1; pad.fY1 = 0; pad.fY2 = 1; }
      if (d.check('LOGY')) { pad.fLogy = 1; pad.fUymin = 0; pad.fUymax = 1; pad.fY1 = 0; pad.fY2 = 1; }
      if (d.check('LOG2Z')) pad.fLogz = 2;
      if (d.check('LOGZ')) pad.fLogz = 1;
      if (d.check('LOG2')) pad.fLogx = pad.fLogy = pad.fLogz = 2;
      if (d.check('LOG')) pad.fLogx = pad.fLogy = pad.fLogz = 1;
      if (d.check('GRIDX')) pad.fGridx = 1;
      if (d.check('GRIDY')) pad.fGridy = 1;
      if (d.check('GRID')) pad.fGridx = pad.fGridy = 1;
      if (d.check('TICKX')) pad.fTickx = 1;
      if (d.check('TICKY')) pad.fTicky = 1;
      if (d.check('TICK')) pad.fTickx = pad.fTicky = 1;
      if (d.check('OTX')) pad.$OTX = true;
      if (d.check('OTY')) pad.$OTY = true;
      if (d.check('CTX')) pad.$CTX = true;
      if (d.check('CTY')) pad.$CTY = true;
      if (d.check('RX')) pad.$RX = true;
      if (d.check('RY')) pad.$RY = true;

      this.storeDrawOpt(opt);
   }

   /** @summary draw TPad object */
   static async draw(dom, pad, opt) {
      let painter = new TPadPainter(dom, pad, false);
      painter.decodeOptions(opt);

      if (painter.getCanvSvg().empty()) {
         // one can draw pad without canvas
         painter.has_canvas = false;
         painter.this_pad_name = '';
         painter.setTopPainter();
      } else {
         // pad painter will be registered in the canvas painters list
         painter.addToPadPrimitives(painter.pad_name);
      }

      painter.createPadSvg();

      if (painter.matchObjectType(clTPad) && (!painter.has_canvas || painter.hasObjectsToDraw()))
         painter.addPadButtons();

      // we select current pad, where all drawing is performed
      let prev_name = painter.has_canvas ? painter.selectCurrentPad(painter.this_pad_name) : undefined;

      // set active pad
      selectActivePad({ pp: painter, active: true });

      // flag used to prevent immediate pad redraw during first draw
      return painter.drawPrimitives().then(() => {
         painter.showPadButtons();
         // we restore previous pad name
         painter.selectCurrentPad(prev_name);
         return painter;
      });
   };

} // class TPadPainter

var TPadPainter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
TPadPainter: TPadPainter,
PadButtonsHandler: PadButtonsHandler,
clTButton: clTButton
});

/** @summary direct draw of TFrame object,
  * @desc pad or canvas should already exist
  * @private */
function directDrawTFrame(dom, obj, opt) {
   let fp = new TFramePainter(dom, obj);
   fp.addToPadPrimitives();
   if (opt == '3d') fp.mode3d = true;
   return fp.redraw();
}

const TCanvasStatusBits = {
   kShowEventStatus: BIT(15),
   kAutoExec: BIT(16),
   kMenuBar: BIT(17),
   kShowToolBar: BIT(18),
   kShowEditor: BIT(19),
   kMoveOpaque: BIT(20),
   kResizeOpaque: BIT(21),
   kIsGrayscale: BIT(22),
   kShowToolTips: BIT(23)
};

/**
  * @summary Painter for TCanvas object
  *
  * @private
  */

class TCanvasPainter extends TPadPainter {

   /** @summary Constructor */
   constructor(dom, canvas) {
      super(dom, canvas, true);
      this._websocket = null;
      this.tooltip_allowed = settings.Tooltip;
   }

   /** @summary Cleanup canvas painter */
   cleanup() {
      if (this._changed_layout)
         this.setLayoutKind('simple');
      delete this._changed_layout;
      super.cleanup();
   }

   /** @summary Returns layout kind */
   getLayoutKind() {
      let origin = this.selectDom('origin'),
         layout = origin.empty() ? '' : origin.property('layout');

      return layout || 'simple';
   }

   /** @summary Set canvas layout kind */
   setLayoutKind(kind, main_selector) {
      let origin = this.selectDom('origin');
      if (!origin.empty()) {
         if (!kind) kind = 'simple';
         origin.property('layout', kind);
         origin.property('layout_selector', (kind != 'simple') && main_selector ? main_selector : null);
         this._changed_layout = (kind !== 'simple'); // use in cleanup
      }
   }

   /** @summary Changes layout
     * @return {Promise} indicating when finished */
   async changeLayout(layout_kind, mainid) {
      let current = this.getLayoutKind();
      if (current == layout_kind)
         return true;

      let origin = this.selectDom('origin'),
          sidebar = origin.select('.side_panel'),
          main = this.selectDom(), lst = [];

      while (main.node().firstChild)
         lst.push(main.node().removeChild(main.node().firstChild));

      if (!sidebar.empty()) cleanup(sidebar.node());

      this.setLayoutKind('simple'); // restore defaults
      origin.html(''); // cleanup origin

      if (layout_kind == 'simple') {
         main = origin;
         for (let k = 0; k < lst.length; ++k)
            main.node().appendChild(lst[k]);
         this.setLayoutKind(layout_kind);
      } else {

         let grid = new GridDisplay(origin.node(), layout_kind);

         if (mainid == undefined)
            mainid = (layout_kind.indexOf('vert') == 0) ? 0 : 1;

         main = select(grid.getGridFrame(mainid));
         sidebar = select(grid.getGridFrame(1 - mainid));

         main.classed('central_panel', true).style('position', 'relative');
         sidebar.classed('side_panel', true).style('position', 'relative');

         // now append all childs to the new main
         for (let k = 0; k < lst.length; ++k)
            main.node().appendChild(lst[k]);

         this.setLayoutKind(layout_kind, '.central_panel');

         // remove reference to MDIDisplay, solves resize problem
         origin.property('mdi', null);
      }

      // resize main drawing and let draw extras
      resize(main.node());
      return true;
   }

   /** @summary Toggle projection
     * @return {Promise} indicating when ready
     * @private */
   async toggleProjection(kind) {
      delete this.proj_painter;

      if (kind) this.proj_painter = 1; // just indicator that drawing can be preformed

      if (isFunc(this.showUI5ProjectionArea))
         return this.showUI5ProjectionArea(kind);

      let layout = 'simple', mainid;

      switch(kind) {
         case 'X':
         case 'bottom': layout = 'vert2_31'; mainid = 0; break;
         case 'Y':
         case 'left': layout = 'horiz2_13'; mainid = 1; break;
         case 'top': layout = 'vert2_13'; mainid = 1; break;
         case 'right': layout = 'horiz2_31'; mainid = 0; break;
      }

      return this.changeLayout(layout, mainid);
   }

   /** @summary Draw projection for specified histogram
     * @private */
   async drawProjection(kind, hist, hopt) {

      if (!this.proj_painter)
         return false; // ignore drawing if projection not configured

      if (hopt === undefined) hopt = 'hist';

      if (this.proj_painter === 1) {

         let canv = create$1(clTCanvas),
             pad = this.pad,
             main = this.getFramePainter(), drawopt;

         if (kind == 'X') {
            canv.fLeftMargin = pad.fLeftMargin;
            canv.fRightMargin = pad.fRightMargin;
            canv.fLogx = main.logx;
            canv.fUxmin = main.logx ? Math.log10(main.scale_xmin) : main.scale_xmin;
            canv.fUxmax = main.logx ? Math.log10(main.scale_xmax) : main.scale_xmax;
            drawopt = 'fixframe';
         } else if (kind == 'Y') {
            canv.fBottomMargin = pad.fBottomMargin;
            canv.fTopMargin = pad.fTopMargin;
            canv.fLogx = main.logy;
            canv.fUxmin = main.logy ? Math.log10(main.scale_ymin) : main.scale_ymin;
            canv.fUxmax = main.logy ? Math.log10(main.scale_ymax) : main.scale_ymax;
            drawopt = 'rotate';
         }

         canv.fPrimitives.Add(hist, hopt);

         let promise = this.drawInUI5ProjectionArea
                       ? this.drawInUI5ProjectionArea(canv, drawopt)
                       : this.drawInSidePanel(canv, drawopt);

         return promise.then(painter => { this.proj_painter = painter; return painter; });
      }

      this.proj_painter.getMainPainter()?.updateObject(hist, hopt);
      return this.proj_painter.redrawPad();
   }

   /** @summary Checks if canvas shown inside ui5 widget
     * @desc Function should be used only from the func which supposed to be replaced by ui5
     * @private */
   testUI5() {
      if (!this.use_openui) return false;
      console.warn('full ui5 should be used - not loaded yet? Please check!!');
      return true;
   }

   /** @summary Draw in side panel
     * @private */
   async drawInSidePanel(canv, opt) {
      let side = this.selectDom('origin').select('.side_panel');
      return side.empty() ? null : this.drawObject(side.node(), canv, opt);
   }

   /** @summary Show message
     * @desc Used normally with web-based canvas and handled in ui5
     * @private */
   showMessage(msg) {
      if (!this.testUI5())
         showProgress(msg, 7000);
   }

   /** @summary Function called when canvas menu item Save is called */
   saveCanvasAsFile(fname) {
      let pnt = fname.indexOf('.');
      this.createImage(fname.slice(pnt+1))
          .then(res => this.sendWebsocket('SAVE:' + fname + ':' + res));
   }

   /** @summary Send command to server to save canvas with specified name
     * @desc Should be only used in web-based canvas
     * @private */
   sendSaveCommand(fname) {
      this.sendWebsocket('PRODUCE:' + fname);
   }

   /** @summary Submit menu request
     * @private */
   async submitMenuRequest(painter, kind, reqid) {
      // only single request can be handled, no limit better in RCanvas
      return new Promise(resolveFunc => {
         this._getmenu_callback = resolveFunc;
         this.sendWebsocket('GETMENU:' + reqid); // request menu items for given painter
      });
   }

   /** @summary Submit object exec request
     * @private */
   submitExec(painter, exec, snapid) {
      if (this._readonly || !painter) return;

      if (!snapid) snapid = painter.snapid;
      if (snapid && isStr(snapid))
         return this.sendWebsocket(`OBJEXEC:${snapid}:${exec}`);
   }

   /** @summary Send text message with web socket
     * @desc used for communication with server-side of web canvas
     * @private */
   sendWebsocket(msg) {
      if (this._websocket?.canSend()) {
         this._websocket.send(msg);
         return true;
      }
      console.warn(`DROP SEND: ${msg}`);
      return false;
   }

   /** @summary Close websocket connection to canvas
     * @private */
   closeWebsocket(force) {
      if (this._websocket) {
         this._websocket.close(force);
         this._websocket.cleanup();
         delete this._websocket;
      }
   }

   /** @summary Use provided connection for the web canvas
     * @private */
   useWebsocket(handle) {
      this.closeWebsocket();

      this._websocket = handle;
      this._websocket.setReceiver(this);
      this._websocket.connect();
   }

   /** @summary Hanler for websocket open event
     * @private */
   onWebsocketOpened(/*handle*/) {
      // indicate that we are ready to recieve any following commands
   }

   /** @summary Hanler for websocket close event
     * @private */
   onWebsocketClosed(/*handle*/) {
      if (!this.embed_canvas)
         closeCurrentWindow();
   }

   /** @summary Handle websocket messages
     * @private */
   onWebsocketMsg(handle, msg) {
      console.log(`GET MSG len:${msg.length} ${msg.slice(0,60)}`);

      if (msg == 'CLOSE') {
         this.onWebsocketClosed();
         this.closeWebsocket(true);
      } else if (msg.slice(0,6) == 'SNAP6:') {
         // This is snapshot, produced with ROOT6
         let p1 = msg.indexOf(':', 6),
             version = msg.slice(6, p1),
             snap = parse(msg.slice(p1+1));

         this.syncDraw(true).then(() => this.redrawPadSnap(snap)).then(() => {
            this.completeCanvasSnapDrawing();
            let ranges = this.getWebPadOptions(); // all data, including subpads
            if (ranges) ranges = ':' + ranges;
            handle.send('READY6:' + version + ranges); // send ready message back when drawing completed
            this.confirmDraw();
         });
      } else if (msg.slice(0,5) == 'MENU:') {
         // this is menu with exact identifier for object
         let lst = parse(msg.slice(5));
         if (isFunc(this._getmenu_callback)) {
            this._getmenu_callback(lst);
            delete this._getmenu_callback;
         }
      } else if (msg.slice(0,4) == 'CMD:') {
         msg = msg.slice(4);
         let p1 = msg.indexOf(':'),
             cmdid = msg.slice(0,p1),
             cmd = msg.slice(p1+1),
             reply = 'REPLY:' + cmdid + ':';
         if ((cmd == 'SVG') || (cmd == 'PNG') || (cmd == 'JPEG')) {
            this.createImage(cmd.toLowerCase())
                .then(res => handle.send(reply + res));
         } else {
            console.log(`Unrecognized command ${cmd}`);
            handle.send(reply);
         }
      } else if ((msg.slice(0,7) == 'DXPROJ:') || (msg.slice(0,7) == 'DYPROJ:')) {
         let kind = msg[1],
             hist = parse(msg.slice(7));
         this.drawProjection(kind, hist);
      } else if (msg.slice(0,5) == 'SHOW:') {
         let that = msg.slice(5),
             on = (that[that.length-1] == '1');
         this.showSection(that.slice(0,that.length-2), on);
      } else if (msg.slice(0,5) == 'EDIT:') {
         let obj_painter = this.findSnap(msg.slice(5));
         console.log(`GET EDIT ${msg.slice(5)} found ${!!obj_painter}`);
         if (obj_painter)
            this.showSection('Editor', true)
                .then(() => this.producePadEvent('select', obj_painter.getPadPainter(), obj_painter));

      } else {
         console.log(`unrecognized msg ${msg}`);
      }
   }

   /** @summary Handle pad button click event */
   clickPadButton(funcname, evnt) {
      if (funcname == 'ToggleGed') return this.activateGed(this, null, 'toggle');
      if (funcname == 'ToggleStatus') return this.activateStatusBar('toggle');
      super.clickPadButton(funcname, evnt);
   }

   /** @summary Returns true if event status shown in the canvas */
   hasEventStatus() {
      if (this.testUI5())
         return false;
      if (this.brlayout)
         return this.brlayout.hasStatus();
      return getHPainter()?.hasStatusLine() ?? false;
   }

   /** @summary Show/toggle event status bar
     * @private */
   activateStatusBar(state) {
      if (this.testUI5())
         return;
      if (this.brlayout)
         this.brlayout.createStatusLine(23, state);
      else
         getHPainter()?.createStatusLine(23, state);
      this.processChanges('sbits', this);
   }

   /** @summary Show online canvas status
     * @private */
   showCanvasStatus(...msgs) {
      if (this.testUI5()) return;

      let br = this.brlayout || getHPainter()?.brlayout;

      br?.showStatus(...msgs);
   }

   /** @summary Returns true if GED is present on the canvas */
   hasGed() {
      if (this.testUI5()) return false;
      return this.brlayout?.hasContent() ?? false;
   }

   /** @summary Function used to de-activate GED
     * @private */
   removeGed() {
      if (this.testUI5()) return;

      this.registerForPadEvents(null);

      if (this.ged_view) {
         this.ged_view.getController().cleanupGed();
         this.ged_view.destroy();
         delete this.ged_view;
      }
      this.brlayout?.deleteContent(true);

      this.processChanges('sbits', this);
   }

   /** @summary Get view data for ui5 panel
     * @private */
   getUi5PanelData(/* panel_name */) {
      return { jsroot: { settings, create: create$1, parse, toJSON, loadScript, EAxisBits, getColorExec } };
   }

   /** @summary Function used to activate GED
     * @return {Promise} when GED is there
     * @private */
   async activateGed(objpainter, kind, mode) {
      if (this.testUI5() || !this.brlayout)
         return false;

      if (this.brlayout.hasContent()) {
         if ((mode === 'toggle') || (mode === false))
            this.removeGed();
         else
            objpainter?.getPadPainter()?.selectObjectPainter(objpainter);

         return true;
      }

      if (mode === false)
         return false;

      let btns = this.brlayout.createBrowserBtns();

      ToolbarIcons.createSVG(btns, ToolbarIcons.diamand, 15, 'toggle fix-pos mode')
                  .style('margin','3px').on('click', () => this.brlayout.toggleKind('fix'));

      ToolbarIcons.createSVG(btns, ToolbarIcons.circle, 15, 'toggle float mode')
                  .style('margin','3px').on('click', () => this.brlayout.toggleKind('float'));

      ToolbarIcons.createSVG(btns, ToolbarIcons.cross, 15, 'delete GED')
                  .style('margin','3px').on('click', () => this.removeGed());

      // be aware, that jsroot_browser_hierarchy required for flexible layout that element use full browser area
      this.brlayout.setBrowserContent("<div class='jsroot_browser_hierarchy' id='ged_placeholder'>Loading GED ...</div>");
      this.brlayout.setBrowserTitle('GED');
      this.brlayout.toggleBrowserKind(kind || 'float');

      return new Promise(resolveFunc => {

         loadOpenui5().then(sap => {

            select('#ged_placeholder').text('');

            sap.ui.define(['sap/ui/model/json/JSONModel', 'sap/ui/core/mvc/XMLView'], (JSONModel,XMLView) => {

               let oModel = new JSONModel({ handle: null });

               XMLView.create({
                  viewName: 'rootui5.canv.view.Ged',
                  viewData: this.getUi5PanelData('Ged')
               }).then(oGed => {

                  oGed.setModel(oModel);

                  oGed.placeAt('ged_placeholder');

                  this.ged_view = oGed;

                  // TODO: should be moved into Ged controller - it must be able to detect canvas painter itself
                  this.registerForPadEvents(oGed.getController().padEventsReceiver.bind(oGed.getController()));

                  objpainter?.getPadPainter()?.selectObjectPainter(objpainter);

                  console.log('activate GED');
                  this.processChanges('sbits', this);

                  resolveFunc(true);
               });
            });
         });
      });
   }

   /** @summary Show section of canvas  like menu or editor */
   async showSection(that, on) {
      if (this.testUI5())
         return false;

      switch(that) {
         case 'Menu': break;
         case 'StatusBar': this.activateStatusBar(on); break;
         case 'Editor': return this.activateGed(this, null, !!on);
         case 'ToolBar': break;
         case 'ToolTips': this.setTooltipAllowed(on); break;

      }
      return true;
   }

   /** @summary Complete handling of online canvas drawing
     * @private */
   completeCanvasSnapDrawing() {
      if (!this.pad) return;

      if (document && !this.embed_canvas && this._websocket)
         document.title = this.pad.fTitle;

      if (this._all_sections_showed) return;
      this._all_sections_showed = true;
      this.showSection('Menu', this.pad.TestBit(TCanvasStatusBits.kMenuBar));
      this.showSection('StatusBar', this.pad.TestBit(TCanvasStatusBits.kShowEventStatus));
      this.showSection('ToolBar', this.pad.TestBit(TCanvasStatusBits.kShowToolBar));
      this.showSection('Editor', this.pad.TestBit(TCanvasStatusBits.kShowEditor));
      this.showSection('ToolTips', this.pad.TestBit(TCanvasStatusBits.kShowToolTips) || this._highlight_connect);
   }

   /** @summary Handle highlight in canvas - delver information to server
     * @private */
   processHighlightConnect(hints) {
      if (!hints || hints.length == 0 || !this._highlight_connect ||
           !this._websocket || this.doingDraw() || !this._websocket.canSend(2)) return;

      let hint = hints[0] || hints[1];
      if (!hint || !hint.painter || !hint.painter.snapid || !hint.user_info) return;
      let pp = hint.painter.getPadPainter() || this;
      if (!pp.snapid) return;

      let arr = [pp.snapid, hint.painter.snapid, '0', '0'];

      if ((hint.user_info.binx !== undefined) && (hint.user_info.biny !== undefined)) {
         arr[2] = hint.user_info.binx.toString();
         arr[3] = hint.user_info.biny.toString();
      }  else if (hint.user_info.bin !== undefined) {
         arr[2] = hint.user_info.bin.toString();
      }

      let msg = JSON.stringify(arr);

      if (this._last_highlight_msg != msg) {
         this._last_highlight_msg = msg;
         this.sendWebsocket(`HIGHLIGHT:${msg}`);
      }
   }

   /** @summary Method informs that something was changed in the canvas
     * @desc used to update information on the server (when used with web6gui)
     * @private */
   processChanges(kind, painter, subelem) {
      // check if we could send at least one message more - for some meaningful actions
      if (!this._websocket || this._readonly || !this._websocket.canSend(2) || !isStr(kind)) return;

      let msg = '';
      if (!painter) painter = this;
      switch (kind) {
         case 'sbits':
            msg = 'STATUSBITS:' + this.getStatusBits();
            break;
         case 'frame': // when changing frame
         case 'zoom':  // when changing zoom inside frame
            if (!isFunc(painter.getWebPadOptions))
               painter = painter.getPadPainter();
            if (isFunc(painter.getWebPadOptions))
               msg = 'OPTIONS6:' + painter.getWebPadOptions('only_this');
            break;
         case 'drawopt':
            if (painter.snapid)
               msg = 'DRAWOPT:' + JSON.stringify([painter.snapid.toString(), painter.getDrawOpt() || '']);
            break;
         case 'pave_moved':
            if (isFunc(painter.fillWebObjectOptions)) {
               let info = painter.fillWebObjectOptions();
               if (info) msg = 'PRIMIT6:' + toJSON(info);
            }
            break;
         case 'logx':
         case 'logy':
         case 'logz': {
            let pp = painter.getPadPainter();

            if (pp?.snapid && pp?.pad) {
               let name = 'SetLog' + kind[3], value = pp.pad['fLog' + kind[3]];
               painter = pp;
               kind = `exec:${name}(${value})`;
            }
            break;
         }
      }

      if (!msg && painter?.snapid && (kind.slice(0,5) == 'exec:'))
         msg = 'PRIMIT6:' + toJSON({
                  _typename: 'TWebObjectOptions',
                  snapid: painter.snapid.toString() + (subelem ? '#'+subelem : ''),
                  opt: kind.slice(5),
                  fcust: 'exec',
                  fopt: []
               });

      if (msg) {
         console.log(`Sending ${msg.length} ${msg.slice(0,40)}`);
         this._websocket.send(msg);
      } else {
         console.log(`Unprocessed changes ${kind} for painter of ${painter?.getObject()?._typename} subelem ${subelem}`);
      }
   }

   /** @summary Select active pad on the canvas */
   selectActivePad(pad_painter, obj_painter, click_pos) {
      if (!this.snapid || !pad_painter) return; // only interactive canvas

      let arg = null, ischanged = false, is_button = pad_painter.matchObjectType(clTButton);

      if (pad_painter.snapid && this._websocket)
         arg = { _typename: 'TWebPadClick', padid: pad_painter.snapid.toString(), objid: '', x: -1, y: -1, dbl: false };

      if (!pad_painter.is_active_pad && !is_button) {
         ischanged = true;
         this.forEachPainterInPad(pp => pp.drawActiveBorder(null, pp === pad_painter), 'pads');
      }

      if ((obj_painter?.snapid !== undefined) && arg) {
         ischanged = true;
         arg.objid = obj_painter.snapid.toString();
      }

      if (click_pos && arg) {
         ischanged = true;
         arg.x = Math.round(click_pos.x || 0);
         arg.y = Math.round(click_pos.y || 0);
         if (click_pos.dbl) arg.dbl = true;
      }

      if (arg && (ischanged || is_button))
         this.sendWebsocket('PADCLICKED:' + toJSON(arg));
   }

   /** @summary Return actual TCanvas status bits  */
   getStatusBits() {
      let bits = 0;
      if (this.hasEventStatus()) bits |= TCanvasStatusBits.kShowEventStatus;
      if (this.hasGed()) bits |= TCanvasStatusBits.kShowEditor;
      if (this.isTooltipAllowed()) bits |= TCanvasStatusBits.kShowToolTips;
      if (this.use_openui) bits |= TCanvasStatusBits.kMenuBar;
      return bits;
   }

   /** @summary produce JSON for TCanvas, which can be used to display canvas once again */
   produceJSON() {

      let canv = this.getObject(),
          fill0 = (canv.fFillStyle == 0);

      if (fill0) canv.fFillStyle = 1001;

      if (!this.normal_canvas) {

         // fill list of primitives from painters
         this.forEachPainterInPad(p => {
            if (p.$secondary) return; // ignore all secondary painters

            let subobj = p.getObject();
            if (subobj?._typename)
               canv.fPrimitives.Add(subobj, p.getDrawOpt());
         }, 'objects');
      }

      let res = toJSON(canv);

      if (fill0) canv.fFillStyle = 0;

      if (!this.normal_canvas)
         canv.fPrimitives.Clear();

      return res;
   }

   /** @summary draw TCanvas */
   static async draw(dom, can, opt) {
      let nocanvas = !can;
      if (nocanvas) can = create$1(clTCanvas);

      let painter = new TCanvasPainter(dom, can);
      painter.checkSpecialsInPrimitives(can);

      if (!nocanvas && can.fCw && can.fCh && !isBatchMode()) {
         let rect0 = painter.selectDom().node().getBoundingClientRect();
         if (!rect0.height && (rect0.width > 0.1*can.fCw)) {
            painter.selectDom().style('width', can.fCw+'px').style('height', can.fCh+'px');
            painter._fixed_size = true;
         }
      }

      painter.decodeOptions(opt);
      painter.normal_canvas = !nocanvas;
      painter.createCanvasSvg(0);

      painter.addPadButtons();

      if (nocanvas && opt.indexOf('noframe') < 0)
         directDrawTFrame(dom, null);

      // select global reference - required for keys handling
      selectActivePad({ pp: painter, active: true });

      return painter.drawPrimitives().then(() => {
         painter.showPadButtons();
         return painter;
      });
   }

} // class TCanvasPainter


/** @summary Ensure TCanvas and TFrame for the painter object
  * @param {Object} painter  - painter object to process
  * @param {string|boolean} frame_kind  - false for no frame or '3d' for special 3D mode
  * @desc Assign dom, creates TCanvas if necessary, add to list of pad painters */
async function ensureTCanvas(painter, frame_kind) {
   if (!painter)
      return Promise.reject(Error('Painter not provided in ensureTCanvas'));

   // simple check - if canvas there, can use painter
   let noframe = (frame_kind === false) || (frame_kind == '3d') ? 'noframe' : '',
       promise = painter.getCanvSvg().empty()
                 ? TCanvasPainter.draw(painter.getDom(), null, noframe)
                 : Promise.resolve(true);

   return promise.then(() => {
      if ((frame_kind !== false) &&  painter.getFrameSvg().select('.main_layer').empty() && !painter.getFramePainter())
         directDrawTFrame(painter.getDom(), null, frame_kind);

      painter.addToPadPrimitives();
      return painter;
   });
}

/** @summary draw TPad snapshot from TWebCanvas
  * @private */
async function drawTPadSnapshot(dom, snap /*, opt*/) {
   let can = create$1(clTCanvas),
       painter = new TCanvasPainter(dom, can);
   painter.normal_canvas = false;
   painter.addPadButtons();

   return painter.syncDraw(true).then(() => painter.redrawPadSnap(snap)).then(() => {
      painter.confirmDraw();
      painter.showPadButtons();
      return painter;
   });
}

/** @summary draw TGaxis object
  * @private */
function drawTGaxis(dom, obj, opt) {
   let painter = new TAxisPainter(dom, obj, false);
   painter.disable_zooming = true;
   return ensureTCanvas(painter, false).then(() => {
      if (opt) painter.convertTo(opt);
      return painter.redraw();
   }).then(() => painter);
}

/** @summary draw TGaxis object
  * @private */
function drawTFrame(dom, obj, opt) {
   let fp = new TFramePainter(dom, obj);
   return ensureTCanvas(fp, false).then(() => {
      if (opt == '3d') fp.mode3d = true;
      return fp.redraw();
   });
}

var TCanvasPainter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
ensureTCanvas: ensureTCanvas,
drawTPadSnapshot: drawTPadSnapshot,
drawTGaxis: drawTGaxis,
drawTFrame: drawTFrame,
TPadPainter: TPadPainter,
TCanvasPainter: TCanvasPainter
});

const clTDiamond = 'TDiamond', clTPavesText = 'TPavesText', clTPaveLabel = 'TPaveLabel';

/**
 * @summary painter for TPave-derived classes
 *
 * @private
 */

class TPavePainter extends ObjectPainter {

   /** @summary constructor
     * @param {object|string} dom - DOM element for drawing or element id
     * @param {object} pave - TPave-based object */
   constructor(dom, pave) {
      super(dom, pave);
      this.Enabled = true;
      this.UseContextMenu = true;
      this.UseTextColor = false; // indicates if text color used, enabled menu entry
   }

   /** @summary Draw pave and content
     * @return {Promise} */
   async drawPave(arg) {

      this.UseTextColor = false;

      if (!this.Enabled) {
         this.removeG();
         return this;
      }

      let pt = this.getObject(), opt = pt.fOption.toUpperCase(),
          fp = this.getFramePainter(), pp = this.getPadPainter();

      if (pt.fInit === 0) {
         this.stored = Object.assign({}, pt); // store coordinates to use them when updating
         pt.fInit = 1;
         let pad = pp.getRootPad(true);

         if ((pt._typename == clTPaletteAxis) && !pt.fX1 && !pt.fX2 && !pt.fY1 && !pt.fY2) {
            if (fp) {
               pt.fX1NDC = fp.fX2NDC + 0.01;
               pt.fX2NDC = Math.min(0.96, fp.fX2NDC + 0.06);
               pt.fY1NDC = fp.fY1NDC;
               pt.fY2NDC = fp.fY2NDC;
            } else {
               pt.fX2NDC = 0.8;
               pt.fX1NDC = 0.9;
               pt.fY1NDC = 0.1;
               pt.fY2NDC = 0.9;
            }
         } else if (opt.indexOf('NDC') >= 0) {
            pt.fX1NDC = pt.fX1; pt.fX2NDC = pt.fX2;
            pt.fY1NDC = pt.fY1; pt.fY2NDC = pt.fY2;
         } else if (pad && (pad.fX1 == 0) && (pad.fX2 == 1) && (pad.fY1 == 0) && (pad.fY2 == 1) && isStr(arg) && (arg.indexOf('postpone') >= 0)) {
            // special case when pad not yet initialized
            pt.fInit = 0; // do not init until axes drawn
            pt.fX1NDC = pt.fY1NDC = 0.99;
            pt.fX2NDC = pt.fY2NDC = 1;
         } else if (pad) {
            if (pad.fLogx) {
               if (pt.fX1 > 0) pt.fX1 = Math.log10(pt.fX1);
               if (pt.fX2 > 0) pt.fX2 = Math.log10(pt.fX2);
            }
            if (pad.fLogy) {
               if (pt.fY1 > 0) pt.fY1 = Math.log10(pt.fY1);
               if (pt.fY2 > 0) pt.fY2 = Math.log10(pt.fY2);
            }
            pt.fX1NDC = (pt.fX1 - pad.fX1) / (pad.fX2 - pad.fX1);
            pt.fY1NDC = (pt.fY1 - pad.fY1) / (pad.fY2 - pad.fY1);
            pt.fX2NDC = (pt.fX2 - pad.fX1) / (pad.fX2 - pad.fX1);
            pt.fY2NDC = (pt.fY2 - pad.fY1) / (pad.fY2 - pad.fY1);

         } else {
            pt.fX1NDC = pt.fY1NDC = 0.1;
            pt.fX2NDC = pt.fY2NDC = 0.9;
         }

         if ((pt.fX1NDC == pt.fX2NDC) && (pt.fY1NDC == pt.fY2NDC) && (pt._typename == clTLegend)) {
            pt.fX1NDC = Math.max(pad ? pad.fLeftMargin : 0, pt.fX2NDC - 0.3);
            pt.fX2NDC = Math.min(pt.fX1NDC + 0.3, pad ? 1 - pad.fRightMargin : 1);
            let h0 = Math.max(pt.fPrimitives ? pt.fPrimitives.arr.length*0.05 : 0, 0.2);
            pt.fY2NDC = Math.min(pad ? 1 - pad.fTopMargin : 1, pt.fY1NDC + h0);
            pt.fY1NDC = Math.max(pt.fY2NDC - h0, pad ? pad.fBottomMargin : 0);
         }
      }

      // fill stats before drawing to have coordinates early
      if (this.isStats() && !this.NoFillStats && !pp?._fast_drawing) {

         let main = pt.$main_painter || this.getMainPainter();

         if (isFunc(main?.fillStatistic)) {

            let dostat = parseInt(pt.fOptStat), dofit = parseInt(pt.fOptFit);
            if (!Number.isInteger(dostat)) dostat = gStyle.fOptStat;
            if (!Number.isInteger(dofit)) dofit = gStyle.fOptFit;

            // we take statistic from main painter
            if (main.fillStatistic(this, dostat, dofit)) {

               // adjust the size of the stats box with the number of lines
               let nlines = pt.fLines?.arr.length || 0;
               if ((nlines > 0) && !this.moved_interactive && ((gStyle.fStatFontSize <= 0) || (gStyle.fStatFont % 10 === 3)))
                  pt.fY1NDC = pt.fY2NDC - nlines * 0.25 * gStyle.fStatH;
            }
         }
      }

      let pad_rect = pp.getPadRect(),
          brd = pt.fBorderSize,
          dx = (opt.indexOf('L') >= 0) ? -1 : ((opt.indexOf('R') >= 0) ? 1 : 0),
          dy = (opt.indexOf('T') >= 0) ? -1 : ((opt.indexOf('B') >= 0) ? 1 : 0);

      // container used to recalculate coordinates
      this.createG();

      this._pave_x = Math.round(pt.fX1NDC * pad_rect.width);
      this._pave_y = Math.round((1.0 - pt.fY2NDC) * pad_rect.height);
      let width = Math.round((pt.fX2NDC - pt.fX1NDC) * pad_rect.width),
          height = Math.round((pt.fY2NDC - pt.fY1NDC) * pad_rect.height);

      this.draw_g.attr('transform', `translate(${this._pave_x},${this._pave_y})`);

      this.createAttLine({ attr: pt, width: (brd > 0) ? pt.fLineWidth : 0 });

      this.createAttFill({ attr: pt });

      if (pt._typename == clTDiamond) {
         let h2 = Math.round(height/2), w2 = Math.round(width/2),
             dpath = `l${w2},${-h2}l${w2},${h2}l${-w2},${h2}z`;

         if ((brd > 1) && (pt.fShadowColor > 0) && (dx || dy) && !this.fillatt.empty())
            this.draw_g.append('svg:path')
                 .attr('d','M0,'+(h2+brd) + dpath)
                 .style('fill', this.getColor(pt.fShadowColor))
                 .style('stroke', this.getColor(pt.fShadowColor))
                 .style('stroke-width', '1px');

         this.draw_g.append('svg:path')
             .attr('d', 'M0,'+h2 +dpath)
             .call(this.fillatt.func)
             .call(this.lineatt.func);

         let text_g = this.draw_g.append('svg:g')
                                 .attr('transform', `translate(${Math.round(width/4)},${Math.round(height/4)})`);

         return this.drawPaveText(w2, h2, arg, text_g);
      }

      // add shadow decoration before main rect
      if ((brd > 1) && (pt.fShadowColor > 0) && !pt.fNpaves && (dx || dy)) {
         let spath = '', scol = this.getColor(pt.fShadowColor);
         if (this.fillatt.empty()) {
            if ((dx < 0) && (dy < 0))
               spath = `M0,0v${height-brd}h${-brd}v${-height}h${width}v${brd}`;
            else // ((dx < 0) && (dy > 0))
               spath = `M0,${height}v${brd-height}h${-brd}v${height}h${width}v${-brd}`;
         } else {
            // when main is filled, one also can use fill for shadow to avoid complexity
            spath = `M${dx*brd},${dy*brd}v${height}h${width}v${-height}`;
         }
         this.draw_g.append('svg:path')
                    .attr('d', spath + 'z')
                    .style('fill', scol)
                    .style('stroke', scol)
                    .style('stroke-width', '1px');
      }

      if (pt.fNpaves)
         for (let n = pt.fNpaves-1; n > 0; --n)
            this.draw_g.append('svg:path')
               .attr('d', `M${dx*4*n},${dy*4*n}h${width}v${height}h${-width}z`)
               .call(this.fillatt.func)
               .call(this.lineatt.func);

      let rect;
      if (!isBatchMode() || !this.fillatt.empty() || !this.lineatt.empty())
           rect = this.draw_g.append('svg:path')
                      .attr('d', `M0,0H${width}V${height}H0Z`)
                      .call(this.fillatt.func)
                      .call(this.lineatt.func);

      let promise = this.paveDrawFunc ? this.paveDrawFunc(width, height, arg) : Promise.resolve(true);

      return promise.then(() => {

         if (isBatchMode() || (pt._typename === clTPave)) return this;

         // here all kind of interactive settings
         if (rect)
            rect.style('pointer-events', 'visibleFill')
                .on('mouseenter', () => this.showObjectStatus());

         addDragHandler(this, { obj: pt, x: this._pave_x, y: this._pave_y, width, height,
                                minwidth: 10, minheight: 20, canselect: true,
                        redraw: () => { this.moved_interactive = true; this.interactiveRedraw(false, 'pave_moved'); this.drawPave(); },
                        ctxmenu: browser$1.touches && settings.ContextMenu && this.UseContextMenu });

         if (this.UseContextMenu && settings.ContextMenu)
             this.draw_g.on('contextmenu', evnt => this.paveContextMenu(evnt));

         if (pt._typename == clTPaletteAxis)
            this.interactivePaletteAxis(width, height);

         return this;
      });
   }

   /** @summary Fill option object used in TWebCanvas */
   fillWebObjectOptions(res) {

      let pave = this.getObject();

      if (!res) {
         let snapid = this.snapid;
         if (!snapid && this._hist_painter?.snapid && pave?.fName)
            snapid = this._hist_painter.snapid + '#func_' + pave.fName;

         if (!snapid) return null;
         res = { _typename: 'TWebObjectOptions', snapid: snapid.toString(), opt: this.getDrawOpt(), fcust: '', fopt: [] };
      }

      if (pave?.fInit) {
         res.fcust = 'pave';
         res.fopt = [pave.fX1NDC, pave.fY1NDC, pave.fX2NDC, pave.fY2NDC];
      }

      return res;
   }

   /** @summary draw TPaveLabel object */
   async drawPaveLabel(width, height) {
      let pave = this.getObject();
      if (!pave.fLabel || !pave.fLabel.trim())
         return this;

      this.UseTextColor = true;

      this.startTextDrawing(pave.fTextFont, height/1.2);

      this.drawText({ align: pave.fTextAlign, width, height, text: pave.fLabel, color: this.getColor(pave.fTextColor) });

      return this.finishTextDrawing();
   }

   /** @summary draw TPaveStats object */
   drawPaveStats(width, height) {

      let pt = this.getObject(), lines = [],
          color = this.getColor(pt.fTextColor),
          first_stat = 0, num_cols = 0, maxlen = 0;

      // now draw TLine and TBox objects
      for (let j = 0; j < pt.fLines.arr.length; ++j) {
         let entry = pt.fLines.arr[j];
         if ((entry._typename == clTText) || (entry._typename == clTLatex))
            lines.push(entry.fTitle);
      }

      let nlines = lines.length;

      // adjust font size
      for (let j = 0; j < nlines; ++j) {
         let line = lines[j];
         if (j > 0) maxlen = Math.max(maxlen, line.length);
         if ((j == 0) || (line.indexOf('|') < 0)) continue;
         if (first_stat === 0) first_stat = j;
         let parts = line.split('|');
         if (parts.length > num_cols)
            num_cols = parts.length;
      }

      // for characters like 'p' or 'y' several more pixels required to stay in the box when drawn in last line
      let stepy = height / nlines, has_head = false, margin_x = pt.fMargin * width;

      this.startTextDrawing(pt.fTextFont, height/(nlines * 1.2));

      this.UseTextColor = true;

      if (nlines == 1) {
         this.drawText({ align: pt.fTextAlign, width, height, text: lines[0], color, latex: 1 });
      } else
      for (let j = 0; j < nlines; ++j) {
         let y = j*stepy;
         this.UseTextColor = true;

         if (first_stat && (j >= first_stat)) {
            let parts = lines[j].split('|');
            for (let n = 0; n < parts.length; ++n)
               this.drawText({ align: 'middle', x: width * n / num_cols, y, latex: 0,
                               width: width/num_cols, height: stepy, text: parts[n], color });
         } else if (lines[j].indexOf('=') < 0) {
            if (j == 0) {
               has_head = true;
               let max_hlen = Math.max(maxlen, Math.round((width-2*margin_x)/stepy/0.65));
               if (lines[j].length > max_hlen + 5)
                  lines[j] = lines[j].slice(0,max_hlen+2) + '...';
            }
            this.drawText({ align: (j == 0) ? 'middle' : 'start', x: margin_x, y,
                            width: width-2*margin_x, height: stepy, text: lines[j], color });
         } else {
            let parts = lines[j].split('='), args = [];

            for (let n = 0; n < 2; ++n) {
               let arg = {
                  align: (n == 0) ? 'start' : 'end', x: margin_x, y,
                  width: width-2*margin_x, height: stepy, text: parts[n], color,
                  _expected_width: width-2*margin_x, _args: args,
                  post_process(painter) {
                    if (this._args[0].ready && this._args[1].ready)
                       painter.scaleTextDrawing(1.05*(this._args[0].result_width+this._args[1].result_width)/this._expected_width, painter.draw_g);
                  }
               };
               args.push(arg);
            }

            for (let n = 0; n < 2; ++n)
               this.drawText(args[n]);
         }
      }

      let lpath = '';

      if ((pt.fBorderSize > 0) && has_head)
         lpath += `M0,${Math.round(stepy)}h${width}`;

      if ((first_stat > 0) && (num_cols > 1)) {
         for (let nrow = first_stat; nrow < nlines; ++nrow)
            lpath += `M0,${Math.round(nrow * stepy)}h${width}`;
         for (let ncol = 0; ncol < num_cols - 1; ++ncol)
            lpath += `M${Math.round(width / num_cols * (ncol + 1))},${Math.round(first_stat * stepy)}V${height}`;
      }

      if (lpath) this.draw_g.append('svg:path').attr('d',lpath).call(this.lineatt.func);

      // this.draw_g.classed('most_upper_primitives', true); // this primitive will remain on top of list

      return this.finishTextDrawing(undefined, (nlines > 1));
   }

   /** @summary draw TPaveText object */
   drawPaveText(width, height, dummy_arg, text_g) {

      let pt = this.getObject(),
          tcolor = this.getColor(pt.fTextColor),
          arr = pt?.fLines?.arr || [],
          nlines = arr.length,
          pp = this.getPadPainter(),
          pad_height = pp.getPadHeight(),
          draw_header = (pt.fLabel.length > 0),
          promises = [],
          stepy = height / (nlines || 1),
          margin_x = pt.fMargin * width, max_font_size = 0;

      // for single line (typically title) limit font size
      if ((nlines == 1) && (pt.fTextSize > 0)) {
         max_font_size = Math.round(pt.fTextSize * pad_height);
         if (max_font_size < 3) max_font_size = 3;
      }

      if (!text_g) text_g = this.draw_g;

      let fast = (nlines == 1) && pp?._fast_drawing, num_default = 0;

      for(let nline = 0; nline < nlines; ++nline) {
         let entry = arr[nline], texty = nline*stepy;

         switch(entry._typename) {
            case clTText:
            case clTLatex:
               if (!entry.fTitle || !entry.fTitle.trim()) continue;

               if (entry.fX || entry.fY) {
                  // individual positioning
                  let x = entry.fX ? entry.fX*width : margin_x,
                      y = entry.fY ? (1 - entry.fY)*height : texty,
                      color = entry.fTextColor ? this.getColor(entry.fTextColor) : '';
                  if (!color) {
                     color = tcolor;
                     this.UseTextColor = true;
                  }

                  let sub_g = text_g.append('svg:g');

                  this.startTextDrawing(pt.fTextFont, (entry.fTextSize || pt.fTextSize) * pad_height, sub_g);

                  this.drawText({ align: entry.fTextAlign || pt.fTextAlign, x, y, text: entry.fTitle, color,
                                  latex: (entry._typename == clTText) ? 0 : 1,  draw_g: sub_g, fast });

                  promises.push(this.finishTextDrawing(sub_g));
               } else {
                  // default position
                  if (num_default++ === 0)
                     this.startTextDrawing(pt.fTextFont, height/(nlines * 1.2), text_g, max_font_size);

                  let arg = null;

                  if (nlines == 1) {
                     arg = { x: 0, y: 0, width, height };
                  } else {
                     arg = { x: margin_x, y: texty, width: width - 2*margin_x, height: stepy };
                     if (entry.fTextColor) arg.color = this.getColor(entry.fTextColor);
                     if (entry.fTextSize) arg.font_size = Math.round(entry.fTextSize * pad_height);
                  }

                  arg.align = entry.fTextAlign || pt.fTextAlign;
                  arg.draw_g = text_g;
                  arg.latex = (entry._typename == clTText ? 0 : 1);
                  arg.text = entry.fTitle;
                  arg.fast = fast;
                  if (!arg.color) { this.UseTextColor = true; arg.color = tcolor; }
                  this.drawText(arg);
               }
               break;

            case clTLine:
               let lx1 = entry.fX1 ? Math.round(entry.fX1*width) : 0,
                   lx2 = entry.fX2 ? Math.round(entry.fX2*width) : width,
                   ly1 = entry.fY1 ? Math.round((1 - entry.fY1)*height) : Math.round(texty + stepy*0.5),
                   ly2 = entry.fY2 ? Math.round((1 - entry.fY2)*height) : Math.round(texty + stepy*0.5),
                   lineatt = new TAttLineHandler(entry);
               text_g.append('svg:path')
                     .attr('d', `M${lx1},${ly1}L${lx2},${ly2}`)
                     .call(lineatt.func);
               break;

            case clTBox:
               let bx1 = entry.fX1 ? Math.round(entry.fX1*width) : 0,
                   bx2 = entry.fX2 ? Math.round(entry.fX2*width) : width,
                   by1 = entry.fY1 ? Math.round((1 - entry.fY1)*height) : Math.round(texty),
                   by2 = entry.fY2 ? Math.round((1 - entry.fY2)*height) : Math.round(texty + stepy),
                   fillatt = this.createAttFill(entry);
               text_g.append('svg:path')
                     .attr('d', `M${bx1},${by1}H${bx2}V${by2}H${bx1}Z`)
                     .call(fillatt.func);
               break;
         }
      }

      if (num_default > 0)
         promises.push(this.finishTextDrawing(text_g, num_default > 1));

      if (draw_header) {
         let x = Math.round(width*0.25),
             y = Math.round(-height*0.02),
             w = Math.round(width*0.5),
             h = Math.round(height*0.04),
             lbl_g = text_g.append('svg:g');

         lbl_g.append('svg:path')
               .attr('d', `M${x},${y}h${w}v${h}h${-w}z`)
               .call(this.fillatt.func)
               .call(this.lineatt.func);

         this.startTextDrawing(pt.fTextFont, h/1.5, lbl_g);

         this.drawText({ align: 22, x, y, width: w, height: h, text: pt.fLabel, color: tcolor, draw_g: lbl_g });

         promises.push(this.finishTextDrawing(lbl_g));

         this.UseTextColor = true;
      }

      return Promise.all(promises).then(() => this);
   }

   /** @summary Method used to convert value to string according specified format
     * @desc format can be like 5.4g or 4.2e or 6.4f or 'stat' or 'fit' or 'entries' */
   format(value, fmt) {
      if (!fmt) fmt = 'stat';

      let pave = this.getObject();

      switch(fmt) {
         case 'stat' : fmt = pave.fStatFormat || gStyle.fStatFormat; break;
         case 'fit': fmt = pave.fFitFormat || gStyle.fFitFormat; break;
         case 'entries': if ((Math.abs(value) < 1e9) && (Math.round(value) == value)) return value.toFixed(0); fmt = '14.7g'; break;
         case 'last': fmt = this.lastformat; break;
      }

      let res = floatToString(value, fmt || '6.4g', true);

      this.lastformat = res[1];

      return res[0];
   }

   /** @summary Draw TLegend object */
   drawLegend(w, h) {

      let legend = this.getObject(),
          nlines = legend.fPrimitives.arr.length,
          ncols = legend.fNColumns,
          nrows = nlines;

      if (ncols < 2) {
         ncols = 1;
      } else {
         while ((nrows-1)*ncols >= nlines) nrows--;
      }

      const isEmpty = entry => !entry.fObject && !entry.fOption && (!entry.fLabel || (entry.fLabel == ' '));

      if (ncols == 1)
         for (let ii = 0; ii < nlines; ++ii)
            if (isEmpty(legend.fPrimitives.arr[ii])) nrows--;

      if (nrows < 1) nrows = 1;

      let tcolor = this.getColor(legend.fTextColor),
          column_width = Math.round(w/ncols),
          padding_x = Math.round(0.03*w/ncols),
          padding_y = Math.round(0.03*h),
          step_y = (h - 2*padding_y)/nrows,
          font_size = 0.9*step_y,
          max_font_size = 0, // not limited in the beggining
          pp = this.getPadPainter(),
          ph = pp.getPadHeight(),
          any_opt = false, i = -1;

      if (legend.fTextSize && (ph*legend.fTextSize > 2) && (ph*legend.fTextSize < font_size))
         font_size = max_font_size = Math.round(ph*legend.fTextSize);

      this.startTextDrawing(legend.fTextFont, font_size, this.draw_g, max_font_size);

      for (let ii = 0; ii < nlines; ++ii) {
         let leg = legend.fPrimitives.arr[ii];

         if (isEmpty(leg)) continue; // let discard empty entry

         if (ncols == 1) ++i; else i = ii;

         let lopt = leg.fOption.toLowerCase(),
             icol = i % ncols, irow = (i - icol) / ncols,
             x0 = icol * column_width,
             tpos_x = x0 + Math.round(legend.fMargin*column_width),
             mid_x = Math.round((x0 + tpos_x)/2),
             pos_y = Math.round(irow*step_y + padding_y), // top corner
             mid_y = Math.round((irow+0.5)*step_y + padding_y), // center line
             o_fill = leg, o_marker = leg, o_line = leg,
             mo = leg.fObject,
             painter = null, isany = false;

         const draw_fill = lopt.indexOf('f') != -1,
               draw_line = lopt.indexOf('l') != -1,
               draw_error = lopt.indexOf('e') != -1,
               draw_marker = lopt.indexOf('p') != -1;

         if (isObject(mo)) {
            if ('fLineColor' in mo) o_line = mo;
            if ('fFillColor' in mo) o_fill = mo;
            if ('fMarkerColor' in mo) o_marker = mo;

            painter = pp.findPainterFor(mo);
         }

         // Draw fill pattern (in a box)
         if (draw_fill) {
            let lineatt, fillatt = painter?.fillatt || this.createAttFill(o_fill);
            if ((lopt.indexOf('l') < 0 && lopt.indexOf('e') < 0) && (lopt.indexOf('p') < 0)) {
               lineatt = painter?.lineatt || new TAttLineHandler(o_line);
               if (lineatt.empty()) lineatt = null;
            }

            if (!fillatt.empty() || lineatt) {
                isany = true;
               // box total height is yspace*0.7
               // define x,y as the center of the symbol for this entry
               let rect = this.draw_g.append('svg:path')
                              .attr('d', `M${x0 + padding_x},${Math.round(pos_y+step_y*0.1)}v${Math.round(step_y*0.8)}h${tpos_x-2*padding_x-x0}v${-Math.round(step_y*0.8)}z`)
                              .call(fillatt.func);
                if (lineatt)
                   rect.call(lineatt.func);
            }
         }

         // Draw line and error (when specified)
         if (draw_line || draw_error) {
            let lineatt = painter?.lineatt || new TAttLineHandler(o_line);
            if (!lineatt.empty()) {
               isany = true;
               this.draw_g.append('svg:path')
                  .attr('d', `M${x0 + padding_x},${mid_y}H${tpos_x - padding_x}`)
                  .call(lineatt.func);
               if (draw_error)
                  this.draw_g.append('svg:path')
                      .attr('d', `M${mid_x},${Math.round(pos_y+step_y*0.1)}V${Math.round(pos_y+step_y*0.9)}`)
                      .call(lineatt.func);
            }
         }

         // Draw Polymarker
         if (draw_marker) {
            let marker = painter?.markeratt || new TAttMarkerHandler(o_marker);
            if (!marker.empty()) {
               isany = true;
               this.draw_g
                   .append('svg:path')
                   .attr('d', marker.create((x0 + tpos_x)/2, mid_y))
                   .call(marker.func);
            }
         }

         // special case - nothing draw, try to show rect with line attributes
         if (!isany && painter?.lineatt && !painter.lineatt.empty())
            this.draw_g.append('svg:path')
                       .attr('d', `M${x0 + padding_x},${Math.round(pos_y+step_y*0.1)}v${Math.round(step_y*0.8)}h${tpos_x-2*padding_x-x0}v${-Math.round(step_y*0.8)}z`)
                       .style('fill', 'none')
                       .call(painter.lineatt.func);

         let pos_x = tpos_x;
         if (lopt)
            any_opt = true;
         else if (!any_opt)
            pos_x = x0 + padding_x;

         if (leg.fLabel)
            this.drawText({ align: legend.fTextAlign, x: pos_x, y: pos_y, width: x0+column_width-pos_x-padding_x, height: step_y, text: leg.fLabel, color: tcolor });
      }

      // rescale after all entries are shown
      return this.finishTextDrawing();
   }

   /** @summary draw color palette with axis */
   drawPaletteAxis(s_width, s_height, arg) {

      let palette = this.getObject(),
          axis = palette.fAxis,
          can_move = isStr(arg) && (arg.indexOf('can_move') >= 0),
          postpone_draw = isStr(arg) && (arg.indexOf('postpone') >= 0),
          cjust = isStr(arg) && (arg.indexOf('cjust') >= 0),
          pp = this.getPadPainter(),
          width = pp.getPadWidth(),
          height = pp.getPadHeight(),
          pad = pp.getRootPad(true),
          main = palette.$main_painter || this.getMainPainter(),
          framep = this.getFramePainter(),
          zmin = 0, zmax = 100, gzmin, gzmax,
          contour = main.fContour,
          levels = contour ? contour.getLevels() : null,
          draw_palette = main.fPalette, axis_transform = '';

      this._palette_vertical = (palette.fX2NDC - palette.fX1NDC) < (palette.fY2NDC - palette.fY1NDC);

      axis.fTickSize = 0.6 * s_width / width; // adjust axis ticks size

      if (contour && framep) {
         if ((framep.zmin !== undefined) && (framep.zmax !== undefined) && (framep.zmin !== framep.zmax)) {
            gzmin = framep.zmin;
            gzmax = framep.zmax;
            zmin = framep.zoom_zmin;
            zmax = framep.zoom_zmax;
            if (zmin === zmax) { zmin = gzmin; zmax = gzmax; }
         } else {
            zmin = levels[0];
            zmax = levels[levels.length-1];
         }
         //zmin = Math.min(levels[0], framep.zmin);
         //zmax = Math.max(levels[levels.length-1], framep.zmax);
      } else if ((main.gmaxbin !== undefined) && (main.gminbin !== undefined)) {
         // this is case of TH2 (needs only for size adjustment)
         zmin = main.gminbin; zmax = main.gmaxbin;
      } else if ((main.hmin !== undefined) && (main.hmax !== undefined)) {
         // this is case of TH1
         zmin = main.hmin; zmax = main.hmax;
      }

      this.draw_g.selectAll('rect').style('fill', 'white');

      if ((gzmin === undefined) || (gzmax === undefined) || (gzmin == gzmax)) {
         gzmin = zmin; gzmax = zmax;
      }

      if (this._palette_vertical) {
         this._swap_side = palette.fX2NDC < 0.5;
         this.z_handle.configureAxis('zaxis', gzmin, gzmax, zmin, zmax, true, [0, s_height], { log: pad ? pad.fLogz : 0, fixed_ticks: cjust ? levels : null, maxTickSize: Math.round(s_width*0.7), swap_side: this._swap_side });
         axis_transform = this._swap_side ? '' : `translate(${s_width})`;
      } else {
         this._swap_side = palette.fY1NDC > 0.5;
         this.z_handle.configureAxis('zaxis', gzmin, gzmax, zmin, zmax, false, [0, s_width], { log: pad ? pad.fLogz : 0, fixed_ticks: cjust ? levels : null, maxTickSize: Math.round(s_height*0.7), swap_side: this._swap_side });
         axis_transform = this._swap_side ? '' : `translate(0,${s_height})`;
      }

      if (!contour || !draw_palette || postpone_draw)
         // we need such rect to correctly calculate size
         this.draw_g.append('svg:path')
                    .attr('d', `M0,0H${s_width}V${s_height}H0Z`)
                    .style('fill', 'white');
      else
         for (let i = 0; i < levels.length-1; ++i) {
            let z0 = Math.round(this.z_handle.gr(levels[i])),
                z1 = Math.round(this.z_handle.gr(levels[i+1])),
                lvl = (levels[i]+levels[i+1])/2, d;

            if (this._palette_vertical) {
               if ((z1 >= s_height) || (z0 < 0)) continue;
               z0 += 1; // ensure correct gap filling between colors

               if (z0 > s_height) {
                  z0 = s_height;
                  lvl = levels[i]*0.001+levels[i+1]*0.999;
               } else if (z1 < 0) {
                  z1 = 0;
                  lvl = levels[i]*0.999+levels[i+1]*0.001;
               }
               d = `M0,${z1}H${s_width}V${z0}H0Z`;
            } else {
               if ((z0 >= s_width) || (z1 < 0)) continue;
               z1 += 1; // ensure correct gap filling between colors

               if (z1 > s_width) {
                  z1 = s_width;
                  lvl = levels[i]*0.999+levels[i+1]*0.001;
               } else if (z0 < 0) {
                  z0 = 0;
                  lvl = levels[i]*0.001+levels[i+1]*0.999;
               }
               d = `M${z0},0V${s_height}H${z1}V0Z`;
            }

            let col = contour.getPaletteColor(draw_palette, lvl);
            if (!col) continue;

            let r = this.draw_g.append('svg:path')
                       .attr('d', d)
                       .style('fill', col)
                       .property('fill0', col)
                       .property('fill1', rgb(col).darker(0.5).formatHex());

            if (this.isTooltipAllowed())
               r.on('mouseover', function() {
                  select(this).transition().duration(100).style('fill', select(this).property('fill1'));
               }).on('mouseout', function() {
                  select(this).transition().duration(100).style('fill', select(this).property('fill0'));
               }).append('svg:title').text(levels[i].toFixed(2) + ' - ' + levels[i+1].toFixed(2));

            if (settings.Zooming)
               r.on('dblclick', () => this.getFramePainter().unzoom('z'));
         }

      return this.z_handle.drawAxis(this.draw_g, s_width, s_height, axis_transform).then(() => {

         if (can_move && ('getBoundingClientRect' in this.draw_g.node())) {
            let rect = this.draw_g.node().getBoundingClientRect();

            if (this._palette_vertical) {
               let shift = (this._pave_x + parseInt(rect.width)) - Math.round(0.995*width) + 3;

               if (shift > 0) {
                  this._pave_x -= shift;
                  this.draw_g.attr('transform', `translate(${this._pave_x},${this._pave_y})`);
                  palette.fX1NDC -= shift/width;
                  palette.fX2NDC -= shift/width;
               }
            } else {
               let shift = Math.round((1.05 - gStyle.fTitleY)*height) - rect.y;
               if (shift > 0) {
                  this._pave_y += shift;
                  this.draw_g.attr('transform', `translate(${this._pave_x},${this._pave_y})`);
                  palette.fY1NDC -= shift/height;
                  palette.fY2NDC -= shift/height;
               }
            }
         }

         return this;
      });
   }

   /** @summary Add interactive methods for palette drawing */
   interactivePaletteAxis(s_width, s_height) {
      let doing_zoom = false, sel1 = 0, sel2 = 0, zoom_rect = null;

      const moveRectSel = evnt => {

         if (!doing_zoom) return;
         evnt.preventDefault();

         let m = pointer(evnt, this.draw_g.node());
         if (this._palette_vertical) {
            sel2 = Math.min(Math.max(m[1], 0), s_height);
            zoom_rect.attr('y', Math.min(sel1, sel2))
                     .attr('height', Math.abs(sel2-sel1));
         } else {
            sel2 = Math.min(Math.max(m[0], 0), s_width);
            zoom_rect.attr('x', Math.min(sel1, sel2))
                     .attr('width', Math.abs(sel2-sel1));
         }
      }, endRectSel = evnt => {
         if (!doing_zoom) return;

         evnt.preventDefault();
         select(window).on('mousemove.colzoomRect', null)
                          .on('mouseup.colzoomRect', null);
         zoom_rect.remove();
         zoom_rect = null;
         doing_zoom = false;

         let z = this.z_handle.gr, z1 = z.invert(sel1), z2 = z.invert(sel2);

         this.getFramePainter().zoom('z', Math.min(z1, z2), Math.max(z1, z2));
      }, startRectSel = evnt => {
         // ignore when touch selection is activated
         if (doing_zoom) return;
         doing_zoom = true;

         evnt.preventDefault();
         evnt.stopPropagation();

         let origin = pointer(evnt, this.draw_g.node());

         zoom_rect = this.draw_g.append('svg:rect').attr('class', 'zoom').attr('id', 'colzoomRect');

         if (this._palette_vertical) {
            sel1 = sel2 = origin[1];
            zoom_rect.attr('x', '0')
                     .attr('width', s_width)
                     .attr('y', sel1)
                     .attr('height', 1);
         } else {
            sel1 = sel2 = origin[0];
            zoom_rect.attr('x', sel1)
                     .attr('width', 1)
                     .attr('y', 0)
                     .attr('height', s_height);
         }

         select(window).on('mousemove.colzoomRect', moveRectSel)
                          .on('mouseup.colzoomRect', endRectSel, true);
      };

      if (settings.Zooming)
         this.draw_g.selectAll('.axis_zoom')
                    .on('mousedown', startRectSel)
                    .on('dblclick', () => this.getFramePainter().unzoom('z'));

      if (settings.ZoomWheel)
         this.draw_g.on('wheel', evnt => {
            let pos = pointer(evnt, this.draw_g.node()),
                coord = this._palette_vertical ? (1 - pos[1] / s_height) : pos[0] / s_width,
                item = this.z_handle.analyzeWheelEvent(evnt, coord);
            if (item && item.changed)
               this.getFramePainter().zoom('z', item.min, item.max);
         });
   }

   /** @summary Fill context menu for the TPave object */
   fillContextMenu(menu) {
      let pave = this.getObject();

      menu.add('header: ' + pave._typename + '::' + pave.fName);
      if (this.isStats()) {
         menu.add('Default position', function() {
            pave.fX2NDC = gStyle.fStatX;
            pave.fX1NDC = pave.fX2NDC - gStyle.fStatW;
            pave.fY2NDC = gStyle.fStatY;
            pave.fY1NDC = pave.fY2NDC - gStyle.fStatH;
            pave.fInit = 1;
            this.interactiveRedraw(true, 'pave_moved');
         });

         menu.add('Save to gStyle', () => {
            gStyle.fStatX = pave.fX2NDC;
            gStyle.fStatW = pave.fX2NDC - pave.fX1NDC;
            gStyle.fStatY = pave.fY2NDC;
            gStyle.fStatH = pave.fY2NDC - pave.fY1NDC;
            if (this.fillatt) this.fillatt.saveToStyle('fStatColor', 'fStatStyle');
            gStyle.fStatTextColor = pave.fTextColor;
            gStyle.fStatFontSize = pave.fTextSize;
            gStyle.fStatFont = pave.fTextFont;
         }, 'Store stats position and graphical attributes to gStyle');

         menu.add('SetStatFormat', () => {
            menu.input('Enter StatFormat', pave.fStatFormat).then(fmt => {
               if (!fmt) return;
               pave.fStatFormat = fmt;
               this.interactiveRedraw(true, `exec:SetStatFormat("${fmt}")`);
            });
         });
         menu.add('SetFitFormat', () => {
            menu.input('Enter FitFormat', pave.fFitFormat).then(fmt => {
               if (!fmt) return;
               pave.fFitFormat = fmt;
               this.interactiveRedraw(true, `exec:SetFitFormat("${fmt}")`);
            });
         });
         menu.add('separator');
         menu.add('sub:SetOptStat', () => {
            menu.input('Enter OptStat', pave.fOptStat, 'int').then(fmt => {
               pave.fOptStat = fmt;
               this.interactiveRedraw(true, `exec:SetOptStat(${fmt})`);
            });
         });
         function AddStatOpt(pos, name) {
            let opt = (pos<10) ? pave.fOptStat : pave.fOptFit;
            opt = parseInt(parseInt(opt) / parseInt(Math.pow(10,pos % 10))) % 10;
            menu.addchk(opt, name, opt * 100 + pos, function(arg) {
               let newopt = (arg % 100 < 10) ? pave.fOptStat : pave.fOptFit,
                   oldopt = parseInt(arg / 100);
               newopt -= (oldopt > 0 ? oldopt : -1) * parseInt(Math.pow(10, arg % 10));
               if (arg % 100 < 10) {
                  pave.fOptStat = newopt;
                  this.interactiveRedraw(true, `exec:SetOptStat(${newopt})`);
               } else {
                  pave.fOptFit = newopt;
                  this.interactiveRedraw(true, `exec:SetOptFit(${newopt})`);
               }
            });
         }

         AddStatOpt(0, 'Histogram name');
         AddStatOpt(1, 'Entries');
         AddStatOpt(2, 'Mean');
         AddStatOpt(3, 'Std Dev');
         AddStatOpt(4, 'Underflow');
         AddStatOpt(5, 'Overflow');
         AddStatOpt(6, 'Integral');
         AddStatOpt(7, 'Skewness');
         AddStatOpt(8, 'Kurtosis');
         menu.add('endsub:');

         menu.add('sub:SetOptFit', () => {
            menu.input('Enter OptStat', pave.fOptFit, 'int').then(fmt => {
               pave.fOptFit = fmt;
               this.interactiveRedraw(true, `exec:SetOptFit(${fmt})`);
            });
         });
         AddStatOpt(10, 'Fit parameters');
         AddStatOpt(11, 'Par errors');
         AddStatOpt(12, 'Chi square / NDF');
         AddStatOpt(13, 'Probability');
         menu.add('endsub:');

         menu.add('separator');
      } else if (pave.fName === 'title') {
         menu.add('Default position', function() {
            pave.fX1NDC = gStyle.fTitleW > 0 ? gStyle.fTitleX - gStyle.fTitleW/2 : gStyle.fPadLeftMargin;
            pave.fY1NDC = gStyle.fTitleY - Math.min(gStyle.fTitleFontSize*1.1, 0.06);
            pave.fX2NDC = gStyle.fTitleW > 0 ? gStyle.fTitleX + gStyle.fTitleW/2 : 1 - gStyle.fPadRightMargin;
            pave.fY2NDC = gStyle.fTitleY;
            pave.fInit = 1;
            this.interactiveRedraw(true, 'pave_moved');
         });

         menu.add('Save to gStyle', function() {
            gStyle.fTitleX = (pave.fX2NDC + pave.fX1NDC)/2;
            gStyle.fTitleY = pave.fY2NDC;
            if (this.fillatt) this.fillatt.saveToStyle('fTitleColor', 'fTitleStyle');
            gStyle.fTitleTextColor = pave.fTextColor;
            gStyle.fTitleFontSize = pave.fTextSize;
            gStyle.fTitleFont = pave.fTextFont;
         }, 'Store title position and graphical attributes to gStyle');
      }

      if (this.UseTextColor)
         menu.addTextAttributesMenu(this);

      menu.addAttributesMenu(this);

      if ((menu.size() > 0) && this.showInspector('check'))
         menu.add('Inspect', this.showInspector);

      return menu.size() > 0;
   }

   /** @summary Show pave context menu */
   paveContextMenu(evnt) {
      if (this.z_handle) {
         let fp = this.getFramePainter();
         if (isFunc(fp?.showContextMenu))
             fp.showContextMenu('z', evnt);
         return;
      }

      evnt.stopPropagation(); // disable main context menu
      evnt.preventDefault();  // disable browser context menu

      createMenu$1(evnt, this).then(menu => {
         this.fillContextMenu(menu);
         return this.fillObjectExecMenu(menu, this.isTitle() ? 'title' : undefined);
       }).then(menu => menu.show());
   }

   /** @summary Returns true when stat box is drawn */
   isStats() {
      return this.matchObjectType(clTPaveStats);
   }

   /** @summary Returns true when title is drawn */
   isTitle() {
      return this.matchObjectType(clTPaveText) && (this.getObject()?.fName == 'title');
   }

   /** @summary Clear text in the pave */
   clearPave() {
      this.getObject().Clear();
   }

   /** @summary Add text to pave */
   addText(txt) {
      this.getObject().AddText(txt);
   }

   /** @summary Fill function parameters */
   fillFunctionStat(f1, dofit) {
      if (!dofit || !f1) return false;

      let print_fval    = dofit % 10,
          print_ferrors = Math.floor(dofit/10) % 10,
          print_fchi2   = Math.floor(dofit/100) % 10,
          print_fprob   = Math.floor(dofit/1000) % 10;

      if (print_fchi2 > 0)
         this.addText('#chi^2 / ndf = ' + this.format(f1.fChisquare,'fit') + ' / ' + f1.fNDF);
      if (print_fprob > 0)
         this.addText('Prob = '  + this.format(Prob(f1.fChisquare, f1.fNDF)));
      if (print_fval > 0)
         for(let n = 0; n < f1.GetNumPars(); ++n) {
            let parname = f1.GetParName(n), parvalue = f1.GetParValue(n), parerr = f1.GetParError(n);

            parvalue = (parvalue === undefined) ? '<not avail>' : this.format(Number(parvalue),'fit');
            if (parerr !== undefined) {
               parerr = this.format(parerr,'last');
               if ((Number(parerr) === 0) && (f1.GetParError(n) != 0))
                  parerr = this.format(f1.GetParError(n),'4.2g');
            }

            if ((print_ferrors > 0) && parerr)
               this.addText(`${parname} = ${parvalue} #pm ${parerr}`);
            else
               this.addText(`${parname} = ${parvalue}`);
         }

      return true;
   }

   /** @summary Is dummy pos of the pave painter */
   isDummyPos(p) {
      if (!p) return true;

      return !p.fInit && !p.fX1 && !p.fX2 && !p.fY1 && !p.fY2 && !p.fX1NDC && !p.fX2NDC && !p.fY1NDC && !p.fY2NDC;
   }

   /** @summary Update TPave object  */
   updateObject(obj) {
      if (!this.matchObjectType(obj)) return false;

      let pave = this.getObject();

      if (!pave.modified_NDC && !this.isDummyPos(obj)) {
         // if position was not modified interactively, update from source object

         if (this.stored && !obj.fInit && (this.stored.fX1 == obj.fX1)
             && (this.stored.fX2 == obj.fX2) && (this.stored.fY1 == obj.fY1) && (this.stored.fY2 == obj.fY2)) {
            // case when source object not initialized and original coordinates are not changed
            // take over only modified NDC coordinate, used in tutorials/graphics/canvas.C
            if (this.stored.fX1NDC != obj.fX1NDC) pave.fX1NDC = obj.fX1NDC;
            if (this.stored.fX2NDC != obj.fX2NDC) pave.fX2NDC = obj.fX2NDC;
            if (this.stored.fY1NDC != obj.fY1NDC) pave.fY1NDC = obj.fY1NDC;
            if (this.stored.fY2NDC != obj.fY2NDC) pave.fY2NDC = obj.fY2NDC;
         } else {
            pave.fInit = obj.fInit;
            pave.fX1 = obj.fX1; pave.fX2 = obj.fX2;
            pave.fY1 = obj.fY1; pave.fY2 = obj.fY2;
            pave.fX1NDC = obj.fX1NDC; pave.fX2NDC = obj.fX2NDC;
            pave.fY1NDC = obj.fY1NDC; pave.fY2NDC = obj.fY2NDC;
         }

         this.stored = Object.assign({}, obj); // store latest coordinates
      }

      pave.fOption = obj.fOption;
      pave.fBorderSize = obj.fBorderSize;

      switch (obj._typename) {
         case clTPaveText:
            pave.fLines = clone(obj.fLines);
            return true;
         case clTPavesText:
            pave.fLines = clone(obj.fLines);
            pave.fNpaves = obj.fNpaves;
            return true;
         case clTPaveLabel:
            pave.fLabel = obj.fLabel;
            return true;
         case clTPaveStats:
            pave.fOptStat = obj.fOptStat;
            pave.fOptFit = obj.fOptFit;
            return true;
         case clTLegend:
            let oldprim = pave.fPrimitives;
            pave.fPrimitives = obj.fPrimitives;
            pave.fNColumns = obj.fNColumns;
            if (oldprim && oldprim.arr && pave.fPrimitives && pave.fPrimitives.arr && (oldprim.arr.length == pave.fPrimitives.arr.length)) {
               // try to sync object reference, new object does not displayed automatically
               // in ideal case one should use snapids in the entries
               for (let k = 0; k < oldprim.arr.length; ++k) {
                  let oldobj = oldprim.arr[k].fObject, newobj = pave.fPrimitives.arr[k].fObject;

                  if (oldobj && newobj && oldobj._typename == newobj._typename && oldobj.fName == newobj.fName)
                     pave.fPrimitives.arr[k].fObject = oldobj;
               }
            }
            return true;
         case clTPaletteAxis:
            pave.fBorderSize = 1;
            pave.fShadowColor = 0;
            return true;
      }

      return false;
   }

   /** @summary redraw pave object */
   async redraw() {
      return this.drawPave();
   }

   /** @summary cleanup pave painter */
   cleanup() {
      if (this.z_handle) {
         this.z_handle.cleanup();
         delete this.z_handle;
      }

      super.cleanup();
   }

   /** @summary Returns true if object is supported */
   static canDraw(obj) {
      let typ = obj?._typename;
      return typ == clTPave || typ == clTPaveLabel || typ == clTPaveStats || typ == clTPaveText ||
             typ == clTPavesText || typ == clTDiamond || typ == clTLegend || typ == clTPaletteAxis;
   }

   /** @summary Draw TPave */
   static async draw(dom, pave, opt) {
      let painter = new TPavePainter(dom, pave);

      return ensureTCanvas(painter, false).then(() => {

         if ((pave.fName === 'title') && (pave._typename === clTPaveText)) {
            let tpainter = painter.getPadPainter().findPainterFor(null, 'title');
            if (tpainter && (tpainter !== painter)) {
               tpainter.removeFromPadPrimitives();
               tpainter.cleanup();
            } else if ((opt == 'postitle') || painter.isDummyPos(pave)) {
               let st = gStyle, fp = painter.getFramePainter();
               if (st && fp) {
                  let midx = st.fTitleX, y2 = st.fTitleY, w = st.fTitleW, h = st.fTitleH;

                  if (!h) h = (y2-fp.fY2NDC)*0.7;
                  if (!w) w = fp.fX2NDC - fp.fX1NDC;
                  if (!Number.isFinite(h) || (h <= 0)) h = 0.06;
                  if (!Number.isFinite(w) || (w <= 0)) w = 0.44;

                  pave.fX1NDC = midx - w/2;
                  pave.fY1NDC = y2 - h;
                  pave.fX2NDC = midx + w/2;
                  pave.fY2NDC = y2;
                  pave.fInit = 1;
               }
            }
         } else if (pave._typename === clTPaletteAxis) {
            pave.fBorderSize = 1;
            pave.fShadowColor = 0;

            // check some default values of TGaxis object, otherwise axis will not be drawn
            if (pave.fAxis) {
               if (!pave.fAxis.fChopt) pave.fAxis.fChopt = '+';
               if (!pave.fAxis.fNdiv) pave.fAxis.fNdiv = 12;
               if (!pave.fAxis.fLabelOffset) pave.fAxis.fLabelOffset = 0.005;
            }

            painter.z_handle = new TAxisPainter(dom, pave.fAxis, true);
            painter.z_handle.setPadName(painter.getPadName());

            painter.UseContextMenu = true;
         }

         painter.NoFillStats = (opt == 'nofillstats');

         switch (pave._typename) {
            case clTPaveLabel:
               painter.paveDrawFunc = painter.drawPaveLabel;
               break;
            case clTPaveStats:
               painter.paveDrawFunc = painter.drawPaveStats;
               painter.$secondary = true; // indicates that painter created from others
               break;
            case clTPaveText:
            case clTPavesText:
            case clTDiamond:
               painter.paveDrawFunc = painter.drawPaveText;
               break;
            case clTLegend:
               painter.paveDrawFunc = painter.drawLegend;
               break;
            case clTPaletteAxis:
               painter.paveDrawFunc = painter.drawPaletteAxis;
               break;
         }

         return painter.drawPave(opt);
      });
   }

} // TPavePainter

/** @summary Produce and draw TLegend object for the specified dom
  * @desc Should be called when all other objects are painted
  * Invoked when item '$legend' specified in url string
  * @return {Promise} with TLegend painter
  * @private */
async function produceLegend(dom, opt) {
   let main_painter = getElementMainPainter(dom),
       pp = main_painter ? main_painter.getPadPainter() : null,
       pad = pp?.getRootPad(true);

   if (!pad) return null;

   let leg = create$1(clTLegend);

   for (let k = 0; k < pp.painters.length; ++k) {
      let painter = pp.painters[k],
          obj = painter.getObject();

      if (!obj) continue;

      let entry = create$1(clTLegendEntry);
      entry.fObject = obj;
      entry.fLabel = (opt == 'all') ? obj.fName : painter.getItemName();
      entry.fOption = '';
      if (!entry.fLabel) continue;

      if (painter.lineatt?.used)
         entry.fOption += 'l';
      if (painter.fillatt?.used)
         entry.fOption += 'f';
      if (painter.markeratt?.used)
         entry.fOption += 'm';
      if (!entry.fOption)
         entry.fOption = 'l';

      leg.fPrimitives.Add(entry);
   }

   // no entries - no need to draw legend
   let szx = 0.4, szy = leg.fPrimitives.arr.length;
   if (!szy) return null;
   if (szy > 8) szy = 8;
   szy *= 0.1;

   leg.fX1NDC = szx*pad.fLeftMargin + (1-szx)*(1-pad.fRightMargin);
   leg.fY1NDC = (1-szy)*(1-pad.fTopMargin) + szy*pad.fBottomMargin;
   leg.fX2NDC = 0.99-pad.fRightMargin;
   leg.fY2NDC = 0.99-pad.fTopMargin;
   leg.fFillStyle = 1001;

   return TPavePainter.draw(dom, leg);
}

var TPavePainter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
TPavePainter: TPavePainter,
produceLegend: produceLegend
});

const CoordSystem = { kCARTESIAN: 1, kPOLAR: 2, kCYLINDRICAL: 3, kSPHERICAL: 4, kRAPIDITY: 5 };

function createDefaultPalette() {
   const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2/3 - t) * 6;
      return p;
   }, HLStoRGB = (h, l, s) => {
      const q = (l < 0.5) ? l * (1 + s) : l + s - l * s,
            p = 2 * l - q,
            r = hue2rgb(p, q, h + 1/3),
            g = hue2rgb(p, q, h),
            b = hue2rgb(p, q, h - 1/3);
      return '#' + toHex(r) + toHex(g) + toHex(b);
   }, minHue = 0, maxHue = 280, maxPretty = 50, palette = [];
   for (let i = 0; i < maxPretty; ++i) {
      const hue = (maxHue - (i + 1) * ((maxHue - minHue) / maxPretty)) / 360;
      palette.push(HLStoRGB(hue, 0.5, 1));
   }
   return new ColorPalette(palette);
}

function createGrayPalette() {
   let palette = [];
   for (let i = 0; i < 50; ++i) {
      const code = toHex((i+2)/60);
      palette.push('#'+code+code+code);
   }
   return new ColorPalette(palette);
}

/** @summary Create color palette
  * @private */
function getColorPalette(id) {
   id = id || settings.Palette;
   if ((id > 0) && (id < 10)) return createGrayPalette();
   if (id < 51) return createDefaultPalette();
   if (id > 113) id = 57;
   let rgb, stops = [0,0.125,0.25,0.375,0.5,0.625,0.75,0.875,1];
   switch(id) {
      // Deep Sea
      case 51: rgb = [[0,9,13,17,24,32,27,25,29],[0,0,0,2,37,74,113,160,221],[28,42,59,78,98,129,154,184,221]]; break;
      // Grey Scale
      case 52: rgb = [[0,32,64,96,128,160,192,224,255],[0,32,64,96,128,160,192,224,255],[0,32,64,96,128,160,192,224,255]]; break;
      // Dark Body Radiator
      case 53: rgb = [[0,45,99,156,212,230,237,234,242],[0,0,0,45,101,168,238,238,243],[0,1,1,3,9,8,11,95,230]]; break;
      // Two-color hue (dark blue through neutral gray to bright yellow)
      case 54: rgb = [[0,22,44,68,93,124,160,192,237],[0,16,41,67,93,125,162,194,241],[97,100,99,99,93,68,44,26,74]]; break;
      // Rain Bow
      case 55: rgb = [[0,5,15,35,102,196,208,199,110],[0,48,124,192,206,226,97,16,0],[99,142,198,201,90,22,13,8,2]]; break;
      // Inverted Dark Body Radiator
      case 56: rgb = [[242,234,237,230,212,156,99,45,0],[243,238,238,168,101,45,0,0,0],[230,95,11,8,9,3,1,1,0]]; break;
      // Bird (default, keep float for backward compatibility)
      case 57: rgb = [[ 53.091,15.096,19.89,5.916,45.951,135.1755,208.743,253.878,248.982],[42.432,91.7745,128.5455,163.6845,183.039,191.046,186.864,200.481,250.716],[134.9715,221.442,213.8175,201.807,163.8375,118.881,89.2245,50.184,13.7445]]; break;
      // Cubehelix
      case 58: rgb = [[0,24,2,54,176,236,202,194,255],[0,29,92,129,117,120,176,236,255],[0,68,80,34,57,172,252,245,255]]; break;
      // Green Red Violet
      case 59: rgb = [[13,23,25,63,76,104,137,161,206],[95,67,37,21,0,12,35,52,79],[4,3,2,6,11,22,49,98,208]]; break;
      // Blue Red Yellow
      case 60: rgb = [[0,61,89,122,143,160,185,204,231],[0,0,0,0,14,37,72,132,235],[0,140,224,144,4,5,6,9,13]]; break;
      // Ocean
      case 61: rgb = [[14,7,2,0,5,11,55,131,229],[105,56,26,1,42,74,131,171,229],[2,21,35,60,92,113,160,185,229]]; break;
      // Color Printable On Grey
      case 62: rgb = [[0,0,0,70,148,231,235,237,244],[0,0,0,0,0,69,67,216,244],[0,102,228,231,177,124,137,20,244]]; break;
      // Alpine
      case 63: rgb = [[50,56,63,68,93,121,165,192,241],[66,81,91,96,111,128,155,189,241],[97,91,75,65,77,103,143,167,217]]; break;
      // Aquamarine
      case 64: rgb = [[145,166,167,156,131,114,101,112,132],[158,178,179,181,163,154,144,152,159],[190,199,201,192,176,169,160,166,190]]; break;
      // Army
      case 65: rgb = [[93,91,99,108,130,125,132,155,174],[126,124,128,129,131,121,119,153,173],[103,94,87,85,80,85,107,120,146]]; break;
      // Atlantic
      case 66: rgb = [[24,40,69,90,104,114,120,132,103],[29,52,94,127,150,162,159,151,101],[29,52,96,132,162,181,184,186,131]]; break;
      // Aurora
      case 67: rgb = [[46,38,61,92,113,121,132,150,191],[46,36,40,69,110,135,131,92,34],[46,80,74,70,81,105,165,211,225]]; break;
      // Avocado
      case 68: rgb = [[0,4,12,30,52,101,142,190,237],[0,40,86,121,140,172,187,213,240],[0,9,14,18,21,23,27,35,101]]; break;
      // Beach
      case 69: rgb = [[198,206,206,211,198,181,161,171,244],[103,133,150,172,178,174,163,175,244],[49,54,55,66,91,130,184,224,244]]; break;
      // Black Body
      case 70: rgb = [[243,243,240,240,241,239,186,151,129],[0,46,99,149,194,220,183,166,147],[6,8,36,91,169,235,246,240,233]]; break;
      // Blue Green Yellow
      case 71: rgb = [[22,19,19,25,35,53,88,139,210],[0,32,69,108,135,159,183,198,215],[77,96,110,116,110,100,90,78,70]]; break;
      // Brown Cyan
      case 72: rgb = [[68,116,165,182,189,180,145,111,71],[37,82,135,178,204,225,221,202,147],[16,55,105,147,196,226,232,224,178]]; break;
      // CMYK
      case 73: rgb = [[61,99,136,181,213,225,198,136,24],[149,140,96,83,132,178,190,135,22],[214,203,168,135,110,100,111,113,22]]; break;
      // Candy
      case 74: rgb = [[76,120,156,183,197,180,162,154,140],[34,35,42,69,102,137,164,188,197],[ 64,69,78,105,142,177,205,217,198]]; break;
      // Cherry
      case 75: rgb = [[37,102,157,188,196,214,223,235,251],[37,29,25,37,67,91,132,185,251],[37,32,33,45,66,98,137,187,251]]; break;
      // Coffee
      case 76: rgb = [[79,100,119,137,153,172,192,205,250],[63,79,93,103,115,135,167,196,250],[51,59,66,61,62,70,110,160,250]]; break;
      // Dark Rain Bow
      case 77: rgb = [[43,44,50,66,125,172,178,155,157],[63,63,85,101,138,163,122,51,39],[121,101,58,44,47,55,57,44,43]]; break;
      // Dark Terrain
      case 78: rgb = [[0,41,62,79,90,87,99,140,228],[0,57,81,93,85,70,71,125,228],[95,91,91,82,60,43,44,112,228]]; break;
      // Fall
      case 79: rgb = [[49,59,72,88,114,141,176,205,222],[78,72,66,57,59,75,106,142,173],[ 78,55,46,40,39,39,40,41,47]]; break;
      // Fruit Punch
      case 80: rgb = [[243,222,201,185,165,158,166,187,219],[94,108,132,135,125,96,68,51,61],[7,9,12,19,45,89,118,146,118]]; break;
      // Fuchsia
      case 81: rgb = [[19,44,74,105,137,166,194,206,220],[19,28,40,55,82,110,159,181,220],[19,42,68,96,129,157,188,203,220]]; break;
      // Grey Yellow
      case 82: rgb = [[33,44,70,99,140,165,199,211,216],[ 38,50,76,105,140,165,191,189,167],[ 55,67,97,124,140,166,163,129,52]]; break;
      // Green Brown Terrain
      case 83: rgb = [[0,33,73,124,136,152,159,171,223],[0,43,92,124,134,126,121,144,223],[0,43,68,76,73,64,72,114,223]]; break;
      // Green Pink
      case 84: rgb = [[5,18,45,124,193,223,205,128,49],[48,134,207,230,193,113,28,0,7],[6,15,41,121,193,226,208,130,49]]; break;
      // Island
      case 85: rgb = [[180,106,104,135,164,188,189,165,144],[72,126,154,184,198,207,205,190,179],[41,120,158,188,194,181,145,100,62]]; break;
      // Lake
      case 86: rgb = [[57,72,94,117,136,154,174,192,215],[0,33,68,109,140,171,192,196,209],[116,137,173,201,200,201,203,190,187]]; break;
      // Light Temperature
      case 87: rgb = [[31,71,123,160,210,222,214,199,183],[40,117,171,211,231,220,190,132,65],[234,214,228,222,210,160,105,60,34]]; break;
      // Light Terrain
      case 88: rgb = [[123,108,109,126,154,172,188,196,218],[184,138,130,133,154,175,188,196,218],[208,130,109,99,110,122,150,171,218]]; break;
      // Mint
      case 89: rgb = [[105,106,122,143,159,172,176,181,207],[252,197,194,187,174,162,153,136,125],[146,133,144,155,163,167,166,162,174]]; break;
      // Neon
      case 90: rgb = [[171,141,145,152,154,159,163,158,177],[236,143,100,63,53,55,44,31,6],[59,48,46,44,42,54,82,112,179]]; break;
      // Pastel
      case 91: rgb = [[180,190,209,223,204,228,205,152,91],[93,125,147,172,181,224,233,198,158],[236,218,160,133,114,132,162,220,218]]; break;
      // Pearl
      case 92: rgb = [[225,183,162,135,115,111,119,145,211],[205,177,166,135,124,117,117,132,172],[186,165,155,135,126,130,150,178,226]]; break;
      // Pigeon
      case 93: rgb = [[39,43,59,63,80,116,153,177,223],[39,43,59,74,91,114,139,165,223],[ 39,50,59,70,85,115,151,176,223]]; break;
      // Plum
      case 94: rgb = [[0,38,60,76,84,89,101,128,204],[0,10,15,23,35,57,83,123,199],[0,11,22,40,63,86,97,94,85]]; break;
      // Red Blue
      case 95: rgb = [[94,112,141,165,167,140,91,49,27],[27,46,88,135,166,161,135,97,58],[42,52,81,106,139,158,155,137,116]]; break;
      // Rose
      case 96: rgb = [[30,49,79,117,135,151,146,138,147],[63,60,72,90,94,94,68,46,16],[18,28,41,56,62,63,50,36,21]]; break;
      // Rust
      case 97: rgb = [[0,30,63,101,143,152,169,187,230],[0,14,28,42,58,61,67,74,91],[39,26,21,18,15,14,14,13,13]]; break;
      // Sandy Terrain
      case 98: rgb = [[149,140,164,179,182,181,131,87,61],[62,70,107,136,144,138,117,87,74],[40,38,45,49,49,49,38,32,34]]; break;
      // Sienna
      case 99: rgb = [[99,112,148,165,179,182,183,183,208],[39,40,57,79,104,127,148,161,198],[15,16,18,33,51,79,103,129,177]]; break;
      // Solar
      case 100: rgb = [[99,116,154,174,200,196,201,201,230],[0,0,8,32,58,83,119,136,173],[5,6,7,9,9,14,17,19,24]]; break;
      // South West
      case 101: rgb = [[82,106,126,141,155,163,142,107,66],[ 62,44,69,107,135,152,149,132,119],[39,25,31,60,73,68,49,72,188]]; break;
      // Starry Night
      case 102: rgb = [[18,29,44,72,116,158,184,208,221],[27,46,71,105,146,177,189,190,183],[39,55,80,108,130,133,124,100,76]]; break;
      // Sunset
      case 103: rgb = [[0,48,119,173,212,224,228,228,245],[0,13,30,47,79,127,167,205,245],[0,68,75,43,16,22,55,128,245]]; break;
      // Temperature Map
      case 104: rgb = [[34,70,129,187,225,226,216,193,179],[48,91,147,194,226,229,196,110,12],[234,212,216,224,206,110,53,40,29]]; break;
      // Thermometer
      case 105: rgb = [[30,55,103,147,174,203,188,151,105],[0,65,138,182,187,175,121,53,9],[191,202,212,208,171,140,97,57,30]]; break;
      // Valentine
      case 106: rgb = [[112,97,113,125,138,159,178,188,225],[16,17,24,37,56,81,110,136,189],[38,35,46,59,78,103,130,152,201]]; break;
      // Visible Spectrum
      case 107: rgb = [[18,72,5,23,29,201,200,98,29],[0,0,43,167,211,117,0,0,0],[51,203,177,26,10,9,8,3,0]]; break;
      // Water Melon
      case 108: rgb = [[19,42,64,88,118,147,175,187,205],[19,55,89,125,154,169,161,129,70],[19,32,47,70,100,128,145,130,75]]; break;
      // Cool
      case 109: rgb = [[33,31,42,68,86,111,141,172,227],[255,175,145,106,88,55,15,0,0],[255,205,202,203,208,205,203,206,231]]; break;
      // Copper
      case 110: rgb = [[0,25,50,79,110,145,181,201,254],[0,16,30,46,63,82,101,124,179],[0,12,21,29,39,49,61,74,103]]; break;
      // Gist Earth
      case 111: rgb = [[0,13,30,44,72,120,156,200,247],[0,36,84,117,141,153,151,158,247],[0,94,100,82,56,66,76,131,247]]; break;
      // Viridis
      case 112: rgb = [[26,51,43,33,28,35,74,144,246],[9,24,55,87,118,150,180,200,222],[30,96,112,114,112,101,72,35,0]]; break;
      // Cividis
      case 113: rgb = [[0,5,65,97,124,156,189,224,255],[32,54,77,100,123,148,175,203,234],[77,110,107,111,120,119,111,94,70]]; break;
      default: return createDefaultPalette();
   }

   const NColors = 255, Red = rgb[0], Green = rgb[1], Blue = rgb[2], palette = [];

   for (let g = 1; g < stops.length; g++) {
       // create the colors...
       const nColorsGradient = Math.round(Math.floor(NColors*stops[g]) - Math.floor(NColors*stops[g-1]));
       for (let c = 0; c < nColorsGradient; c++) {
          const col = '#' + toHex(Red[g-1] + c * (Red[g] - Red[g-1]) / nColorsGradient, 1)
                          + toHex(Green[g-1] + c * (Green[g] - Green[g-1]) / nColorsGradient, 1)
                          + toHex(Blue[g-1] + c * (Blue[g] - Blue[g-1]) / nColorsGradient, 1);
          palette.push(col);
       }
    }

    return new ColorPalette(palette);
}


/**
 * @summary Class to decode histograms draw options
 *
 * @private
 */

class THistDrawOptions {
   constructor() { this.reset(); }

   /** @summary Reset hist draw options */
   reset() {
      Object.assign(this,
            { Axis: 0, RevX: false, RevY: false, SymlogX: 0, SymlogY: 0,
              Bar: false, BarStyle: 0, Curve: false,
              Hist: true, Line: false, Fill: false,
              Error: false, ErrorKind: -1, errorX: gStyle.fErrorX,
              Mark: false, Same: false, Scat: false, ScatCoef: 1., Func: true,
              Arrow: false, Box: false, BoxStyle: 0,
              Text: false, TextAngle: 0, TextKind: '', Char: 0, Color: false, Contour: 0, Cjust: false,
              Lego: 0, Surf: 0, Off: 0, Tri: 0, Proj: 0, AxisPos: 0,
              Spec: false, Pie: false, List: false, Zscale: false, Zvert: true, PadPalette: false,
              Candle: '', Violin: '', Scaled: null, Circular: 0,
              GLBox: 0, GLColor: false, Project: '',
              System: CoordSystem.kCARTESIAN,
              AutoColor: false, NoStat: false, ForceStat: false, PadStats: false, PadTitle: false, AutoZoom: false,
              HighRes: 0, Zero: true, Palette: 0, BaseLine: false,
              Optimize: settings.OptimizeDraw, adjustFrame: false,
              Mode3D: false, x3dscale: 1, y3dscale: 1,
              Render3D: constants$1.Render3D.Default,
              FrontBox: true, BackBox: true,
              _pmc: false, _plc: false, _pfc: false, need_fillcol: false,
              minimum: kNoZoom, maximum: kNoZoom, ymin: 0, ymax: 0 });
   }

   /** @summary Decode histogram draw options */
   decode(opt, hdim, histo, pad, painter) {
      this.orginal = opt; // will be overwritten by storeDrawOpt call

      const d = new DrawOptions(opt);

      if ((hdim === 1) && (histo.fSumw2.length > 0))
         for (let n = 0; n < histo.fSumw2.length; ++n)
            if (histo.fSumw2[n] > 0) { this.Error = true; this.Hist = false; this.Zero = false; break; }

      this.ndim = hdim || 1; // keep dimensions, used for now in GED

      this.PadStats = d.check('USE_PAD_STATS');
      this.PadPalette = d.check('USE_PAD_PALETTE');
      this.PadTitle = d.check('USE_PAD_TITLE');

      if (d.check('PAL', true)) this.Palette = d.partAsInt();
      // this is zooming of histo content
      if (d.check('MINIMUM:', true)) { this.ominimum = true; this.minimum = parseFloat(d.part); }
                                else { this.ominimum = false; this.minimum = histo.fMinimum; }
      if (d.check('MAXIMUM:', true)) { this.omaximum = true; this.maximum = parseFloat(d.part); }
                                else { this.omaximum = false; this.maximum = histo.fMaximum; }
      if (d.check('HMIN:', true)) { this.ohmin = true; this.hmin = parseFloat(d.part); }
                             else { this.ohmin = false; delete this.hmin; }
      if (d.check('HMAX:', true)) { this.ohmax = true; this.hmax = parseFloat(d.part); }
                             else { this.ohmax = false; delete this.hmax; }

      // let configure histogram titles - only for debug purposes
      if (d.check('HTITLE:', true)) histo.fTitle = decodeURIComponent(d.part.toLowerCase());
      if (d.check('XTITLE:', true)) histo.fXaxis.fTitle = decodeURIComponent(d.part.toLowerCase());
      if (d.check('YTITLE:', true)) histo.fYaxis.fTitle = decodeURIComponent(d.part.toLowerCase());
      if (d.check('ZTITLE:', true)) histo.fZaxis.fTitle = decodeURIComponent(d.part.toLowerCase());

      if (d.check('_ADJUST_FRAME_')) this.adjustFrame = true;

      if (d.check('NOOPTIMIZE')) this.Optimize = 0;
      if (d.check('OPTIMIZE')) this.Optimize = 2;

      if (d.check('AUTOCOL')) this.AutoColor = true;
      if (d.check('AUTOZOOM')) this.AutoZoom = true;

      if (d.check('OPTSTAT',true)) this.optstat = d.partAsInt();
      if (d.check('OPTFIT',true)) this.optfit = d.partAsInt();

      if (d.check('NOSTAT')) this.NoStat = true;
      if (d.check('STAT')) this.ForceStat = true;

      if (d.check('NOTOOLTIP') && painter) painter.setTooltipAllowed(false);
      if (d.check('TOOLTIP') && painter) painter.setTooltipAllowed(true);

      if (d.check('SYMLOGX', true)) this.SymlogX = d.partAsInt(0, 3);
      if (d.check('SYMLOGY', true)) this.SymlogY = d.partAsInt(0, 3);

      if (d.check('X3DSC', true)) this.x3dscale = d.partAsInt(0, 100) / 100;
      if (d.check('Y3DSC', true)) this.y3dscale = d.partAsInt(0, 100) / 100;

      let lx = false, ly = false, check3dbox = '', check3d = (hdim == 3);
      if (d.check('LOGXY')) lx = ly = true;
      if (d.check('LOGX')) lx = true;
      if (d.check('LOGY')) ly = true;
      if (lx && pad) { pad.fLogx = 1; pad.fUxmin = 0; pad.fUxmax = 1; pad.fX1 = 0; pad.fX2 = 1; }
      if (ly && pad) { pad.fLogy = 1; pad.fUymin = 0; pad.fUymax = 1; pad.fY1 = 0; pad.fY2 = 1; }
      if (d.check('LOGZ') && pad) pad.fLogz = 1;
      if (d.check('GRIDXY') && pad) pad.fGridx = pad.fGridy = 1;
      if (d.check('GRIDX') && pad) pad.fGridx = 1;
      if (d.check('GRIDY') && pad) pad.fGridy = 1;
      if (d.check('TICKXY') && pad) pad.fTickx = pad.fTicky = 1;
      if (d.check('TICKX') && pad) pad.fTickx = 1;
      if (d.check('TICKY') && pad) pad.fTicky = 1;

      d.getColor = function() {
         this.color = this.partAsInt(1) - 1;
         if (this.color >= 0) return true;
         for (let col = 0; col < 8; ++col)
            if (getColor(col).toUpperCase() === this.part)
               { this.color = col; return true; }
         return false;
      };

      if (d.check('FILL_', true) && d.getColor())
         this.histoFillColor = d.color;

      if (d.check('LINE_', true) && d.getColor())
         this.histoLineColor = getColor(d.color);

      if (d.check('XAXIS_', true) && d.getColor())
         histo.fXaxis.fAxisColor = histo.fXaxis.fLabelColor = histo.fXaxis.fTitleColor = d.color;

      if (d.check('YAXIS_', true) && d.getColor())
         histo.fYaxis.fAxisColor = histo.fYaxis.fLabelColor = histo.fYaxis.fTitleColor = d.color;

      let has_main = painter ? !!painter.getMainPainter() : false;

      if (d.check('X+')) { this.AxisPos = 10; this.second_x = has_main; }
      if (d.check('Y+')) { this.AxisPos += 1; this.second_y = has_main; }

      if (d.check('SAMES')) { this.Same = true; this.ForceStat = true; }
      if (d.check('SAME')) { this.Same = true; this.Func = true; }

      if (d.check('SPEC')) this.Spec = true; // not used

      if (d.check('BASE0') || d.check('MIN0'))
         this.BaseLine = 0;
      else if (gStyle.fHistMinimumZero)
         this.BaseLine = 0;

      if (d.check('PIE')) this.Pie = true; // not used

      if (d.check('CANDLE', true)) this.Candle = d.part || '1';
      if (d.check('VIOLIN', true)) { this.Violin = d.part || '1'; delete this.Candle; }
      if (d.check('NOSCALED')) this.Scaled = false;
      if (d.check('SCALED')) this.Scaled = true;

      if (d.check('GLBOX',true)) this.GLBox = 10 + d.partAsInt();
      if (d.check('GLCOL')) this.GLColor = true;

      d.check('GL'); // suppress GL

      if (d.check('CIRCULAR', true) || d.check('CIRC', true)) {
         this.Circular = 11;
         if (d.part.indexOf('0') >= 0) this.Circular = 10; // black and white
         if (d.part.indexOf('1') >= 0) this.Circular = 11; // color
         if (d.part.indexOf('2') >= 0) this.Circular = 12; // color and width
      }

      this.Chord = d.check('CHORD');

      if (d.check('LEGO', true)) {
         this.Lego = 1;
         if (d.part.indexOf('0') >= 0) this.Zero = false;
         if (d.part.indexOf('1') >= 0) this.Lego = 11;
         if (d.part.indexOf('2') >= 0) this.Lego = 12;
         if (d.part.indexOf('3') >= 0) this.Lego = 13;
         if (d.part.indexOf('4') >= 0) this.Lego = 14;
         check3dbox = d.part;
         if (d.part.indexOf('Z') >= 0) this.Zscale = true;
      }

      if (d.check('R3D_', true))
         this.Render3D = constants$1.Render3D.fromString(d.part.toLowerCase());

      if (d.check('SURF', true)) {
         this.Surf = d.partAsInt(10, 1);
         check3dbox = d.part;
         if (d.part.indexOf('Z') >= 0) this.Zscale = true;
      }

      if (d.check('TF3', true)) check3dbox = d.part;

      if (d.check('ISO', true)) check3dbox = d.part;

      if (d.check('LIST')) this.List = true; // not used

      if (d.check('CONT', true) && (hdim>1)) {
         this.Contour = 1;
         if (d.part.indexOf('Z') >= 0) this.Zscale = true;
         if (d.part.indexOf('1') >= 0) this.Contour = 11; else
         if (d.part.indexOf('2') >= 0) this.Contour = 12; else
         if (d.part.indexOf('3') >= 0) this.Contour = 13; else
         if (d.part.indexOf('4') >= 0) this.Contour = 14;
      }

      // decode bar/hbar option
      if (d.check('HBAR', true))
         this.BarStyle = 20;
      else if (d.check('BAR', true))
         this.BarStyle = 10;
      if (this.BarStyle > 0) {
         this.Hist = false;
         this.need_fillcol = true;
         this.BarStyle += d.partAsInt();
      }

      if (d.check('ARR'))
         this.Arrow = true;

      if (d.check('BOX',true))
         this.BoxStyle = 10 + d.partAsInt();

      this.Box = this.BoxStyle > 0;

      if (d.check('CJUST')) this.Cjust = true;
      if (d.check('COL')) this.Color = true;
      if (d.check('CHAR')) this.Char = 1;
      if (d.check('FUNC')) { this.Func = true; this.Hist = false; }
      if (d.check('AXIS3D')) { this.Axis = 1; this.Lego = 1; check3d = true; }
      if (d.check('AXIS')) this.Axis = 1;
      if (d.check('AXIG')) this.Axis = 2;

      if (d.check('TEXT', true)) {
         this.Text = true;
         this.Hist = false;
         this.TextAngle = Math.min(d.partAsInt(), 90);
         if (d.part.indexOf('N') >= 0) this.TextKind = 'N';
         if (d.part.indexOf('E0') >= 0) this.TextLine = true;
         if (d.part.indexOf('E') >= 0) this.TextKind = 'E';
      }

      if (d.check('SCAT=', true)) {
         this.Scat = true;
         this.ScatCoef = parseFloat(d.part);
         if (!Number.isFinite(this.ScatCoef) || (this.ScatCoef <= 0)) this.ScatCoef = 1.;
      }

      if (d.check('SCAT')) this.Scat = true;
      if (d.check('POL')) this.System = CoordSystem.kPOLAR;
      if (d.check('CYL')) this.System = CoordSystem.kCYLINDRICAL;
      if (d.check('SPH')) this.System = CoordSystem.kSPHERICAL;
      if (d.check('PSR')) this.System = CoordSystem.kRAPIDITY;

      if (d.check('TRI', true)) {
         this.Color = false;
         this.Tri = 1;
         check3dbox = d.part;
         if (d.part.indexOf('ERR') >= 0) this.Error = true;
      }

      if (d.check('AITOFF')) this.Proj = 1;
      if (d.check('MERCATOR')) this.Proj = 2;
      if (d.check('SINUSOIDAL')) this.Proj = 3;
      if (d.check('PARABOLIC')) this.Proj = 4;
      if (this.Proj > 0) this.Contour = 14;

      if (d.check('PROJX',true)) this.Project = 'X' + d.partAsInt(0,1);
      if (d.check('PROJY',true)) this.Project = 'Y' + d.partAsInt(0,1);
      if (d.check('PROJ')) this.Project = 'Y1';

      if (check3dbox) {
         if (check3dbox.indexOf('FB') >= 0) this.FrontBox = false;
         if (check3dbox.indexOf('BB') >= 0) this.BackBox = false;
      }

      if (check3d && d.check('FB')) this.FrontBox = false;
      if (check3d && d.check('BB')) this.BackBox = false;

      this._pfc = d.check('PFC');
      this._plc = d.check('PLC') || this.AutoColor;
      this._pmc = d.check('PMC');

      if (d.check('L')) { this.Line = true; this.Hist = false; this.Error = false; }
      if (d.check('F')) { this.Fill = true; this.need_fillcol = true; }

      if (d.check('A')) this.Axis = -1;

      if (d.check('RX') || (pad && pad.$RX)) this.RevX = true;
      if (d.check('RY') || (pad && pad.$RY)) this.RevY = true;
      const check_axis_bit = (opt, axis, bit) => {
         let flag = d.check(opt);
         if (pad && pad['$'+opt]) { flag = true; pad['$'+opt] = undefined; }
         if (flag && histo)
             if (!histo[axis].TestBit(bit))
                histo[axis].InvertBit(bit);
      };
      check_axis_bit('OTX', 'fXaxis', EAxisBits.kOppositeTitle);
      check_axis_bit('OTY', 'fYaxis', EAxisBits.kOppositeTitle);
      check_axis_bit('CTX', 'fXaxis', EAxisBits.kCenterTitle);
      check_axis_bit('CTY', 'fYaxis', EAxisBits.kCenterTitle);

      if (d.check('B1')) { this.BarStyle = 1; this.BaseLine = 0; this.Hist = false; this.need_fillcol = true; }
      if (d.check('B')) { this.BarStyle = 1; this.Hist = false; this.need_fillcol = true; }
      if (d.check('C')) { this.Curve = true; this.Hist = false; }
      if (d.check('][')) { this.Off = 1; this.Hist = true; }

      if (d.check('HIST')) { this.Hist = true; this.Func = true; this.Error = false; }

      this.Bar = (this.BarStyle > 0);

      delete this.MarkStyle; // remove mark style if any

      if (d.check('P0')) { this.Mark = true; this.Hist = false; this.Zero = true; }
      if (d.check('P')) { this.Mark = true; this.Hist = false; this.Zero = false; }
      if (d.check('HZ')) { this.Zscale = true; this.Zvert = false; }
      if (d.check('Z')) this.Zscale = true;
      if (d.check('*')) { this.Mark = true; this.MarkStyle = 3; this.Hist = false; }
      if (d.check('H')) this.Hist = true;

      if (d.check('E', true)) {
         this.Error = true;
         if (hdim == 1) {
            this.Zero = false; // do not draw empty bins with errors
            this.Hist = false;
            if (Number.isInteger(parseInt(d.part[0]))) this.ErrorKind = parseInt(d.part[0]);
            if ((this.ErrorKind === 3) || (this.ErrorKind === 4)) this.need_fillcol = true;
            if (this.ErrorKind === 0) this.Zero = true; // enable drawing of empty bins
            if (d.part.indexOf('X0') >= 0) this.errorX = 0;
         }
      }
      if (d.check('9')) this.HighRes = 1;
      if (d.check('0')) this.Zero = false;
      if (this.Color && d.check('1')) this.Zero = false;

      // flag identifies 3D drawing mode for histogram
      if ((this.Lego > 0) || (hdim == 3) ||
          ((this.Surf > 0) || this.Error && (hdim == 2))) this.Mode3D = true;

      //if (this.Surf == 15)
      //   if (this.System == CoordSystem.kPOLAR || this.System == CoordSystem.kCARTESIAN)
      //      this.Surf = 13;
   }

   /** @summary Tries to reconstruct string with hist draw options */
   asString(is_main_hist, pad) {
      let res = '';
      if (this.Mode3D) {

         if (this.Lego) {
            res = 'LEGO';
            if (!this.Zero) res += '0';
            if (this.Lego > 10) res += (this.Lego-10);
            if (this.Zscale) res+='Z';
         } else if (this.Surf) {
            res = 'SURF' + (this.Surf-10);
            if (this.Zscale) res+='Z';
         }
         if (!this.FrontBox) res+='FB';
         if (!this.BackBox) res+='BB';

         if (this.x3dscale !== 1) res += '_X3DSC' + Math.round(this.x3dscale * 100);
         if (this.y3dscale !== 1) res += '_Y3DSC' + Math.round(this.y3dscale * 100);

      } else {
         if (this.Candle) {
            res = 'CANDLE' + this.Candle;
         } else if (this.Violin) {
            res = 'VIOLIN' + this.Violin;
         } else if (this.Scat) {
            res = 'SCAT';
         } else if (this.Color) {
            res = 'COL';
            if (!this.Zero) res+='0';
            if (this.Zscale) res += (!this.Zvert ? 'HZ' : 'Z');
            if (this.Axis < 0) res+='A';
         } else if (this.Contour) {
            res = 'CONT';
            if (this.Contour > 10) res += (this.Contour-10);
            if (this.Zscale) res+='Z';
         } else if (this.Bar) {
            res = (this.BaseLine === false) ? 'B' : 'B1';
         } else if (this.Mark) {
            res = this.Zero ? 'P0' : 'P'; // here invert logic with 0
         } else if (this.Error) {
            res = 'E';
            if (this.ErrorKind >= 0) res += this.ErrorKind;
         } else if (this.Line) {
            res += 'L';
            if (this.Fill) res += 'F';
         }

         if (this.Cjust) res += ' CJUST';

         if (this.Text) {
            res += 'TEXT';
            if (this.TextAngle) res += this.TextAngle;
            res += this.TextKind;
         }
      }

      if (is_main_hist && res) {

         if (this.ForceStat || (this.StatEnabled === true))
            res += '_STAT';
         else if (this.NoStat || (this.StatEnabled === false))
            res += '_NOSTAT';
      }

      if (is_main_hist && pad && res) {
         if (pad.fLogx) res += '_LOGX';
         if (pad.fLogy) res += '_LOGY';
         if (pad.fLogz) res += '_LOGZ';
         if (pad.fGridx) res += '_GRIDX';
         if (pad.fGridy) res += '_GRIDY';
         if (pad.fTickx) res += '_TICKX';
         if (pad.fTicky) res += '_TICKY';
      }

      return res;
   }

} // class THistDrawOptions


/**
 * @summary Handle for histogram contour
 *
 * @private
 */

class HistContour {

   constructor(zmin, zmax) {
      this.arr = [];
      this.colzmin = zmin;
      this.colzmax = zmax;
      this.below_min_indx = -1;
      this.exact_min_indx = 0;
   }

   /** @summary Returns contour levels */
   getLevels() { return this.arr; }

   /** @summary Create normal contour levels */
   createNormal(nlevels, log_scale, zminpositive) {
      if (log_scale) {
         if (this.colzmax <= 0)
            this.colzmax = 1.;
         if (this.colzmin <= 0)
            if ((zminpositive === undefined) || (zminpositive <= 0))
               this.colzmin = 0.0001*this.colzmax;
            else
               this.colzmin = ((zminpositive < 3) || (zminpositive > 100)) ? 0.3*zminpositive : 1;
         if (this.colzmin >= this.colzmax) this.colzmin = 0.0001*this.colzmax;

         let logmin = Math.log(this.colzmin)/Math.log(10),
             logmax = Math.log(this.colzmax)/Math.log(10),
             dz = (logmax-logmin)/nlevels;
         this.arr.push(this.colzmin);
         for (let level = 1; level < nlevels; level++)
            this.arr.push(Math.exp((logmin + dz*level)*Math.log(10)));
         this.arr.push(this.colzmax);
         this.custom = true;
      } else {
         if ((this.colzmin === this.colzmax) && (this.colzmin !== 0)) {
            this.colzmax += 0.01*Math.abs(this.colzmax);
            this.colzmin -= 0.01*Math.abs(this.colzmin);
         }
         let dz = (this.colzmax-this.colzmin)/nlevels;
         for (let level = 0; level <= nlevels; level++)
            this.arr.push(this.colzmin + dz*level);
      }
   }

   /** @summary Create custom contour levels */
   createCustom(levels) {
      this.custom = true;
      for (let n = 0; n < levels.length; ++n)
         this.arr.push(levels[n]);

      if (this.colzmax > this.arr[this.arr.length-1])
         this.arr.push(this.colzmax);
   }

   /** @summary Configure indicies */
   configIndicies(below_min, exact_min) {
      this.below_min_indx = below_min;
      this.exact_min_indx = exact_min;
   }

   /** @summary Get index based on z value */
   getContourIndex(zc) {
      // bins less than zmin not drawn
      if (zc < this.colzmin) return this.below_min_indx;

      // if bin content exactly zmin, draw it when col0 specified or when content is positive
      if (zc === this.colzmin) return this.exact_min_indx;

      if (!this.custom)
         return Math.floor(0.01+(zc-this.colzmin)*(this.arr.length-1)/(this.colzmax-this.colzmin));

      let l = 0, r = this.arr.length-1;
      if (zc < this.arr[0]) return -1;
      if (zc >= this.arr[r]) return r;
      while (l < r-1) {
         let mid = Math.round((l+r)/2);
         if (this.arr[mid] > zc) r = mid; else l = mid;
      }
      return l;
   }

   /** @summary Get palette color */
   getPaletteColor(palette, zc) {
      let zindx = this.getContourIndex(zc);
      if (zindx < 0) return null;

      let pindx = palette.calcColorIndex(zindx, this.arr.length);

      return palette.getColor(pindx);
   }

   /** @summary Get palette index */
   getPaletteIndex(palette, zc) {
      let zindx = this.getContourIndex(zc);

      return (zindx < 0) ? null : palette.calcColorIndex(zindx, this.arr.length);
   }

} // class HistContour

/** @summary histogram status bits
  * @private */
const TH1StatusBits = {
   kNoStats       : BIT(9),  // don't draw stats box
   kUserContour   : BIT(10), // user specified contour levels
   kCanRebin      : BIT(11), // can rebin axis
   kLogX          : BIT(15), // X-axis in log scale
   kIsZoomed      : BIT(16), // bit set when zooming on Y axis
   kNoTitle       : BIT(17), // don't draw the histogram title
   kIsAverage     : BIT(18)  // Bin contents are average (used by Add)
};


/**
 * @summary Basic painter for histogram classes
 * @private
 */

class THistPainter extends ObjectPainter {

   /** @summary Constructor
     * @param {object|string} dom - DOM element for drawing or element id
     * @param {object} histo - TH1 derived histogram object */
   constructor(dom, histo) {
      super(dom, histo);
      this.draw_content = true;
      this.nbinsx = 0;
      this.nbinsy = 0;
      this.accept_drops = true; // indicate that one can drop other objects like doing Draw('same')
      this.mode3d = false;
      this.hist_painter_id = internals.id_counter++; // assign unique identifier for hist painter
   }

   /** @summary Returns histogram object */
   getHisto() {
      return this.getObject();
   }

   /** @summary Returns histogram axis */
   getAxis(name) {
      let histo = this.getObject();
      switch(name) {
         case 'x': return histo?.fXaxis;
         case 'y': return histo?.fYaxis;
         case 'z': return histo?.fZaxis;
      }
      return null;
   }

   /** @summary Returns true if TProfile */
   isTProfile() {
      return this.matchObjectType(clTProfile);
   }

   /** @summary Returns true if TH1K */
   isTH1K() {
      return this.matchObjectType('TH1K');
   }

   /** @summary Returns true if TH2Poly */
   isTH2Poly() {
      return this.matchObjectType(/^TH2Poly/) || this.matchObjectType(/^TProfile2Poly/);
   }

   /** @summary Clear 3d drawings - if any */
   clear3DScene() {
      let fp = this.getFramePainter();
      if (isFunc(fp?.create3DScene))
         fp.create3DScene(-1);
      this.mode3d = false;
   }

   /** @summary Cleanup histogram painter */
   cleanup() {

      this.clear3DScene();

      delete this.fPalette;
      delete this.fContour;
      delete this.options;

      super.cleanup();
   }

   /** @summary Returns number of histogram dimensions */
   getDimension() {
      let histo = this.getHisto();
      if (!histo) return 0;
      if (histo._typename.match(/^TH2/)) return 2;
      if (histo._typename.match(/^TProfile2D/)) return 2;
      if (histo._typename.match(/^TH3/)) return 3;
      if (this.isTH2Poly()) return 2;
      return 1;
   }

   /** @summary Decode options string opt and fill the option structure */
   decodeOptions(opt) {
      let histo = this.getHisto(),
          hdim = this.getDimension(),
          pp = this.getPadPainter(),
          pad = pp?.getRootPad(true);

      if (!this.options)
         this.options = new THistDrawOptions;
      else
         this.options.reset();

      this.options.decode(opt || histo.fOption, hdim, histo, pad, this);

      this.storeDrawOpt(opt); // opt will be return as default draw option, used in webcanvas
   }

   /** @summary Copy draw options from other painter */
   copyOptionsFrom(src) {
      if (src === this) return;
      let o = this.options, o0 = src.options;

      o.Mode3D = o0.Mode3D;
      o.Zero = o0.Zero;
      if (o0.Mode3D) {
         o.Lego = o0.Lego;
         o.Surf = o0.Surf;
      } else {
         o.Color = o0.Color;
         o.Contour = o0.Contour;
      }
   }

   /** @summary copy draw options to all other histograms in the pad */
   copyOptionsToOthers() {
      this.forEachPainter(painter => {
         if ((painter !== this) && isFunc(painter.copyOptionsFrom))
            painter.copyOptionsFrom(this);
      }, 'objects');
   }

   /** @summary Scan histogram content
     * @abstract */
   scanContent(/*when_axis_changed*/) {
      // function will be called once new histogram or
      // new histogram content is assigned
      // one should find min,max,nbins, maxcontent values
      // if when_axis_changed === true specified, content will be scanned after axis zoom changed
   }

   /** @summary Check pad ranges when drawing of frame axes will be performed */
   checkPadRange(use_pad) {
      if (this.isMainPainter())
         this.check_pad_range = use_pad ? 'pad_range' : true;
   }

   /** @summary Generates automatic color for some objects painters */
   createAutoColor(numprimitives) {
      if (!numprimitives) {
         let pad = this.getPadPainter().getRootPad(true);
         numprimitives = pad?.fPrimitves ? pad.fPrimitves.arr.length : 5;
      }

      let indx = this._auto_color || 0;
      this._auto_color = indx+1;

      let pal = this.getHistPalette();

      if (pal) {
         if (numprimitives < 2) numprimitives = 2;
         if (indx >= numprimitives) indx = numprimitives - 1;
         let palindx = Math.round(indx * (pal.getLength()-3) / (numprimitives-1)),
             colvalue = pal.getColor(palindx);

         return this.addColor(colvalue);
      }

      this._auto_color = this._auto_color % 8;
      return indx+2;
   }

   /** @summary Create necessary histogram draw attributes */
   createHistDrawAttributes() {

      let histo = this.getHisto();

      if (this.options._pfc || this.options._plc || this.options._pmc) {
         let mp = this.getMainPainter();
         if (isFunc(mp?.createAutoColor)) {
            let icolor = mp.createAutoColor();
            if (this.options._pfc) { histo.fFillColor = icolor; delete this.fillatt; }
            if (this.options._plc) { histo.fLineColor = icolor; delete this.lineatt; }
            if (this.options._pmc) { histo.fMarkerColor = icolor; delete this.markeratt; }
            this.options._pfc = this.options._plc = this.options._pmc = false;
         }
      }

      this.createAttFill({ attr: histo, color: this.options.histoFillColor, kind: 1 });

      this.createAttLine({ attr: histo, color0: this.options.histoLineColor });
   }

   /** @summary Assign snapid for histo painter
     * @desc Used to assign snapid also for functions painters */
   setSnapId(snapid) {
      this.snapid = snapid;

      this.getPadPainter().forEachPainterInPad(objp => {
         if (objp.child_painter_id === this.hist_painter_id) {
            let obj = objp.getObject();
            if (obj && obj.fName)
               objp.snapid = snapid + '#func_' + obj.fName;
         }
       }, 'objects');
   }

   /** @summary Update histogram object
     * @param obj - new histogram instance
     * @param opt - new drawing option (optional)
     * @param is_online - if update from online canvas, need to redraw functions
     * @return {Boolean} - true if histogram was successfully updated */
   updateObject(obj, opt, is_online) {

      let histo = this.getHisto(),
          fp = this.getFramePainter(),
          pp = this.getPadPainter();

      if (obj !== histo) {

         if (!this.matchObjectType(obj)) return false;

         // simple replace of object does not help - one can have different
         // complex relations between histo and stat box, histo and colz axis,
         // one could have THStack or TMultiGraph object
         // The only that could be done is update of content

         // check only stats bit, later other settings can be monitored
         let statpainter = pp?.findPainterFor(this.findStat());
         if (histo.TestBit(TH1StatusBits.kNoStats) != obj.TestBit(TH1StatusBits.kNoStats)) {
            histo.fBits = obj.fBits;
            if (statpainter) statpainter.Enabled = !histo.TestBit(TH1StatusBits.kNoStats);
         }

         // special treatment for webcanvas - also name can be changed
         if (this.snapid !== undefined)
            histo.fName = obj.fName;

         histo.fFillColor = obj.fFillColor;
         histo.fFillStyle = obj.fFillStyle;
         histo.fLineColor = obj.fLineColor;
         histo.fLineStyle = obj.fLineStyle;
         histo.fLineWidth = obj.fLineWidth;

         histo.fEntries = obj.fEntries;
         histo.fTsumw = obj.fTsumw;
         histo.fTsumwx = obj.fTsumwx;
         histo.fTsumwx2 = obj.fTsumwx2;
         histo.fXaxis.fNbins = obj.fXaxis.fNbins;
         if (this.getDimension() > 1) {
            histo.fTsumwy = obj.fTsumwy;
            histo.fTsumwy2 = obj.fTsumwy2;
            histo.fTsumwxy = obj.fTsumwxy;
            histo.fYaxis.fNbins = obj.fYaxis.fNbins;
            if (this.getDimension() > 2) {
               histo.fTsumwz = obj.fTsumwz;
               histo.fTsumwz2 = obj.fTsumwz2;
               histo.fTsumwxz = obj.fTsumwxz;
               histo.fTsumwyz = obj.fTsumwyz;
               histo.fZaxis.fNbins = obj.fZaxis.fNbins;
            }
         }

         const copyAxisMembers = (name, tgt, src) => {
            tgt.fTitle = src.fTitle;
            tgt.fLabels = src.fLabels;
            tgt.fXmin = src.fXmin;
            tgt.fXmax = src.fXmax;
            tgt.fTimeDisplay = src.fTimeDisplay;
            tgt.fTimeFormat = src.fTimeFormat;
            tgt.fAxisColor = src.fAxisColor;
            tgt.fLabelColor = src.fLabelColor;
            tgt.fLabelFont = src.fLabelFont;
            tgt.fLabelOffset = src.fLabelOffset;
            tgt.fLabelSize = src.fLabelSize;
            tgt.fNdivisions = src.fNdivisions;
            tgt.fTickLength = src.fTickLength;
            tgt.fTitleColor = src.fTitleColor;
            tgt.fTitleFont = src.fTitleFont;
            tgt.fTitleOffset = src.fTitleOffset;
            tgt.fTitleSize = src.fTitleSize;
            if (this.snapid && (!fp || !fp.zoomChangedInteractive(name))) {
               tgt.fFirst = src.fFirst;
               tgt.fLast = src.fLast;
               tgt.fBits = src.fBits;
            }
         };

         copyAxisMembers('x', histo.fXaxis, obj.fXaxis);
         copyAxisMembers('y', histo.fYaxis, obj.fYaxis);
         copyAxisMembers('z', histo.fZaxis, obj.fZaxis);

         histo.fArray = obj.fArray;
         histo.fNcells = obj.fNcells;
         histo.fTitle = obj.fTitle;
         histo.fMinimum = obj.fMinimum;
         histo.fMaximum = obj.fMaximum;
         histo.fSumw2 = obj.fSumw2;

         if (this.isTProfile()) {
            histo.fBinEntries = obj.fBinEntries;
         } else if (this.isTH1K()) {
            histo.fNIn = obj.fNIn;
            histo.fReady = 0;
         } else if (this.isTH2Poly()) {
            histo.fBins = obj.fBins;
         }

         if (this.options.Func) {

            let painters = [], newfuncs = [], update_painters = [], pid = this.hist_painter_id;

            // find painters associated with histogram
            if (pp)
               pp.forEachPainterInPad(objp => {
                  if (objp.child_painter_id === pid)
                     painters.push(objp);
               }, 'objects');

            if (obj.fFunctions)
               for (let n = 0; n < obj.fFunctions.arr.length; ++n) {
                  let func = obj.fFunctions.arr[n];
                  if (!func?._typename || !this.needDrawFunc(histo, func)) continue;

                  let funcpainter = null, func_indx = -1;

                  // try to find matching object in associated list of painters
                  for (let i = 0; i < painters.length; ++i)
                     if (painters[i].matchObjectType(func._typename) && (painters[i].getObject().fName === func.fName)) {
                        funcpainter = painters[i];
                        func_indx = i;
                        break;
                     }
                  // or just in generic list of painted objects
                  if (!funcpainter && func.fName)
                     funcpainter = pp ? pp.findPainterFor(null, func.fName, func._typename) : null;

                  if (funcpainter) {
                     funcpainter.updateObject(func);
                     if (func_indx >= 0) {
                        painters.splice(func_indx, 1);
                        update_painters.push(funcpainter);
                      }
                  } else {
                     newfuncs.push(func);
                  }
               }

            // stat painter has to be kept even when no object exists in the list
            if (statpainter) {
               let indx = painters.indexOf(statpainter);
               if (indx >= 0) painters.splice(indx, 1);
            }

            // remove all function which are not found in new list of primitives
            if (pp && (painters.length > 0))
               pp.cleanPrimitives(p => painters.indexOf(p) >= 0);

            // plot new objects on the same pad with next redraw
            if (newfuncs.length > 0)
               this._extraFunctions = newfuncs;

            if (is_online && (update_painters.length > 0))
               this._extraPainters = update_painters;
         }

         let changed_opt = (histo.fOption != obj.fOption);
         histo.fOption = obj.fOption;

         if (((opt !== undefined) && (this.options.original !== opt)) || changed_opt)
            this.decodeOptions(opt || histo.fOption);
      }

      if (!this.options.ominimum)
         this.options.minimum = histo.fMinimum;
      if (!this.options.omaximum)
         this.options.maximum = histo.fMaximum;

      if (this.snapid || !fp || !fp.zoomChangedInteractive())
         this.checkPadRange();

      this.scanContent();

      this.histogram_updated = true; // indicate that object updated

      return true;
   }

   /** @summary Extract axes bins and ranges
     * @desc here functions are defined to convert index to axis value and back
     * was introduced to support non-equidistant bins */
   extractAxesProperties(ndim) {

      const assignTAxisFuncs = axis => {
         if (axis.fXbins.length >= axis.fNbins) {
            axis.regular = false;
            axis.GetBinCoord = function(bin) {
               let indx = Math.round(bin);
               if (indx <= 0) return this.fXmin;
               if (indx > this.fNbins) return this.fXmax;
               if (indx==bin) return this.fXbins[indx];
               let indx2 = (bin < indx) ? indx - 1 : indx + 1;
               return this.fXbins[indx] * Math.abs(bin-indx2) + this.fXbins[indx2] * Math.abs(bin-indx);
            };
            axis.FindBin = function(x,add) {
               for (let k = 1; k < this.fXbins.length; ++k)
                  if (x < this.fXbins[k]) return Math.floor(k-1+add);
               return this.fNbins;
            };
         } else {
            axis.regular = true;
            axis.binwidth = (axis.fXmax - axis.fXmin) / (axis.fNbins || 1);
            axis.GetBinCoord = function(bin) { return this.fXmin + bin*this.binwidth; };
            axis.FindBin = function(x,add) { return Math.floor((x - this.fXmin) / this.binwidth + add); };
         }
      };

      this.nbinsx = this.nbinsy = this.nbinsz = 0;

      const histo = this.getHisto();

      this.nbinsx = histo.fXaxis.fNbins;
      this.xmin = histo.fXaxis.fXmin;
      this.xmax = histo.fXaxis.fXmax;
      assignTAxisFuncs(histo.fXaxis);

      this.ymin = histo.fYaxis.fXmin;
      this.ymax = histo.fYaxis.fXmax;

      if ((ndim == 1) && this.options.ohmin && this.options.ohmax) {
         this.ymin = this.options.hmin;
         this.ymax = this.options.hmax;
      }

      if (ndim > 1) {
         this.nbinsy = histo.fYaxis.fNbins;
         assignTAxisFuncs(histo.fYaxis);

         this.zmin = histo.fZaxis.fXmin;
         this.zmax = histo.fZaxis.fXmax;

         if ((ndim == 2) && this.options.ohmin && this.options.ohmax) {
            this.zmin = this.options.hmin;
            this.zmax = this.options.hmax;
         }
      }

      if (ndim > 2) {
         this.nbinsz = histo.fZaxis.fNbins;
         assignTAxisFuncs(histo.fZaxis);
       }
   }

    /** @summary Draw axes for histogram
      * @desc axes can be drawn only for main histogram */
   async drawAxes() {
      let fp = this.getFramePainter();
      if (!fp) return false;

      let histo = this.getHisto();

      // artificially add y range to display axes
      if (this.ymin === this.ymax) this.ymax += 1;

      if (!this.isMainPainter()) {
         let opts = {
            second_x: (this.options.AxisPos >= 10),
            second_y: (this.options.AxisPos % 10) == 1,
            hist_painter: this
         };

         if ((!opts.second_x && !opts.second_y) || fp.hasDrawnAxes(opts.second_x, opts.second_y))
            return false;

         fp.setAxes2Ranges(opts.second_x, histo.fXaxis, this.xmin, this.xmax, opts.second_y, histo.fYaxis, this.ymin, this.ymax);

         fp.createXY2(opts);

         return fp.drawAxes2(opts.second_x, opts.second_y);
      }

      if (this.options.adjustFrame) {
         let pad = this.getPadPainter().getRootPad();
         if (pad) {
            if (pad.fUxmin < pad.fUxmax) {
               fp.fX1NDC = (this.xmin - pad.fUxmin) / (pad.fUxmax - pad.fUxmin);
               fp.fX2NDC = (this.xmax - pad.fUxmin) / (pad.fUxmax - pad.fUxmin);
            }
            if (pad.fUymin < pad.fUymax) {
               fp.fY1NDC = (this.ymin - pad.fUymin) / (pad.fUymax - pad.fUymin);
               fp.fY2NDC = (this.ymax - pad.fUymin) / (pad.fUymax - pad.fUymin);
            }

            pad.fLeftMargin = fp.fX1NDC;
            pad.fRightMargin = 1 - fp.fX2NDC;
            pad.fBottomMargin = fp.fY1NDC;
            pad.fTopMargin = 1 - fp.fY2NDC;
            pad.fFrameLineColor = 0;
            pad.fFrameLineWidth = 0;
            fp.setRootPadRange(pad);

            fp.fillatt.setSolidColor('none');

            fp.redraw();
         }

         this.options.adjustFrame = false;
      }

      fp.setAxesRanges(histo.fXaxis, this.xmin, this.xmax, histo.fYaxis, this.ymin, this.ymax, histo.fZaxis, 0, 0);

      fp.createXY({ ndim: this.getDimension(),
                    check_pad_range: this.check_pad_range,
                    zoom_ymin: this.zoom_ymin,
                    zoom_ymax: this.zoom_ymax,
                    ymin_nz: this.ymin_nz,
                    swap_xy: (this.options.BarStyle >= 20),
                    reverse_x: this.options.RevX,
                    reverse_y: this.options.RevY,
                    symlog_x: this.options.SymlogX,
                    symlog_y: this.options.SymlogY,
                    Proj: this.options.Proj,
                    extra_y_space: this.options.Text && (this.options.BarStyle > 0),
                    hist_painter: this });
      delete this.check_pad_range;

      if (this.options.Same)
         return false;

      return fp.drawAxes(false, this.options.Axis < 0, (this.options.Axis < 0),
                         this.options.AxisPos, this.options.Zscale && this.options.Zvert, this.options.Zscale && !this.options.Zvert);
   }

   /** @summary Inform web canvas that something changed in the histogram */
   processOnlineChange(kind) {
      let cp = this.getCanvPainter();
      if (isFunc(cp?.processChanges))
         cp.processChanges(kind, this);
   }

   /** @summary Toggle histogram title drawing */
   toggleTitle(arg) {
      let histo = this.getHisto();
      if (!this.isMainPainter() || !histo)
         return false;
      if (arg === 'only-check')
         return !histo.TestBit(TH1StatusBits.kNoTitle);
      histo.InvertBit(TH1StatusBits.kNoTitle);
      this.drawHistTitle().then(() => this.processOnlineChange(`exec:SetBit(TH1::kNoTitle,${histo.TestBit(TH1StatusBits.kNoTitle)?1:0})`));
   }

   /** @summary Draw histogram title
     * @return {Promise} with painter */
   async drawHistTitle() {

      // case when histogram drawn over other histogram (same option)
      if (!this.isMainPainter() || this.options.Same)
         return this;

      let histo = this.getHisto(), st = gStyle,
          pp = this.getPadPainter(),
          tpainter = pp?.findPainterFor(null, 'title'),
          pt = tpainter?.getObject(),
          draw_title = !histo.TestBit(TH1StatusBits.kNoTitle) && (st.fOptTitle > 0);

      if (!pt && isFunc(pp?.findInPrimitives))
         pt = pp.findInPrimitives('title', clTPaveText);

      if (pt) {
         pt.Clear();
         if (draw_title) pt.AddText(histo.fTitle);
         if (tpainter) return tpainter.redraw().then(() => this);
      } else if (draw_title && !tpainter && histo.fTitle && !this.options.PadTitle) {
         pt = create$1(clTPaveText);
         Object.assign(pt, { fName: 'title', fFillColor: st.fTitleColor, fFillStyle: st.fTitleStyle, fBorderSize: st.fTitleBorderSize,
                             fTextFont: st.fTitleFont, fTextSize: st.fTitleFontSize, fTextColor: st.fTitleTextColor, fTextAlign: st.fTitleAlign });
         pt.AddText(histo.fTitle);
         return TPavePainter.draw(this.getDom(), pt, 'postitle').then(tp => {
            if (tp) tp.$secondary = true;
            return this;
         });
      }

      return this;
   }

   /** @summary Live change and update of title drawing
     * @desc Used from the GED */
   processTitleChange(arg) {

      let histo = this.getHisto(),
          pp = this.getPadPainter(),
          tpainter = pp?.findPainterFor(null, 'title');

      if (!histo || !tpainter) return null;

      if (arg === 'check')
         return (!this.isMainPainter() || this.options.Same) ? null : histo;

      tpainter.clearPave();
      tpainter.addText(histo.fTitle);

      tpainter.redraw();

      this.submitCanvExec(`SetTitle("${histo.fTitle}")`);
   }

   /** @summary Update statistics when web canvas is drawn */
   updateStatWebCanvas() {
      if (!this.snapid) return;

      let stat = this.findStat(),
          statpainter = this.getPadPainter()?.findPainterFor(stat);

      if (statpainter && !statpainter.snapid) statpainter.redraw();
   }

   /** @summary Find stats box
     * @desc either in list of functions or as object of correspondent painter */
   findStat() {
      if (this.options.PadStats)
         return this.getPadPainter()?.findPainterFor(null, 'stats', clTPaveStats)?.getObject();

      return this.findFunction(clTPaveStats, 'stats');
   }

   /** @summary Toggle statbox drawing
     * @private */
   toggleStat(arg) {

      let stat = this.findStat(), pp = this.getPadPainter(), statpainter;

      if (!arg) arg = '';

      if (!stat) {
         if (arg.indexOf('-check') > 0) return false;
         // when statbox created first time, one need to draw it
         stat = this.createStat(true);
      } else {
         statpainter = pp?.findPainterFor(stat);
      }

      if (arg == 'only-check')
         return statpainter?.Enabled || false;

      if (arg == 'fitpar-check')
         return stat?.fOptFit || false;

      if (arg == 'fitpar-toggle') {
         if (!stat) return false;
         stat.fOptFit = stat.fOptFit ? 0 : 1111; // for websocket command should be send to server
         statpainter?.redraw();
         return true;
      }

      let has_stats;

      if (statpainter) {
         statpainter.Enabled = !statpainter.Enabled;
         this.options.StatEnabled = statpainter.Enabled; // used only for interactive
         // when stat box is drawn, it always can be drawn individually while it
         // should be last for colz redrawPad is used
         statpainter.redraw();
         has_stats = statpainter.Enabled;
      } else {
         let prev_name = this.selectCurrentPad(this.getPadName());
         TPavePainter.draw(this.getDom(), stat).then(() => this.selectCurrentPad(prev_name));
         has_stats = true;
      }

      this.processOnlineChange(`exec:SetBit(TH1::kNoStats,${has_stats?0:1})`,this);

      return has_stats;
   }

   /** @summary Returns true if stats box fill can be ingored */
   isIgnoreStatsFill() {
      return !this.getObject() || (!this.draw_content && !this.create_stats && !this.snapid) || (this.options.Axis > 0);
   }

   /** @summary Create stat box for histogram if required */
   createStat(force) {

      let histo = this.getHisto();

      if (this.options.PadStats || !histo) return null;

      if (!force && !this.options.ForceStat) {
         if (this.options.NoStat || histo.TestBit(TH1StatusBits.kNoStats) || !settings.AutoStat) return null;

         if ((this.options.Axis > 0) || !this.isMainPainter()) return null;
      }

      let stats = this.findStat(), st = gStyle,
          optstat = this.options.optstat, optfit = this.options.optfit;

      if (optstat !== undefined) {
         if (stats) stats.fOptStat = optstat;
         delete this.options.optstat;
      } else {
         optstat = histo.$custom_stat || st.fOptStat;
      }

      if (optfit !== undefined) {
         if (stats) stats.fOptFit = optfit;
         delete this.options.optfit;
      } else {
         optfit = st.fOptFit;
      }

      if (!stats && !optstat && !optfit) return null;

      this.create_stats = true;

      if (stats) return stats;

      stats = create$1(clTPaveStats);
      Object.assign(stats, {
         fName: 'stats', fOptStat: optstat, fOptFit: optfit,
         fX1NDC: st.fStatX - st.fStatW, fY1NDC: st.fStatY - st.fStatH, fX2NDC: st.fStatX, fY2NDC: st.fStatY,
         fTextAlign: 12
      });

      if (histo._typename.match(/^TProfile/) || histo._typename.match(/^TH2/))
         stats.fY1NDC = 0.67;

      stats.AddText(histo.fName);

      this.addFunction(stats);

      return stats;
   }

   /** @summary Find function in histogram list of functions */
   findFunction(type_name, obj_name) {
      let funcs = this.getHisto()?.fFunctions?.arr;
      if (!funcs) return null;

      for (let i = 0; i < funcs.length; ++i) {
         let f = funcs[i];
         if (obj_name && (f.fName !== obj_name)) continue;
         if (f._typename === type_name) return f;
      }

      return null;
   }

   /** @summary Add function to histogram list of functions */
   addFunction(obj, asfirst) {
      let histo = this.getHisto();
      if (!histo || !obj) return;

      if (!histo.fFunctions)
         histo.fFunctions = create$1(clTList);

      if (asfirst)
         histo.fFunctions.AddFirst(obj);
      else
         histo.fFunctions.Add(obj);
   }

   /** @summary Check if such function should be drawn directly */
   needDrawFunc(histo, func) {
      if (func._typename === clTPaveStats)
          return !histo.TestBit(TH1StatusBits.kNoStats) && !this.options.NoStat;

       if (func._typename === clTF1)
          return !func.TestBit(BIT(9));

       return func._typename !== clTPaletteAxis;
   }

   /** @summary Method draws next function from the functions list
     * @return {Promise} fulfilled when drawing is ready */
   async drawNextFunction(indx, only_extra) {
      let histo = this.getHisto(), func = null, opt = '';

      if (only_extra) {
         if (this._extraPainters) {
             let p = this._extraPainters.shift();
             if (this._extraPainters.length == 0)
                delete this._extraPainters;
             return getPromise(p.redraw()).then(() => this.drawNextFunction(indx, only_extra));
         }
         if (this._extraFunctions && (indx < this._extraFunctions.length))
            func = this._extraFunctions[indx];
         else
            delete this._extraFunctions;
      } else {
         if (this.options.Func && histo.fFunctions && (indx < histo.fFunctions.arr.length)) {
            func = histo.fFunctions.arr[indx];
            opt = histo.fFunctions.opt[indx];
         }
      }

      if (!func) return true;

      let pp = this.getPadPainter(),
          do_draw = false,
          func_painter = pp?.findPainterFor(func);

      // no need to do something if painter for object was already done
      // object will be redraw automatically
      if (!func_painter)
         do_draw = this.needDrawFunc(histo, func);

      if (!do_draw)
         return this.drawNextFunction(indx+1, only_extra);

      func.$histo = histo; // required to draw TF1 correctly

      let promise = TPavePainter.canDraw(func) ? TPavePainter.draw(this.getDom(), func, opt)
                                               : pp.drawObject(this.getDom(), func, opt);

      return promise.then(painter => {
         if (isObject(painter))
            painter.child_painter_id = this.hist_painter_id;

         return this.drawNextFunction(indx+1, only_extra);
      });
   }

   /** @summary Returns selected index for specified axis
     * @desc be aware - here indexes starts from 0 */
   getSelectIndex(axis, side, add) {
      let indx = 0,
          nbin = this['nbins'+axis] || 0,
          taxis = this.getAxis(axis);

      if (this.options.second_x && axis == 'x') axis = 'x2';
      if (this.options.second_y && axis == 'y') axis = 'y2';
      let main = this.getFramePainter(),
          min = main ? main[`zoom_${axis}min`] : 0,
          max = main ? main[`zoom_${axis}max`] : 0;

      if ((min !== max) && taxis) {
         if (side == 'left')
            indx = taxis.FindBin(min, add || 0);
         else
            indx = taxis.FindBin(max, (add || 0) + 0.5);
         if (indx < 0) indx = 0; else if (indx > nbin) indx = nbin;
      } else {
         indx = (side == 'left') ? 0 : nbin;
      }

      // TAxis object of histogram, where user range can be stored
      if (taxis) {
         if ((taxis.fFirst === taxis.fLast) || !taxis.TestBit(EAxisBits.kAxisRange) ||
             ((taxis.fFirst <= 1) && (taxis.fLast >= nbin))) taxis = undefined;
      }

      if (side == 'left') {
         if (indx < 0) indx = 0;
         if (taxis && (taxis.fFirst > 1) && (indx < taxis.fFirst)) indx = taxis.fFirst-1;
      } else {
         if (indx > nbin) indx = nbin;
         if (taxis && (taxis.fLast <= nbin) && (indx>taxis.fLast)) indx = taxis.fLast;
      }

      return indx;
   }

   /** @summary Unzoom user range if any */
   unzoomUserRange(dox, doy, doz) {

      let res = false, histo = this.getHisto();

      if (!histo) return false;

      let unzoomTAxis = obj => {
         if (!obj || !obj.TestBit(EAxisBits.kAxisRange)) return false;
         if (obj.fFirst === obj.fLast) return false;
         if ((obj.fFirst <= 1) && (obj.fLast >= obj.fNbins)) return false;
         obj.InvertBit(EAxisBits.kAxisRange);
         return true;
      };

      let uzoomMinMax = ndim => {
         if (this.getDimension() !== ndim) return false;
         if ((this.options.minimum === kNoZoom) && (this.options.maximum === kNoZoom)) return false;
         if (!this.draw_content) return false; // if not drawing content, not change min/max
         this.options.minimum = this.options.maximum = kNoZoom;
         this.scanContent(true); // to reset ymin/ymax
         return true;
      };

      if (dox && unzoomTAxis(histo.fXaxis)) res = true;
      if (doy && (unzoomTAxis(histo.fYaxis) || uzoomMinMax(1))) res = true;
      if (doz && (unzoomTAxis(histo.fZaxis) || uzoomMinMax(2))) res = true;

      return res;
   }

   /** @summary Add different interactive handlers
     * @desc only first (main) painter in list allowed to add interactive functionality
     * Most of interactivity now handled by frame
     * @return {Promise} for ready */
   async addInteractivity() {
      let ismain = this.isMainPainter(),
          second_axis = (this.options.AxisPos > 0),
          fp = ismain || second_axis ? this.getFramePainter() : null;
      return fp ? fp.addInteractivity(!ismain && second_axis) : false;
   }

   /** @summary Invoke dialog to enter and modify user range */
   changeUserRange(menu, arg) {
      let histo = this.getHisto(),
          taxis = histo ? histo['f'+arg+'axis'] : null;
      if (!taxis) return;

      let curr = '[1,' + taxis.fNbins + ']';
      if (taxis.TestBit(EAxisBits.kAxisRange))
          curr = '[' + taxis.fFirst +',' + taxis.fLast +']';

      menu.input(`Enter user range for axis ${arg} like [1,${taxis.fNbins}]`, curr).then(res => {
         if (!res) return;
         res = JSON.parse(res);
         if (!res || (res.length != 2)) return;
         let first = parseInt(res[0]), last = parseInt(res[1]);
         if (!Number.isInteger(first) || !Number.isInteger(last)) return;
         taxis.fFirst = first;
         taxis.fLast = last;

         let newflag = (taxis.fFirst < taxis.fLast) && (taxis.fFirst >= 1) && (taxis.fLast <= taxis.fNbins);

         if (newflag != taxis.TestBit(EAxisBits.kAxisRange))
            taxis.InvertBit(EAxisBits.kAxisRange);

         this.interactiveRedraw();
      });
   }

   /** @summary Start dialog to modify range of axis where histogram values are displayed */
   changeValuesRange(menu) {
      let curr;
      if ((this.options.minimum != kNoZoom) && (this.options.maximum != kNoZoom))
         curr = `[${this.options.minimum},${this.options.maximum}]`;
      else
         curr = `[${this.gminbin},${this.gmaxbin}]`;

      menu.input('Enter min/max hist values or empty string to reset', curr).then(res => {
         res = res ? JSON.parse(res) : [];

         if (!isObject(res) || (res.length != 2) || !Number.isFinite(res[0]) || !Number.isFinite(res[1])) {
            this.options.minimum = this.options.maximum = kNoZoom;
         } else {
            this.options.minimum = res[0];
            this.options.maximum = res[1];
          }

         this.interactiveRedraw();
       });
   }

   /** @summary Fill histogram context menu */
   fillContextMenu(menu) {

      let histo = this.getHisto(),
          fp = this.getFramePainter();
      if (!histo) return;

      menu.add('header:'+ histo._typename + '::' + histo.fName);

      if (this.options.Axis <= 0)
         menu.addchk(this.toggleStat('only-check'), 'Show statbox', () => this.toggleStat());

      if (histo.fTitle && this.isMainPainter())
         menu.addchk(this.toggleTitle('only-check'), 'Show title', () => this.toggleTitle());

      if (this.draw_content) {
         if (this.getDimension() == 1) {
            menu.add('User range X', () => this.changeUserRange(menu, 'X'));
         } else {
            menu.add('sub:User ranges');
            menu.add('X', () => this.changeUserRange(menu, 'X'));
            menu.add('Y', () => this.changeUserRange(menu, 'Y'));
            if (this.getDimension() > 2)
               menu.add('Z', () => this.changeUserRange(menu, 'Z'));
            else
               menu.add('Values', () => this.changeValuesRange(menu));
            menu.add('endsub:');
         }

         if (isFunc(this.fillHistContextMenu))
            this.fillHistContextMenu(menu);
      }

      if (this.options.Mode3D) {
         // menu for 3D drawings

         if (menu.size() > 0)
            menu.add('separator');

         let main = this.getMainPainter() || this;

         menu.addchk(main.isTooltipAllowed(), 'Show tooltips', function() {
            main.setTooltipAllowed('toggle');
         });

         menu.addchk(fp.enable_highlight, 'Highlight bins', function() {
            fp.enable_highlight = !fp.enable_highlight;
            if (!fp.enable_highlight && fp.highlightBin3D && fp.mode3d) fp.highlightBin3D(null);
         });

         if (isFunc(fp?.render3D)) {
            menu.addchk(main.options.FrontBox, 'Front box', function() {
               main.options.FrontBox = !main.options.FrontBox;
               fp.render3D();
            });
            menu.addchk(main.options.BackBox, 'Back box', function() {
               main.options.BackBox = !main.options.BackBox;
               fp.render3D();
            });
         }

         if (this.draw_content) {
            menu.addchk(!this.options.Zero, 'Suppress zeros', function() {
               this.options.Zero = !this.options.Zero;
               this.interactiveRedraw('pad');
            });

            if ((this.options.Lego == 12) || (this.options.Lego == 14)) {
               menu.addchk(this.options.Zscale, 'Z scale', () => this.toggleColz());
               if (this.fillPaletteMenu) this.fillPaletteMenu(menu);
            }
         }

         if (isFunc(main.control?.reset))
            menu.add('Reset camera', function() {
               main.control.reset();
            });
      }

      menu.addAttributesMenu(this);

      if (this.histogram_updated && fp.zoomChangedInteractive())
         menu.add('Let update zoom', function() {
            fp.zoomChangedInteractive('reset');
         });

      return true;
   }

   /** @summary Auto zoom into histogram non-empty range
     * @abstract */
   autoZoom() {}

   /** @summary Process click on histogram-defined buttons */
   clickButton(funcname) {
      let fp = this.getFramePainter();

      if (!this.isMainPainter() || !fp) return false;

      switch(funcname) {
         case 'ToggleZoom':
            if ((fp.zoom_xmin !== fp.zoom_xmax) || (fp.zoom_ymin !== fp.zoom_ymax) || (fp.zoom_zmin !== fp.zoom_zmax)) {
               fp.unzoom();
               fp.zoomChangedInteractive('reset');
               return true;
            }
            if (this.draw_content) {
               this.autoZoom();
               return true;
            }
            break;
         case 'ToggleLogX': fp.toggleAxisLog('x'); break;
         case 'ToggleLogY': fp.toggleAxisLog('y'); break;
         case 'ToggleLogZ': fp.toggleAxisLog('z'); break;
         case 'ToggleStatBox': this.toggleStat(); return true;
      }
      return false;
   }

   /** @summary Fill pad toolbar with histogram-related functions */
   fillToolbar(not_shown) {
      let pp = this.getPadPainter();
      if (!pp) return;

      pp.addPadButton('auto_zoom', 'Toggle between unzoom and autozoom-in', 'ToggleZoom', 'Ctrl *');
      pp.addPadButton('arrow_right', 'Toggle log x', 'ToggleLogX', 'PageDown');
      pp.addPadButton('arrow_up', 'Toggle log y', 'ToggleLogY', 'PageUp');
      if (this.getDimension() > 1)
         pp.addPadButton('arrow_diag', 'Toggle log z', 'ToggleLogZ');
      if (this.options.Axis <= 0)
         pp.addPadButton('statbox', 'Toggle stat box', 'ToggleStatBox');
      if (!not_shown) pp.showPadButtons();
   }

   /** @summary Returns tooltip information for 3D drawings */
   get3DToolTip(indx) {
      let histo = this.getHisto(),
          tip = { bin: indx, name: histo.fName, title: histo.fTitle };
      switch (this.getDimension()) {
         case 1:
            tip.ix = indx; tip.iy = 1;
            tip.value = histo.getBinContent(tip.ix);
            tip.error = histo.getBinError(indx);
            tip.lines = this.getBinTooltips(indx-1);
            break;
         case 2:
            tip.ix = indx % (this.nbinsx + 2);
            tip.iy = (indx - tip.ix) / (this.nbinsx + 2);
            tip.value = histo.getBinContent(tip.ix, tip.iy);
            tip.error = histo.getBinError(indx);
            tip.lines = this.getBinTooltips(tip.ix-1, tip.iy-1);
            break;
         case 3:
            tip.ix = indx % (this.nbinsx+2);
            tip.iy = ((indx - tip.ix) / (this.nbinsx+2)) % (this.nbinsy+2);
            tip.iz = (indx - tip.ix - tip.iy * (this.nbinsx+2)) / (this.nbinsx+2) / (this.nbinsy+2);
            tip.value = histo.getBinContent(tip.ix, tip.iy, tip.iz);
            tip.error = histo.getBinError(indx);
            tip.lines = this.getBinTooltips(tip.ix-1, tip.iy-1, tip.iz-1);
            break;
      }

      return tip;
   }

   /** @summary Create contour object for histogram */
   createContour(nlevels, zmin, zmax, zminpositive, custom_levels) {

      let cntr = new HistContour(zmin, zmax);

      if (custom_levels) {
         cntr.createCustom(custom_levels);
      } else {
         if (nlevels < 2) nlevels = gStyle.fNumberContours;
         let pad = this.getPadPainter().getRootPad(true);
         cntr.createNormal(nlevels, pad ? pad.fLogz : 0, zminpositive);
      }

      cntr.configIndicies(this.options.Zero ? -1 : 0, (cntr.colzmin != 0) || !this.options.Zero || this.isTH2Poly() ? 0 : -1);

      let fp = this.getFramePainter();
      if ((this.getDimension() < 3) && fp) {
         fp.zmin = cntr.colzmin;
         fp.zmax = cntr.colzmax;
      }

      this.fContour = cntr;
      return cntr;
   }

   /** @summary Return contour object */
   getContour(force_recreate) {
      if (this.fContour && !force_recreate)
         return this.fContour;

      let main = this.getMainPainter(),
          fp = this.getFramePainter();

      if (main?.fContour && (main !== this)) {
         this.fContour = main.fContour;
         return this.fContour;
      }

      // if not initialized, first create contour array
      // difference from ROOT - fContour includes also last element with maxbin, which makes easier to build logz
      let histo = this.getObject(), nlevels = 0, apply_min,
          zmin = this.minbin, zmax = this.maxbin, zminpos = this.minposbin,
          custom_levels;
      if (zmin === zmax) { zmin = this.gminbin; zmax = this.gmaxbin; zminpos = this.gminposbin; }
      let gzmin = zmin, gzmax = zmax;
      if (this.options.minimum !== kNoZoom) { zmin = this.options.minimum; gzmin = Math.min(gzmin,zmin); apply_min = true; }
      if (this.options.maximum !== kNoZoom) { zmax = this.options.maximum; gzmax = Math.max(gzmax, zmax); apply_min = false; }
      if (zmin >= zmax) {
         if (apply_min) zmax = zmin + 1; else zmin = zmax - 1;
      }

      if (fp && (fp.zoom_zmin != fp.zoom_zmax)) {
         zmin = fp.zoom_zmin;
         zmax = fp.zoom_zmax;
      }

      if (histo.fContour && (histo.fContour.length > 1))
         if (histo.TestBit(TH1StatusBits.kUserContour))
            custom_levels = histo.fContour;
         else
            nlevels = histo.fContour.length;

      let cntr = this.createContour(nlevels, zmin, zmax, zminpos, custom_levels);

      if ((this.getDimension() < 3) && fp) {

         fp.zmin = gzmin;
         fp.zmax = gzmax;

         if ((gzmin != cntr.colzmin) || (gzmax != cntr.colzmax)) {
            fp.zoom_zmin = cntr.colzmin;
            fp.zoom_zmax = cntr.colzmax;
         } else {
            fp.zoom_zmin = fp.zoom_zmax = undefined;
         }
      }

      return cntr;
   }

   /** @summary Return levels from contour object */
   getContourLevels() {
      return this.getContour().getLevels();
   }

   /** @summary Returns color palette associated with histogram
     * @desc Create if required, checks pad and canvas for custom palette */
   getHistPalette(force) {
      if (force) this.fPalette = null;
      if (!this.fPalette && !this.options.Palette) {
         let pp = this.getPadPainter();
         if (isFunc(pp?.getCustomPalette))
            this.fPalette = pp.getCustomPalette();
      }
      if (!this.fPalette)
         this.fPalette = getColorPalette(this.options.Palette);
      return this.fPalette;
   }

   /** @summary Fill menu entries for palette */
   fillPaletteMenu(menu) {
      menu.addPaletteMenu(this.options.Palette || settings.Palette, arg => {
         this.options.Palette = parseInt(arg);
         this.getHistPalette(true);
         this.redraw(); // redraw histogram
      });
   }

   /** @summary draw color palette
     * @return {Promise} when done */
   async drawColorPalette(enabled, postpone_draw, can_move) {
      // only when create new palette, one could change frame size
      let mp = this.getMainPainter();
      if (mp !== this) {
         if (mp && (mp.draw_content !== false))
            return null;
      }

      let pal = this.findFunction(clTPaletteAxis),
          pp = this.getPadPainter(),
          pal_painter = pp?.findPainterFor(pal),
          found_in_func = !!pal;

      if (this._can_move_colz) { can_move = true; delete this._can_move_colz; }

      if (!pal_painter && !pal) {
         pal_painter = pp?.findPainterFor(undefined, undefined, clTPaletteAxis);
         if (pal_painter) {
            pal = pal_painter.getObject();
            // add to list of functions
            this.addFunction(pal, true);
         }
      }

      if (!enabled) {
         if (pal_painter) {
            this.options.Zvert = pal_painter._palette_vertical;
            pal_painter.Enabled = false;
            pal_painter.removeG(); // completely remove drawing without need to redraw complete pad
         }

         return null;
      }

      if (!pal) {

         if (this.options.PadPalette)
            return null;

         pal = create$1(clTPave);

         Object.assign(pal, { _typename: clTPaletteAxis, fName: clTPave, fH: null, fAxis: create$1(clTGaxis),
                               fX1NDC: 0.905, fX2NDC: 0.945, fY1NDC: 0.1, fY2NDC: 0.9, fInit: 1, $can_move: true });

         if (!this.options.Zvert)
            Object.assign(pal, { fX1NDC: 0.1, fX2NDC: 0.9, fY1NDC: 0.805, fY2NDC: 0.845 });

         let zaxis = this.getHisto().fZaxis;

         Object.assign(pal.fAxis, { fTitle: zaxis.fTitle, fTitleSize: zaxis.fTitleSize, fChopt: '+',
                                    fLineColor: zaxis.fAxisColor, fLineSyle: 1, fLineWidth: 1,
                                    fTextAngle: 0, fTextSize: zaxis.fLabelSize, fTextAlign: 11,
                                    fTextColor: zaxis.fLabelColor, fTextFont: zaxis.fLabelFont });

         // place colz in the beginning, that stat box is always drawn on the top
         this.addFunction(pal, true);

         can_move = true;
      } else if (pp?._palette_vertical !== undefined) {
         this.options.Zvert = pp._palette_vertical;
      }

      let fp = this.getFramePainter();

      // keep palette width
      if (can_move && fp && pal.$can_move) {
         if (this.options.Zvert) {
            if (pal.fX1NDC > 0.5) {
               pal.fX2NDC = fp.fX2NDC + 0.005 + (pal.fX2NDC - pal.fX1NDC);
               pal.fX1NDC = fp.fX2NDC + 0.005;
            } else {
               pal.fX1NDC = fp.fX1NDC - 0.03 - (pal.fX2NDC - pal.fX1NDC);
               pal.fX2NDC = fp.fX1NDC - 0.03;
            }
            pal.fY1NDC = fp.fY1NDC;
            pal.fY2NDC = fp.fY2NDC;
         } else {
            pal.fX1NDC = fp.fX1NDC;
            pal.fX2NDC = fp.fX2NDC;
            if (pal.fY2NDC > 0.5) {
               pal.fY2NDC = fp.fY2NDC + 0.005 + (pal.fY2NDC - pal.fY1NDC);
               pal.fY1NDC = fp.fY2NDC + 0.005;
            } else {
               pal.fY1NDC = fp.fY1NDC - 0.05 - (pal.fY2NDC - pal.fY1NDC);
               pal.fY2NDC = fp.fY1NDC - 0.05;
            }
         }
      }

      //  required for z scale setting
      // TODO: use weak reference (via pad list of painters and any kind of string)
      pal.$main_painter = this;

      let arg = '', pr;
      if (postpone_draw) arg += ';postpone';
      if (can_move && !this.do_redraw_palette) arg += ';can_move';
      if (this.options.Cjust) arg+=';cjust';

      if (!pal_painter) {
         // when histogram drawn on sub pad, let draw new axis object on the same pad
         let prev = this.selectCurrentPad(this.getPadName());
         pr = TPavePainter.draw(this.getDom(), pal, arg).then(_palp => {
            pal_painter = _palp;
            this.selectCurrentPad(prev);
            if (found_in_func)
               pal_painter._hist_painter = this;
         });
      } else {
         pal_painter.Enabled = true;
         // real drawing will be perform at the end
         if (postpone_draw) return pal_painter;
         pr = pal_painter.drawPave(arg);
      }

      return pr.then(() => {

         // mark painter as secondary - not in list of TCanvas primitives
         pal_painter.$secondary = true;
         this.options.Zvert = pal_painter._palette_vertical;

         // make dummy redraw, palette will be updated only from histogram painter
         pal_painter.redraw = () => {};

         let need_redraw = false;

         // special code to adjust frame position to actual position of palette
         if (can_move && fp && !this.do_redraw_palette) {

            let pad = pp?.getRootPad(true);

            if (this.options.Zvert) {
               if ((pal.fX1NDC > 0.5) && (fp.fX2NDC > pal.fX1NDC)) {
                  need_redraw = true;
                  fp.fX2NDC = pal.fX1NDC - 0.01;

                  if (fp.fX1NDC > fp.fX2NDC - 0.1) fp.fX1NDC = Math.max(0, fp.fX2NDC - 0.1);
                } else if ((pal.fX2NDC < 0.5) && (fp.fX1NDC < pal.fX2NDC)) {
                  need_redraw = true;
                  fp.fX1NDC = pal.fX2NDC + 0.05;
                  if (fp.fX2NDC < fp.fX1NDC + 0.1) fp.fX2NDC = Math.min(1., fp.fX1NDC + 0.1);
                }
                if (need_redraw && pad) {
                   pad.fLeftMargin = fp.fX1NDC;
                   pad.fRightMargin = 1 - fp.fX2NDC;
                }
            } else {
               if ((pal.fY1NDC > 0.5) && (fp.fY2NDC > pal.fY1NDC)) {
                  need_redraw = true;
                  fp.fY2NDC = pal.fY1NDC - 0.01;
                  if (fp.fY1NDC > fp.fY2NDC - 0.1) fp.fY1NDC = Math.max(0, fp.fXYNDC - 0.1);
               } else if ((pal.fY2NDC < 0.5) && (fp.fY1NDC < pal.fY2NDC)) {
                  need_redraw = true;
                  fp.fY1NDC = pal.fY2NDC + 0.05;
                  if (fp.fXYNDC < fp.fY1NDC + 0.1) fp.fY2NDC = Math.min(1., fp.fY1NDC + 0.1);

               }
               if (need_redraw && pad) {
                  pad.fTopMargin = fp.fY1NDC;
                  pad.fBottomMargin = 1 - fp.fY2NDC;
               }
            }
         }

         if (!need_redraw)
            return pal_painter;

         this.do_redraw_palette = true;

         fp.redraw();

         let pr = !postpone_draw ? this.redraw() : Promise.resolve(true);
         return pr.then(() => {
             delete this.do_redraw_palette;
             return pal_painter;
         });
      });
   }

   /** @summary Toggle color z palette drawing */
   toggleColz() {
      let can_toggle = this.options.Mode3D ? (this.options.Lego === 12 || this.options.Lego === 14 || this.options.Surf === 11 || this.options.Surf === 12) :
                       this.options.Color || this.options.Contour;

      if (can_toggle) {
         this.options.Zscale = !this.options.Zscale;
         return this.drawColorPalette(this.options.Zscale, false, true)
                    .then(() => this.processOnlineChange('drawopt'));
      }
   }

   /** @summary Toggle 3D drawing mode */
   toggleMode3D() {
      this.options.Mode3D = !this.options.Mode3D;

      if (this.options.Mode3D) {
         if (!this.options.Surf && !this.options.Lego && !this.options.Error) {
            if ((this.nbinsx >= 50) || (this.nbinsy >= 50))
               this.options.Lego = this.options.Color ? 14 : 13;
            else
               this.options.Lego = this.options.Color ? 12 : 1;

            this.options.Zero = false; // do not show zeros by default
         }
      }

      this.copyOptionsToOthers();
      this.interactiveRedraw('pad', 'drawopt');
   }

   /** @summary Prepare handle for color draw */
   prepareDraw(args) {

      if (!args) args = { rounding: true, extra: 0, middle: 0 };

      if (args.extra === undefined) args.extra = 0;
      if (args.middle === undefined) args.middle = 0;

      let histo = this.getHisto(),
          xaxis = histo.fXaxis, yaxis = histo.fYaxis,
          pmain = this.getFramePainter(),
          hdim = this.getDimension(),
          i, j, x, y, binz, binarea,
          res = {
             i1: this.getSelectIndex('x', 'left', 0 - args.extra),
             i2: this.getSelectIndex('x', 'right', 1 + args.extra),
             j1: (hdim === 1) ? 0 : this.getSelectIndex('y', 'left', 0 - args.extra),
             j2: (hdim === 1) ? 1 : this.getSelectIndex('y', 'right', 1 + args.extra),
             min: 0, max: 0, sumz: 0, xbar1: 0, xbar2: 1, ybar1: 0, ybar2: 1
          };

      res.grx = new Float32Array(res.i2+1);
      res.gry = new Float32Array(res.j2+1);

      if (typeof histo.fBarOffset == 'number' && typeof histo.fBarWidth == 'number'
           && (histo.fBarOffset || histo.fBarWidth !== 1000)) {
             if (histo.fBarOffset <= 1000) {
                res.xbar1 = res.ybar1 = 0.001*histo.fBarOffset;
             } else if (histo.fBarOffset <= 3000) {
                res.xbar1 = 0.001*(histo.fBarOffset-2000);
             } else if (histo.fBarOffset <= 5000) {
                res.ybar1 = 0.001*(histo.fBarOffset-4000);
             }

             if (histo.fBarWidth <= 1000) {
                res.xbar2 = Math.min(1., res.xbar1 + 0.001*histo.fBarWidth);
                res.ybar2 = Math.min(1., res.ybar1 + 0.001*histo.fBarWidth);
             } else if (histo.fBarWidth <= 3000) {
                res.xbar2 = Math.min(1., res.xbar1 + 0.001*(histo.fBarWidth-2000));
                // res.ybar2 = res.ybar1 + 1;
             } else if (histo.fBarWidth <= 5000) {
                // res.xbar2 = res.xbar1 + 1;
                res.ybar2 = Math.min(1., res.ybar1 + 0.001*(histo.fBarWidth-4000));
             }
         }

      if (args.original) {
         res.original = true;
         res.origx = new Float32Array(res.i2+1);
         res.origy = new Float32Array(res.j2+1);
      }

      if (args.pixel_density) args.rounding = true;

      if (!pmain) {
         console.warn('cannot draw histogram without frame');
         return res;
      }

      let funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y);

       // calculate graphical coordinates in advance
      for (i = res.i1; i <= res.i2; ++i) {
         x = xaxis.GetBinCoord(i + args.middle);
         if (funcs.logx && (x <= 0)) { res.i1 = i+1; continue; }
         if (res.origx) res.origx[i] = x;
         res.grx[i] = funcs.grx(x);
         if (args.rounding) res.grx[i] = Math.round(res.grx[i]);

         if (args.use3d) {
            if (res.grx[i] < -pmain.size_x3d) { res.i1 = i; res.grx[i] = -pmain.size_x3d; }
            if (res.grx[i] > pmain.size_x3d) { res.i2 = i; res.grx[i] = pmain.size_x3d; }
         }
      }

      if (hdim === 1) {
         res.gry[0] = funcs.gry(0);
         res.gry[1] = funcs.gry(1);
      } else
      for (j = res.j1; j <= res.j2; ++j) {
         y = yaxis.GetBinCoord(j + args.middle);
         if (funcs.logy && (y <= 0)) { res.j1 = j+1; continue; }
         if (res.origy) res.origy[j] = y;
         res.gry[j] = funcs.gry(y);
         if (args.rounding) res.gry[j] = Math.round(res.gry[j]);

         if (args.use3d) {
            if (res.gry[j] < -pmain.size_y3d) { res.j1 = j; res.gry[j] = -pmain.size_y3d; }
            if (res.gry[j] > pmain.size_y3d) { res.j2 = j; res.gry[j] = pmain.size_y3d; }
         }
      }

      //  find min/max values in selected range

      this.maxbin = this.minbin = this.minposbin = null;

      for (i = res.i1; i < res.i2; ++i) {
         for (j = res.j1; j < res.j2; ++j) {
            binz = histo.getBinContent(i + 1, j + 1);
            res.sumz += binz;
            if (args.pixel_density) {
               binarea = (res.grx[i+1]-res.grx[i])*(res.gry[j]-res.gry[j+1]);
               if (binarea <= 0) continue;
               res.max = Math.max(res.max, binz);
               if ((binz > 0) && ((binz<res.min) || (res.min === 0))) res.min = binz;
               binz = binz/binarea;
            }
            if (this.maxbin === null) {
               this.maxbin = this.minbin = binz;
            } else {
               this.maxbin = Math.max(this.maxbin, binz);
               this.minbin = Math.min(this.minbin, binz);
            }
            if (binz > 0)
               if ((this.minposbin === null) || (binz<this.minposbin)) this.minposbin = binz;
         }
      }

      // force recalculation of z levels
      this.fContour = null;

      return res;
   }

   /** @summary Get tip text for axis bin */
   getAxisBinTip(name, axis, bin) {
      let pmain = this.getFramePainter(),
          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),
          handle = funcs[name+'_handle'],
          x1 = axis.GetBinLowEdge(bin+1);

      if (handle.kind === 'labels')
         return funcs.axisAsText(name, x1);

      let x2 = axis.GetBinLowEdge(bin+2);

      if (handle.kind === 'time')
         return funcs.axisAsText(name, (x1+x2)/2);

      return `[${funcs.axisAsText(name, x1)}, ${funcs.axisAsText(name, x2)})`;
   }

   /** @summary generic draw function for histograms
     * @private */
   static async _drawHist(painter, opt) {

      return ensureTCanvas(painter).then(() => {

         painter.setAsMainPainter();

         painter.decodeOptions(opt);

         if (painter.isTH2Poly()) {
            if (painter.options.Mode3D)
               painter.options.Lego = 12; // lego always 12
            else if (!painter.options.Color)
               painter.options.Color = true; // default is color
         }

         painter.checkPadRange(/*!painter.options.Mode3D && */ (painter.options.Contour != 14));

         painter.scanContent();

         painter.createStat(); // only when required

         return painter.callDrawFunc();
      }).then(() => painter.drawNextFunction(0)).then(() => {
         if (!painter.Mode3D && painter.options.AutoZoom)
            return painter.autoZoom();
      }).then(() => {
         if (painter.options.Project && !painter.mode3d && isFunc(painter.toggleProjection))
             return painter.toggleProjection(painter.options.Project);
      }).then(() => {
          painter.fillToolbar();
          return painter;
      });
   }

} // class THistPainter

/**
 * @summary Painter for TH1 classes
 * @private
 */

class TH1Painter$2 extends THistPainter {

   /** @summary Convert TH1K into normal binned histogram */
   convertTH1K() {
      let histo = this.getObject();
      if (histo.fReady) return;

      let arr = histo.fArray, entries = histo.fEntries; // array of values
      histo.fNcells = histo.fXaxis.fNbins + 2;
      histo.fArray = new Float64Array(histo.fNcells).fill(0);
      for (let n = 0; n < histo.fNIn; ++n)
         histo.Fill(arr[n]);
      histo.fReady = 1;
      histo.fEntries = entries;
   }

   /** @summary Scan content of 1-D histogram
     * @desc Detect min/max values for x and y axis
     * @param {boolean} when_axis_changed - true when zooming was changed, some checks may be skipped */
   scanContent(when_axis_changed) {

      if (when_axis_changed && !this.nbinsx)
         when_axis_changed = false;

      if (this.isTH1K())
         this.convertTH1K();

      let histo = this.getHisto();

      if (!when_axis_changed)
         this.extractAxesProperties(1);

      let left = this.getSelectIndex('x', 'left'),
          right = this.getSelectIndex('x', 'right');

      if (when_axis_changed && (left === this.scan_xleft) && (right === this.scan_xright))
         return;

      // Paint histogram axis only
      this.draw_content = !(this.options.Axis > 0);

      this.scan_xleft = left;
      this.scan_xright = right;

      let hmin = 0, hmin_nz = 0, hmax = 0, hsum = 0, first = true,
          profile = this.isTProfile(), value, err;

      for (let i = 0; i < this.nbinsx; ++i) {
         value = histo.getBinContent(i + 1);
         hsum += profile ? histo.fBinEntries[i + 1] : value;

         if ((i < left) || (i >= right))
            continue;

         if ((value > 0) && ((hmin_nz == 0) || (value < hmin_nz)))
            hmin_nz = value;

         if (first) {
            hmin = hmax = value;
            first = false;
         }

         err = this.options.Error ? histo.getBinError(i + 1) : 0;

         hmin = Math.min(hmin, value - err);
         hmax = Math.max(hmax, value + err);
      }

      // account overflow/underflow bins
      if (profile)
         hsum += histo.fBinEntries[0] + histo.fBinEntries[this.nbinsx + 1];
      else
         hsum += histo.getBinContent(0) + histo.getBinContent(this.nbinsx + 1);

      this.stat_entries = hsum;
      if (histo.fEntries > 1) this.stat_entries = histo.fEntries;

      this.hmin = hmin;
      this.hmax = hmax;

      this.ymin_nz = hmin_nz; // value can be used to show optimal log scale

      if ((this.nbinsx == 0) || ((Math.abs(hmin) < 1e-300) && (Math.abs(hmax) < 1e-300)))
         this.draw_content = false;

      let set_zoom = false;

      if (this.draw_content) {
         if (hmin >= hmax) {
            if (hmin == 0) {
               this.ymin = 0; this.ymax = 1;
            } else if (hmin < 0) {
               this.ymin = 2 * hmin; this.ymax = 0;
            } else {
               this.ymin = 0; this.ymax = hmin * 2;
            }
         } else {
            let dy = (hmax - hmin) * gStyle.fHistTopMargin;
            this.ymin = hmin - dy;
            if ((this.ymin < 0) && (hmin >= 0)) this.ymin = 0;
            this.ymax = hmax + dy;
         }
      }

      hmin = this.options.minimum;
      hmax = this.options.maximum;

      if ((hmin === hmax) && (hmin !== kNoZoom)) {
         if (hmin < 0) {
            hmin *= 2; hmax = 0;
         } else {
            hmin = 0; hmax *= 2;
            if (!hmax) hmax = 1;
         }
      }

      if ((hmin != kNoZoom) && (hmax != kNoZoom) && !this.draw_content &&
          ((this.ymin == this.ymax) || (this.ymin > hmin) || (this.ymax < hmax))) {
         this.ymin = hmin;
         this.ymax = hmax;
      } else {
         if (hmin != kNoZoom) {
            if (hmin < this.ymin)
               this.ymin = hmin;
             set_zoom = true;
         }
         if (hmax != kNoZoom) {
            if (hmax > this.ymax)
               this.ymax = hmax;
            set_zoom = true;
         }
      }

      // always set zoom when hmin/hmax is configured
      // fMinimum/fMaximum values is a way how ROOT handles Y scale zooming for TH1

      if (!when_axis_changed) {

         if (set_zoom) {
            this.zoom_ymin = (hmin == kNoZoom) ? this.ymin : hmin;
            this.zoom_ymax = (hmax == kNoZoom) ? this.ymax : hmax;
         } else {
            delete this.zoom_ymin;
            delete this.zoom_ymax;
         }
      }

      // used in FramePainter.isAllowedDefaultYZooming
      this.wheel_zoomy = (this.getDimension() > 1) || !this.draw_content;
   }

   /** @summary Count histogram statistic */
   countStat(cond) {
      let profile = this.isTProfile(),
          histo = this.getHisto(), xaxis = histo.fXaxis,
          left = this.getSelectIndex('x', 'left'),
          right = this.getSelectIndex('x', 'right'),
          stat_sumw = 0, stat_sumwx = 0, stat_sumwx2 = 0, stat_sumwy = 0, stat_sumwy2 = 0,
          i, xx = 0, w = 0, xmax = null, wmax = null,
          fp = this.getFramePainter(),
          res = { name: histo.fName, meanx: 0, meany: 0, rmsx: 0, rmsy: 0, integral: 0, entries: this.stat_entries, xmax: 0, wmax: 0 },
          has_counted_stat = !fp.isAxisZoomed('x') && (Math.abs(histo.fTsumw) > 1e-300);

      for (i = left; i < right; ++i) {
         xx = xaxis.GetBinCoord(i + 0.5);

         if (cond && !cond(xx)) continue;

         if (profile) {
            w = histo.fBinEntries[i + 1];
            stat_sumwy += histo.fArray[i + 1];
            stat_sumwy2 += histo.fSumw2[i + 1];
         } else {
            w = histo.getBinContent(i + 1);
         }

         if ((xmax === null) || (w > wmax)) {
            xmax = xx;
            wmax = w;
         }

         if (!has_counted_stat) {
            stat_sumw += w;
            stat_sumwx += w * xx;
            stat_sumwx2 += w * xx**2;
         }
      }

      // when no range selection done, use original statistic from histogram
      if (has_counted_stat) {
         stat_sumw = histo.fTsumw;
         stat_sumwx = histo.fTsumwx;
         stat_sumwx2 = histo.fTsumwx2;
      }

      res.integral = stat_sumw;

      if (Math.abs(stat_sumw) > 1e-300) {
         res.meanx = stat_sumwx / stat_sumw;
         res.meany = stat_sumwy / stat_sumw;
         res.rmsx = Math.sqrt(Math.abs(stat_sumwx2 / stat_sumw - res.meanx**2));
         res.rmsy = Math.sqrt(Math.abs(stat_sumwy2 / stat_sumw - res.meany**2));
      }

      if (xmax !== null) {
         res.xmax = xmax;
         res.wmax = wmax;
      }

      return res;
   }

   /** @summary Fill stat box */
   fillStatistic(stat, dostat, dofit) {

      // no need to refill statistic if histogram is dummy
      if (this.isIgnoreStatsFill()) return false;

      let histo = this.getHisto(),
          data = this.countStat(),
          print_name = dostat % 10,
          print_entries = Math.floor(dostat / 10) % 10,
          print_mean = Math.floor(dostat / 100) % 10,
          print_rms = Math.floor(dostat / 1000) % 10,
          print_under = Math.floor(dostat / 10000) % 10,
          print_over = Math.floor(dostat / 100000) % 10,
          print_integral = Math.floor(dostat / 1000000) % 10,
          print_skew = Math.floor(dostat / 10000000) % 10,
          print_kurt = Math.floor(dostat / 100000000) % 10;

      // make empty at the beginning
      stat.clearPave();

      if (print_name > 0)
         stat.addText(data.name);

      if (this.isTProfile()) {

         if (print_entries > 0)
            stat.addText('Entries = ' + stat.format(data.entries,'entries'));

         if (print_mean > 0) {
            stat.addText('Mean = ' + stat.format(data.meanx));
            stat.addText('Mean y = ' + stat.format(data.meany));
         }

         if (print_rms > 0) {
            stat.addText('Std Dev = ' + stat.format(data.rmsx));
            stat.addText('Std Dev y = ' + stat.format(data.rmsy));
         }

      } else {

         if (print_entries > 0)
            stat.addText('Entries = ' + stat.format(data.entries, 'entries'));

         if (print_mean > 0)
            stat.addText('Mean = ' + stat.format(data.meanx));

         if (print_rms > 0)
            stat.addText('Std Dev = ' + stat.format(data.rmsx));

         if (print_under > 0)
            stat.addText('Underflow = ' + stat.format((histo.fArray.length > 0) ? histo.fArray[0] : 0, 'entries'));

         if (print_over > 0)
            stat.addText('Overflow = ' + stat.format((histo.fArray.length > 0) ? histo.fArray[histo.fArray.length - 1] : 0, 'entries'));

         if (print_integral > 0)
            stat.addText('Integral = ' + stat.format(data.integral, 'entries'));

         if (print_skew > 0)
            stat.addText('Skew = <not avail>');

         if (print_kurt > 0)
            stat.addText('Kurt = <not avail>');
      }

      if (dofit) stat.fillFunctionStat(this.findFunction(clTF1), dofit);

      return true;
   }

   /** @summary Draw histogram as bars */
   drawBars(height, pmain, funcs) {

      this.createG(true);

      let left = this.getSelectIndex('x', 'left', -1),
          right = this.getSelectIndex('x', 'right', 1),
          histo = this.getHisto(), xaxis = histo.fXaxis,
          show_text = this.options.Text, text_col, text_angle, text_size,
          i, x1, x2, grx1, grx2, y, gry1, gry2, w,
          bars = '', barsl = '', barsr = '',
          side = (this.options.BarStyle > 10) ? this.options.BarStyle % 10 : 0;

      if (side > 4) side = 4;
      gry2 = pmain.swap_xy ? 0 : height;
      if (Number.isFinite(this.options.BaseLine))
         if (this.options.BaseLine >= funcs.scale_ymin)
            gry2 = Math.round(funcs.gry(this.options.BaseLine));

      if (show_text) {
         text_col = this.getColor(histo.fMarkerColor);
         text_angle = -1*this.options.TextAngle;
         text_size = 20;

         if ((histo.fMarkerSize !== 1) && text_angle)
            text_size = 0.02*height*histo.fMarkerSize;

         this.startTextDrawing(42, text_size, this.draw_g, text_size);
      }

      for (i = left; i < right; ++i) {
         x1 = xaxis.GetBinLowEdge(i+1);
         x2 = xaxis.GetBinLowEdge(i+2);

         if (pmain.logx && (x2 <= 0)) continue;

         grx1 = Math.round(funcs.grx(x1));
         grx2 = Math.round(funcs.grx(x2));

         y = histo.getBinContent(i+1);
         if (funcs.logy && (y < funcs.scale_ymin)) continue;
         gry1 = Math.round(funcs.gry(y));

         w = grx2 - grx1;
         grx1 += Math.round(histo.fBarOffset/1000*w);
         w = Math.round(histo.fBarWidth/1000*w);

         if (pmain.swap_xy)
            bars += `M${gry2},${grx1}h${gry1-gry2}v${w}h${gry2-gry1}z`;
         else
            bars += `M${grx1},${gry1}h${w}v${gry2-gry1}h${-w}z`;

         if (side > 0) {
            grx2 = grx1 + w;
            w = Math.round(w * side / 10);
            if (pmain.swap_xy) {
               barsl += `M${gry2},${grx1}h${gry1-gry2}v${w}h${gry2-gry1}z`;
               barsr += `M${gry2},${grx2}h${gry1-gry2}v${-w}h${gry2-gry1}z`;
            } else {
               barsl += `M${grx1},${gry1}h${w}v${gry2-gry1}h${-w}z`;
               barsr += `M${grx2},${gry1}h${-w}v${gry2-gry1}h${w}z`;
            }
         }

         if (show_text && y) {
            let lbl = (y === Math.round(y)) ? y.toString() : floatToString(y, gStyle.fPaintTextFormat);

            if (pmain.swap_xy)
               this.drawText({ align: 12, x: Math.round(gry1 + text_size/2), y: Math.round(grx1+0.1), height: Math.round(w*0.8), text: lbl, color: text_col, latex: 0 });
            else if (text_angle)
               this.drawText({ align: 12, x: grx1+w/2, y: Math.round(gry1 - 2 - text_size/5), width: 0, height: 0, rotate: text_angle, text: lbl, color: text_col, latex: 0 });
            else
               this.drawText({ align: 22, x: Math.round(grx1 + w*0.1), y: Math.round(gry1-2-text_size), width: Math.round(w*0.8), height: text_size, text: lbl, color: text_col, latex: 0 });
         }
      }

      if (bars)
         this.draw_g.append('svg:path')
                    .attr('d', bars)
                    .call(this.fillatt.func);

      if (barsl)
         this.draw_g.append('svg:path')
               .attr('d', barsl)
               .call(this.fillatt.func)
               .style('fill', rgb(this.fillatt.color).brighter(0.5).formatHex());

      if (barsr)
         this.draw_g.append('svg:path')
               .attr('d', barsr)
               .call(this.fillatt.func)
               .style('fill', rgb(this.fillatt.color).darker(0.5).formatHex());

      if (show_text)
         return this.finishTextDrawing();
   }

   /** @summary Draw histogram as filled errors */
   drawFilledErrors(funcs) {
      this.createG(true);

      let left = this.getSelectIndex('x', 'left', -1),
          right = this.getSelectIndex('x', 'right', 1),
          histo = this.getHisto(), xaxis = histo.fXaxis,
          i, x, grx, y, yerr, bins1 = [], bins2 = [];

      for (i = left; i < right; ++i) {
         x = xaxis.GetBinCoord(i+0.5);
         if (funcs.logx && (x <= 0)) continue;
         grx = Math.round(funcs.grx(x));

         y = histo.getBinContent(i+1);
         yerr = histo.getBinError(i+1);
         if (funcs.logy && (y-yerr < funcs.scale_ymin)) continue;

         bins1.push({ grx, gry:  Math.round(funcs.gry(y + yerr)) });
         bins2.unshift({ grx, gry: Math.round(funcs.gry(y - yerr)) });
      }

      let kind = (this.options.ErrorKind === 4) ? 'bezier' : 'line',
          path1 = buildSvgPath(kind, bins1),
          path2 = buildSvgPath('L'+kind, bins2);

      this.draw_g.append('svg:path')
                 .attr('d', path1.path + path2.path + 'Z')
                 .call(this.fillatt.func);
   }

   /** @summary Draw TH1 bins in SVG element
     * @return Promise or scalar value */
   draw1DBins() {

      this.createHistDrawAttributes();

      let pmain = this.getFramePainter(),
          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),
          width = pmain.getFrameWidth(), height = pmain.getFrameHeight();

      if (!this.draw_content || (width <= 0) || (height <= 0))
          return this.removeG();

      if (this.options.Bar)
         return this.drawBars(height, pmain, funcs);

      if ((this.options.ErrorKind === 3) || (this.options.ErrorKind === 4))
         return this.drawFilledErrors(pmain, funcs);

      let left = this.getSelectIndex('x', 'left', -1),
          right = this.getSelectIndex('x', 'right', 2),
          histo = this.getHisto(),
          want_tooltip = !isBatchMode() && settings.Tooltip,
          xaxis = histo.fXaxis,
          res = '', lastbin = false,
          startx, currx, curry, x, grx, y, gry, curry_min, curry_max, prevy, prevx, i, bestimin, bestimax,
          exclude_zero = !this.options.Zero,
          show_errors = this.options.Error,
          show_markers = this.options.Mark,
          show_line = this.options.Line || this.options.Curve,
          show_text = this.options.Text,
          text_profile = show_text && (this.options.TextKind == 'E') && this.isTProfile() && histo.fBinEntries,
          path_fill = null, path_err = null, path_marker = null, path_line = null,
          hints_err = null, hints_marker = null, hsz = 5,
          do_marker = false, do_err = false,
          dend = 0, dlw = 0, my, yerr1, yerr2, bincont, binerr, mx1, mx2, midx, mmx1, mmx2,
          text_col, text_angle, text_size;

      if (show_errors && !show_markers && (histo.fMarkerStyle > 1))
         show_markers = true;

      if (this.options.ErrorKind === 2) {
         if (this.fillatt.empty()) show_markers = true;
                              else path_fill = '';
      } else if (this.options.Error) {
         path_err = '';
         hints_err = want_tooltip ? '' : null;
         do_err = true;
      }

      if (show_line) path_line = '';

      dlw = this.lineatt.width + gStyle.fEndErrorSize;
      if (this.options.ErrorKind === 1)
         dend = Math.floor((this.lineatt.width-1)/2);

      if (show_markers) {
         // draw markers also when e2 option was specified
         this.createAttMarker({ attr: histo, style: this.options.MarkStyle }); // when style not configured, it will be ignored
         if (this.markeratt.size > 0) {
            // simply use relative move from point, can optimize in the future
            path_marker = '';
            do_marker = true;
            this.markeratt.resetPos();
            if ((hints_err === null) && want_tooltip && (!this.markeratt.fill || (this.markeratt.getFullSize() < 7))) {
               hints_marker = '';
               hsz = Math.max(5, Math.round(this.markeratt.getFullSize()*0.7));
             }
         } else {
            show_markers = false;
         }
      }

      let draw_markers = show_errors || show_markers,
          draw_any_but_hist = draw_markers || show_text || show_line,
          draw_hist = this.options.Hist && (!this.lineatt.empty() || !this.fillatt.empty());

      if (!draw_hist && !draw_any_but_hist)
         return this.removeG();

      this.createG(true);

      if (show_text) {
         text_col = this.getColor(histo.fMarkerColor);
         text_angle = -1*this.options.TextAngle;
         text_size = 20;

         if ((histo.fMarkerSize !== 1) && text_angle)
            text_size = 0.02*height*histo.fMarkerSize;

         if (!text_angle && !this.options.TextKind) {
             let space = width / (right - left + 1);
             if (space < 3 * text_size) {
                text_angle = 270;
                text_size = Math.round(space*0.7);
             }
         }

         this.startTextDrawing(42, text_size, this.draw_g, text_size);
      }

      // if there are too many points, exclude many vertical drawings at the same X position
      // instead define min and max value and made min-max drawing
      let use_minmax = draw_any_but_hist || ((right - left) > 3*width);

      // just to get correct values for the specified bin
      const extract_bin = bin => {
         bincont = histo.getBinContent(bin+1);
         if (exclude_zero && (bincont === 0)) return false;
         mx1 = Math.round(funcs.grx(xaxis.GetBinLowEdge(bin+1)));
         mx2 = Math.round(funcs.grx(xaxis.GetBinLowEdge(bin+2)));
         midx = Math.round((mx1 + mx2) / 2);
         my = Math.round(funcs.gry(bincont));
         if (show_errors) {
            binerr = histo.getBinError(bin+1);
            yerr1 = Math.round(my - funcs.gry(bincont + binerr)); // up
            yerr2 = Math.round(funcs.gry(bincont - binerr) - my); // down
         } else {
            yerr1 = yerr2 = 20;
         }
         return true;
      }, draw_errbin = () => {
         let edx = 5;
         if (this.options.errorX > 0) {
            edx = Math.round((mx2 - mx1) * this.options.errorX);
            mmx1 = midx - edx;
            mmx2 = midx + edx;
            if (this.options.ErrorKind === 1)
               path_err += `M${mmx1+dend},${my-dlw}v${2*dlw}m0,-${dlw}h${mmx2-mmx1-2*dend}m0,-${dlw}v${2*dlw}`;
            else
               path_err += `M${mmx1+dend},${my}h${mmx2-mmx1-2*dend}`;
         }
         if (this.options.ErrorKind === 1)
            path_err += `M${midx-dlw},${my-yerr1+dend}h${2*dlw}m${-dlw},0v${yerr1+yerr2-2*dend}m${-dlw},0h${2*dlw}`;
         else
            path_err += `M${midx},${my-yerr1+dend}v${yerr1+yerr2-2*dend}`;
         if (hints_err !== null)
            hints_err += `M${midx-edx},${my-yerr1}h${2*edx}v${yerr1+yerr2}h${-2*edx}z`;
      }, draw_bin = bin => {
         if (extract_bin(bin)) {
            if (show_text) {
               let cont = text_profile ? histo.fBinEntries[bin+1] : bincont;

               if (cont !== 0) {
                  let lbl = (cont === Math.round(cont)) ? cont.toString() : floatToString(cont, gStyle.fPaintTextFormat);

                  if (text_angle)
                     this.drawText({ align: 12, x: midx, y: Math.round(my - 2 - text_size/5), width: 0, height: 0, rotate: text_angle, text: lbl, color: text_col, latex: 0 });
                  else
                     this.drawText({ align: 22, x: Math.round(mx1 + (mx2-mx1)*0.1), y: Math.round(my-2-text_size), width: Math.round((mx2-mx1)*0.8), height: text_size, text: lbl, color: text_col, latex: 0 });
               }
            }

            if (show_line && (path_line !== null))
               path_line += ((path_line.length === 0) ? 'M' : 'L') + `${midx},${my}`;

            if (draw_markers) {
               if ((my >= -yerr1) && (my <= height + yerr2)) {
                  if (path_fill !== null)
                     path_fill += `M${mx1},${my-yerr1}h${mx2-mx1}v${yerr1+yerr2+1}h${mx1-mx2}z`;
                  if ((path_marker !== null) && do_marker) {
                     path_marker += this.markeratt.create(midx, my);
                     if (hints_marker !== null)
                        hints_marker += `M${midx-hsz},${my-hsz}h${2*hsz}v${2*hsz}h${-2*hsz}z`;
                  }

                  if ((path_err !== null) && do_err)
                     draw_errbin();
               }
            }
         }
      };

      // check if we should draw markers or error marks directly, skipping optimization
      if (do_marker || do_err)
         if (!settings.OptimizeDraw || ((right-left < 50000) && (settings.OptimizeDraw == 1))) {
            for (i = left; i < right; ++i) {
               if (extract_bin(i)) {
                  if (path_marker !== null)
                     path_marker += this.markeratt.create(midx, my);
                  if (hints_marker !== null)
                     hints_marker += `M${midx-hsz},${my-hsz}h${2*hsz}v${2*hsz}h${-2*hsz}z`;
                  if (path_err !== null)
                     draw_errbin();
               }
            }
            do_err = do_marker = false;
         }


      for (i = left; i <= right; ++i) {

         x = xaxis.GetBinLowEdge(i+1);

         if (this.logx && (x <= 0)) continue;

         grx = Math.round(funcs.grx(x));

         lastbin = (i === right);

         if (lastbin && (left<right)) {
            gry = curry;
         } else {
            y = histo.getBinContent(i+1);
            gry = Math.round(funcs.gry(y));
         }

         if (res.length === 0) {
            bestimin = bestimax = i;
            prevx = startx = currx = grx;
            prevy = curry_min = curry_max = curry = gry;
            res = `M${currx},${curry}`;
         } else if (use_minmax) {
            if ((grx === currx) && !lastbin) {
               if (gry < curry_min)
                  bestimax = i;
               else if (gry > curry_max)
                  bestimin = i;

               curry_min = Math.min(curry_min, gry);
               curry_max = Math.max(curry_max, gry);
               curry = gry;
            } else {

               if (draw_any_but_hist) {
                  if (bestimin === bestimax)
                     draw_bin(bestimin);
                  else if (bestimin < bestimax) {
                     draw_bin(bestimin); draw_bin(bestimax);
                  } else {
                     draw_bin(bestimax); draw_bin(bestimin);
                  }
               }

               // when several points at same X differs, need complete logic
               if (draw_hist && ((curry_min !== curry_max) || (prevy !== curry_min))) {

                  if (prevx !== currx)
                     res += 'h'+(currx-prevx);

                  if (curry === curry_min) {
                     if (curry_max !== prevy)
                        res += 'v' + (curry_max - prevy);
                     if (curry_min !== curry_max)
                        res += 'v' + (curry_min - curry_max);
                  } else {
                     if (curry_min !== prevy)
                        res += 'v' + (curry_min - prevy);
                     if (curry_max !== curry_min)
                        res += 'v' + (curry_max - curry_min);
                     if (curry !== curry_max)
                       res += 'v' + (curry - curry_max);
                  }

                  prevx = currx;
                  prevy = curry;
               }

               if (lastbin && (prevx !== grx))
                  res += 'h' + (grx-prevx);

               bestimin = bestimax = i;
               curry_min = curry_max = curry = gry;
               currx = grx;
            }
            // end of use_minmax
         } else if ((gry !== curry) || lastbin) {
            if (grx !== currx) res += `h${grx-currx}`;
            if (gry !== curry) res += `v${gry-curry}`;
            curry = gry;
            currx = grx;
         }
      }

      let fill_for_interactive = want_tooltip && this.fillatt.empty() && draw_hist && !draw_markers && !show_line,
          h0 = height + 3;
      if (!fill_for_interactive) {
         let gry0 = Math.round(funcs.gry(0));
         if (gry0 <= 0)
            h0 = -3;
         else if (gry0 < height)
            h0 = gry0;
      }
      let close_path = `L${currx},${h0}H${startx}Z`;

      if (draw_markers || show_line) {
         if (path_fill)
            this.draw_g.append('svg:path')
                       .attr('d', path_fill)
                       .call(this.fillatt.func);

         if (path_err)
               this.draw_g.append('svg:path')
                   .attr('d', path_err)
                   .call(this.lineatt.func);

          if (hints_err)
               this.draw_g.append('svg:path')
                   .attr('d', hints_err)
                   .style('fill', 'none')
                   .style('pointer-events', isBatchMode() ? null : 'visibleFill');

         if (path_line) {
            if (!this.fillatt.empty() && !draw_hist)
               this.draw_g.append('svg:path')
                     .attr('d', path_line + close_path)
                     .call(this.fillatt.func);

            this.draw_g.append('svg:path')
                   .attr('d', path_line)
                   .style('fill', 'none')
                   .call(this.lineatt.func);
         }

         if (path_marker)
            this.draw_g.append('svg:path')
                .attr('d', path_marker)
                .call(this.markeratt.func);

         if (hints_marker)
            this.draw_g.append('svg:path')
                .attr('d', hints_marker)
                .style('fill', 'none')
                .style('pointer-events', isBatchMode() ? null : 'visibleFill');
      }

      if (res && draw_hist)
         this.draw_g.append('svg:path')
                    .attr('d', res + ((!this.fillatt.empty() || fill_for_interactive) ? close_path : ''))
                    .style('stroke-linejoin','miter')
                    .call(this.lineatt.func)
                    .call(this.fillatt.func);

      if (show_text)
         return this.finishTextDrawing();
   }

   /** @summary Provide text information (tooltips) for histogram bin */
   getBinTooltips(bin) {
      let tips = [],
          name = this.getObjectHint(),
          pmain = this.getFramePainter(),
          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),
          histo = this.getHisto(),
          x1 = histo.fXaxis.GetBinLowEdge(bin+1),
          x2 = histo.fXaxis.GetBinLowEdge(bin+2),
          cont = histo.getBinContent(bin+1),
          xlbl = this.getAxisBinTip('x', histo.fXaxis, bin);

      if (name) tips.push(name);

      if (this.options.Error || this.options.Mark) {
         tips.push('x = ' + xlbl, 'y = ' + funcs.axisAsText('y', cont));
         if (this.options.Error) {
            if (xlbl[0] == '[') tips.push('error x = ' + ((x2 - x1) / 2).toPrecision(4));
            tips.push('error y = ' + histo.getBinError(bin + 1).toPrecision(4));
         }
      } else {
         tips.push(`bin = ${bin+1}`, `x = ${xlbl}`);
         if (histo.$baseh) cont -= histo.$baseh.getBinContent(bin+1);
         if (cont === Math.round(cont))
            tips.push('entries = ' + cont);
         else
            tips.push('entries = ' + floatToString(cont, gStyle.fStatFormat));
      }

      return tips;
   }

   /** @summary Process tooltip event */
   processTooltipEvent(pnt) {
      if (!pnt || !this.draw_content || !this.draw_g || this.options.Mode3D) {
         if (this.draw_g)
            this.draw_g.select('.tooltip_bin').remove();
         return null;
      }

      const pmain = this.getFramePainter(),
            funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),
            histo = this.getHisto(),
            left = this.getSelectIndex('x', 'left', -1),
            right = this.getSelectIndex('x', 'right', 2);
      let width = pmain.getFrameWidth(),
          height = pmain.getFrameHeight(),
          findbin = null, show_rect,
          grx1, midx, grx2, gry1, midy, gry2, gapx = 2,
          l = left, r = right, pnt_x = pnt.x, pnt_y = pnt.y;

      const GetBinGrX = i => {
         let xx = histo.fXaxis.GetBinLowEdge(i+1);
         return (funcs.logx && (xx <= 0)) ? null : funcs.grx(xx);
      }, GetBinGrY = i => {
         let yy = histo.getBinContent(i + 1);
         if (funcs.logy && (yy < funcs.scale_ymin))
            return funcs.swap_xy ? -1000 : 10*height;
         return Math.round(funcs.gry(yy));
      };

      if (funcs.swap_xy)
         [pnt_x, pnt_y, width, height] = [pnt_y, pnt_x, height, width];

      let descent_order = funcs.swap_xy != pmain.x_handle.reverse;

      while (l < r-1) {
         let m = Math.round((l+r)*0.5), xx = GetBinGrX(m);
         if ((xx === null) || (xx < pnt_x - 0.5)) {
            if (descent_order) r = m; else l = m;
         } else if (xx > pnt_x + 0.5) {
            if (descent_order) l = m; else r = m;
         } else { l++; r--; }
      }

      findbin = r = l;
      grx1 = GetBinGrX(findbin);

      if (descent_order) {
         while ((l > left) && (GetBinGrX(l-1) < grx1 + 2)) --l;
         while ((r < right) && (GetBinGrX(r+1) > grx1 - 2)) ++r;
      } else {
         while ((l > left) && (GetBinGrX(l-1) > grx1 - 2)) --l;
         while ((r < right) && (GetBinGrX(r+1) < grx1 + 2)) ++r;
      }

      if (l < r) {
         // many points can be assigned with the same cursor position
         // first try point around mouse y
         let best = height;
         for (let m = l; m <= r; m++) {
            let dist = Math.abs(GetBinGrY(m) - pnt_y);
            if (dist < best) { best = dist; findbin = m; }
         }

         // if best distance still too far from mouse position, just take from between
         if (best > height/10)
            findbin = Math.round(l + (r-l) / height * pnt_y);

         grx1 = GetBinGrX(findbin);
      }

      grx1 = Math.round(grx1);
      grx2 = Math.round(GetBinGrX(findbin+1));

      if (this.options.Bar) {
         let w = grx2 - grx1;
         grx1 += Math.round(histo.fBarOffset/1000*w);
         grx2 = grx1 + Math.round(histo.fBarWidth/1000*w);
      }

      if (grx1 > grx2)
         [grx1, grx2] = [grx2, grx1];

      midx = Math.round((grx1 + grx2)/2);

      midy = gry1 = gry2 = GetBinGrY(findbin);

      if (this.options.Bar) {
         show_rect = true;

         gapx = 0;

         gry1 = Math.round(funcs.gry(((this.options.BaseLine !== false) && (this.options.BaseLine > funcs.scale_ymin)) ? this.options.BaseLine : funcs.scale_ymin));

         if (gry1 > gry2)
            [gry1, gry2] = [gry2, gry1];

         if (!pnt.touch && (pnt.nproc === 1))
            if ((pnt_y < gry1) || (pnt_y > gry2)) findbin = null;

      } else if (this.options.Error || this.options.Mark || this.options.Line || this.options.Curve)  {

         show_rect = true;

         let msize = 3;
         if (this.markeratt) msize = Math.max(msize, this.markeratt.getFullSize());

         if (this.options.Error) {
            let cont = histo.getBinContent(findbin+1),
                binerr = histo.getBinError(findbin+1);

            gry1 = Math.round(funcs.gry(cont + binerr)); // up
            gry2 = Math.round(funcs.gry(cont - binerr)); // down

            if ((cont == 0) && this.isTProfile()) findbin = null;

            let dx = (grx2-grx1)*this.options.errorX;
            grx1 = Math.round(midx - dx);
            grx2 = Math.round(midx + dx);
         }

         // show at least 6 pixels as tooltip rect
         if (grx2 - grx1 < 2*msize) { grx1 = midx-msize; grx2 = midx+msize; }

         gry1 = Math.min(gry1, midy - msize);
         gry2 = Math.max(gry2, midy + msize);

         if (!pnt.touch && (pnt.nproc === 1))
            if ((pnt_y < gry1) || (pnt_y > gry2)) findbin = null;

      } else {

         // if histogram alone, use old-style with rects
         // if there are too many points at pixel, use circle
         show_rect = (pnt.nproc === 1) && (right-left < width);

         if (show_rect) {
            gry2 = height;

            if (!this.fillatt.empty()) {
               gry2 = Math.min(height, Math.max(0, Math.round(funcs.gry(0))));
               if (gry2 < gry1)
                 [gry1, gry2] = [gry2, gry1];
            }

            // for mouse events pointer should be between y1 and y2
            if (((pnt.y < gry1) || (pnt.y > gry2)) && !pnt.touch) findbin = null;
         }
      }

      if (findbin !== null) {
         // if bin on boundary found, check that x position is ok
         if ((findbin === left) && (grx1 > pnt_x + gapx))
            findbin = null;
         else if ((findbin === right-1) && (grx2 < pnt_x - gapx))
            findbin = null;
         else if ((pnt_x < grx1 - gapx) || (pnt_x > grx2 + gapx))
            findbin = null; // if bars option used check that bar is not match
         else if (!this.options.Zero && (histo.getBinContent(findbin+1) === 0))
            findbin = null; // exclude empty bin if empty bins suppressed
      }

      let ttrect = this.draw_g.select('.tooltip_bin');

      if ((findbin === null) || ((gry2 <= 0) || (gry1 >= height))) {
         ttrect.remove();
         return null;
      }

      let res = { name: histo.fName, title: histo.fTitle,
                  x: midx, y: midy, exact: true,
                  color1: this.lineatt ? this.lineatt.color : 'green',
                  color2: this.fillatt ? this.fillatt.getFillColorAlt('blue') : 'blue',
                  lines: this.getBinTooltips(findbin) };

      if (pnt.disabled) {
         // case when tooltip should not highlight bin

         ttrect.remove();
         res.changed = true;
      } else if (show_rect) {

         if (ttrect.empty())
            ttrect = this.draw_g.append('svg:rect')
                                .attr('class', 'tooltip_bin h1bin')
                                .style('pointer-events', 'none');

         res.changed = ttrect.property('current_bin') !== findbin;

         if (res.changed)
            ttrect.attr('x', funcs.swap_xy ? gry1 : grx1)
                  .attr('width', funcs.swap_xy ? gry2-gry1 : grx2-grx1)
                  .attr('y', funcs.swap_xy ? grx1 : gry1)
                  .attr('height', funcs.swap_xy ? grx2-grx1 : gry2-gry1)
                  .style('opacity', '0.3')
                  .property('current_bin', findbin);

         res.exact = (Math.abs(midy - pnt_y) <= 5) || ((pnt_y >= gry1) && (pnt_y <= gry2));

         res.menu = res.exact; // one could show context menu when histogram is selected
         // distance to middle point, use to decide which menu to activate
         res.menu_dist = Math.sqrt((midx-pnt_x)**2 + (midy-pnt_y)**2);

      } else {
         let radius = this.lineatt.width + 3;

         if (ttrect.empty())
            ttrect = this.draw_g.append('svg:circle')
                                .attr('class', 'tooltip_bin')
                                .style('pointer-events', 'none')
                                .attr('r', radius)
                                .call(this.lineatt.func)
                                .call(this.fillatt.func);

         res.exact = (Math.abs(midx - pnt.x) <= radius) && (Math.abs(midy - pnt.y) <= radius);

         res.menu = res.exact; // show menu only when mouse pointer exactly over the histogram
         res.menu_dist = Math.sqrt((midx-pnt.x)**2 + (midy-pnt.y)**2);

         res.changed = ttrect.property('current_bin') !== findbin;

         if (res.changed)
            ttrect.attr('cx', midx)
                  .attr('cy', midy)
                  .property('current_bin', findbin);
      }

      if (res.changed)
         res.user_info = { obj: histo,  name: histo.fName,
                           bin: findbin, cont: histo.getBinContent(findbin+1),
                           grx: midx, gry: midy };

      return res;
   }

   /** @summary Fill histogram context menu */
   fillHistContextMenu(menu) {

      menu.add('Auto zoom-in', () => this.autoZoom());

      let opts = this.getSupportedDrawOptions();

      menu.addDrawMenu('Draw with', opts, arg => {
         if (arg === 'inspect')
            return this.showInspector();

         this.decodeOptions(arg);

         if (this.options.need_fillcol && this.fillatt && this.fillatt.empty())
            this.fillatt.change(5,1001);

         // redraw all objects in pad, inform dependent objects
         this.interactiveRedraw('pad', 'drawopt');
      });

      if (!this.snapid && !this.isTProfile())
         menu.addRebinMenu(sz => this.rebinHist(sz));
   }

   /** @summary Rebin histogram, used via context menu */
   rebinHist(sz) {
      let histo = this.getHisto(),
          xaxis = histo.fXaxis,
          nbins = Math.floor(xaxis.fNbins/ sz);
      if (nbins < 2) return;

      let arr = new Array(nbins+2), xbins = null;

      if (xaxis.fXbins.length > 0)
         xbins = new Array(nbins);

      arr[0] = histo.fArray[0];
      let indx = 1;

      for (let i = 1; i <= nbins; ++i) {
         if (xbins) xbins[i-1] = xaxis.fXbins[indx-1];
         let sum = 0;
         for (let k = 0; k < sz; ++k)
           sum += histo.fArray[indx++];
         arr[i] = sum;

      }

      if (xbins) {
         if (indx <= xaxis.fXbins.length)
            xaxis.fXmax = xaxis.fXbins[indx-1];
         xaxis.fXbins = xbins;
      } else {
         xaxis.fXmax = xaxis.fXmin + (xaxis.fXmax - xaxis.fXmin) / xaxis.fNbins * nbins * sz;
      }

      xaxis.fNbins = nbins;

      let overflow = 0;
      while (indx < histo.fArray.length)
         overflow += histo.fArray[indx++];
      arr[nbins+1] = overflow;

      histo.fArray = arr;
      histo.fSumw2 = [];

      this.scanContent();

      this.interactiveRedraw('pad');
   }

   /** @summary Perform automatic zoom inside non-zero region of histogram */
   autoZoom() {
      let left = this.getSelectIndex('x', 'left', -1),
          right = this.getSelectIndex('x', 'right', 1),
          dist = right - left,
          histo = this.getHisto();

      if ((dist == 0) || !histo) return;

      // first find minimum
      let min = histo.getBinContent(left + 1);
      for (let indx = left; indx < right; ++indx)
         min = Math.min(min, histo.getBinContent(indx+1));
      if (min > 0) return; // if all points positive, no chance for autoscale

      while ((left < right) && (histo.getBinContent(left+1) <= min)) ++left;
      while ((left < right) && (histo.getBinContent(right) <= min)) --right;

      // if singular bin
      if ((left === right-1) && (left > 2) && (right < this.nbinsx-2)) {
         --left; ++right;
      }

      if ((right - left < dist) && (left < right))
         return this.getFramePainter().zoom(histo.fXaxis.GetBinLowEdge(left+1), histo.fXaxis.GetBinLowEdge(right+1));
   }

   /** @summary Checks if it makes sense to zoom inside specified axis range */
   canZoomInside(axis,min,max) {
      let histo = this.getHisto();

      if ((axis == 'x') && histo && (histo.fXaxis.FindBin(max,0.5) - histo.fXaxis.FindBin(min,0) > 1)) return true;

      if ((axis == 'y') && (Math.abs(max-min) > Math.abs(this.ymax-this.ymin)*1e-6)) return true;

      return false;
   }

   /** @summary Call drawing function depending from 3D mode */
   async callDrawFunc(reason) {

      let main = this.getMainPainter(),
          fp = this.getFramePainter();

     if ((main !== this) && fp && (fp.mode3d !== this.options.Mode3D))
        this.copyOptionsFrom(main);

      return this.options.Mode3D ? this.draw3D(reason) : this.draw2D(reason);
   }

   /** @summary Performs 2D drawing of histogram
     * @return {Promise} when ready */
   async draw2D(/* reason */) {
      this.clear3DScene();

      this.scanContent(true);

      let pr = this.isMainPainter() ? this.drawColorPalette(false) : Promise.resolve(true);

      return pr.then(() => this.drawAxes())
               .then(() => this.draw1DBins())
               .then(() => this.drawHistTitle())
               .then(() => this.drawNextFunction(0, true))
               .then(() => {
                   this.updateStatWebCanvas();
                   return this.addInteractivity();
               });
   }

   /** @summary Should performs 3D drawing of histogram
     * @desc Disable in 2D case, just draw with default options
     * @return {Promise} when ready */
   async draw3D(reason) {
      console.log('3D drawing is disabled, load ./hist/TH1Painter.mjs');
      return this.draw2D(reason);
   }

   /** @summary Redraw histogram */
   redraw(reason) {
      return this.callDrawFunc(reason);
   }

   /** @summary draw TH1 object */
   static async draw(dom, histo, opt) {
      return THistPainter._drawHist(new TH1Painter$2(dom, histo), opt);
   }

} // class TH1Painter

/** @summary Draw 1-D histogram in 3D
  * @private */

class TH1Painter extends TH1Painter$2 {

   /** @summary draw TH1 object in 3D mode */
   draw3D(reason) {

      this.mode3d = true;

      let main = this.getFramePainter(), // who makes axis drawing
          is_main = this.isMainPainter(), // is main histogram
          histo = this.getHisto(),
          pr = Promise.resolve(true),
          zmult = 1 + 2*gStyle.fHistTopMargin;

      if (reason == 'resize')  {

         if (is_main && main.resize3D()) main.render3D();

      } else {

         this.deleteAttr();

         this.scanContent(true); // may be required for axis drawings

         if (is_main) {
            assignFrame3DMethods(main);
            pr = main.create3DScene(this.options.Render3D, this.options.x3dscale, this.options.y3dscale).then(() => {
               main.setAxesRanges(histo.fXaxis, this.xmin, this.xmax, histo.fYaxis, this.ymin, this.ymax, histo.fZaxis, 0, 0, this);
               main.set3DOptions(this.options);
               main.drawXYZ(main.toplevel, TAxisPainter, { use_y_for_z: true, zmult, zoom: settings.Zooming, ndim: 1, draw: this.options.Axis !== -1 });
            });
         }

         if (main.mode3d)
            pr = pr.then(() => {
               drawBinsLego(this);
               main.render3D();
               this.updateStatWebCanvas();
               main.addKeysHandler();
            });
      }

      if (is_main)
         pr = pr.then(() => this.drawColorPalette(this.options.Zscale && ((this.options.Lego === 12) || (this.options.Lego === 14))))
                .then(() => this.drawHistTitle());

      return pr.then(() => this);
   }

   /** @summary draw TH1 object */
   static async draw(dom, histo, opt) {
      return THistPainter._drawHist(new TH1Painter(dom, histo), opt);
   }

} // class TH1Painter

var TH1Painter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
TH1Painter: TH1Painter
});

/**
 * @summary Painter for TH2 classes
 * @private
 */

class TH2Painter$2 extends THistPainter {

   /** @summary constructor
     * @param {object} histo - histogram object */
   constructor(dom, histo) {
      super(dom, histo);
      this.fPalette = null;
      this.wheel_zoomy = true;
      this._show_empty_bins = false;
   }

   /** @summary cleanup painter */
   cleanup() {
      delete this.tt_handle;

      super.cleanup();
   }

   /** @summary Toggle projection */
   toggleProjection(kind, width) {

      if ((kind == 'Projections') || (kind == 'Off')) kind = '';

      if (isStr(kind) && (kind.length > 1)) {
          width = parseInt(kind.slice(1));
          kind = kind[0];
      }

      if (!width) width = 1;

      if (kind && (this.is_projection == kind)) {
         if (this.projection_width === width) {
            kind = '';
         } else {
            this.projection_width = width;
            return;
         }
      }

      delete this.proj_hist;

      let new_proj = (this.is_projection === kind) ? '' : kind;
      this.projection_width = width;
      this.is_projection = ''; // avoid projection handling until area is created

      this.provideSpecialDrawArea(new_proj).then(() => { this.is_projection = new_proj; return this.redrawProjection(); });
   }

   /** @summary Redraw projection */
   async redrawProjection(ii1, ii2, jj1, jj2) {
      if (!this.is_projection)
         return false;

      if (jj2 === undefined) {
         if (!this.tt_handle) return;
         ii1 = Math.round((this.tt_handle.i1 + this.tt_handle.i2)/2); ii2 = ii1+1;
         jj1 = Math.round((this.tt_handle.j1 + this.tt_handle.j2)/2); jj2 = jj1+1;
      }

      let canp = this.getCanvPainter();

      if (canp && !canp._readonly && (this.snapid !== undefined)) {
         // this is when projection should be created on the server side
         let exec = `EXECANDSEND:D${this.is_projection}PROJ:${this.snapid}:`;
         if (this.is_projection == 'X')
            exec += `ProjectionX("_projx",${jj1+1},${jj2},"")`;
         else
            exec += `ProjectionY("_projy",${ii1+1},${ii2},"")`;
         canp.sendWebsocket(exec);
         return true;
      }

      if (this.doing_projection)
         return false;

      this.doing_projection = true;

      let histo = this.getHisto();

      if (!this.proj_hist) {
         if (this.is_projection == 'X') {
            this.proj_hist = createHistogram('TH1D', this.nbinsx);
            Object.assign(this.proj_hist.fXaxis, histo.fXaxis);
            this.proj_hist.fName = 'xproj';
            this.proj_hist.fTitle = 'X projection';
         } else {
            this.proj_hist = createHistogram('TH1D', this.nbinsy);
            Object.assign(this.proj_hist.fXaxis, histo.fYaxis);
            this.proj_hist.fName = 'yproj';
            this.proj_hist.fTitle = 'Y projection';
         }
      }

      let first = 0, last = -1;
      if (this.is_projection == 'X') {
         for (let i = 0; i < this.nbinsx; ++i) {
            let sum = 0;
            for (let j = jj1; j < jj2; ++j)
               sum += histo.getBinContent(i+1,j+1);
            this.proj_hist.setBinContent(i+1, sum);
         }
         this.proj_hist.fTitle = 'X projection ' + (jj1+1 == jj2 ? `bin ${jj2}` : `bins [${jj1+1} .. ${jj2}]`);
         if (this.tt_handle) { first = this.tt_handle.i1+1; last = this.tt_handle.i2; }

      } else {
         for (let j = 0; j < this.nbinsy; ++j) {
            let sum = 0;
            for (let i = ii1; i < ii2; ++i)
               sum += histo.getBinContent(i+1,j+1);
            this.proj_hist.setBinContent(j+1, sum);
         }
         this.proj_hist.fTitle = 'Y projection ' + (ii1+1 == ii2 ? `bin ${ii2}` : `bins [${ii1+1} .. ${ii2}]`);
         if (this.tt_handle) { first = this.tt_handle.j1+1; last = this.tt_handle.j2; }
      }

      if (first < last) {
         let axis = this.proj_hist.fXaxis;
         axis.fFirst = first;
         axis.fLast = last;

         if (((axis.fFirst == 1) && (axis.fLast == axis.fNbins)) == axis.TestBit(EAxisBits.kAxisRange))
            axis.InvertBit(EAxisBits.kAxisRange);
      }

      // reset statistic before display
      this.proj_hist.fEntries = 0;
      this.proj_hist.fTsumw = 0;

      return this.drawInSpecialArea(this.proj_hist).then(res => { delete this.doing_projection; return res; });
   }

   /** @summary Execute TH2 menu command
     * @desc Used to catch standard menu items and provide local implementation */
   executeMenuCommand(method, args) {
      if (super.executeMenuCommand(method, args))
         return true;

      if ((method.fName == 'SetShowProjectionX') || (method.fName == 'SetShowProjectionY')) {
         this.toggleProjection(method.fName[17], args && parseInt(args) ? parseInt(args) : 1);
         return true;
      }

      return false;
   }

   /** @summary Fill histogram context menu */
   fillHistContextMenu(menu) {
      if (!this.isTH2Poly()) {
         menu.add('sub:Projections', () => this.toggleProjection());
         let kind = this.is_projection || '';
         if (kind) kind += this.projection_width;
         const kinds = ['X1', 'X2', 'X3', 'X5', 'X10', 'Y1', 'Y2', 'Y3', 'Y5', 'Y10'];
         if (this.is_projection) kinds.push('Off');
         for (let k = 0; k < kinds.length; ++k)
            menu.addchk(kind==kinds[k], kinds[k], kinds[k], arg => this.toggleProjection(arg));
         menu.add('endsub:');

         menu.add('Auto zoom-in', () => this.autoZoom());
      }

      let opts = this.getSupportedDrawOptions();

      menu.addDrawMenu('Draw with', opts, arg => {
         if (arg == 'inspect')
            return this.showInspector();
         this.decodeOptions(arg);
         this.interactiveRedraw('pad', 'drawopt');
      });

      if (this.options.Color)
         this.fillPaletteMenu(menu);
   }

   /** @summary Process click on histogram-defined buttons */
   clickButton(funcname) {
      if (super.clickButton(funcname)) return true;

      if (this !== this.getMainPainter()) return false;

      switch(funcname) {
         case 'ToggleColor': this.toggleColor(); break;
         case 'ToggleColorZ': this.toggleColz(); break;
         case 'Toggle3D': this.toggleMode3D(); break;
         default: return false;
      }

      // all methods here should not be processed further
      return true;
   }

   /** @summary Fill pad toolbar with histogram-related functions */
   fillToolbar() {
      super.fillToolbar(true);

      let pp = this.getPadPainter();
      if (!pp) return;

      if (!this.isTH2Poly())
         pp.addPadButton('th2color', 'Toggle color', 'ToggleColor');
      pp.addPadButton('th2colorz', 'Toggle color palette', 'ToggleColorZ');
      pp.addPadButton('th2draw3d', 'Toggle 3D mode', 'Toggle3D');
      pp.showPadButtons();
   }

   /** @summary Toggle color drawing mode */
   toggleColor() {

      if (this.options.Mode3D) {
         this.options.Mode3D = false;
         this.options.Color = true;
      } else {
         this.options.Color = !this.options.Color;
      }

      this._can_move_colz = true; // indicate that next redraw can move Z scale

      this.copyOptionsToOthers();

      this.interactiveRedraw('pad', 'drawopt');
   }

   /** @summary Perform automatic zoom inside non-zero region of histogram */
   autoZoom() {
      if (this.isTH2Poly()) return; // not implemented

      let i1 = this.getSelectIndex('x', 'left', -1),
          i2 = this.getSelectIndex('x', 'right', 1),
          j1 = this.getSelectIndex('y', 'left', -1),
          j2 = this.getSelectIndex('y', 'right', 1),
          i,j, histo = this.getObject();

      if ((i1 == i2) || (j1 == j2)) return;

      // first find minimum
      let min = histo.getBinContent(i1 + 1, j1 + 1);
      for (i = i1; i < i2; ++i)
         for (j = j1; j < j2; ++j)
            min = Math.min(min, histo.getBinContent(i+1, j+1));
      if (min > 0) return; // if all points positive, no chance for autoscale

      let ileft = i2, iright = i1, jleft = j2, jright = j1;

      for (i = i1; i < i2; ++i)
         for (j = j1; j < j2; ++j)
            if (histo.getBinContent(i + 1, j + 1) > min) {
               if (i < ileft) ileft = i;
               if (i >= iright) iright = i + 1;
               if (j < jleft) jleft = j;
               if (j >= jright) jright = j + 1;
            }

      let xmin, xmax, ymin, ymax, isany = false;

      if ((ileft === iright-1) && (ileft > i1+1) && (iright < i2-1)) { ileft--; iright++; }
      if ((jleft === jright-1) && (jleft > j1+1) && (jright < j2-1)) { jleft--; jright++; }

      if ((ileft > i1 || iright < i2) && (ileft < iright - 1)) {
         xmin = histo.fXaxis.GetBinLowEdge(ileft+1);
         xmax = histo.fXaxis.GetBinLowEdge(iright+1);
         isany = true;
      }

      if ((jleft > j1 || jright < j2) && (jleft < jright - 1)) {
         ymin = histo.fYaxis.GetBinLowEdge(jleft+1);
         ymax = histo.fYaxis.GetBinLowEdge(jright+1);
         isany = true;
      }

      if (isany)
         return this.getFramePainter().zoom(xmin, xmax, ymin, ymax);
   }

   /** @summary Scan TH2 histogram content */
   scanContent(when_axis_changed) {

      // no need to rescan histogram while result does not depend from axis selection
      if (when_axis_changed && this.nbinsx && this.nbinsy) return;

      let i, j, histo = this.getObject();

      this.extractAxesProperties(2);

      if (this.isTH2Poly()) {
         this.gminposbin = null;
         this.gminbin = this.gmaxbin = 0;

         for (let n = 0, len = histo.fBins.arr.length; n < len; ++n) {
            let bin_content = histo.fBins.arr[n].fContent;
            if (n === 0) this.gminbin = this.gmaxbin = bin_content;

            if (bin_content < this.gminbin) this.gminbin = bin_content; else
               if (bin_content > this.gmaxbin) this.gmaxbin = bin_content;

            if (bin_content > 0)
               if ((this.gminposbin === null) || (this.gminposbin > bin_content)) this.gminposbin = bin_content;
         }
      } else {
         // global min/max, used at the moment in 3D drawing
         this.gminbin = this.gmaxbin = histo.getBinContent(1, 1);
         this.gminposbin = null;
         for (i = 0; i < this.nbinsx; ++i) {
            for (j = 0; j < this.nbinsy; ++j) {
               let bin_content = histo.getBinContent(i+1, j+1);
               if (bin_content < this.gminbin)
                  this.gminbin = bin_content;
               else if (bin_content > this.gmaxbin)
                  this.gmaxbin = bin_content;
               if (bin_content > 0)
                  if ((this.gminposbin === null) || (this.gminposbin > bin_content))
                     this.gminposbin = bin_content;
            }
         }
      }

      // this value used for logz scale drawing
      if (this.gminposbin === null)
         this.gminposbin = this.gmaxbin*1e-4;

      if (this.options.Axis > 0) {
         // Paint histogram axis only
         this.draw_content = false;
      } else {
         this.draw_content = (this.gmaxbin > 0);
         if (!this.draw_content  && this.options.Zero && this.isTH2Poly()) {
            this.draw_content = true;
            this.options.Line = 1;
         }
      }
   }

   /** @summary Count TH2 histogram statistic
     * @desc Optionally one could provide condition function to select special range */
   countStat(cond) {
      let histo = this.getHisto(), xaxis = histo.fXaxis, yaxis = histo.fYaxis,
          stat_sum0 = 0, stat_sumx1 = 0, stat_sumy1 = 0,
          stat_sumx2 = 0, stat_sumy2 = 0,
          xside, yside, xx, yy, zz,
          fp = this.getFramePainter(),
          funcs = fp.getGrFuncs(this.options.second_x, this.options.second_y),
          res = { name: histo.fName, entries: 0, integral: 0, meanx: 0, meany: 0, rmsx: 0, rmsy: 0, matrix: [0,0,0,0,0,0,0,0,0], xmax: 0, ymax:0, wmax: null },
          has_counted_stat = !fp.isAxisZoomed('x') && !fp.isAxisZoomed('y') && (Math.abs(histo.fTsumw) > 1e-300) && !cond;

      if (this.isTH2Poly()) {

         let len = histo.fBins.arr.length, i, bin, n, gr, ngr, numgraphs, numpoints;

         for (i = 0; i < len; ++i) {
            bin = histo.fBins.arr[i];

            xside = 1; yside = 1;

            if (bin.fXmin > funcs.scale_xmax) xside = 2; else
            if (bin.fXmax < funcs.scale_xmin) xside = 0;
            if (bin.fYmin > funcs.scale_ymax) yside = 2; else
            if (bin.fYmax < funcs.scale_ymin) yside = 0;

            xx = yy = numpoints = 0;
            gr = bin.fPoly; numgraphs = 1;
            if (gr._typename === clTMultiGraph) { numgraphs = bin.fPoly.fGraphs.arr.length; gr = null; }

            for (ngr = 0; ngr < numgraphs; ++ngr) {
               if (!gr || (ngr > 0)) gr = bin.fPoly.fGraphs.arr[ngr];

               for (n = 0; n < gr.fNpoints; ++n) {
                  ++numpoints;
                  xx += gr.fX[n];
                  yy += gr.fY[n];
               }
            }

            if (numpoints > 1) {
               xx = xx / numpoints;
               yy = yy / numpoints;
            }

            zz = bin.fContent;

            res.entries += zz;

            res.matrix[yside * 3 + xside] += zz;

            if ((xside != 1) || (yside != 1) || (cond && !cond(xx,yy))) continue;

            if ((res.wmax === null) || (zz > res.wmax)) {
               res.wmax = zz;
               res.xmax = xx;
               res.ymax = yy;
            }

            if (!has_counted_stat) {
               stat_sum0 += zz;
               stat_sumx1 += xx * zz;
               stat_sumy1 += yy * zz;
               stat_sumx2 += xx * xx * zz;
               stat_sumy2 += yy * yy * zz;
            }
         }
      } else {
         let xleft = this.getSelectIndex('x', 'left'),
             xright = this.getSelectIndex('x', 'right'),
             yleft = this.getSelectIndex('y', 'left'),
             yright = this.getSelectIndex('y', 'right'),
             xi, yi;

         for (xi = 0; xi <= this.nbinsx + 1; ++xi) {
            xside = (xi <= xleft) ? 0 : (xi > xright ? 2 : 1);
            xx = xaxis.GetBinCoord(xi - 0.5);

            for (yi = 0; yi <= this.nbinsy + 1; ++yi) {
               yside = (yi <= yleft) ? 0 : (yi > yright ? 2 : 1);
               yy = yaxis.GetBinCoord(yi - 0.5);

               zz = histo.getBinContent(xi, yi);

               res.entries += zz;

               res.matrix[yside * 3 + xside] += zz;

               if ((xside != 1) || (yside != 1) || (cond && !cond(xx,yy))) continue;

               if ((res.wmax === null) || (zz > res.wmax)) {
                  res.wmax = zz;
                  res.xmax = xx;
                  res.ymax = yy;
               }

               if (!has_counted_stat) {
                  stat_sum0 += zz;
                  stat_sumx1 += xx * zz;
                  stat_sumy1 += yy * zz;
                  stat_sumx2 += xx**2 * zz;
                  stat_sumy2 += yy**2 * zz;
                  // stat_sumxy += xx * yy * zz;
               }
            }
         }
      }

      if (has_counted_stat) {
         stat_sum0 = histo.fTsumw;
         stat_sumx1 = histo.fTsumwx;
         stat_sumx2 = histo.fTsumwx2;
         stat_sumy1 = histo.fTsumwy;
         stat_sumy2 = histo.fTsumwy2;
         // stat_sumxy = histo.fTsumwxy;
      }

      if (Math.abs(stat_sum0) > 1e-300) {
         res.meanx = stat_sumx1 / stat_sum0;
         res.meany = stat_sumy1 / stat_sum0;
         res.rmsx = Math.sqrt(Math.abs(stat_sumx2 / stat_sum0 - res.meanx**2));
         res.rmsy = Math.sqrt(Math.abs(stat_sumy2 / stat_sum0 - res.meany**2));
      }

      if (res.wmax === null)
         res.wmax = 0;
      res.integral = stat_sum0;

      if (histo.fEntries > 1)
         res.entries = histo.fEntries;

      return res;
   }

   /** @summary Fill TH2 statistic in stat box */
   fillStatistic(stat, dostat, dofit) {

      // no need to refill statistic if histogram is dummy
      if (this.isIgnoreStatsFill()) return false;

      let data = this.countStat(),
          print_name = Math.floor(dostat % 10),
          print_entries = Math.floor(dostat / 10) % 10,
          print_mean = Math.floor(dostat / 100) % 10,
          print_rms = Math.floor(dostat / 1000) % 10,
          print_under = Math.floor(dostat / 10000) % 10,
          print_over = Math.floor(dostat / 100000) % 10,
          print_integral = Math.floor(dostat / 1000000) % 10,
          print_skew = Math.floor(dostat / 10000000) % 10,
          print_kurt = Math.floor(dostat / 100000000) % 10;

      stat.clearPave();

      if (print_name > 0)
         stat.addText(data.name);

      if (print_entries > 0)
         stat.addText('Entries = ' + stat.format(data.entries, 'entries'));

      if (print_mean > 0) {
         stat.addText('Mean x = ' + stat.format(data.meanx));
         stat.addText('Mean y = ' + stat.format(data.meany));
      }

      if (print_rms > 0) {
         stat.addText('Std Dev x = ' + stat.format(data.rmsx));
         stat.addText('Std Dev y = ' + stat.format(data.rmsy));
      }

      if (print_integral > 0)
         stat.addText('Integral = ' + stat.format(data.matrix[4], 'entries'));

      if (print_skew > 0) {
         stat.addText('Skewness x = <undef>');
         stat.addText('Skewness y = <undef>');
      }

      if (print_kurt > 0)
         stat.addText('Kurt = <undef>');

      if ((print_under > 0) || (print_over > 0)) {
         let get = i => data.matrix[i].toFixed(0);

         stat.addText(`${get(6)} | ${get(7)} | ${get(7)}`);
         stat.addText(`${get(3)} | ${get(4)} | ${get(5)}`);
         stat.addText(`${get(0)} | ${get(1)} | ${get(2)}`);
      }

      if (dofit) stat.fillFunctionStat(this.findFunction(clTF2), dofit);

      return true;
   }

   /** @summary Draw TH2 bins as colors */
   drawBinsColor() {
      const histo = this.getHisto(),
            handle = this.prepareDraw(),
            cntr = this.getContour(),
            palette = this.getHistPalette(),
            entries = [],
            show_empty = this._show_empty_bins,
            can_merge = (handle.ybar2 === 1) && (handle.ybar1 === 0);

      let dx, dy, x1, y2, binz, is_zero, colindx, last_entry = null,
          skip_zero = !this.options.Zero;

      const flush_last_entry = () => {
         last_entry.path += `h${dx}v${last_entry.y1-last_entry.y2}h${-dx}z`;
         last_entry = null;
      };

      // check in the beginning if zero can be skipped
      if (!skip_zero && !show_empty && (cntr.getPaletteIndex(palette, 0) === null)) skip_zero = true;

      // now start build
      for (let i = handle.i1; i < handle.i2; ++i) {

         dx = handle.grx[i+1] - handle.grx[i];
         x1 = Math.round(handle.grx[i] + dx*handle.xbar1);
         dx = Math.round(dx*(handle.xbar2 - handle.xbar1)) || 1;

         for (let j = handle.j2 - 1; j >= handle.j1; --j) {
            binz = histo.getBinContent(i + 1, j + 1);
            is_zero = (binz === 0);

            if (is_zero && skip_zero) {
               if (last_entry) flush_last_entry();
               continue;
            }

            colindx = cntr.getPaletteIndex(palette, binz);
            if (colindx === null) {
               if (is_zero && show_empty) {
                  colindx = 0;
                } else {
                   if (last_entry) flush_last_entry();
                   continue;
                }
            }

            dy = (handle.gry[j] - handle.gry[j+1]) || 1;
            if (can_merge) {
               y2 = handle.gry[j+1];
            } else {
               y2 = Math.round(handle.gry[j+1] + dy*handle.ybar2);
               dy = Math.round(dy*(handle.ybar2 - handle.ybar1)) || 1;
            }

            let cmd1 = `M${x1},${y2}`,
                entry = entries[colindx];
            if (!entry) {
               entry = entries[colindx] = { path: cmd1 };
            } else if (can_merge && (entry === last_entry)) {
               entry.y1 = y2 + dy;
               continue;
            } else {
               let ddx = x1 - entry.x1, ddy = y2 - entry.y2;
               if (ddx || ddy) {
                  let cmd2 = `m${ddx},${ddy}`;
                  entry.path += (cmd2.length < cmd1.length) ? cmd2 : cmd1;
               }

            }
            if (last_entry) flush_last_entry();

            entry.x1 = x1;
            entry.y2 = y2;

            if (can_merge) {
               entry.y1 = y2 + dy;
               last_entry = entry;
            } else {
               entry.path += `h${dx}v${dy}h${-dx}z`;
            }
         }
         if (last_entry) flush_last_entry();
      }

      entries.forEach((entry,colindx) => {
        if (entry)
           this.draw_g
               .append('svg:path')
               .attr('fill', palette.getColor(colindx))
               .attr('d', entry.path);
      });

      return handle;
   }

   /** @summary Build histogram contour lines */
   buildContour(handle, levels, palette, contour_func) {

      const histo = this.getObject(),
            kMAXCONTOUR = 2004,
            kMAXCOUNT = 2000,
            // arguments used in the PaintContourLine
            xarr = new Float32Array(2*kMAXCONTOUR),
            yarr = new Float32Array(2*kMAXCONTOUR),
            itarr = new Int32Array(2*kMAXCONTOUR),
            nlevels = levels.length;
      let lj = 0, ipoly, poly, polys = [], np, npmax = 0,
          x = [0.,0.,0.,0.], y = [0.,0.,0.,0.], zc = [0.,0.,0.,0.], ir = [0,0,0,0],
          i, j, k, n, m, ljfill, count,
          xsave, ysave, itars, ix, jx;

      const BinarySearch = zc => {
         for (let kk = 0; kk < nlevels; ++kk)
            if (zc < levels[kk])
               return kk-1;
         return nlevels-1;
      }, PaintContourLine = (elev1, icont1, x1, y1,  elev2, icont2, x2, y2) => {
         /* Double_t *xarr, Double_t *yarr, Int_t *itarr, Double_t *levels */
         let vert = (x1 === x2),
             tlen = vert ? (y2 - y1) : (x2 - x1),
             n = icont1 +1,
             tdif = elev2 - elev1,
             ii = lj-1,
             maxii = kMAXCONTOUR/2 -3 + lj,
             icount = 0,
             xlen, pdif, diff, elev;

         while (n <= icont2 && ii <= maxii) {
//          elev = fH->GetContourLevel(n);
            elev = levels[n];
            diff = elev - elev1;
            pdif = diff/tdif;
            xlen = tlen*pdif;
            if (vert) {
               xarr[ii] = x1;
               yarr[ii] = y1 + xlen;
            } else {
               xarr[ii] = x1 + xlen;
               yarr[ii] = y1;
            }
            itarr[ii] = n;
            icount++;
            ii += 2;
            n++;
         }
         return icount;
      };

      let arrx = handle.original ? handle.origx : handle.grx,
          arry = handle.original ? handle.origy : handle.gry;

      for (j = handle.j1; j < handle.j2-1; ++j) {

         y[1] = y[0] = (arry[j] + arry[j+1])/2;
         y[3] = y[2] = (arry[j+1] + arry[j+2])/2;

         for (i = handle.i1; i < handle.i2-1; ++i) {

            zc[0] = histo.getBinContent(i+1, j+1);
            zc[1] = histo.getBinContent(i+2, j+1);
            zc[2] = histo.getBinContent(i+2, j+2);
            zc[3] = histo.getBinContent(i+1, j+2);

            for (k=0;k<4;k++)
               ir[k] = BinarySearch(zc[k]);

            if ((ir[0] !== ir[1]) || (ir[1] !== ir[2]) || (ir[2] !== ir[3]) || (ir[3] !== ir[0])) {
               x[3] = x[0] = (arrx[i] + arrx[i+1])/2;
               x[2] = x[1] = (arrx[i+1] + arrx[i+2])/2;

               if (zc[0] <= zc[1]) n = 0; else n = 1;
               if (zc[2] <= zc[3]) m = 2; else m = 3;
               if (zc[n] > zc[m]) n = m;
               n++;
               lj=1;
               for (ix=1;ix<=4;ix++) {
                  m = n%4 + 1;
                  ljfill = PaintContourLine(zc[n-1],ir[n-1],x[n-1],y[n-1], zc[m-1],ir[m-1],x[m-1],y[m-1]);
                  lj += 2*ljfill;
                  n = m;
               }

               if (zc[0] <= zc[1]) n = 0; else n = 1;
               if (zc[2] <= zc[3]) m = 2; else m = 3;
               if (zc[n] > zc[m]) n = m;
               n++;
               lj=2;
               for (ix=1;ix<=4;ix++) {
                  if (n == 1) m = 4;
                  else        m = n-1;
                  ljfill = PaintContourLine(zc[n-1],ir[n-1],x[n-1],y[n-1], zc[m-1],ir[m-1],x[m-1],y[m-1]);
                  lj += 2*ljfill;
                  n = m;
               }
               //     Re-order endpoints

               count = 0;
               for (ix = 1; ix <= lj - 5; ix += 2) {
                  //count = 0;
                  while (itarr[ix-1] != itarr[ix]) {
                     xsave = xarr[ix];
                     ysave = yarr[ix];
                     itars = itarr[ix];
                     for (jx=ix; jx<=lj-5; jx +=2) {
                        xarr[jx]  = xarr[jx+2];
                        yarr[jx]  = yarr[jx+2];
                        itarr[jx] = itarr[jx+2];
                     }
                     xarr[lj-3]  = xsave;
                     yarr[lj-3]  = ysave;
                     itarr[lj-3] = itars;
                     if (count > kMAXCOUNT) break;
                     count++;
                  }
               }

               if (count > kMAXCOUNT) continue;

               for (ix = 1; ix <= lj - 2; ix += 2) {

                  ipoly = itarr[ix-1];

                  if ((ipoly >= 0) && (ipoly < levels.length)) {
                     poly = polys[ipoly];
                     if (!poly)
                        poly = polys[ipoly] = createTPolyLine(kMAXCONTOUR*4, true);

                     np = poly.fLastPoint;
                     if (np < poly.fN-2) {
                        poly.fX[np+1] = Math.round(xarr[ix-1]); poly.fY[np+1] = Math.round(yarr[ix-1]);
                        poly.fX[np+2] = Math.round(xarr[ix]); poly.fY[np+2] = Math.round(yarr[ix]);
                        poly.fLastPoint = np+2;
                        npmax = Math.max(npmax, poly.fLastPoint+1);
                     }
                  }
               }
            } // end of if (ir[0]
         } // end of j
      } // end of i

      let polysort = new Int32Array(levels.length), first = 0;
      //find first positive contour
      for (ipoly = 0; ipoly < levels.length; ipoly++) {
         if (levels[ipoly] >= 0) { first = ipoly; break; }
      }
      //store negative contours from 0 to minimum, then all positive contours
      k = 0;
      for (ipoly = first-1; ipoly >= 0; ipoly--) { polysort[k] = ipoly; k++; }
      for (ipoly = first; ipoly < levels.length; ipoly++) { polysort[k] = ipoly; k++; }

      let xp = new Float32Array(2*npmax),
          yp = new Float32Array(2*npmax);

      for (k = 0; k < levels.length; ++k) {

         ipoly = polysort[k];
         poly = polys[ipoly];
         if (!poly) continue;

         let colindx = palette.calcColorIndex(ipoly, levels.length),
             xx = poly.fX, yy = poly.fY, np = poly.fLastPoint+1,
             istart = 0, iminus, iplus, xmin = 0, ymin = 0, nadd;

         while (true) {

            iminus = npmax;
            iplus  = iminus+1;
            xp[iminus]= xx[istart];   yp[iminus] = yy[istart];
            xp[iplus] = xx[istart+1]; yp[iplus]  = yy[istart+1];
            xx[istart] = xx[istart+1] = xmin;
            yy[istart] = yy[istart+1] = ymin;
            while (true) {
               nadd = 0;
               for (i=2;i<np;i+=2) {
                  if ((iplus < 2*npmax-1) && (xx[i] === xp[iplus]) && (yy[i] === yp[iplus])) {
                     iplus++;
                     xp[iplus] = xx[i+1]; yp[iplus] = yy[i+1];
                     xx[i] = xx[i+1] = xmin;
                     yy[i] = yy[i+1] = ymin;
                     nadd++;
                  }
                  if ((iminus > 0) && (xx[i+1] === xp[iminus]) && (yy[i+1] === yp[iminus])) {
                     iminus--;
                     xp[iminus] = xx[i]; yp[iminus] = yy[i];
                     xx[i] = xx[i+1] = xmin;
                     yy[i] = yy[i+1] = ymin;
                     nadd++;
                  }
               }
               if (nadd == 0) break;
            }

            if ((iminus+1 < iplus) && (iminus >= 0))
               contour_func(colindx, xp, yp, iminus, iplus, ipoly);

            istart = 0;
            for (i = 2; i < np; i += 2) {
               if (xx[i] !== xmin && yy[i] !== ymin) {
                  istart = i;
                  break;
               }
            }

            if (istart === 0) break;
         }
      }
   }

   /** @summary Draw histogram bins as contour */
   drawBinsContour() {
      let handle = this.prepareDraw({ rounding: false, extra: 100, original: this.options.Proj != 0 }),
          main = this.getFramePainter(),
          frame_w = main.getFrameWidth(),
          frame_h = main.getFrameHeight(),
          funcs = main.getGrFuncs(this.options.second_x, this.options.second_y),
          levels = this.getContourLevels(),
          palette = this.getHistPalette(),
          func = main.getProjectionFunc();

      const buildPath = (xp,yp,iminus,iplus,do_close) => {
         let cmd = '', lastx, lasty, x0, y0, isany = false, matched, x, y;
         for (let i = iminus; i <= iplus; ++i) {
            if (func) {
               let pnt = func(xp[i], yp[i]);
               x = Math.round(funcs.grx(pnt.x));
               y = Math.round(funcs.gry(pnt.y));
            } else {
               x = Math.round(xp[i]);
               y = Math.round(yp[i]);
            }
            if (!cmd) {
               cmd = `M${x},${y}`; x0 = x; y0 = y;
            } else if ((i == iplus) && (iminus !== iplus) && (x == x0) && (y == y0)) {
               if (!isany) return ''; // all same points
               cmd += 'z'; do_close = false; matched = true;
            } else {
               let dx = x - lastx, dy = y - lasty;
               if (dx) {
                  isany = true;
                  cmd += dy ? `l${dx},${dy}` : `h${dx}`;
               } else if (dy) {
                  isany = true;
                  cmd += `v${dy}`;
               }
            }

            lastx = x; lasty = y;
         }

         if (do_close && !matched && !func)
            return '<failed>';
         if (do_close) cmd += 'z';
         return cmd;

      }, get_segm_intersection = (segm1, segm2) => {

          let s02_x, s02_y, s10_x, s10_y, s32_x, s32_y, s_numer, t_numer, denom, t;
          s10_x = segm1.x2 - segm1.x1;
          s10_y = segm1.y2 - segm1.y1;
          s32_x = segm2.x2 - segm2.x1;
          s32_y = segm2.y2 - segm2.y1;

          denom = s10_x * s32_y - s32_x * s10_y;
          if (denom == 0)
              return 0; // Collinear
          let denomPositive = denom > 0;

          s02_x = segm1.x1 - segm2.x1;
          s02_y = segm1.y1 - segm2.y1;
          s_numer = s10_x * s02_y - s10_y * s02_x;
          if ((s_numer < 0) == denomPositive)
              return null; // No collision

          t_numer = s32_x * s02_y - s32_y * s02_x;
          if ((t_numer < 0) == denomPositive)
              return null; // No collision

          if (((s_numer > denom) == denomPositive) || ((t_numer > denom) == denomPositive))
              return null; // No collision
          // Collision detected
          t = t_numer / denom;
          return { x: Math.round(segm1.x1 + (t * s10_x)), y: Math.round(segm1.y1 + (t * s10_y)) };

      }, buildPathOutside = (xp,yp,iminus,iplus,side) => {

         // try to build path which fills area to outside borders

         const points = [{x: 0, y: 0}, {x: frame_w, y: 0}, {x: frame_w, y: frame_h}, {x: 0, y: frame_h}];

         const get_intersect = (i, di) => {
            let segm = { x1: xp[i], y1: yp[i], x2: 2*xp[i] - xp[i+di], y2: 2*yp[i] - yp[i+di] };
            for (let i = 0; i < 4; ++i) {
               let res = get_segm_intersection(segm, { x1: points[i].x, y1: points[i].y, x2: points[(i+1)%4].x, y2: points[(i+1)%4].y });
               if (res) {
                  res.indx = i + 0.5;
                  return res;
               }
            }
            return null;
         };

         let pnt1, pnt2;
         iminus--;
         while ((iminus < iplus - 1) && !pnt1)
            pnt1 = get_intersect(++iminus, 1);
         iplus++;
         while ((iminus < iplus - 1) && pnt1 && !pnt2)
            pnt2 = get_intersect(--iplus, -1);
         if (!pnt1 || !pnt2) return '';

         // TODO: now side is always same direction, could be that side should be checked more precise

         let dd = buildPath(xp,yp,iminus,iplus),
             indx = pnt2.indx, step = side*0.5;

         dd += `L${pnt2.x},${pnt2.y}`;

         while (Math.abs(indx - pnt1.indx) > 0.1) {
            indx = Math.round(indx + step) % 4;
            dd += `L${points[indx].x},${points[indx].y}`;
            indx += step;
         }

         return dd + `L${pnt1.x},${pnt1.y}z`;
      };

      if (this.options.Contour === 14) {
         let dd = `M0,0h${frame_w}v${frame_h}h${-frame_w}z`;
         if (this.options.Proj) {
            let sz = handle.j2 - handle.j1, xd = new Float32Array(sz*2), yd = new Float32Array(sz*2);
            for (let i = 0; i < sz; ++i) {
               xd[i] = handle.origx[handle.i1];
               yd[i] = (handle.origy[handle.j1]*(i+0.5) + handle.origy[handle.j2]*(sz-0.5-i))/sz;
               xd[i+sz] = handle.origx[handle.i2];
               yd[i+sz] = (handle.origy[handle.j2]*(i+0.5) + handle.origy[handle.j1]*(sz-0.5-i))/sz;
            }
            dd = buildPath(xd,yd,0,2*sz-1, true);
         }

         this.draw_g
             .append('svg:path')
             .attr('d', dd)
             .style('fill', palette.calcColor(0, levels.length));
      }

      this.buildContour(handle, levels, palette, (colindx,xp,yp,iminus,iplus,ipoly) => {
         let icol = palette.getColor(colindx),
             fillcolor = icol, lineatt;

         switch (this.options.Contour) {
            case 1: break;
            case 11: fillcolor = 'none'; lineatt = new TAttLineHandler({ color: icol }); break;
            case 12: fillcolor = 'none'; lineatt = new TAttLineHandler({ color: 1, style: (ipoly%5 + 1), width: 1 }); break;
            case 13: fillcolor = 'none'; lineatt = this.lineatt; break;
         }

         let dd = buildPath(xp, yp, iminus, iplus, fillcolor != 'none');
         if (dd == '<failed>')
            dd = buildPathOutside(xp, yp, iminus, iplus, 1);
         if (!dd) return;

         let elem = this.draw_g
                        .append('svg:path')
                        .attr('class', 'th2_contour')
                        .attr('d', dd)
                        .style('fill', fillcolor);

         if (lineatt)
            elem.call(lineatt.func);
      });

      handle.hide_only_zeros = true; // text drawing suppress only zeros

      return handle;
   }

   /** @summary Create poly bin */
   createPolyBin(funcs, bin, text_pos) {
      let cmd = '', grcmd = '', acc_x = 0, acc_y = 0, ngr, ngraphs = 1, gr = null;

      if (bin.fPoly._typename == clTMultiGraph)
         ngraphs = bin.fPoly.fGraphs.arr.length;
      else
         gr = bin.fPoly;

      if (text_pos)
         bin._sumx = bin._sumy = bin._suml = 0;

      const addPoint = (x1,y1,x2,y2) => {
         const len = Math.sqrt((x1-x2)**2 + (y1-y2)**2);
         bin._sumx += (x1+x2)*len/2;
         bin._sumy += (y1+y2)*len/2;
         bin._suml += len;
      };

      const flush = () => {
         if (acc_x) { grcmd += 'h' + acc_x; acc_x = 0; }
         if (acc_y) { grcmd += 'v' + acc_y; acc_y = 0; }
      };

      for (ngr = 0; ngr < ngraphs; ++ngr) {
         if (!gr || (ngr > 0)) gr = bin.fPoly.fGraphs.arr[ngr];

         const x = gr.fX, y = gr.fY;
         let n, nextx, nexty, npnts = gr.fNpoints, dx, dy,
             grx = Math.round(funcs.grx(x[0])),
             gry = Math.round(funcs.gry(y[0]));

         if ((npnts > 2) && (x[0] === x[npnts-1]) && (y[0] === y[npnts-1])) npnts--;

         let poscmd = `M${grx},${gry}`;

         grcmd = '';

         for (n = 1; n < npnts; ++n) {
            nextx = Math.round(funcs.grx(x[n]));
            nexty = Math.round(funcs.gry(y[n]));
            if (text_pos) addPoint(grx,gry, nextx, nexty);
            dx = nextx - grx;
            dy = nexty - gry;
            if (dx || dy) {
               if (dx === 0) {
                  if ((acc_y === 0) || ((dy < 0) !== (acc_y < 0))) flush();
                  acc_y += dy;
               } else if (dy === 0) {
                  if ((acc_x === 0) || ((dx < 0) !== (acc_x < 0))) flush();
                  acc_x += dx;
               } else {
                  flush();
                  grcmd += 'l' + dx + ',' + dy;
               }

               grx = nextx; gry = nexty;
            }
         }

         if (text_pos) addPoint(grx, gry, Math.round(funcs.grx(x[0])), Math.round(funcs.gry(y[0])));
         flush();

         if (grcmd)
            cmd += poscmd + grcmd + 'z';
      }

      if (text_pos) {
         if (bin._suml > 0) {
            bin._midx = Math.round(bin._sumx / bin._suml);
            bin._midy = Math.round(bin._sumy / bin._suml);
         } else {
            bin._midx = Math.round(funcs.grx((bin.fXmin + bin.fXmax)/2));
            bin._midy = Math.round(funcs.gry((bin.fYmin + bin.fYmax)/2));
         }
      }

      return cmd;
   }

   /** @summary draw TH2Poly as color */
   async drawPolyBinsColor() {
      let histo = this.getObject(),
          pmain = this.getFramePainter(),
          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),
          h = pmain.getFrameHeight(),
          colPaths = [], textbins = [],
          colindx, cmd, bin, item,
          i, len = histo.fBins.arr.length;

      // force recalculations of contours
      // use global coordinates
      this.maxbin = this.gmaxbin;
      this.minbin = this.gminbin;
      this.minposbin = this.gminposbin;

      let cntr = this.getContour(true), palette = this.getHistPalette();

      for (i = 0; i < len; ++i) {
         bin = histo.fBins.arr[i];
         colindx = cntr.getPaletteIndex(palette, bin.fContent);
         if (colindx === null) continue;
         if (bin.fContent === 0) {
            if (!this.options.Zero || !this.options.Line) continue;
            colindx = 0; // make dummy fill color to draw only line
         }

         // check if bin outside visible range
         if ((bin.fXmin > funcs.scale_xmax) || (bin.fXmax < funcs.scale_xmin) ||
             (bin.fYmin > funcs.scale_ymax) || (bin.fYmax < funcs.scale_ymin)) continue;

         cmd = this.createPolyBin(funcs, bin, this.options.Text && bin.fContent);

         if (colPaths[colindx] === undefined)
            colPaths[colindx] = cmd;
         else
            colPaths[colindx] += cmd;

         if (this.options.Text && bin.fContent) textbins.push(bin);
      }

      for (colindx = 0; colindx < colPaths.length; ++colindx)
         if (colPaths[colindx]) {
            item = this.draw_g
                     .append('svg:path')
                     .style('fill', colindx ? this.fPalette.getColor(colindx) : 'none')
                     .attr('d', colPaths[colindx]);
            if (this.options.Line)
               item.call(this.lineatt.func);
         }

      let pr = Promise.resolve(true);

      if (textbins.length > 0) {
         let color = this.getColor(histo.fMarkerColor),
             rotate = -1*this.options.TextAngle,
             text_g = this.draw_g.append('svg:g').attr('class', 'th2poly_text'),
             text_size = ((histo.fMarkerSize !== 1) && rotate) ? Math.round(0.02*h*histo.fMarkerSize) : 12,
             text;

         this.startTextDrawing(42, text_size, text_g, text_size);

         for (i = 0; i < textbins.length; ++i) {
            bin = textbins[i];

            if (!this.options.TextKind) {
               text = (Math.round(bin.fContent) === bin.fContent) ? bin.fContent.toString() :
                          floatToString(bin.fContent, gStyle.fPaintTextFormat);
            } else {
               text = bin.fPoly?.fName;
               if (!text || (text == 'Graph'))
                  text = bin.fNumber.toString();
            }

            this.drawText({ align: 22, x: bin._midx, y: bin._midy, rotate, text, color, latex: 0, draw_g: text_g });
         }

         pr = this.finishTextDrawing(text_g, true);
      }

      return pr.then(() => { return { poly: true }; });
   }

   /** @summary Draw TH2 bins as text */
   async drawBinsText(handle) {
      let histo = this.getObject(),
          x, y, width, height,
          color = this.getColor(histo.fMarkerColor),
          rotate = -1*this.options.TextAngle,
          draw_g = this.draw_g.append('svg:g').attr('class', 'th2_text'),
          text_size = 20, text_offset = 0,
          profile2d = this.matchObjectType(clTProfile2D) && isFunc(histo.getBinEntries),
          show_err = (this.options.TextKind == 'E'),
          latex = (show_err && !this.options.TextLine) ? 1 : 0;

      if (!handle) handle = this.prepareDraw({ rounding: false });

      if ((histo.fMarkerSize !== 1) && rotate)
         text_size = Math.round(0.02*histo.fMarkerSize*this.getFramePainter().getFrameHeight());

      if (histo.fBarOffset !== 0) text_offset = histo.fBarOffset*1e-3;

      this.startTextDrawing(42, text_size, draw_g, text_size);

      for (let i = handle.i1; i < handle.i2; ++i) {
         let binw = handle.grx[i+1] - handle.grx[i];
         for (let j = handle.j1; j < handle.j2; ++j) {
            let binz = histo.getBinContent(i+1, j+1);
            if ((binz === 0) && !this._show_empty_bins) continue;
            let binh = handle.gry[j] - handle.gry[j+1];

            if (profile2d)
               binz = histo.getBinEntries(i+1, j+1);

            let text = (binz === Math.round(binz)) ? binz.toString() :
                         floatToString(binz, gStyle.fPaintTextFormat);

            if (show_err) {
               let errz = histo.getBinError(histo.getBin(i+1,j+1)),
                   lble = (errz === Math.round(errz)) ? errz.toString() :
                            floatToString(errz, gStyle.fPaintTextFormat);
               if (this.options.TextLine)
                  text += '\xB1' + lble;
               else
                  text = `#splitline{${text}}{#pm${lble}}`;
            }

            if (rotate /*|| (histo.fMarkerSize !== 1)*/) {
               x = Math.round(handle.grx[i] + binw*0.5);
               y = Math.round(handle.gry[j+1] + binh*(0.5 + text_offset));
               width = height = 0;
            } else {
               x = Math.round(handle.grx[i] + binw*0.1);
               y = Math.round(handle.gry[j+1] + binh*(0.1 + text_offset));
               width = Math.round(binw*0.8);
               height = Math.round(binh*0.8);
            }

            this.drawText({ align: 22, x, y, width, height, rotate, text, color, latex, draw_g });
         }
      }

      handle.hide_only_zeros = true; // text drawing suppress only zeros

      return this.finishTextDrawing(draw_g, true).then(() => handle);
   }

   /** @summary Draw TH2 bins as arrows */
   drawBinsArrow() {
      let histo = this.getObject(), cmd = '',
          i,j, dn = 1e-30, dx, dy, xc,yc,
          dxn,dyn,x1,x2,y1,y2, anr,si,co,
          handle = this.prepareDraw({ rounding: false }),
          scale_x = (handle.grx[handle.i2] - handle.grx[handle.i1])/(handle.i2 - handle.i1 + 1)/2,
          scale_y = (handle.gry[handle.j2] - handle.gry[handle.j1])/(handle.j2 - handle.j1 + 1)/2;

      const makeLine = (dx, dy) => {
         if (dx)
            return dy ? `l${dx},${dy}` : `h${dx}`;
         return dy ? `v${dy}` : '';
      };

      for (let loop = 0; loop < 2; ++loop)
         for (i = handle.i1; i < handle.i2; ++i)
            for (j = handle.j1; j < handle.j2; ++j) {

               if (i === handle.i1)
                  dx = histo.getBinContent(i+2, j+1) - histo.getBinContent(i+1, j+1);
               else if (i === handle.i2-1)
                  dx = histo.getBinContent(i+1, j+1) - histo.getBinContent(i, j+1);
               else
                  dx = 0.5*(histo.getBinContent(i+2, j+1) - histo.getBinContent(i, j+1));

               if (j === handle.j1)
                  dy = histo.getBinContent(i+1, j+2) - histo.getBinContent(i+1, j+1);
               else if (j === handle.j2-1)
                  dy = histo.getBinContent(i+1, j+1) - histo.getBinContent(i+1, j);
               else
                  dy = 0.5*(histo.getBinContent(i+1, j+2) - histo.getBinContent(i+1, j));

               if (loop === 0) {
                  dn = Math.max(dn, Math.abs(dx), Math.abs(dy));
               } else {
                  xc = (handle.grx[i] + handle.grx[i+1])/2;
                  yc = (handle.gry[j] + handle.gry[j+1])/2;
                  dxn = scale_x*dx/dn;
                  dyn = scale_y*dy/dn;
                  x1  = xc - dxn;
                  x2  = xc + dxn;
                  y1  = yc - dyn;
                  y2  = yc + dyn;
                  dx = Math.round(x2-x1);
                  dy = Math.round(y2-y1);

                  if (dx || dy) {
                     cmd += `M${Math.round(x1)},${Math.round(y1)}${makeLine(dx,dy)}`;

                     if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                        anr = Math.sqrt(9/(dx**2 + dy**2));
                        si  = Math.round(anr*(dx + dy));
                        co  = Math.round(anr*(dx - dy));
                        if (si || co)
                           cmd += `m${-si},${co}${makeLine(si,-co)}${makeLine(-co,-si)}`;
                     }
                  }
               }
            }

      this.draw_g
         .append('svg:path')
         .attr('d', cmd)
         .style('fill', 'none')
         .call(this.lineatt.func);

      return handle;
   }

   /** @summary Draw TH2 bins as boxes */
   drawBinsBox() {

      let histo = this.getObject(),
          handle = this.prepareDraw({ rounding: false }),
          main = this.getMainPainter();

      if (main === this) {
         if (main.maxbin === main.minbin) {
            main.maxbin = main.gmaxbin;
            main.minbin = main.gminbin;
            main.minposbin = main.gminposbin;
         }
         if (main.maxbin === main.minbin)
            main.minbin = Math.min(0, main.maxbin-1);
      }

      let absmax = Math.max(Math.abs(main.maxbin), Math.abs(main.minbin)),
          absmin = Math.max(0, main.minbin),
          i, j, binz, absz, res = '', cross = '', btn1 = '', btn2 = '',
          zdiff, dgrx, dgry, xx, yy, ww, hh, xyfactor,
          uselogz = false, logmin = 0,
          pad = this.getPadPainter().getRootPad(true);

      if (pad && pad.fLogz && (absmax > 0)) {
         uselogz = true;
         let logmax = Math.log(absmax);
         if (absmin > 0)
            logmin = Math.log(absmin);
         else if ((main.minposbin>=1) && (main.minposbin<100))
            logmin = Math.log(0.7);
         else
            logmin = (main.minposbin > 0) ? Math.log(0.7*main.minposbin) : logmax - 10;
         if (logmin >= logmax) logmin = logmax - 10;
         xyfactor = 1. / (logmax - logmin);
      } else {
         xyfactor = 1. / (absmax - absmin);
      }

      // now start build
      for (i = handle.i1; i < handle.i2; ++i) {
         for (j = handle.j1; j < handle.j2; ++j) {
            binz = histo.getBinContent(i + 1, j + 1);
            absz = Math.abs(binz);
            if ((absz === 0) || (absz < absmin)) continue;

            zdiff = uselogz ? ((absz > 0) ? Math.log(absz) - logmin : 0) : (absz - absmin);
            // area of the box should be proportional to absolute bin content
            zdiff = 0.5 * ((zdiff < 0) ? 1 : (1 - Math.sqrt(zdiff * xyfactor)));
            // avoid oversized bins
            if (zdiff < 0) zdiff = 0;

            ww = handle.grx[i+1] - handle.grx[i];
            hh = handle.gry[j] - handle.gry[j+1];

            dgrx = zdiff * ww;
            dgry = zdiff * hh;

            xx = Math.round(handle.grx[i] + dgrx);
            yy = Math.round(handle.gry[j+1] + dgry);

            ww = Math.max(Math.round(ww - 2*dgrx), 1);
            hh = Math.max(Math.round(hh - 2*dgry), 1);

            res += `M${xx},${yy}v${hh}h${ww}v${-hh}z`;

            if ((binz < 0) && (this.options.BoxStyle === 10))
               cross += `M${xx},${yy}l${ww},${hh}m0,${-hh}l${-ww},${hh}`;

            if ((this.options.BoxStyle === 11) && (ww>5) && (hh>5)) {
               const pww = Math.round(ww*0.1),
                     phh = Math.round(hh*0.1),
                     side1 = `M${xx},${yy}h${ww}l${-pww},${phh}h${2*pww-ww}v${hh-2*phh}l${-pww},${phh}z`,
                     side2 = `M${xx+ww},${yy+hh}v${-hh}l${-pww},${phh}v${hh-2*phh}h${2*pww-ww}l${-pww},${phh}z`;
               if (binz < 0) { btn2 += side1; btn1 += side2; }
                        else { btn1 += side1; btn2 += side2; }
            }
         }
      }

      if (res) {
         let elem = this.draw_g.append('svg:path')
                               .attr('d', res)
                               .call(this.fillatt.func);
         if ((this.options.BoxStyle !== 11) && this.fillatt.empty())
            elem.call(this.lineatt.func);
      }

      if (btn1 && this.fillatt.hasColor())
         this.draw_g.append('svg:path')
                    .attr('d', btn1)
                    .call(this.fillatt.func)
                    .style('fill', rgb(this.fillatt.color).brighter(0.5).formatHex());

      if (btn2)
         this.draw_g.append('svg:path')
                    .attr('d', btn2)
                    .call(this.fillatt.func)
                    .style('fill', !this.fillatt.hasColor() ? 'red' : rgb(this.fillatt.color).darker(0.5).formatHex());

      if (cross) {
         let elem = this.draw_g.append('svg:path')
                               .attr('d', cross)
                               .style('fill', 'none');
         if (!this.lineatt.empty())
            elem.call(this.lineatt.func);
         else
            elem.style('stroke', 'black');
      }

      return handle;
   }

   /** @summary Draw histogram bins as candle plot */
   drawBinsCandle() {

      const kNoOption           = 0,
            kBox                = 1,
            kMedianLine         = 10,
            kMedianNotched      = 20,
            kMedianCircle       = 30,
            kMeanLine           = 100,
            kMeanCircle         = 300,
            kWhiskerAll         = 1000,
            kWhisker15          = 2000,
            kAnchor             = 10000,
            kPointsOutliers     = 100000,
            kPointsAll          = 200000,
            kPointsAllScat      = 300000,
            kHistoLeft          = 1000000,
            kHistoRight         = 2000000,
            kHistoViolin        = 3000000,
            kHistoZeroIndicator = 10000000,
            kHorizontal         = 100000000,
            fallbackCandle      = kBox + kMedianLine + kMeanCircle + kWhiskerAll + kAnchor,
            fallbackViolin      = kMeanCircle + kWhiskerAll + kHistoViolin + kHistoZeroIndicator;

      let fOption = kNoOption;

      const isOption = opt => {
         let mult = 1;
         while (opt >= mult) mult *= 10;
         mult /= 10;
         return Math.floor(fOption/mult) % 10 === Math.floor(opt/mult);

      }, parseOption = (opt, is_candle) => {

         let direction = '', preset = '',
             res = kNoOption, c0 = opt[0], c1 = opt[1];

         if (c0 >= 'A' && c0 <= 'Z') direction = c0;
         if (c0 >= '1' && c0 <= '9') preset = c0;
         if (c1 >= 'A' && c1 <= 'Z' && preset) direction = c1;
         if (c1 >= '1' && c1 <= '9' && direction) preset = c1;

         if (is_candle)
            switch(preset) {
               case '1': res += fallbackCandle; break;
               case '2': res += kBox + kMeanLine + kMedianLine + kWhisker15 + kAnchor + kPointsOutliers; break;
               case '3': res += kBox + kMeanCircle + kMedianLine + kWhisker15 + kAnchor + kPointsOutliers; break;
               case '4': res += kBox + kMeanCircle + kMedianNotched + kWhisker15 + kAnchor + kPointsOutliers; break;
               case '5': res += kBox + kMeanLine + kMedianLine + kWhisker15 + kAnchor + kPointsAll; break;
               case '6': res += kBox + kMeanCircle + kMedianLine + kWhisker15 + kAnchor + kPointsAllScat; break;
               default: res += fallbackCandle;
            }
         else
            switch(preset) {
               case '1': res += fallbackViolin; break;
               case '2': res += kMeanCircle + kWhisker15 + kHistoViolin + kHistoZeroIndicator + kPointsOutliers; break;
               default: res += fallbackViolin;
            }

         let l = opt.indexOf('('), r = opt.lastIndexOf(')');
         if ((l >= 0) && (r > l+1))
            res = parseInt(opt.slice(l+1, r));

         fOption = res;

         if ((direction == 'Y' || direction == 'H') && !isOption(kHorizontal))
            fOption += kHorizontal;

      }, extractQuantiles = (xx,proj,prob) => {

         let integral = 0, cnt = 0, sum1 = 0,
             res = { max: 0, first: -1, last: -1, entries: 0 };

         for (let j = 0; j < proj.length; ++j) {
            if (proj[j] > 0) {
               res.max = Math.max(res.max, proj[j]);
               if (res.first < 0) res.first = j;
               res.last = j;
            }
            integral += proj[j];
            sum1 += proj[j]*(xx[j]+xx[j+1])/2;
         }
         if (integral <= 0) return null;

         res.entries = integral;
         res.mean = sum1/integral;
         res.quantiles = new Array(prob.length);
         res.indx = new Array(prob.length);

         let sum = 0, nextv = 0;
         for (let j = 0; j < proj.length; ++j) {
            let v = nextv, x = xx[j];

            // special case - flat integral with const value
            if ((v === prob[cnt]) && (proj[j] === 0) && (v < 0.99)) {
               while ((proj[j] === 0) && (j < proj.length)) j++;
               x = (xx[j] + x) / 2; // this will be mid value
            }

            sum += proj[j];
            nextv = sum / integral;
            while ((prob[cnt] >= v) && (prob[cnt] < nextv)) {
               res.indx[cnt] = j;
               res.quantiles[cnt] = x + ((prob[cnt] - v) / (nextv - v)) * (xx[j + 1] - x);
               if (cnt++ == prob.length) return res;
               x = xx[j];
            }
         }

         while (cnt < prob.length) {
            res.indx[cnt] = proj.length-1;
            res.quantiles[cnt++] = xx[xx.length-1];
         }

         return res;
      };

      if (this.options.Candle)
         parseOption(this.options.Candle, true);
      else if (this.options.Violin)
         parseOption(this.options.Violin, false);

      let histo = this.getHisto(),
          handle = this.prepareDraw(),
          pmain = this.getFramePainter(), // used for axis values conversions
          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),
          bars = '', lines = '', dashed_lines = '',
          hists = '', hlines = '',
          markers = '', cmarkers = '', attrcmarkers = null,
          xx, proj, swapXY = isOption(kHorizontal),
          scaledViolin = true, scaledCandle = false,
          maxContent = 0, maxIntegral = 0;

      if (this.options.Scaled !== null)
         scaledViolin = scaledCandle = this.options.Scaled;
      else if (histo.fTitle.indexOf('unscaled') >= 0)
         scaledViolin = scaledCandle = false;
      else if (histo.fTitle.indexOf('scaled') >= 0)
         scaledViolin = scaledCandle = true;

      if (scaledViolin && (isOption(kHistoRight) || isOption(kHistoLeft) || isOption(kHistoViolin)))
         for (let i = 0; i < this.nbinsx; ++i)
            for (let j = 0; j < this.nbinsy; ++j)
               maxContent = Math.max(maxContent, histo.getBinContent(i + 1, j + 1));

      const make_path = (...a) => {
         if (a[1] === 'array') a = a[0];
         let l = a.length, i = 2, xx = a[0], yy = a[1],
             res = swapXY ? `M${yy},${xx}` : `M${xx},${yy}`;
         while (i < l) {
            switch(a[i]) {
               case 'Z': return res + 'z';
               case 'V': if (yy != a[i+1]) { res += (swapXY ? 'h' : 'v') + (a[i+1] - yy); yy = a[i+1]; } break;
               case 'H': if (xx != a[i+1]) { res += (swapXY ? 'v' : 'h') + (a[i+1] - xx); xx = a[i+1]; } break;
               default: res += swapXY ? `l${a[i+1]-yy},${a[i]-xx}` : `l${a[i]-xx},${a[i+1]-yy}`; xx = a[i]; yy = a[i+1];
            }
            i += 2;
         }
         return res;
      }, make_marker = (x,y) => {
         if (!markers) {
            this.createAttMarker({ attr: histo, style: isOption(kPointsAllScat) ? 0 : 5 });
            this.markeratt.resetPos();
         }
         markers += swapXY ? this.markeratt.create(y,x) : this.markeratt.create(x,y);
      }, make_cmarker = (x,y) => {
         if (!attrcmarkers) {
            attrcmarkers = new TAttMarkerHandler({attr: histo, style: 24});
            attrcmarkers.resetPos();
         }
         cmarkers += swapXY ? attrcmarkers.create(y,x) : attrcmarkers.create(x,y);
      };

      //if ((histo.fFillStyle == 0) && (histo.fFillColor > 0) && (!this.fillatt || this.fillatt.empty()))
      //     this.createAttFill({ color: this.getColor(histo.fFillColor), pattern: 1001 });

      if (histo.fMarkerColor === 1) histo.fMarkerColor = histo.fLineColor;

      handle.candle = []; // array of drawn points

      // Determining the quantiles
      const fBoxRange = 0.5, // for now constants, later can be made configurable
            prob = [ 1e-15 ,
                    0.5 - fBoxRange/2.,
                    0.5,
                    0.5 + fBoxRange/2.,
                    1-1e-15 ];

      const produceCandlePoint = (bin_indx, grx_left, grx_right, xindx1, xindx2) => {
         let res = extractQuantiles(xx, proj, prob);
         if (!res) return;

         let pnt = { bin: bin_indx, swapXY: swapXY, fBoxDown: res.quantiles[1], fMedian: res.quantiles[2], fBoxUp: res.quantiles[3] },
             fWhiskerDown = res.quantiles[0], fWhiskerUp = res.quantiles[4], iqr = pnt.fBoxUp - pnt.fBoxDown;

         if (isOption(kWhisker15)) { // Improved whisker definition, with 1.5*iqr
            let pos = pnt.fBoxDown-1.5*iqr, indx = res.indx[1];
            while ((xx[indx] > pos) && (indx > 0)) indx--;
            while (!proj[indx]) indx++;
            fWhiskerDown = xx[indx]; // use lower edge here
            pos = pnt.fBoxUp+1.5*iqr; indx = res.indx[3];
            while ((xx[indx] < pos) && (indx < proj.length)) indx++;
            while (!proj[indx]) indx--;
            fWhiskerUp = xx[indx+1]; // use upper index edge here
         }

         let fMean = res.mean,
             fMedianErr = 1.57*iqr/Math.sqrt(res.entries);

         //estimate quantiles... simple function... not so nice as GetQuantiles

         // exclude points with negative y when log scale is specified
         if (fWhiskerDown <= 0)
           if ((swapXY && funcs.logx) || (!swapXY && funcs.logy)) return;

         let w = (grx_right - grx_left), candleWidth, histoWidth,
             center = (grx_left + grx_right) / 2 + histo.fBarOffset/1000*w;
         if ((histo.fBarWidth > 0) && (histo.fBarWidth !== 1000)) {
            candleWidth = histoWidth = w * histo.fBarWidth / 1000;
         } else {
            candleWidth = w*0.66;
            histoWidth = w*0.8;
         }

         if (scaledViolin && (maxContent > 0))
            histoWidth *= res.max/maxContent;
         if (scaledCandle && (maxIntegral > 0))
            candleWidth *= res.entries/maxIntegral;

         pnt.x1 = Math.round(center - candleWidth/2);
         pnt.x2 = Math.round(center + candleWidth/2);
         center = Math.round(center);

         let x1d = Math.round(center - candleWidth/3),
             x2d = Math.round(center + candleWidth/3),
             ff = swapXY ? funcs.grx : funcs.gry;

         pnt.yy1 = Math.round(ff(fWhiskerUp));
         pnt.y1 = Math.round(ff(pnt.fBoxUp));
         pnt.y0 = Math.round(ff(pnt.fMedian));
         pnt.y2 = Math.round(ff(pnt.fBoxDown));
         pnt.yy2 = Math.round(ff(fWhiskerDown));

         let y0m = Math.round(ff(fMean)),
             y01 = Math.round(ff(pnt.fMedian + fMedianErr)),
             y02 = Math.round(ff(pnt.fMedian - fMedianErr));

         if (isOption(kHistoZeroIndicator))
            hlines += make_path(center, Math.round(ff(xx[xindx1])), 'V', Math.round(ff(xx[xindx2])));

         if (isOption(kMedianLine))
            lines += make_path(pnt.x1, pnt.y0, 'H', pnt.x2);
         else if (isOption(kMedianNotched))
            lines += make_path(x1d, pnt.y0, 'H', x2d);
         else if (isOption(kMedianCircle))
            make_cmarker(center, pnt.y0);

         if (isOption(kMeanCircle))
            make_cmarker(center, y0m);
         else if (isOption(kMeanLine))
            dashed_lines += make_path(pnt.x1, y0m, 'H', pnt.x2);

         if (isOption(kBox))
            if (isOption(kMedianNotched))
               bars += make_path(pnt.x1, pnt.y1, 'V', y01, x1d, pnt.y0, pnt.x1, y02, 'V', pnt.y2, 'H', pnt.x2, 'V', y02, x2d, pnt.y0, pnt.x2, y01, 'V', pnt.y1, 'Z');
            else
               bars += make_path(pnt.x1, pnt.y1, 'V', pnt.y2, 'H', pnt.x2, 'V', pnt.y1, 'Z');

        if (isOption(kAnchor))  // Draw the anchor line
            lines += make_path(pnt.x1, pnt.yy1, 'H', pnt.x2) + make_path(pnt.x1, pnt.yy2, 'H', pnt.x2);

         if (isOption(kWhiskerAll) && !isOption(kHistoZeroIndicator)) { // Whiskers are dashed
            dashed_lines += make_path(center, pnt.y1, 'V', pnt.yy1) + make_path(center, pnt.y2, 'V', pnt.yy2);
         } else if ((isOption(kWhiskerAll) && isOption(kHistoZeroIndicator)) || isOption(kWhisker15)) {
            lines += make_path(center, pnt.y1, 'V', pnt.yy1) + make_path(center, pnt.y2, 'V', pnt.yy2);
         }

         if (isOption(kPointsOutliers) || isOption(kPointsAll) || isOption(kPointsAllScat)) {

            // reset seed for each projection to have always same pixels
            let rnd = new TRandom(bin_indx*7521 + Math.round(res.integral)),
                show_all = !isOption(kPointsOutliers),
                show_scat = isOption(kPointsAllScat);
            for (let ii = 0; ii < proj.length; ++ii) {
               let bin_content = proj[ii], binx = (xx[ii] + xx[ii+1])/2,
                   marker_x = center, marker_y = 0;

               if (!bin_content) continue;
               if (!show_all && (binx >= fWhiskerDown) && (binx <= fWhiskerUp)) continue;

               for (let k = 0; k < bin_content; k++) {
                  if (show_scat)
                     marker_x = center + Math.round(((rnd.random() - 0.5) * candleWidth));

                  if ((bin_content == 1) && !show_scat)
                     marker_y = Math.round(ff(binx));
                  else
                     marker_y = Math.round(ff(xx[ii] + rnd.random()*(xx[ii+1]-xx[ii])));

                  make_marker(marker_x, marker_y);
               }
            }
         }

         if ((isOption(kHistoRight) || isOption(kHistoLeft) || isOption(kHistoViolin)) && (res.max > 0) && (res.first >= 0)) {
            let arr = [], scale = (swapXY ? -0.5 : 0.5) *histoWidth/res.max;

            xindx1 = Math.max(xindx1, res.first);
            xindx2 = Math.min(xindx2-1, res.last);

            if (isOption(kHistoRight) || isOption(kHistoViolin)) {
               let prev_x = center, prev_y = Math.round(ff(xx[xindx1]));
               arr.push(prev_x, prev_y);
               for (let ii = xindx1; ii <= xindx2; ii++) {
                  let curr_x = Math.round(center + scale*proj[ii]),
                      curr_y = Math.round(ff(xx[ii+1]));
                  if (curr_x != prev_x) {
                     if (ii != xindx1) arr.push('V', prev_y);
                     arr.push('H', curr_x);
                  }
                  prev_x = curr_x;
                  prev_y = curr_y;
               }
               arr.push('V', prev_y);
            }

            if (isOption(kHistoLeft) || isOption(kHistoViolin)) {
               let prev_x = center, prev_y = Math.round(ff(xx[xindx2+1]));
               if (arr.length == 0)
                  arr.push(prev_x, prev_y);
               for (let ii = xindx2; ii >= xindx1; ii--) {
                  let curr_x = Math.round(center - scale*proj[ii]),
                      curr_y = Math.round(ff(xx[ii]));
                  if (curr_x != prev_x) {
                     if (ii != xindx2) arr.push('V', prev_y);
                     arr.push('H', curr_x);
                  }
                  prev_x = curr_x;
                  prev_y = curr_y;
               }
               arr.push('V', prev_y);
            }

            arr.push('H', center); // complete histogram

            hists += make_path(arr, 'array');

            if (!this.fillatt.empty()) hists += 'Z';
         }

         handle.candle.push(pnt); // keep point for the tooltip

      };

      if (swapXY) {
         xx = new Array(this.nbinsx+1);
         proj = new Array(this.nbinsx);
         for (let i = 0; i < this.nbinsx+1; ++i)
            xx[i] = histo.fXaxis.GetBinLowEdge(i+1);

         if(scaledCandle)
            for (let j = 0; j < this.nbinsy; ++j) {
               let sum = 0;
               for (let i = 0; i < this.nbinsx; ++i)
                  sum += histo.getBinContent(i+1, j+1);
               maxIntegral = Math.max(maxIntegral, sum);
            }

         for (let j = handle.j1; j < handle.j2; ++j) {
            for (let i = 0; i < this.nbinsx; ++i)
               proj[i] = histo.getBinContent(i+1, j+1);

            produceCandlePoint(j, handle.gry[j+1], handle.gry[j], handle.i1, handle.i2);
         }

      } else {
         xx = new Array(this.nbinsy+1);
         proj = new Array(this.nbinsy);

         for (let j = 0; j < this.nbinsy+1; ++j)
            xx[j] = histo.fYaxis.GetBinLowEdge(j+1);

         if(scaledCandle)
            for (let i = 0; i < this.nbinsx; ++i) {
               let sum = 0;
               for (let j = 0; j < this.nbinsy; ++j)
                  sum += histo.getBinContent(i+1, j+1);
               maxIntegral = Math.max(maxIntegral, sum);
            }

         // loop over visible x-bins
         for (let i = handle.i1; i < handle.i2; ++i) {
            for (let j = 0; j < this.nbinsy; ++j)
               proj[j] = histo.getBinContent(i+1, j+1);

            produceCandlePoint(i, handle.grx[i], handle.grx[i+1], handle.j1, handle.j2);
         }
      }

      if (hlines && (histo.fFillColor > 0))
         this.draw_g.append('svg:path')
             .attr('d', hlines)
             .style('stroke', this.getColor(histo.fFillColor));

      let hline_color = (isOption(kHistoZeroIndicator) && (histo.fFillStyle != 0)) ? this.fillatt.color : this.lineatt.color;
      if (hists && (!this.fillatt.empty() || (hline_color != 'none')))
         this.draw_g.append('svg:path')
             .attr('d', hists)
             .style('stroke', (hline_color != 'none') ? hline_color : null)
             .style('pointer-events', isBatchMode() ? null : 'visibleFill')
             .call(this.fillatt.func);

      if (bars)
         this.draw_g.append('svg:path')
             .attr('d', bars)
             .call(this.lineatt.func)
             .call(this.fillatt.func);

      if (lines)
         this.draw_g.append('svg:path')
             .attr('d', lines)
             .call(this.lineatt.func)
             .style('fill','none');

      if (dashed_lines) {
         let dashed = new TAttLineHandler({ attr: histo, style: 2 });
         this.draw_g.append('svg:path')
             .attr('d', dashed_lines)
             .call(dashed.func)
             .style('fill','none');
      }

      if (cmarkers)
         this.draw_g.append('svg:path')
             .attr('d', cmarkers)
             .call(attrcmarkers.func);

      if (markers)
         this.draw_g.append('svg:path')
             .attr('d', markers)
             .call(this.markeratt.func);

      return handle;
   }

   /** @summary Draw TH2 bins as scatter plot */
   drawBinsScatter() {
      let histo = this.getObject(),
          handle = this.prepareDraw({ rounding: true, pixel_density: true }),
          colPaths = [], currx = [], curry = [], cell_w = [], cell_h = [],
          colindx, cmd1, cmd2, i, j, binz, cw, ch, factor = 1.,
          scale = this.options.ScatCoef * ((this.gmaxbin) > 2000 ? 2000. / this.gmaxbin : 1.),
          rnd = new TRandom(handle.sumz);

      if (scale*handle.sumz < 1e5) {
         // one can use direct drawing of scatter plot without any patterns

         this.createAttMarker({ attr: histo });

         this.markeratt.resetPos();

         let path = '';
         for (i = handle.i1; i < handle.i2; ++i) {
            cw = handle.grx[i+1] - handle.grx[i];
            for (j = handle.j1; j < handle.j2; ++j) {
               ch = handle.gry[j] - handle.gry[j+1];
               binz = histo.getBinContent(i + 1, j + 1);

               let npix = Math.round(scale*binz);
               if (npix <= 0) continue;

               for (let k = 0; k < npix; ++k)
                  path += this.markeratt.create(
                            Math.round(handle.grx[i] + cw * rnd.random()),
                            Math.round(handle.gry[j+1] + ch * rnd.random()));
            }
         }

         this.draw_g
              .append('svg:path')
              .attr('d', path)
              .call(this.markeratt.func);

         return handle;
      }

      // limit filling factor, do not try to produce as many points as filled area;
      if (this.maxbin > 0.7) factor = 0.7/this.maxbin;

      let nlevels = Math.round(handle.max - handle.min),
          cntr = this.createContour((nlevels > 50) ? 50 : nlevels, this.minposbin, this.maxbin, this.minposbin);

      // now start build
      for (i = handle.i1; i < handle.i2; ++i) {
         for (j = handle.j1; j < handle.j2; ++j) {
            binz = histo.getBinContent(i + 1, j + 1);
            if ((binz <= 0) || (binz < this.minbin)) continue;

            cw = handle.grx[i+1] - handle.grx[i];
            ch = handle.gry[j] - handle.gry[j+1];
            if (cw*ch <= 0) continue;

            colindx = cntr.getContourIndex(binz/cw/ch);
            if (colindx < 0) continue;

            cmd1 = `M${handle.grx[i]},${handle.gry[j+1]}`;
            if (colPaths[colindx] === undefined) {
               colPaths[colindx] = cmd1;
               cell_w[colindx] = cw;
               cell_h[colindx] = ch;
            } else {
               cmd2 = `m${handle.grx[i]-currx[colindx]},${handle.gry[j+1] - curry[colindx]}`;
               colPaths[colindx] += (cmd2.length < cmd1.length) ? cmd2 : cmd1;
               cell_w[colindx] = Math.max(cell_w[colindx], cw);
               cell_h[colindx] = Math.max(cell_h[colindx], ch);
            }

            currx[colindx] = handle.grx[i];
            curry[colindx] = handle.gry[j+1];

            colPaths[colindx] += `v${ch}h${cw}v${-ch}z`;
         }
      }

      let layer = this.getFrameSvg().select('.main_layer'),
          defs = layer.select('defs');
      if (defs.empty() && (colPaths.length > 0))
         defs = layer.insert('svg:defs', ':first-child');

      this.createAttMarker({ attr: histo });

      for (colindx = 0; colindx < colPaths.length; ++colindx)
        if ((colPaths[colindx] !== undefined) && (colindx < cntr.arr.length)) {
           let pattern_class = 'scatter_' + colindx,
               pattern = defs.select('.' + pattern_class);
           if (pattern.empty())
              pattern = defs.append('svg:pattern')
                            .attr('class', pattern_class)
                            .attr('id', 'jsroot_scatter_pattern_' + internals.id_counter++)
                            .attr('patternUnits', 'userSpaceOnUse');
           else
              pattern.selectAll('*').remove();

           let npix = Math.round(factor*cntr.arr[colindx]*cell_w[colindx]*cell_h[colindx]);
           if (npix < 1) npix = 1;

           let arrx = new Float32Array(npix), arry = new Float32Array(npix);

           if (npix === 1) {
              arrx[0] = arry[0] = 0.5;
           } else {
              for (let n = 0; n < npix; ++n) {
                 arrx[n] = rnd.random();
                 arry[n] = rnd.random();
              }
           }

           // arrx.sort();

           this.markeratt.resetPos();

           let path = '';

           for (let n = 0; n < npix; ++n)
              path += this.markeratt.create(arrx[n] * cell_w[colindx], arry[n] * cell_h[colindx]);

           pattern.attr('width', cell_w[colindx])
                  .attr('height', cell_h[colindx])
                  .append('svg:path')
                  .attr('d', path)
                  .call(this.markeratt.func);

           this.draw_g
               .append('svg:path')
               .attr('scatter-index', colindx)
               .style('fill', `url(#${pattern.attr('id')})`)
               .attr('d', colPaths[colindx]);
        }

      return handle;
   }

   /** @summary Draw TH2 bins in 2D mode */
   draw2DBins() {

      if (this._hide_frame && this.isMainPainter()) {
         this.getFrameSvg().style('display', null);
         delete this._hide_frame;
      }

      if (!this.draw_content)
         return this.removeG();

      this.createHistDrawAttributes();

      this.createG(true);

      let handle, pr;

      if (this.isTH2Poly()) {
         pr = this.drawPolyBinsColor();
      } else {
         if (this.options.Scat)
            handle = this.drawBinsScatter();

         if (this.options.Color)
            handle = this.drawBinsColor();
         else if (this.options.Box)
            handle = this.drawBinsBox();
         else if (this.options.Arrow)
            handle = this.drawBinsArrow();
         else if (this.options.Contour)
            handle = this.drawBinsContour();
         else if (this.options.Candle || this.options.Violin)
            handle = this.drawBinsCandle();

         if (this.options.Text)
            pr = this.drawBinsText(handle);

         if (!handle && !pr)
            handle = this.drawBinsScatter();
      }

      if (handle)
         this.tt_handle = handle;
      else if (pr)
         return pr.then(tt => { this.tt_handle = tt; });
   }

   /** @summary Draw TH2 in circular mode */
   drawBinsCircular() {

      this.getFrameSvg().style('display', 'none');
      this._hide_frame = true;

      let rect = this.getPadPainter().getFrameRect(),
          hist = this.getHisto(),
          palette = this.options.Circular > 10 ? this.getHistPalette() : null,
          text_size = 20,
          circle_size = 16,
          axis = hist.fXaxis,
          getBinLabel = indx => {
            if (axis.fLabels)
               for (let i = 0; i < axis.fLabels.arr.length; ++i) {
                  const tstr = axis.fLabels.arr[i];
                  if (tstr.fUniqueID === indx+1) return tstr.fString;
               }
            return indx.toString();
          };

      this.createG();

      this.draw_g.attr('transform', `translate(${Math.round(rect.x + rect.width/2)},${Math.round(rect.y + rect.height/2)})`);

      let nbins = Math.min(this.nbinsx, this.nbinsy);

      this.startTextDrawing(42, text_size, this.draw_g);

      let pnts = [];

      for (let n = 0; n < nbins; n++) {
         let a = (0.5 - n/nbins)*Math.PI*2,
             cx = Math.round((0.9*rect.width/2 - 2*circle_size) * Math.cos(a)),
             cy = Math.round((0.9*rect.height/2 - 2*circle_size) * Math.sin(a)),
             x = Math.round(0.9*rect.width/2 * Math.cos(a)),
             y = Math.round(0.9*rect.height/2 * Math.sin(a)),
             rotate = Math.round(a/Math.PI*180), align = 12,
             color = palette ? palette.calcColor(n, nbins) : 'black';

         pnts.push({ x: cx, y: cy, a, color }); // remember points coordinates

         if ((rotate < -90) || (rotate > 90)) { rotate += 180; align = 32; }

         let s2 = Math.round(text_size/2), s1 = 2*s2;

         this.draw_g.append('path')
                    .attr('d',`M${cx-s2},${cy} a${s2},${s2},0,1,0,${s1},0a${s2},${s2},0,1,0,${-s1},0z`)
                    .style('stroke', color)
                    .style('fill','none');

         this.drawText({ align, rotate, x, y, text: getBinLabel(n)});
      }

      let max_width = circle_size/2, max_value = 0, min_value = 0;
      if (this.options.Circular > 11) {
         for (let i = 0; i < nbins - 1; ++i)
           for (let j = i+1; j < nbins; ++j) {
              let cont = hist.getBinContent(i+1, j+1);
              if (cont > 0) {
                 max_value = Math.max(max_value, cont);
                 if (!min_value || (cont < min_value)) min_value = cont;
              }
           }
      }

      for (let i = 0; i < nbins-1; ++i) {
         let path = '', pi = pnts[i];

         for (let j = i+1; j < nbins; ++j) {
            let cont = hist.getBinContent(i+1, j+1);
            if (cont <= 0) continue;

            let pj = pnts[j],
                a = (pi.a + pj.a)/2,
                qr = 0.5*(1-Math.abs(pi.a - pj.a)/Math.PI), // how far Q point will be away from center
                qx = Math.round(qr*rect.width/2 * Math.cos(a)),
                qy = Math.round(qr*rect.height/2 * Math.sin(a));

            path += `M${pi.x},${pi.y}Q${qx},${qy},${pj.x},${pj.y}`;

            if ((this.options.Circular > 11) && (max_value > min_value)) {
               let width = Math.round((cont - min_value) / (max_value - min_value) * (max_width - 1) + 1);
               this.draw_g.append('path').attr('d', path).style('stroke', pi.color).style('stroke-width', width).style('fill','none');
               path = '';
            }
         }
         if (path)
            this.draw_g.append('path').attr('d', path).style('stroke', pi.color).style('fill','none');
      }

      return this.finishTextDrawing();
   }

   /** @summary Draw histogram bins as chord diagram */
   async drawBinsChord() {

      this.getFrameSvg().style('display', 'none');
      this._hide_frame = true;

      let fullsum = 0, used = [], isint = true,
          nbins = Math.min(this.nbinsx, this.nbinsy),
          hist = this.getHisto();
      for (let i = 0; i < nbins; ++i) {
         let sum = 0;
         for (let j = 0; j < nbins; ++j) {
            let cont = hist.getBinContent(i+1, j+1);
            if (cont > 0) {
               sum += cont;
               if (isint && (Math.round(cont) !== cont)) isint = false;
            }
         }
         if (sum > 0) used.push(i);
         fullsum += sum;
      }

      // do not show less than 2 elements
      if (used.length < 2) return true;

      let rect = this.getPadPainter().getFrameRect(),
          palette = this.getHistPalette(),
          outerRadius = Math.min(rect.width, rect.height) * 0.5 - 60,
          innerRadius = outerRadius - 10,
          data = [], labels = [],
          getColor = indx => palette.calcColor(indx, used.length),
          ndig = 0, tickStep = 1,
          formatValue = v => v.toString(),
          formatTicks = v => ndig > 3 ? v.toExponential(0) : v.toFixed(ndig),
          d3_descending = (a,b) => { return b < a ? -1 : b > a ? 1 : b >= a ? 0 : Number.NaN; };

      if (!isint && fullsum < 10) {
         let lstep = Math.round(Math.log10(fullsum) - 2.3);
         ndig = -lstep;
         tickStep = Math.pow(10, lstep);
      } else if (fullsum > 200) {
         let lstep = Math.round(Math.log10(fullsum) - 2.3);
         tickStep = Math.pow(10, lstep);
      }

      if (tickStep * 250 < fullsum)
         tickStep *= 5;
      else if (tickStep * 100 < fullsum)
         tickStep *= 2;

      for (let i = 0; i < used.length; ++i) {
         data[i] = [];
         for (let j = 0; j < used.length; ++j)
            data[i].push(hist.getBinContent(used[i]+1, used[j]+1));
         let axis = hist.fXaxis, lbl = 'indx_' + used[i].toString();
         if (axis.fLabels)
            for (let k = 0; k < axis.fLabels.arr.length; ++k) {
               const tstr = axis.fLabels.arr[k];
               if (tstr.fUniqueID === used[i]+1) { lbl = tstr.fString; break; }
            }
         labels.push(lbl);
      }

      this.createG();

      this.draw_g.attr('transform', `translate(${Math.round(rect.x + rect.width/2)},${Math.round(rect.y + rect.height/2)})`);

      const chord$1 = chord()
         .padAngle(10 / innerRadius)
         .sortSubgroups(d3_descending)
         .sortChords(d3_descending);

      const chords = chord$1(data);

      const group = this.draw_g.append('g')
         .attr('font-size', 10)
         .attr('font-family', 'sans-serif')
         .selectAll('g')
         .data(chords.groups)
         .join('g');

      const arc$1 = arc().innerRadius(innerRadius).outerRadius(outerRadius);

      const ribbon = ribbon$1().radius(innerRadius - 1).padAngle(1 / innerRadius);

      function ticks({ startAngle, endAngle, value }) {
         const k = (endAngle - startAngle) / value;
         let arr = [];
         for (let z = 0; z <= value; z += tickStep)
            arr.push({ value: z, angle: z * k + startAngle });
         return arr;
      }

      group.append('path')
         .attr('fill', d => getColor(d.index))
         .attr('d', arc$1);

      group.append('title').text(d => `${labels[d.index]} ${formatValue(d.value)}`);

      const groupTick = group.append('g')
         .selectAll('g')
         .data(ticks)
         .join('g')
         .attr('transform', d => `rotate(${d.angle * 180 / Math.PI - 90}) translate(${outerRadius},0)`);
      groupTick.append('line')
         .attr('stroke', 'currentColor')
         .attr('x2', 6);

      groupTick.append('text')
         .attr('x', 8)
         .attr('dy', '0.35em')
         .attr('transform', d => d.angle > Math.PI ? 'rotate(180) translate(-16)' : null)
         .attr('text-anchor', d => d.angle > Math.PI ? 'end' : null)
         .text(d => formatTicks(d.value));

      group.select('text')
         .attr('font-weight', 'bold')
         .text(function(d) {
            return this.getAttribute('text-anchor') === 'end'
               ? `↑ ${labels[d.index]}` : `${labels[d.index]} ↓`;
         });

      this.draw_g.append('g')
         .attr('fill-opacity', 0.8)
         .selectAll('path')
         .data(chords)
         .join('path')
         .style('mix-blend-mode', 'multiply')
         .attr('fill', d => getColor(d.source.index))
         .attr('d', ribbon)
         .append('title')
         .text(d => `${formatValue(d.source.value)} ${labels[d.target.index]} → ${labels[d.source.index]}${d.source.index === d.target.index ? '' : `\n${formatValue(d.target.value)} ${labels[d.source.index]} → ${labels[d.target.index]}`}`);

      return true;

   }

   /** @summary Provide text information (tooltips) for histogram bin */
   getBinTooltips(i, j) {
      let histo = this.getHisto(),
          binz = histo.getBinContent(i+1, j+1);

      if (histo.$baseh)
         binz -= histo.$baseh.getBinContent(i+1, j+1);

      let lines = [this.getObjectHint(),
                   'x = ' + this.getAxisBinTip('x', histo.fXaxis, i),
                   'y = ' + this.getAxisBinTip('y', histo.fYaxis, j),
                   `bin = ${histo.getBin(i+1,j+1)}  x: ${i+1}  y: ${j+1}`,
                   'entries = ' + ((binz === Math.round(binz)) ? binz : floatToString(binz, gStyle.fStatFormat))];

      if ((this.options.TextKind == 'E') || this.matchObjectType(clTProfile2D)) {
         let errz = histo.getBinError(histo.getBin(i+1,j+1));
         lines.push('error = ' + ((errz === Math.round(errz)) ? errz.toString() : floatToString(errz, gStyle.fPaintTextFormat)));
      }

      return lines;
   }

   /** @summary Provide text information (tooltips) for candle bin */
   getCandleTooltips(p) {
      let pmain = this.getFramePainter(),
          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),
          histo = this.getHisto();

      return [this.getObjectHint(),
              p.swapXY ? 'y = ' + funcs.axisAsText('y', histo.fYaxis.GetBinLowEdge(p.bin+1))
                       : 'x = ' + funcs.axisAsText('x', histo.fXaxis.GetBinLowEdge(p.bin+1)),
              'm-25%  = ' + floatToString(p.fBoxDown, gStyle.fStatFormat),
              'median = ' + floatToString(p.fMedian, gStyle.fStatFormat),
              'm+25%  = ' + floatToString(p.fBoxUp, gStyle.fStatFormat)];
   }

   /** @summary Provide text information (tooltips) for poly bin */
   getPolyBinTooltips(binindx, realx, realy) {

      let histo = this.getHisto(),
          bin = histo.fBins.arr[binindx],
          pmain = this.getFramePainter(),
          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),
          binname = bin.fPoly.fName,
          lines = [], numpoints = 0;

      if (binname === 'Graph') binname = '';
      if (binname.length === 0) binname = bin.fNumber;

      if ((realx === undefined) && (realy === undefined)) {
         realx = realy = 0;
         let gr = bin.fPoly, numgraphs = 1;
         if (gr._typename === clTMultiGraph) { numgraphs = bin.fPoly.fGraphs.arr.length; gr = null; }

         for (let ngr = 0; ngr < numgraphs; ++ngr) {
            if (!gr || (ngr > 0)) gr = bin.fPoly.fGraphs.arr[ngr];

            for (let n = 0; n < gr.fNpoints; ++n) {
               ++numpoints;
               realx += gr.fX[n];
               realy += gr.fY[n];
            }
         }

         if (numpoints > 1) {
            realx = realx / numpoints;
            realy = realy / numpoints;
         }
      }

      lines.push(this.getObjectHint(),
                 'x = ' + funcs.axisAsText('x', realx),
                 'y = ' + funcs.axisAsText('y', realy));
      if (numpoints > 0)
         lines.push('npnts = ' + numpoints);
      lines.push('bin = ' + binname);
      if (bin.fContent === Math.round(bin.fContent))
         lines.push('content = ' + bin.fContent);
      else
         lines.push('content = ' + floatToString(bin.fContent, gStyle.fStatFormat));
      return lines;
   }

   /** @summary Process tooltip event */
   processTooltipEvent(pnt) {
      if (!pnt || !this.draw_content || !this.draw_g || !this.tt_handle || this.options.Proj) {
         if (this.draw_g)
            this.draw_g.select('.tooltip_bin').remove();
         return null;
      }

      let histo = this.getHisto(),
          h = this.tt_handle,
          ttrect = this.draw_g.select('.tooltip_bin');

      if (h.poly) {
         // process tooltips from TH2Poly

         let pmain = this.getFramePainter(),
             funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),
             foundindx = -1, bin;
         const realx = funcs.revertAxis('x', pnt.x),
               realy = funcs.revertAxis('y', pnt.y);

         if ((realx !== undefined) && (realy !== undefined)) {
            const len = histo.fBins.arr.length;

            for (let i = 0; (i < len) && (foundindx < 0); ++i) {
               bin = histo.fBins.arr[i];

               // found potential bins candidate
               if ((realx < bin.fXmin) || (realx > bin.fXmax) ||
                   (realy < bin.fYmin) || (realy > bin.fYmax)) continue;

               // ignore empty bins with col0 option
               if ((bin.fContent === 0) && !this.options.Zero) continue;

               let gr = bin.fPoly, numgraphs = 1;
               if (gr._typename === clTMultiGraph) { numgraphs = bin.fPoly.fGraphs.arr.length; gr = null; }

               for (let ngr = 0; ngr < numgraphs; ++ngr) {
                  if (!gr || (ngr > 0)) gr = bin.fPoly.fGraphs.arr[ngr];
                  if (gr.IsInside(realx,realy)) {
                     foundindx = i;
                     break;
                  }
               }
            }
         }

         if (foundindx < 0) {
            ttrect.remove();
            return null;
         }

         let res = { name: histo.fName, title: histo.fTitle,
                     x: pnt.x, y: pnt.y,
                     color1: this.lineatt ? this.lineatt.color : 'green',
                     color2: this.fillatt ? this.fillatt.getFillColorAlt('blue') : 'blue',
                     exact: true, menu: true,
                     lines: this.getPolyBinTooltips(foundindx, realx, realy) };

         if (pnt.disabled) {
            ttrect.remove();
            res.changed = true;
         } else {

            if (ttrect.empty())
               ttrect = this.draw_g.append('svg:path')
                            .attr('class', 'tooltip_bin h1bin')
                            .style('pointer-events', 'none');

            res.changed = ttrect.property('current_bin') !== foundindx;

            if (res.changed)
                  ttrect.attr('d', this.createPolyBin(funcs, bin))
                        .style('opacity', '0.7')
                        .property('current_bin', foundindx);
         }

         if (res.changed)
            res.user_info = { obj: histo, name: histo.fName,
                              bin: foundindx,
                              cont: bin.fContent,
                              grx: pnt.x, gry: pnt.y };

         return res;

      } else if (h.candle) {
         // process tooltips for candle

         let i, p, match;

         for (i = 0; i < h.candle.length; ++i) {
            p = h.candle[i];
            match = p.swapXY ? ((p.x1 <= pnt.y) && (pnt.y <= p.x2) && (p.yy1 >= pnt.x) && (pnt.x >= p.yy2))
                             : ((p.x1 <= pnt.x) && (pnt.x <= p.x2) && (p.yy1 <= pnt.y) && (pnt.y <= p.yy2));
            if (match) break;
         }

         if (!match) {
            ttrect.remove();
            return null;
         }

         let res = { name: histo.fName, title: histo.fTitle,
                     x: pnt.x, y: pnt.y,
                     color1: this.lineatt ? this.lineatt.color : 'green',
                     color2: this.fillatt ? this.fillatt.getFillColorAlt('blue') : 'blue',
                     lines: this.getCandleTooltips(p), exact: true, menu: true };

         if (pnt.disabled) {
            ttrect.remove();
            res.changed = true;
         } else {

            if (ttrect.empty())
               ttrect = this.draw_g.append('svg:path')
                                   .attr('class', 'tooltip_bin h1bin')
                                   .style('pointer-events', 'none')
                                   .style('opacity', '0.7');

            res.changed = ttrect.property('current_bin') !== i;

            if (res.changed)
               ttrect.attr('d', p.swapXY ? `M${p.yy1},${p.x1}H${p.yy2}V${p.x2}H${p.yy1}Z` : `M${p.x1},${p.yy1}H${p.x2}V${p.yy2}H${p.x1}Z`)
                     .property('current_bin', i);
         }

         if (res.changed)
            res.user_info = { obj: histo,  name: histo.fName,
                              bin: i+1, cont: p.fMedian, binx: i+1, biny: 1,
                              grx: pnt.x, gry: pnt.y };

         return res;
      }

      let i, j, binz = 0, colindx = null,
          i1, i2, j1, j2, x1, x2, y1, y2,
          pmain = this.getFramePainter();

      // search bins position
      if (pmain.reverse_x) {
         for (i = h.i1; i < h.i2; ++i)
            if ((pnt.x<=h.grx[i]) && (pnt.x>=h.grx[i+1])) break;
      } else {
         for (i = h.i1; i < h.i2; ++i)
            if ((pnt.x>=h.grx[i]) && (pnt.x<=h.grx[i+1])) break;
      }

      if (pmain.reverse_y) {
         for (j = h.j1; j < h.j2; ++j)
            if ((pnt.y <= h.gry[j+1]) && (pnt.y >= h.gry[j])) break;
      } else {
         for (j = h.j1; j < h.j2; ++j)
            if ((pnt.y >= h.gry[j+1]) && (pnt.y <= h.gry[j])) break;
      }

      if ((i < h.i2) && (j < h.j2)) {

         i1 = i; i2 = i+1; j1 = j; j2 = j+1;
         x1 = h.grx[i1]; x2 = h.grx[i2];
         y1 = h.gry[j2]; y2 = h.gry[j1];

         let match = true;

         if (this.options.Color) {
            // take into account bar settings
            let dx = x2 - x1, dy = y2 - y1;
            x2 = Math.round(x1 + dx*h.xbar2);
            x1 = Math.round(x1 + dx*h.xbar1);
            y2 = Math.round(y1 + dy*h.ybar2);
            y1 = Math.round(y1 + dy*h.ybar1);
            if (pmain.reverse_x) {
               if ((pnt.x > x1) || (pnt.x <= x2)) match = false;
            } else {
               if ((pnt.x < x1) || (pnt.x >= x2)) match = false;
            }
            if (pmain.reverse_y) {
               if ((pnt.y > y1) || (pnt.y <= y2)) match = false;
            } else {
               if ((pnt.y < y1) || (pnt.y >= y2)) match = false;
            }
         }

         binz = histo.getBinContent(i+1,j+1);
         if (this.is_projection) {
            colindx = 0; // just to avoid hide
         } else if (!match) {
            colindx = null;
         } else if (h.hide_only_zeros) {
            colindx = (binz === 0) && !this._show_empty_bins ? null : 0;
         } else {
            colindx = this.getContour().getPaletteIndex(this.getHistPalette(), binz);
            if ((colindx === null) && (binz === 0) && this._show_empty_bins) colindx = 0;
         }
      }

      if (colindx === null) {
         ttrect.remove();
         return null;
      }

      let res = { name: histo.fName, title: histo.fTitle,
                  x: pnt.x, y: pnt.y,
                  color1: this.lineatt ? this.lineatt.color : 'green',
                  color2: this.fillatt ? this.fillatt.getFillColorAlt('blue') : 'blue',
                  lines: this.getBinTooltips(i, j), exact: true, menu: true };

      if (this.options.Color) res.color2 = this.getHistPalette().getColor(colindx);

      if (pnt.disabled && !this.is_projection) {
         ttrect.remove();
         res.changed = true;
      } else {
         if (ttrect.empty())
            ttrect = this.draw_g.append('svg:path')
                                .attr('class', 'tooltip_bin h1bin')
                                .style('pointer-events', 'none');

         let binid = i*10000 + j;

         if (this.is_projection == 'X') {
            x1 = 0; x2 = this.getFramePainter().getFrameWidth();
            if (this.projection_width > 1) {
               let dd = (this.projection_width-1)/2;
               if (j2+dd >= h.j2) { j2 = Math.min(Math.round(j2+dd), h.j2); j1 = Math.max(j2 - this.projection_width, h.j1); }
                             else { j1 = Math.max(Math.round(j1-dd), h.j1); j2 = Math.min(j1 + this.projection_width, h.j2); }
            }
            y1 = h.gry[j2]; y2 = h.gry[j1];
            binid = j1*777 + j2*333;
         } else if (this.is_projection == 'Y') {
            y1 = 0; y2 = this.getFramePainter().getFrameHeight();
            if (this.projection_width > 1) {
               let dd = (this.projection_width-1)/2;
               if (i2+dd >= h.i2) { i2 = Math.min(Math.round(i2+dd), h.i2); i1 = Math.max(i2 - this.projection_width, h.i1); }
                             else { i1 = Math.max(Math.round(i1-dd), h.i1); i2 = Math.min(i1 + this.projection_width, h.i2); }
            }
            x1 = h.grx[i1]; x2 = h.grx[i2];
            binid = i1*777 + i2*333;
         }

         res.changed = ttrect.property('current_bin') !== binid;

         if (res.changed)
            ttrect.attr('d', `M${x1},${y1}h${x2-x1}v${y2-y1}h${x1-x2}z`)
                  .style('opacity', '0.7')
                  .property('current_bin', binid);

         if (this.is_projection && res.changed)
            this.redrawProjection(i1, i2, j1, j2);
      }

      if (res.changed)
         res.user_info = { obj: histo, name: histo.fName,
                           bin: histo.getBin(i+1, j+1), cont: binz, binx: i+1, biny: j+1,
                           grx: pnt.x, gry: pnt.y };

      return res;
   }

   /** @summary Checks if it makes sense to zoom inside specified axis range */
   canZoomInside(axis, min, max) {

      if (axis == 'z') return true;

      let obj = this.getHisto();
      if (obj) obj = (axis == 'y') ? obj.fYaxis : obj.fXaxis;

      return !obj || (obj.FindBin(max,0.5) - obj.FindBin(min,0) > 1);
   }

   /** @summary Complete paletted drawing */
   completePalette(pp) {
      if (!pp) return true;

      pp.$main_painter = this;
      this.options.Zvert = pp._palette_vertical;

      // redraw palette till the end when contours are available
      return pp.drawPave(this.options.Cjust ? 'cjust' : '');
   }

   /** @summary Performs 2D drawing of histogram
     * @return {Promise} when ready */
   async draw2D(/* reason */) {

      this.clear3DScene();

      let need_palette = this.options.Zscale && (this.options.Color || this.options.Contour);
      // draw new palette, resize frame if required

      return this.drawColorPalette(need_palette, true).then(pp => {

         let pr;
         if (this.options.Circular && this.isMainPainter()) {
            pr = this.drawBinsCircular();
         } else if (this.options.Chord && this.isMainPainter()) {
            pr = this.drawBinsChord();
         } else {
            pr = this.drawAxes().then(() => this.draw2DBins());
         }

         return pr.then(() => this.completePalette(pp));
      }).then(() => this.drawHistTitle())
        .then(() => this.drawNextFunction(0, true))
        .then(() => {
            this.updateStatWebCanvas();
            return this.addInteractivity();
      });
   }

   /** @summary Should performs 3D drawing of histogram
     * @desc Disabled in 2D case. just draw default draw options
     * @return {Promise} when ready */
   async draw3D(reason) {
      console.log('3D drawing is disabled, load ./hist/TH2Painter.mjs');
      return this.draw2D(reason);
   }

   /** @summary Call drawing function depending from 3D mode */
   async callDrawFunc(reason) {
      let main = this.getMainPainter(),
          fp = this.getFramePainter();

     if ((main !== this) && fp && (fp.mode3d !== this.options.Mode3D))
        this.copyOptionsFrom(main);

      return this.options.Mode3D ? this.draw3D(reason) : this.draw2D(reason);
   }

   /** @summary Redraw histogram */
   async redraw(reason) {
      return this.callDrawFunc(reason);
   }

   /** @summary draw TH2 object */
   static async draw(dom, histo, opt) {
      return THistPainter._drawHist(new TH2Painter$2(dom, histo), opt);
   }

} // class TH2Painter

/** @summary Draw TH2Poly histogram as lego
  * @private */
function drawTH2PolyLego(painter) {
   let histo = painter.getHisto(),
       pmain = painter.getFramePainter(),
       axis_zmin = pmain.z_handle.getScaleMin(),
       axis_zmax = pmain.z_handle.getScaleMax(),
       colindx, bin, i, len = histo.fBins.arr.length,
       z0 = pmain.grz(axis_zmin), z1;

   // use global coordinates
   painter.maxbin = painter.gmaxbin;
   painter.minbin = painter.gminbin;
   painter.minposbin = painter.gminposbin;

   let cntr = painter.getContour(true), palette = painter.getHistPalette();

   for (i = 0; i < len; ++i) {
      bin = histo.fBins.arr[i];
      if (bin.fContent < axis_zmin) continue;

      colindx = cntr.getPaletteIndex(palette, bin.fContent);
      if (colindx === null) continue;

      // check if bin outside visible range
      if ((bin.fXmin > pmain.scale_xmax) || (bin.fXmax < pmain.scale_xmin) ||
          (bin.fYmin > pmain.scale_ymax) || (bin.fYmax < pmain.scale_ymin)) continue;

      z1 = pmain.grz((bin.fContent > axis_zmax) ? axis_zmax : bin.fContent);

      let all_pnts = [], all_faces = [],
          ngraphs = 1, gr = bin.fPoly, nfaces = 0;

      if (gr._typename == clTMultiGraph) {
         ngraphs = bin.fPoly.fGraphs.arr.length;
         gr = null;
      }

      for (let ngr = 0; ngr < ngraphs; ++ngr) {
         if (!gr || (ngr > 0)) gr = bin.fPoly.fGraphs.arr[ngr];

         let npnts = gr.fNpoints, x = gr.fX, y = gr.fY;
         while ((npnts>2) && (x[0]===x[npnts-1]) && (y[0]===y[npnts-1])) --npnts;

         let pnts, faces;

         for (let ntry=0;ntry<2;++ntry) {
            // run two loops - on the first try to compress data, on second - run as is (removing duplication)

            let lastx, lasty, currx, curry,
                dist2 = pmain.size_x3d*pmain.size_z3d,
                dist2limit = (ntry > 0) ? 0 : dist2/1e6;

            pnts = []; faces = null;

            for (let vert = 0; vert < npnts; ++vert) {
               currx = pmain.grx(x[vert]);
               curry = pmain.gry(y[vert]);
               if (vert > 0)
                  dist2 = (currx-lastx)*(currx-lastx) + (curry-lasty)*(curry-lasty);
               if (dist2 > dist2limit) {
                  pnts.push(new Vector2(currx, curry));
                  lastx = currx;
                  lasty = curry;
               }
            }

            try {
               if (pnts.length > 2)
                  faces = ShapeUtils.triangulateShape(pnts , []);
            } catch(e) {
               faces = null;
            }

            if (faces && (faces.length>pnts.length-3)) break;
         }

         if (faces && faces.length && pnts) {
            all_pnts.push(pnts);
            all_faces.push(faces);

            nfaces += faces.length * 2;
            if (z1>z0) nfaces += pnts.length*2;
         }
      }

      let pos = new Float32Array(nfaces*9), indx = 0;

      for (let ngr = 0; ngr < all_pnts.length; ++ngr) {
         let pnts = all_pnts[ngr], faces = all_faces[ngr];

         for (let layer = 0; layer < 2; ++layer) {
            for (let n=0;n<faces.length;++n) {
               let face = faces[n],
                   pnt1 = pnts[face[0]],
                   pnt2 = pnts[face[layer === 0 ? 2 : 1]],
                   pnt3 = pnts[face[layer === 0 ? 1 : 2]];

               pos[indx] = pnt1.x;
               pos[indx+1] = pnt1.y;
               pos[indx+2] = layer ? z1 : z0;
               indx+=3;

               pos[indx] = pnt2.x;
               pos[indx+1] = pnt2.y;
               pos[indx+2] = layer ? z1 : z0;
               indx+=3;

               pos[indx] = pnt3.x;
               pos[indx+1] = pnt3.y;
               pos[indx+2] = layer ? z1 : z0;
               indx+=3;
            }
         }

         if (z1>z0) {
            for (let n = 0; n < pnts.length; ++n) {
               let pnt1 = pnts[n],
                   pnt2 = pnts[n > 0 ? n-1 : pnts.length-1];

               pos[indx] = pnt1.x;
               pos[indx+1] = pnt1.y;
               pos[indx+2] = z0;
               indx+=3;

               pos[indx] = pnt2.x;
               pos[indx+1] = pnt2.y;
               pos[indx+2] = z0;
               indx+=3;

               pos[indx] = pnt2.x;
               pos[indx+1] = pnt2.y;
               pos[indx+2] = z1;
               indx+=3;

               pos[indx] = pnt1.x;
               pos[indx+1] = pnt1.y;
               pos[indx+2] = z0;
               indx+=3;

               pos[indx] = pnt2.x;
               pos[indx+1] = pnt2.y;
               pos[indx+2] = z1;
               indx+=3;

               pos[indx] = pnt1.x;
               pos[indx+1] = pnt1.y;
               pos[indx+2] = z1;
               indx+=3;
            }
         }
      }

      let geometry = new BufferGeometry();
      geometry.setAttribute('position', new BufferAttribute(pos, 3));
      geometry.computeVertexNormals();

      let color = painter.fPalette.getColor(colindx),
          material = new MeshBasicMaterial({ color, vertexColors: false }),
          mesh = new Mesh(geometry, material);

      pmain.toplevel.add(mesh);

      mesh.painter = painter;
      mesh.bins_index = i;
      mesh.draw_z0 = z0;
      mesh.draw_z1 = z1;
      mesh.tip_color = 0x00FF00;

      mesh.tooltip = function(/*intersects*/) {

         let p = this.painter, main = p.getFramePainter(),
             bin = p.getObject().fBins.arr[this.bins_index];

         let tip = {
           use_itself: true, // indicate that use mesh itself for highlighting
           x1: main.grx(bin.fXmin),
           x2: main.grx(bin.fXmax),
           y1: main.gry(bin.fYmin),
           y2: main.gry(bin.fYmax),
           z1: this.draw_z0,
           z2: this.draw_z1,
           bin: this.bins_index,
           value: bin.fContent,
           color: this.tip_color,
           lines: p.getPolyBinTooltips(this.bins_index)
         };

         return tip;
      };
   }
}

/** @summary Draw 2-D histogram in 3D
  * @private */
class TH2Painter extends TH2Painter$2 {

   /** @summary draw TH2 object in 3D mode */
   async draw3D(reason) {

      this.mode3d = true;

      let main = this.getFramePainter(), // who makes axis drawing
          is_main = this.isMainPainter(), // is main histogram
          histo = this.getHisto(),
          pr = Promise.resolve(true);

      if (reason == 'resize') {

         if (is_main && main.resize3D()) main.render3D();

      } else {

         let pad = this.getPadPainter().getRootPad(true),
             zmult = 1 + 2*gStyle.fHistTopMargin;

         if (this.draw_content || (this.gmaxbin != 0)) {
            this.zmin = pad?.fLogz ? this.gminposbin * 0.3 : this.gminbin;
            this.zmax = this.gmaxbin;
         } else {
            zmult = 1;
         }

         if (pad?.fLogz && (this.zmin <= 0))
            this.zmin = this.zmax * 1e-5;

         this.deleteAttr();

         if (is_main) {
            assignFrame3DMethods(main);
            pr = main.create3DScene(this.options.Render3D, this.options.x3dscale, this.options.y3dscale).then(() => {
               main.setAxesRanges(histo.fXaxis, this.xmin, this.xmax, histo.fYaxis, this.ymin, this.ymax, histo.fZaxis, this.zmin, this.zmax, this);
               main.set3DOptions(this.options);
               main.drawXYZ(main.toplevel, TAxisPainter, { zmult, zoom: settings.Zooming, ndim: 2, draw: this.options.Axis !== -1 });
            });
         }

         if (main.mode3d)
            pr = pr.then(() => {
               if (this.draw_content) {
                  if (this.isTH2Poly())
                     drawTH2PolyLego(this);
                  else if (this.options.Contour)
                     drawBinsContour3D(this, true);
                  else if (this.options.Surf)
                     drawBinsSurf3D(this);
                  else if (this.options.Error)
                     drawBinsError3D(this);
                  else
                     drawBinsLego(this);
               }
               main.render3D();
               this.updateStatWebCanvas();
               main.addKeysHandler();
            });
      }

      //  (re)draw palette by resize while canvas may change dimension
      if (is_main)
         pr = pr.then(() => this.drawColorPalette(this.options.Zscale && ((this.options.Lego == 12) || (this.options.Lego == 14) ||
                                     (this.options.Surf == 11) || (this.options.Surf == 12)))).then(() => this.drawHistTitle());

      return pr.then(() => this);
   }

   /** @summary draw TH2 object */
   static async draw(dom, histo, opt) {
      return THistPainter._drawHist(new TH2Painter(dom, histo), opt);
   }

} // class TH2Painter

var TH2Painter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
TH2Painter: TH2Painter
});

/**
 * @summary Painter for TH3 classes
 * @private
 */

class TH3Painter extends THistPainter {

   /** @summary Scan TH3 histogram content */
   scanContent(when_axis_changed) {

      // no need to rescan histogram while result does not depend from axis selection
      if (when_axis_changed && this.nbinsx && this.nbinsy && this.nbinsz) return;

      let histo = this.getHisto();

      this.extractAxesProperties(3);

      // global min/max, used at the moment in 3D drawing
      this.gminbin = this.gmaxbin = histo.getBinContent(1,1,1);

      for (let i = 0; i < this.nbinsx; ++i)
         for (let j = 0; j < this.nbinsy; ++j)
            for (let k = 0; k < this.nbinsz; ++k) {
               let bin_content = histo.getBinContent(i+1, j+1, k+1);
               if (bin_content < this.gminbin)
                  this.gminbin = bin_content;
               else if (bin_content > this.gmaxbin)
                  this.gmaxbin = bin_content;
            }

      this.draw_content = this.gmaxbin > 0;
   }

   /** @summary Count TH3 statistic */
   countStat() {
      let histo = this.getHisto(), xaxis = histo.fXaxis, yaxis = histo.fYaxis, zaxis = histo.fZaxis,
          stat_sum0 = 0, stat_sumx1 = 0, stat_sumy1 = 0,
          stat_sumz1 = 0, stat_sumx2 = 0, stat_sumy2 = 0, stat_sumz2 = 0,
          i1 = this.getSelectIndex('x', 'left'),
          i2 = this.getSelectIndex('x', 'right'),
          j1 = this.getSelectIndex('y', 'left'),
          j2 = this.getSelectIndex('y', 'right'),
          k1 = this.getSelectIndex('z', 'left'),
          k2 = this.getSelectIndex('z', 'right'),
          fp = this.getFramePainter(),
          res = { name: histo.fName, entries: 0, integral: 0, meanx: 0, meany: 0, meanz: 0, rmsx: 0, rmsy: 0, rmsz: 0 },
          xi, yi, zi, xx, xside, yy, yside, zz, zside, cont,
          has_counted_stat = (Math.abs(histo.fTsumw) > 1e-300) && !fp.isAxisZoomed('x') && !fp.isAxisZoomed('y') && !fp.isAxisZoomed('z');

      for (xi = 0; xi < this.nbinsx+2; ++xi) {

         xx = xaxis.GetBinCoord(xi - 0.5);
         xside = (xi < i1) ? 0 : (xi > i2 ? 2 : 1);

         for (yi = 0; yi < this.nbinsy+2; ++yi) {

            yy = yaxis.GetBinCoord(yi - 0.5);
            yside = (yi < j1) ? 0 : (yi > j2 ? 2 : 1);

            for (zi = 0; zi < this.nbinsz+2; ++zi) {

               zz = zaxis.GetBinCoord(zi - 0.5);
               zside = (zi < k1) ? 0 : (zi > k2 ? 2 : 1);

               cont = histo.getBinContent(xi, yi, zi);
               res.entries += cont;

               if (!has_counted_stat && (xside == 1) && (yside == 1) && (zside == 1)) {
                  stat_sum0 += cont;
                  stat_sumx1 += xx * cont;
                  stat_sumy1 += yy * cont;
                  stat_sumz1 += zz * cont;
                  stat_sumx2 += xx**2 * cont;
                  stat_sumy2 += yy**2 * cont;
                  stat_sumz2 += zz**2 * cont;
               }
            }
         }
      }

      if (has_counted_stat) {
         stat_sum0  = histo.fTsumw;
         stat_sumx1 = histo.fTsumwx;
         stat_sumx2 = histo.fTsumwx2;
         stat_sumy1 = histo.fTsumwy;
         stat_sumy2 = histo.fTsumwy2;
         stat_sumz1 = histo.fTsumwz;
         stat_sumz2 = histo.fTsumwz2;
      }

      if (Math.abs(stat_sum0) > 1e-300) {
         res.meanx = stat_sumx1 / stat_sum0;
         res.meany = stat_sumy1 / stat_sum0;
         res.meanz = stat_sumz1 / stat_sum0;
         res.rmsx = Math.sqrt(Math.abs(stat_sumx2 / stat_sum0 - res.meanx * res.meanx));
         res.rmsy = Math.sqrt(Math.abs(stat_sumy2 / stat_sum0 - res.meany * res.meany));
         res.rmsz = Math.sqrt(Math.abs(stat_sumz2 / stat_sum0 - res.meanz * res.meanz));
      }

      res.integral = stat_sum0;

      if (histo.fEntries > 1)
         res.entries = histo.fEntries;

      return res;
   }

   /** @summary Fill TH3 statistic in stat box */
   fillStatistic(stat, dostat, dofit) {

      // no need to refill statistic if histogram is dummy
      if (this.isIgnoreStatsFill())
         return false;

      let data = this.countStat(),
          print_name = dostat % 10,
          print_entries = Math.floor(dostat / 10) % 10,
          print_mean = Math.floor(dostat / 100) % 10,
          print_rms = Math.floor(dostat / 1000) % 10,
          print_integral = Math.floor(dostat / 1000000) % 10;
          // print_under = Math.floor(dostat / 10000) % 10,
          // print_over = Math.floor(dostat / 100000) % 10,
          // print_skew = Math.floor(dostat / 10000000) % 10,
          // print_kurt = Math.floor(dostat / 100000000) % 10;

      stat.clearPave();

      if (print_name > 0)
         stat.addText(data.name);

      if (print_entries > 0)
         stat.addText('Entries = ' + stat.format(data.entries,'entries'));

      if (print_mean > 0) {
         stat.addText('Mean x = ' + stat.format(data.meanx));
         stat.addText('Mean y = ' + stat.format(data.meany));
         stat.addText('Mean z = ' + stat.format(data.meanz));
      }

      if (print_rms > 0) {
         stat.addText('Std Dev x = ' + stat.format(data.rmsx));
         stat.addText('Std Dev y = ' + stat.format(data.rmsy));
         stat.addText('Std Dev z = ' + stat.format(data.rmsz));
      }

      if (print_integral > 0) {
         stat.addText('Integral = ' + stat.format(data.integral,'entries'));
      }

      if (dofit) stat.fillFunctionStat(this.findFunction('TF3'), dofit);

      return true;
   }

   /** @summary Provide text information (tooltips) for histogram bin */
   getBinTooltips(ix, iy, iz) {
      let lines = [], histo = this.getHisto();

      lines.push(this.getObjectHint());

      lines.push(`x = ${this.getAxisBinTip('x', histo.fXaxis, ix)}  xbin=${ix+1}`);
      lines.push(`y = ${this.getAxisBinTip('y', histo.fYaxis, iy)}  ybin=${iy+1}`);
      lines.push(`z = ${this.getAxisBinTip('z', histo.fZaxis, iz)}  zbin=${iz+1}`);

      let binz = histo.getBinContent(ix+1, iy+1, iz+1);
      if (binz === Math.round(binz))
         lines.push('entries = ' + binz);
      else
         lines.push('entries = ' + floatToString(binz, gStyle.fStatFormat));

      return lines;
   }

   /** @summary draw 3D histogram as scatter plot
     * @desc If there are too many points, box will be displayed
     * @return {Promise|false} either Promise or just false that drawing cannot be performed */
   draw3DScatter() {

      let histo = this.getObject(),
          main = this.getFramePainter(),
          i1 = this.getSelectIndex('x', 'left', 0.5),
          i2 = this.getSelectIndex('x', 'right', 0),
          j1 = this.getSelectIndex('y', 'left', 0.5),
          j2 = this.getSelectIndex('y', 'right', 0),
          k1 = this.getSelectIndex('z', 'left', 0.5),
          k2 = this.getSelectIndex('z', 'right', 0),
          i, j, k, bin_content;

      if ((i2 <= i1) || (j2 <= j1) || (k2 <= k1))
         return Promise.resolve(true);

      // scale down factor if too large values
      let coef = (this.gmaxbin > 1000) ? 1000/this.gmaxbin : 1,
          numpixels = 0, sumz = 0, content_lmt = Math.max(0, this.gminbin);

      for (i = i1; i < i2; ++i) {
         for (j = j1; j < j2; ++j) {
            for (k = k1; k < k2; ++k) {
               bin_content = histo.getBinContent(i+1, j+1, k+1);
               sumz += bin_content;
               if (bin_content <= content_lmt) continue;
               numpixels += Math.round(bin_content*coef);
            }
         }
      }

      // too many pixels - use box drawing
      if (numpixels > (main.webgl ? 100000 : 30000))
         return false;

      let pnts = new PointsCreator(numpixels, main.webgl, main.size_x3d/200),
          bins = new Int32Array(numpixels), nbin = 0,
          rnd = new TRandom(sumz);

      for (i = i1; i < i2; ++i) {
         for (j = j1; j < j2; ++j) {
            for (k = k1; k < k2; ++k) {
               bin_content = histo.getBinContent(i+1, j+1, k+1);
               if (bin_content <= content_lmt) continue;
               let num = Math.round(bin_content*coef);

               for (let n=0;n<num;++n) {
                  let binx = histo.fXaxis.GetBinCoord(i + rnd.random()),
                      biny = histo.fYaxis.GetBinCoord(j + rnd.random()),
                      binz = histo.fZaxis.GetBinCoord(k + rnd.random());

                  // remember bin index for tooltip
                  bins[nbin++] = histo.getBin(i+1, j+1, k+1);

                  pnts.addPoint(main.grx(binx), main.gry(biny), main.grz(binz));
               }
            }
         }
      }

      return pnts.createPoints({ color: this.getColor(histo.fMarkerColor) }).then(mesh => {
         main.toplevel.add(mesh);

         mesh.bins = bins;
         mesh.painter = this;
         mesh.tip_color = (histo.fMarkerColor===3) ? 0xFF0000 : 0x00FF00;

         mesh.tooltip = function(intersect) {
            if (!Number.isInteger(intersect.index)) {
               console.error(`intersect.index not provided, three.js version ${REVISION}`);
               return null;
            }

            let indx = Math.floor(intersect.index / this.nvertex);
            if ((indx < 0) || (indx >= this.bins.length)) return null;

            let p = this.painter, histo = p.getHisto(),
                main = p.getFramePainter(),
                tip = p.get3DToolTip(this.bins[indx]);

            tip.x1 = main.grx(histo.fXaxis.GetBinLowEdge(tip.ix));
            tip.x2 = main.grx(histo.fXaxis.GetBinLowEdge(tip.ix+1));
            tip.y1 = main.gry(histo.fYaxis.GetBinLowEdge(tip.iy));
            tip.y2 = main.gry(histo.fYaxis.GetBinLowEdge(tip.iy+1));
            tip.z1 = main.grz(histo.fZaxis.GetBinLowEdge(tip.iz));
            tip.z2 = main.grz(histo.fZaxis.GetBinLowEdge(tip.iz+1));
            tip.color = this.tip_color;
            tip.opacity = 0.3;

            return tip;
         };

         return true;
      });
   }

   /** @summary Drawing of 3D histogram */
   async draw3DBins() {

      if (!this.draw_content)
         return false;

      let box_option = this.options.Box ? this.options.BoxStyle : 0;

      if (!box_option && !this.options.GLBox && !this.options.GLColor && !this.options.Lego) {
         let promise = this.draw3DScatter();
         if (promise !== false) return promise;
         box_option = 12; // fall back to box2 draw option
      }

      let histo = this.getHisto(),
          fillcolor = this.getColor(histo.fFillColor),
          main = this.getFramePainter(),
          buffer_size = 0, use_lambert = false,
          use_helper = false, use_colors = false, use_opacity = 1, use_scale = true,
          single_bin_verts, single_bin_norms,

          tipscale = 0.5;

      if (!box_option && this.options.Lego)
         box_option = (this.options.Lego === 1) ? 10 : this.options.Lego;

      if ((this.options.GLBox === 11) || (this.options.GLBox === 12)) {

         tipscale = 0.4;
         use_lambert = true;
         if (this.options.GLBox === 12) use_colors = true;

         let geom = main.webgl ? new SphereGeometry(0.5, 16, 12) : new SphereGeometry(0.5, 8, 6);
         geom.applyMatrix4( new Matrix4().makeRotationX( Math.PI / 2 ) );
         geom.computeVertexNormals();

         let indx = geom.getIndex().array,
             pos = geom.getAttribute('position').array,
             norm = geom.getAttribute('normal').array;

         buffer_size = indx.length*3;
         single_bin_verts = new Float32Array(buffer_size);
         single_bin_norms = new Float32Array(buffer_size);

         for (let k = 0; k < indx.length; ++k) {
            let iii = indx[k]*3;
            single_bin_verts[k*3] = pos[iii];
            single_bin_verts[k*3+1] = pos[iii+1];
            single_bin_verts[k*3+2] = pos[iii+2];
            single_bin_norms[k*3] = norm[iii];
            single_bin_norms[k*3+1] = norm[iii+1];
            single_bin_norms[k*3+2] = norm[iii+2];
         }

      } else {

         let indicies = Box3D.Indexes,
             normals = Box3D.Normals,
             vertices = Box3D.Vertices;

         buffer_size = indicies.length*3;
         single_bin_verts = new Float32Array(buffer_size);
         single_bin_norms = new Float32Array(buffer_size);

         for (let k = 0, nn = -3; k < indicies.length; ++k) {
            let vert = vertices[indicies[k]];
            single_bin_verts[k*3]   = vert.x-0.5;
            single_bin_verts[k*3+1] = vert.y-0.5;
            single_bin_verts[k*3+2] = vert.z-0.5;

            if (k%6 === 0) nn+=3;
            single_bin_norms[k*3]   = normals[nn];
            single_bin_norms[k*3+1] = normals[nn+1];
            single_bin_norms[k*3+2] = normals[nn+2];
         }
         use_helper = true;

         if (box_option === 12) {
            use_colors = true;
         } else if (box_option === 13) {
            use_colors = true;
            use_helper = false;
         }  else if (this.options.GLColor) {
            use_colors = true;
            use_opacity = 0.5;
            use_scale = false;
            use_helper = false;
            use_lambert = true;
         }
      }

      if (use_scale)
         use_scale = (this.gminbin || this.gmaxbin) ? 1 / Math.max(Math.abs(this.gminbin), Math.abs(this.gmaxbin)) : 1;

      let i1 = this.getSelectIndex('x', 'left', 0.5),
          i2 = this.getSelectIndex('x', 'right', 0),
          j1 = this.getSelectIndex('y', 'left', 0.5),
          j2 = this.getSelectIndex('y', 'right', 0),
          k1 = this.getSelectIndex('z', 'left', 0.5),
          k2 = this.getSelectIndex('z', 'right', 0);

      if ((i2 <= i1) || (j2 <= j1) || (k2 <= k1))
         return false;

      let scalex = (main.grx(histo.fXaxis.GetBinLowEdge(i2+1)) - main.grx(histo.fXaxis.GetBinLowEdge(i1+1))) / (i2-i1),
          scaley = (main.gry(histo.fYaxis.GetBinLowEdge(j2+1)) - main.gry(histo.fYaxis.GetBinLowEdge(j1+1))) / (j2-j1),
          scalez = (main.grz(histo.fZaxis.GetBinLowEdge(k2+1)) - main.grz(histo.fZaxis.GetBinLowEdge(k1+1))) / (k2-k1),
          nbins = 0, i, j, k, wei, bin_content, cols_size = [], num_colors = 0, cols_sequence = [],
          cntr = use_colors ? this.getContour() : null,
          palette = use_colors ? this.getHistPalette() : null;

      for (i = i1; i < i2; ++i) {
         for (j = j1; j < j2; ++j) {
            for (k = k1; k < k2; ++k) {
               bin_content = histo.getBinContent(i+1, j+1, k+1);
               if (!this.options.GLColor && ((bin_content === 0) || (bin_content < this.gminbin))) continue;
               wei = use_scale ? Math.pow(Math.abs(bin_content*use_scale), 0.3333) : 1;
               if (wei < 1e-3) continue; // do not draw empty or very small bins

               nbins++;

               if (!use_colors) continue;

               let colindx = cntr.getPaletteIndex(palette, bin_content);
               if (colindx !== null) {
                  if (cols_size[colindx] === undefined) {
                     cols_size[colindx] = 0;
                     cols_sequence[colindx] = num_colors++;
                  }
                  cols_size[colindx]+=1;
               } else {
                  console.error(`not found color for value = ${bin_content}`);
               }
            }
         }
      }

      if (!use_colors) {
         cols_size.push(nbins);
         num_colors = 1;
         cols_sequence = [0];
      }

      const cols_nbins = new Array(num_colors),
            bin_verts = new Array(num_colors),
            bin_norms = new Array(num_colors),
            bin_tooltips = new Array(num_colors),
            helper_kind = new Array(num_colors),
            helper_indexes = new Array(num_colors),  // helper_kind == 1, use original vertices
            helper_positions = new Array(num_colors);  // helper_kind == 2, all vertices copied into separate buffer

      for(let ncol = 0; ncol < cols_size.length; ++ncol) {
         if (!cols_size[ncol]) continue; // ignore dummy colors

         nbins = cols_size[ncol]; // how many bins with specified color
         let nseq = cols_sequence[ncol];

         cols_nbins[nseq] = helper_kind[nseq] = 0; // counter for the filled bins

         // 1 - use same vertices to create helper, one can use maximal 64K vertices
         // 2 - all vertices copied into separate buffer
         if (use_helper)
            helper_kind[nseq] = (nbins * buffer_size / 3 > 0xFFF0) ? 2 : 1;

         bin_verts[nseq] = new Float32Array(nbins * buffer_size);
         bin_norms[nseq] = new Float32Array(nbins * buffer_size);
         bin_tooltips[nseq] = new Int32Array(nbins);

         if (helper_kind[nseq] === 1)
            helper_indexes[nseq] = new Uint16Array(nbins * Box3D.MeshSegments.length);

         if (helper_kind[nseq] === 2)
            helper_positions[nseq] = new Float32Array(nbins * Box3D.Segments.length * 3);
      }

      let binx, grx, biny, gry, binz, grz;

      for (i = i1; i < i2; ++i) {
         binx = histo.fXaxis.GetBinCenter(i+1); grx = main.grx(binx);
         for (j = j1; j < j2; ++j) {
            biny = histo.fYaxis.GetBinCenter(j+1); gry = main.gry(biny);
            for (k = k1; k < k2; ++k) {
               bin_content = histo.getBinContent(i+1, j+1, k+1);
               if (!this.options.GLColor && ((bin_content === 0) || (bin_content < this.gminbin))) continue;

               wei = use_scale ? Math.pow(Math.abs(bin_content*use_scale), 0.3333) : 1;
               if (wei < 1e-3) continue; // do not show very small bins

               let nseq = 0;
               if (use_colors) {
                  let colindx = cntr.getPaletteIndex(palette, bin_content);
                  if (colindx === null) continue;
                  nseq = cols_sequence[colindx];
               }

               nbins = cols_nbins[nseq];

               binz = histo.fZaxis.GetBinCenter(k+1); grz = main.grz(binz);

               // remember bin index for tooltip
               bin_tooltips[nseq][nbins] = histo.getBin(i+1, j+1, k+1);

               let vvv = nbins * buffer_size, bin_v = bin_verts[nseq], bin_n = bin_norms[nseq];

               // Grab the coordinates and scale that are being assigned to each bin
               for (let vi = 0; vi < buffer_size; vi+=3, vvv+=3) {
                  bin_v[vvv]   = grx + single_bin_verts[vi]*scalex*wei;
                  bin_v[vvv+1] = gry + single_bin_verts[vi+1]*scaley*wei;
                  bin_v[vvv+2] = grz + single_bin_verts[vi+2]*scalez*wei;

                  bin_n[vvv]   = single_bin_norms[vi];
                  bin_n[vvv+1] = single_bin_norms[vi+1];
                  bin_n[vvv+2] = single_bin_norms[vi+2];
               }

               if (helper_kind[nseq] === 1) {
                  // reuse vertices created for the mesh
                  let helper_segments = Box3D.MeshSegments;
                  vvv = nbins * helper_segments.length;
                  let shift = Math.round(nbins * buffer_size / 3),
                     helper_i = helper_indexes[nseq];
                  for (let n = 0; n < helper_segments.length; ++n)
                     helper_i[vvv + n] = shift + helper_segments[n];
               }

               if (helper_kind[nseq] === 2) {
                  let helper_segments = Box3D.Segments,
                      helper_p = helper_positions[nseq];
                  vvv = nbins * helper_segments.length * 3;
                  for (let n=0;n<helper_segments.length;++n, vvv+=3) {
                     let vert = Box3D.Vertices[helper_segments[n]];
                     helper_p[vvv]   = grx + (vert.x-0.5)*scalex*wei;
                     helper_p[vvv+1] = gry + (vert.y-0.5)*scaley*wei;
                     helper_p[vvv+2] = grz + (vert.z-0.5)*scalez*wei;
                  }
               }

               cols_nbins[nseq] = nbins+1;
            }
         }
      }

      for(let ncol = 0; ncol < cols_size.length; ++ncol) {
         if (!cols_size[ncol]) continue; // ignore dummy colors

         let nseq = cols_sequence[ncol];

         // BufferGeometries that store geometry of all bins
         let all_bins_buffgeom = new BufferGeometry();

         // Create mesh from bin buffergeometry
         all_bins_buffgeom.setAttribute('position', new BufferAttribute(bin_verts[nseq], 3));
         all_bins_buffgeom.setAttribute('normal', new BufferAttribute(bin_norms[nseq], 3));

         if (use_colors) fillcolor = this.fPalette.getColor(ncol);

         const material = use_lambert ? new MeshLambertMaterial({ color: fillcolor, opacity: use_opacity, transparent: (use_opacity < 1), vertexColors: false })
                                      : new MeshBasicMaterial({ color: fillcolor, opacity: use_opacity, vertexColors: false }),
              combined_bins = new Mesh(all_bins_buffgeom, material);

         combined_bins.bins = bin_tooltips[nseq];
         combined_bins.bins_faces = buffer_size/9;
         combined_bins.painter = this;

         combined_bins.scalex = tipscale*scalex;
         combined_bins.scaley = tipscale*scaley;
         combined_bins.scalez = tipscale*scalez;
         combined_bins.tip_color = (histo.fFillColor === 3) ? 0xFF0000 : 0x00FF00;
         combined_bins.use_scale = use_scale;

         combined_bins.tooltip = function(intersect) {
            if (!Number.isInteger(intersect.faceIndex)) {
               console.error(`intersect.faceIndex not provided, three.js version ${REVISION}`);
               return null;
            }
            let indx = Math.floor(intersect.faceIndex / this.bins_faces);
            if ((indx < 0) || (indx >= this.bins.length)) return null;

            let p = this.painter,
                histo = p.getHisto(),
                main = p.getFramePainter(),
                tip = p.get3DToolTip(this.bins[indx]),
                grx = main.grx(histo.fXaxis.GetBinCoord(tip.ix-0.5)),
                gry = main.gry(histo.fYaxis.GetBinCoord(tip.iy-0.5)),
                grz = main.grz(histo.fZaxis.GetBinCoord(tip.iz-0.5)),
                wei = this.use_scale ? Math.pow(Math.abs(tip.value*this.use_scale), 0.3333) : 1;

            tip.x1 = grx - this.scalex*wei; tip.x2 = grx + this.scalex*wei;
            tip.y1 = gry - this.scaley*wei; tip.y2 = gry + this.scaley*wei;
            tip.z1 = grz - this.scalez*wei; tip.z2 = grz + this.scalez*wei;

            tip.color = this.tip_color;

            return tip;
         };

         main.toplevel.add(combined_bins);

         if (helper_kind[nseq] > 0) {
            let lcolor = this.getColor(histo.fLineColor),
                helper_material = new LineBasicMaterial({ color: lcolor }),
                lines = null;

            if (helper_kind[nseq] === 1) {
               // reuse positions from the mesh - only special index was created
               lines = createLineSegments(bin_verts[nseq], helper_material, helper_indexes[nseq]);
            } else {
               lines = createLineSegments(helper_positions[nseq], helper_material);
            }

            main.toplevel.add(lines);
         }
      }

      return true;
   }

   /** @summary Redraw TH3 histogram */
   async redraw(reason) {

      let main = this.getFramePainter(), // who makes axis and 3D drawing
          histo = this.getHisto(),
          pr = Promise.resolve(true);

      if (reason == 'resize') {

         if (main.resize3D()) main.render3D();

      } else {
         assignFrame3DMethods(main);
         pr = main.create3DScene(this.options.Render3D, this.options.x3dscale, this.options.y3dscale).then(() => {
            main.setAxesRanges(histo.fXaxis, this.xmin, this.xmax, histo.fYaxis, this.ymin, this.ymax, histo.fZaxis, this.zmin, this.zmax, this);
            main.set3DOptions(this.options);
            main.drawXYZ(main.toplevel, TAxisPainter, { zoom: settings.Zooming, ndim: 3, draw: this.options.Axis !== -1 });
            return this.draw3DBins();
         }).then(() => {
            main.render3D();
            this.updateStatWebCanvas();
            main.addKeysHandler();
         });
      }

      return pr.then(() => this.drawHistTitle()).then(() => this);
   }

   /** @summary Fill pad toolbar with TH3-related functions */
   fillToolbar() {
      let pp = this.getPadPainter();
      if (!pp) return;

      pp.addPadButton('auto_zoom', 'Unzoom all axes', 'ToggleZoom', 'Ctrl *');
      if (this.draw_content)
         pp.addPadButton('statbox', 'Toggle stat box', 'ToggleStatBox');
      pp.showPadButtons();
   }

   /** @summary Checks if it makes sense to zoom inside specified axis range */
   canZoomInside(axis,min,max) {
      let obj = this.getHisto();
      if (obj) obj = obj['f'+axis.toUpperCase()+'axis'];
      return !obj || (obj.FindBin(max,0.5) - obj.FindBin(min,0) > 1);
   }

   /** @summary Perform automatic zoom inside non-zero region of histogram */
   autoZoom() {
      let i1 = this.getSelectIndex('x', 'left'),
          i2 = this.getSelectIndex('x', 'right'),
          j1 = this.getSelectIndex('y', 'left'),
          j2 = this.getSelectIndex('y', 'right'),
          k1 = this.getSelectIndex('z', 'left'),
          k2 = this.getSelectIndex('z', 'right'),
          i,j,k, histo = this.getObject();

      if ((i1 === i2) || (j1 === j2) || (k1 === k2)) return;

      // first find minimum
      let min = histo.getBinContent(i1 + 1, j1 + 1, k1+1);
      for (i = i1; i < i2; ++i)
         for (j = j1; j < j2; ++j)
            for (k = k1; k < k2; ++k)
               min = Math.min(min, histo.getBinContent(i+1, j+1, k+1));

      if (min > 0) return; // if all points positive, no chance for autoscale

      let ileft = i2, iright = i1, jleft = j2, jright = j1, kleft = k2, kright = k1;

      for (i = i1; i < i2; ++i)
         for (j = j1; j < j2; ++j)
            for (k = k1; k < k2; ++k)
               if (histo.getBinContent(i+1, j+1, k+1) > min) {
                  if (i < ileft) ileft = i;
                  if (i >= iright) iright = i + 1;
                  if (j < jleft) jleft = j;
                  if (j >= jright) jright = j + 1;
                  if (k < kleft) kleft = k;
                  if (k >= kright) kright = k + 1;
               }

      let xmin, xmax, ymin, ymax, zmin, zmax, isany = false;

      if ((ileft === iright-1) && (ileft > i1+1) && (iright < i2-1)) { ileft--; iright++; }
      if ((jleft === jright-1) && (jleft > j1+1) && (jright < j2-1)) { jleft--; jright++; }
      if ((kleft === kright-1) && (kleft > k1+1) && (kright < k2-1)) { kleft--; kright++; }

      if ((ileft > i1 || iright < i2) && (ileft < iright - 1)) {
         xmin = histo.fXaxis.GetBinLowEdge(ileft+1);
         xmax = histo.fXaxis.GetBinLowEdge(iright+1);
         isany = true;
      }

      if ((jleft > j1 || jright < j2) && (jleft < jright - 1)) {
         ymin = histo.fYaxis.GetBinLowEdge(jleft+1);
         ymax = histo.fYaxis.GetBinLowEdge(jright+1);
         isany = true;
      }

      if ((kleft > k1 || kright < k2) && (kleft < kright - 1)) {
         zmin = histo.fZaxis.GetBinLowEdge(kleft+1);
         zmax = histo.fZaxis.GetBinLowEdge(kright+1);
         isany = true;
      }

      if (isany)
         return this.getFramePainter().zoom(xmin, xmax, ymin, ymax, zmin, zmax);
   }

   /** @summary Fill histogram context menu */
   fillHistContextMenu(menu) {

      let opts = this.getSupportedDrawOptions();

      menu.addDrawMenu('Draw with', opts, arg => {
         if (arg === 'inspect')
            return this.showInspector();

         this.decodeOptions(arg);

         this.interactiveRedraw(true, 'drawopt');
      });
   }

   /** @summary draw TH3 object */
   static async draw(dom, histo, opt) {

      let painter = new TH3Painter(dom, histo);
      painter.mode3d = true;

      return ensureTCanvas(painter, '3d').then(() => {
         painter.setAsMainPainter();
         painter.decodeOptions(opt);
         painter.checkPadRange();
         painter.scanContent();
         return painter.redraw();
      }).then(() => {
         let stats = painter.createStat(); // only when required
         if (stats)
            return TPavePainter.draw(dom, stats, '');
      }).then(() => {
         painter.fillToolbar();
         return painter;
      });
   }

} // class TH3Painter

var TH3Painter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
TH3Painter: TH3Painter
});

/// CSG library for THREE.js

const EPSILON = 1e-5,
      COPLANAR = 0,
      FRONT = 1,
      BACK = 2,
      SPANNING = FRONT | BACK;

class Vertex {

   constructor(x, y, z, nx, ny, nz) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.nx = nx;
      this.ny = ny;
      this.nz = nz;
   }

   setnormal(nx, ny, nz) {
      this.nx = nx;
      this.ny = ny;
      this.nz = nz;
   }

   clone() {
      return new Vertex( this.x, this.y, this.z, this.nx, this.ny, this.nz);
   }

   add( vertex ) {
      this.x += vertex.x;
      this.y += vertex.y;
      this.z += vertex.z;
      return this;
   }

   subtract( vertex ) {
      this.x -= vertex.x;
      this.y -= vertex.y;
      this.z -= vertex.z;
      return this;
   }

   // multiplyScalar( scalar ) {
   //   this.x *= scalar;
   //   this.y *= scalar;
   //   this.z *= scalar;
   //   return this;
   // }

   // cross( vertex ) {
   //    let x = this.x, y = this.y, z = this.z,
   //        vx = vertex.x, vy = vertex.y, vz = vertex.z;
   //
   //    this.x = y * vz - z * vy;
   //    this.y = z * vx - x * vz;
   //    this.z = x * vy - y * vx;
   //
   //    return this;
   // }

   cross3( vx, vy, vz ) {
      let x = this.x, y = this.y, z = this.z;

      this.x = y * vz - z * vy;
      this.y = z * vx - x * vz;
      this.z = x * vy - y * vx;

      return this;
   }


   normalize() {
      let length = Math.sqrt( this.x**2 + this.y**2 + this.z**2 );

      this.x /= length;
      this.y /= length;
      this.z /= length;

      return this;
   }

   dot( vertex ) {
      return this.x*vertex.x + this.y*vertex.y + this.z*vertex.z;
   }

   diff( vertex ) {
      let dx = (this.x - vertex.x),
          dy = (this.y - vertex.y),
          dz = (this.z - vertex.z),
          len2 = this.x**2 + this.y**2 + this.z**2;

      return (dx**2 + dy**2 + dz**2) / (len2 > 0 ? len2 : 1e-10);
   }

/*
   lerp( a, t ) {
      this.add(
         a.clone().subtract( this ).multiplyScalar( t )
      );

      this.normal.add(
         a.normal.clone().sub( this.normal ).multiplyScalar( t )
      );

      //this.uv.add(
      //   a.uv.clone().sub( this.uv ).multiplyScalar( t )
      //);

      return this;
   };

   interpolate( other, t ) {
      return this.clone().lerp( other, t );
   };
*/

   interpolate( a, t ) {
      let t1 = 1 - t;
      return new Vertex(this.x*t1 + a.x*t, this.y*t1 + a.y*t, this.z*t1 + a.z*t,
                        this.nx*t1 + a.nx*t, this.ny*t1 + a.ny*t, this.nz*t1 + a.nz*t);
   }

   applyMatrix4(m) {

      // input: Matrix4 affine matrix

      let x = this.x, y = this.y, z = this.z, e = m.elements;

      this.x = e[0] * x + e[4] * y + e[8]  * z + e[12];
      this.y = e[1] * x + e[5] * y + e[9]  * z + e[13];
      this.z = e[2] * x + e[6] * y + e[10] * z + e[14];

      x = this.nx; y = this.ny; z = this.nz;

      this.nx = e[0] * x + e[4] * y + e[8]  * z;
      this.ny = e[1] * x + e[5] * y + e[9]  * z;
      this.nz = e[2] * x + e[6] * y + e[10] * z;

      return this;
   }

} // class Vertex


class Polygon {

   constructor(vertices, parent, more) {
      this.vertices = vertices || [];
      this.nsign = 1;
      if (parent)
         this.copyProperties(parent, more);
      else if (this.vertices.length > 0)
         this.calculateProperties();
   }

   copyProperties(parent, more) {
      this.normal = parent.normal; // .clone();
      this.w = parent.w;
      this.nsign = parent.nsign;
      if (more && (parent.id !== undefined)) {
         this.id = parent.id;
         this.parent = parent;
      }
      return this;
   }

   calculateProperties(force) {
      if (this.normal && !force) return;

      let a = this.vertices[0],
          b = this.vertices[1],
          c = this.vertices[2];

      this.nsign = 1;

      //this.normal = b.clone().subtract( a ).cross( c.clone().subtract( a ) ).normalize();

      this.normal = new Vertex(b.x - a.x, b.y - a.y, b.z - a.z, 0, 0, 0).cross3(c.x - a.x, c.y - a.y, c.z - a.z).normalize();

      this.w = this.normal.dot( a );
      return this;
   }

   clone() {
      let vertice_count = this.vertices.length,
          vertices = [];

      for (let i = 0; i < vertice_count; ++i )
         vertices.push( this.vertices[i].clone() );

      return new Polygon(vertices, this);
   }

   flip() {

      /// normal is not changed, only sign variable
      //this.normal.multiplyScalar( -1 );
      //this.w *= -1;

      this.nsign *= -1;

      this.vertices.reverse();

      return this;
   }

   classifyVertex( vertex ) {
      let side_value = this.nsign * (this.normal.dot( vertex ) - this.w);

      if ( side_value < -EPSILON ) return BACK;
      if ( side_value > EPSILON ) return FRONT;
      return COPLANAR;
   }

   classifySide( polygon ) {
      let num_positive = 0, num_negative = 0,
          vertice_count = polygon.vertices.length;

      for (let i = 0; i < vertice_count; ++i ) {
         let classification = this.classifyVertex( polygon.vertices[i] );
         if ( classification === FRONT ) {
            ++num_positive;
         } else if ( classification === BACK ) {
            ++num_negative;
         }
      }

      if ( num_positive > 0 && num_negative === 0 ) return FRONT;
      if ( num_positive === 0 && num_negative > 0 ) return BACK;
      if ( num_positive === 0 && num_negative === 0 ) return COPLANAR;
      return SPANNING;
   }

   splitPolygon( polygon, coplanar_front, coplanar_back, front, back ) {
      let classification = this.classifySide( polygon );

      if ( classification === COPLANAR ) {

         ( (this.nsign * polygon.nsign * this.normal.dot( polygon.normal ) > 0) ? coplanar_front : coplanar_back ).push( polygon );

      } else if ( classification === FRONT ) {

         front.push( polygon );

      } else if ( classification === BACK ) {

         back.push( polygon );

      } else {

         let vertice_count = polygon.vertices.length,
             nnx = this.normal.x,
             nny = this.normal.y,
             nnz = this.normal.z,
             i, j, ti, tj, vi, vj,
             t, v,
             f = [], b = [];

         for ( i = 0; i < vertice_count; ++i ) {

            j = (i + 1) % vertice_count;
            vi = polygon.vertices[i];
            vj = polygon.vertices[j];
            ti = this.classifyVertex( vi );
            tj = this.classifyVertex( vj );

            if ( ti != BACK ) f.push( vi );
            if ( ti != FRONT ) b.push( vi );
            if ( (ti | tj) === SPANNING ) {
               // t = ( this.w - this.normal.dot( vi ) ) / this.normal.dot( vj.clone().subtract( vi ) );
               //v = vi.clone().lerp( vj, t );

               t = (this.w - (nnx*vi.x + nny*vi.y + nnz*vi.z)) / (nnx*(vj.x-vi.x) + nny*(vj.y-vi.y) + nnz*(vj.z-vi.z));

               v = vi.interpolate( vj, t );
               f.push( v );
               b.push( v );
            }
         }

         //if ( f.length >= 3 ) front.push( new Polygon( f ).calculateProperties() );
         //if ( b.length >= 3 ) back.push( new Polygon( b ).calculateProperties() );
         if ( f.length >= 3 ) front.push( new Polygon( f, polygon, true ) );
         if ( b.length >= 3 ) back.push( new Polygon( b, polygon, true ) );
      }
   }

} // class Polygon


class Node {
   constructor(polygons, nodeid) {
      this.polygons = [];
      this.front = this.back = undefined;

      if (!polygons) return;

      this.divider = polygons[0].clone();

      let polygon_count = polygons.length,
          front = [], back = [];

      for (let i = 0; i < polygon_count; ++i) {
         if (nodeid !== undefined) {
            polygons[i].id = nodeid++;
            delete polygons[i].parent;
         }

         // by difinition polygon should be COPLANAR for itself
         if (i == 0)
            this.polygons.push(polygons[0]);
         else
            this.divider.splitPolygon( polygons[i], this.polygons, this.polygons, front, back );
      }

      if (nodeid !== undefined) this.maxnodeid = nodeid;

      if (front.length > 0)
         this.front = new Node( front );

      if (back.length > 0)
         this.back = new Node( back );
   }

   //isConvex(polygons) {
   //   let i, j, len = polygons.length;
   //   for ( i = 0; i < len; ++i )
   //      for ( j = 0; j < len; ++j )
   //         if ( i !== j && polygons[i].classifySide( polygons[j] ) !== BACK ) return false;
   //   return true;
   //}

   build( polygons ) {
      let polygon_count = polygons.length,
          first = 0, front = [], back = [];

      if ( !this.divider ) {
         this.divider = polygons[0].clone();
         this.polygons.push(polygons[0]);
         first = 1;
      }

      for (let i = first; i < polygon_count; ++i )
         this.divider.splitPolygon( polygons[i], this.polygons, this.polygons, front, back );

      if (front.length > 0) {
         if ( !this.front ) this.front = new Node();
         this.front.build( front );
      }

      if (back.length > 0) {
         if ( !this.back ) this.back = new Node();
         this.back.build( back );
      }
   }

   collectPolygons(arr) {
      if (arr === undefined)
         arr = [];
      let len = this.polygons.length;
      for (let i = 0; i < len; ++i)
         arr.push(this.polygons[i]);
      this.front?.collectPolygons(arr);
      this.back?.collectPolygons(arr);
      return arr;
   }

   numPolygons() {
      return this.polygons.length + (this.front?.numPolygons() || 0) + (this.back?.numPolygons() || 0);
   }

   clone() {
      let node = new Node();

      node.divider = this.divider?.clone();
      node.polygons = this.polygons.map( polygon => polygon.clone() );
      node.front = this.front?.clone();
      node.back = this.back?.clone();

      return node;
   }

   invert() {
      let polygon_count = this.polygons.length;

      for (let i = 0; i < polygon_count; ++i )
         this.polygons[i].flip();

      this.divider.flip();
      if ( this.front ) this.front.invert();
      if ( this.back ) this.back.invert();

      let temp = this.front;
      this.front = this.back;
      this.back = temp;

      return this;
   }

   clipPolygons( polygons ) {

      if ( !this.divider ) return polygons.slice();

      let polygon_count = polygons.length, front = [], back = [];

      for (let i = 0; i < polygon_count; ++i )
         this.divider.splitPolygon( polygons[i], front, back, front, back );

      if ( this.front ) front = this.front.clipPolygons( front );
      if ( this.back ) back = this.back.clipPolygons( back );
      else back = [];

      return front.concat( back );
   }

   clipTo( node ) {
      this.polygons = node.clipPolygons( this.polygons );
      if ( this.front ) this.front.clipTo( node );
      if ( this.back ) this.back.clipTo( node );
   }

 } // class Node


function createBufferGeometry(polygons) {
   let i, j, polygon_count = polygons.length, buf_size = 0;

   for ( i = 0; i < polygon_count; ++i )
      buf_size += (polygons[i].vertices.length - 2) * 9;

   let positions_buf = new Float32Array(buf_size),
       normals_buf = new Float32Array(buf_size),
       iii = 0, polygon;

   function CopyVertex(vertex) {

      positions_buf[iii] = vertex.x;
      positions_buf[iii+1] = vertex.y;
      positions_buf[iii+2] = vertex.z;

      normals_buf[iii] = polygon.nsign * vertex.nx;
      normals_buf[iii+1] = polygon.nsign * vertex.ny;
      normals_buf[iii+2] = polygon.nsign * vertex.nz;
      iii+=3;
   }

   for ( i = 0; i < polygon_count; ++i ) {
      polygon = polygons[i];
      for ( j = 2; j < polygon.vertices.length; ++j ) {
         CopyVertex(polygon.vertices[0]);
         CopyVertex(polygon.vertices[j-1]);
         CopyVertex(polygon.vertices[j]);
      }
   }

   let geometry = new BufferGeometry();
   geometry.setAttribute('position', new BufferAttribute(positions_buf, 3));
   geometry.setAttribute('normal', new BufferAttribute(normals_buf, 3));

   // geometry.computeVertexNormals();
   return geometry;
}


class Geometry {

   constructor(geometry, transfer_matrix, nodeid, flippedMesh) {
      // Convert BufferGeometry to ThreeBSP

      if ( geometry instanceof Mesh ) {
         // #todo: add hierarchy support
         geometry.updateMatrix();
         transfer_matrix = this.matrix = geometry.matrix.clone();
         geometry = geometry.geometry;
      } else if ( geometry instanceof Node ) {
         this.tree = geometry;
         this.matrix = null; // new Matrix4;
         return this;
      } else if ( geometry instanceof BufferGeometry ) {
         let pos_buf = geometry.getAttribute('position').array,
             norm_buf = geometry.getAttribute('normal').array,
             polygons = [], polygon, vert1, vert2, vert3;

         for (let i=0; i < pos_buf.length; i+=9) {
            polygon = new Polygon;

            vert1 = new Vertex( pos_buf[i], pos_buf[i+1], pos_buf[i+2], norm_buf[i], norm_buf[i+1], norm_buf[i+2]);
            if (transfer_matrix) vert1.applyMatrix4(transfer_matrix);

            vert2 = new Vertex( pos_buf[i+3], pos_buf[i+4], pos_buf[i+5], norm_buf[i+3], norm_buf[i+4], norm_buf[i+5]);
            if (transfer_matrix) vert2.applyMatrix4(transfer_matrix);

            vert3 = new Vertex( pos_buf[i+6], pos_buf[i+7], pos_buf[i+8], norm_buf[i+6], norm_buf[i+7], norm_buf[i+8]);
            if (transfer_matrix) vert3.applyMatrix4(transfer_matrix);

            if (flippedMesh) polygon.vertices.push( vert1, vert3, vert2 );
                        else polygon.vertices.push( vert1, vert2, vert3 );

            polygon.calculateProperties(true);
            polygons.push( polygon );
         }

         this.tree = new Node( polygons, nodeid );
         if (nodeid !== undefined) this.maxid = this.tree.maxnodeid;
         return this;

      } else if (geometry.polygons && (geometry.polygons[0] instanceof Polygon)) {
         let polygons = geometry.polygons;

         for (let i = 0; i < polygons.length; ++i) {
            let polygon = polygons[i];
            if (transfer_matrix) {
               let new_vertices = [];

               for (let n = 0; n < polygon.vertices.length; ++n)
                  new_vertices.push(polygon.vertices[n].clone().applyMatrix4(transfer_matrix));

               polygon.vertices = new_vertices;
            }

            polygon.calculateProperties(transfer_matrix);
         }

         this.tree = new Node( polygons, nodeid );
         if (nodeid !== undefined) this.maxid = this.tree.maxnodeid;
         return this;

      } else {
         throw Error('ThreeBSP: Given geometry is unsupported');
      }

      let polygons = [],
          nfaces = geometry.faces.length,
          face, polygon, vertex, normal, useVertexNormals;

      for (let i = 0; i < nfaces; ++i ) {
         face = geometry.faces[i];
         normal = face.normal;
         // faceVertexUvs = geometry.faceVertexUvs[0][i];
         polygon = new Polygon;

         useVertexNormals = face.vertexNormals && (face.vertexNormals.length==3);

         vertex = geometry.vertices[ face.a ];
         if (useVertexNormals) normal = face.vertexNormals[0];
         // uvs = faceVertexUvs ? new Vector2( faceVertexUvs[0].x, faceVertexUvs[0].y ) : null;
         vertex = new Vertex( vertex.x, vertex.y, vertex.z, normal.x, normal.y, normal.z /*face.normal , uvs */ );
         if (transfer_matrix) vertex.applyMatrix4(transfer_matrix);
         polygon.vertices.push( vertex );

         vertex = geometry.vertices[ face.b ];
         if (useVertexNormals) normal = face.vertexNormals[1];
         //uvs = faceVertexUvs ? new Vector2( faceVertexUvs[1].x, faceVertexUvs[1].y ) : null;
         vertex = new Vertex( vertex.x, vertex.y, vertex.z, normal.x, normal.y, normal.z /*face.normal , uvs */ );
         if (transfer_matrix) vertex.applyMatrix4(transfer_matrix);
         polygon.vertices.push( vertex );

         vertex = geometry.vertices[ face.c ];
         if (useVertexNormals) normal = face.vertexNormals[2];
         // uvs = faceVertexUvs ? new Vector2( faceVertexUvs[2].x, faceVertexUvs[2].y ) : null;
         vertex = new Vertex( vertex.x, vertex.y, vertex.z, normal.x, normal.y, normal.z /*face.normal, uvs */ );
         if (transfer_matrix) vertex.applyMatrix4(transfer_matrix);
         polygon.vertices.push( vertex );

         polygon.calculateProperties(true);
         polygons.push( polygon );
      }

      this.tree = new Node( polygons, nodeid );
      if (nodeid !== undefined) this.maxid = this.tree.maxnodeid;
   }

   subtract( other_tree ) {
      let a = this.tree.clone(),
          b = other_tree.tree.clone();

      a.invert();
      a.clipTo( b );
      b.clipTo( a );
      b.invert();
      b.clipTo( a );
      b.invert();
      a.build( b.collectPolygons() );
      a.invert();
      a = new Geometry( a );
      a.matrix = this.matrix;
      return a;
   }

   union( other_tree ) {
      let a = this.tree.clone(),
          b = other_tree.tree.clone();

      a.clipTo( b );
      b.clipTo( a );
      b.invert();
      b.clipTo( a );
      b.invert();
      a.build( b.collectPolygons() );
      a = new Geometry( a );
      a.matrix = this.matrix;
      return a;
   }

   intersect( other_tree ) {
      let a = this.tree.clone(),
          b = other_tree.tree.clone();

      a.invert();
      b.clipTo( a );
      b.invert();
      a.clipTo( b );
      b.clipTo( a );
      a.build( b.collectPolygons() );
      a.invert();
      a = new Geometry( a );
      a.matrix = this.matrix;
      return a;
   }

   tryToCompress(polygons) {

      if (this.maxid === undefined) return;

      let arr = [], parts, foundpair,
          nreduce = 0, n, len = polygons.length,
          p, p1, p2, i1, i2;

      // sort out polygons
      for (n = 0; n < len; ++n) {
         p = polygons[n];
         if (p.id === undefined) continue;
         if (arr[p.id] === undefined) arr[p.id] = [];

         arr[p.id].push(p);
      }

      for(n = 0; n < arr.length; ++n) {
         parts = arr[n];
         if (parts === undefined) continue;

         len = parts.length;

         foundpair = (len > 1);

         while (foundpair) {
            foundpair = false;

            for (i1 = 0; i1 < len-1; ++i1) {
               p1 = parts[i1];
               if (!p1?.parent) continue;
               for (i2 = i1+1; i2 < len; ++i2) {
                  p2 = parts[i2];
                  if (p2 && (p1.parent === p2.parent) && (p1.nsign === p2.nsign)) {

                     if (p1.nsign !== p1.parent.nsign) p1.parent.flip();

                     nreduce++;
                     parts[i1] = p1.parent;
                     parts[i2] = null;
                     if (p1.parent.vertices.length < 3) console.log('something wrong with parent');
                     foundpair = true;
                     break;
                  }
               }
            }
         }
      }

      if (nreduce > 0) {
         polygons.splice(0, polygons.length);

         for(n = 0; n < arr.length; ++n) {
            parts = arr[n];
            if (parts !== undefined)
               for (i1 = 0, len = parts.length; i1 < len; ++i1)
                  if (parts[i1]) polygons.push(parts[i1]);
         }

      }
   }

   direct_subtract( other_tree ) {
      let a = this.tree,
          b = other_tree.tree;
      a.invert();
      a.clipTo( b );
      b.clipTo( a );
      b.invert();
      b.clipTo( a );
      b.invert();
      a.build( b.collectPolygons() );
      a.invert();
      return this;
   }

   direct_union( other_tree ) {
      let a = this.tree,
          b = other_tree.tree;

      a.clipTo( b );
      b.clipTo( a );
      b.invert();
      b.clipTo( a );
      b.invert();
      a.build( b.collectPolygons() );
      return this;
   }

   direct_intersect( other_tree ) {
      let a = this.tree,
          b = other_tree.tree;

      a.invert();
      b.clipTo( a );
      b.invert();
      a.clipTo( b );
      b.clipTo( a );
      a.build( b.collectPolygons() );
      a.invert();
      return this;
   }

   cut_from_plane( other_tree) {
      // just cut peaces from second geometry, which just simple plane

      let a = this.tree,
          b = other_tree.tree;

      a.invert();
      b.clipTo( a );

      return this;
   }

   scale(x,y,z) {
      // try to scale as BufferGeometry
      let polygons = this.tree.collectPolygons();

      for (let i = 0; i < polygons.length; ++i) {
         let polygon = polygons[i];
         for (let k=0; k < polygon.vertices.length; ++k) {
            let v = polygon.vertices[k];
            v.x *= x;
            v.y *= y;
            v.z *= z;
         }
         polygon.calculateProperties(true);
      }
   }

   toPolygons() {
      let polygons = this.tree.collectPolygons();

      this.tryToCompress(polygons);

      for (let i = 0; i < polygons.length; ++i ) {
         delete polygons[i].id;
         delete polygons[i].parent;
      }

      return polygons;
   }

   toBufferGeometry() {
      return createBufferGeometry(this.toPolygons());
   }

   toMesh( material ) {
      let geometry = this.toBufferGeometry(),
         mesh = new Mesh( geometry, material );

      if (this.matrix) {
         mesh.position.setFromMatrixPosition( this.matrix );
         mesh.rotation.setFromRotationMatrix( this.matrix );
      }

      return mesh;
   }

} // class Geometry

/** @summary create geometry to make cut on specified axis
  * @private */
function createNormal(axis_name, pos, size) {
   if (!size || (size < 10000)) size = 10000;

   let vertices;

   switch(axis_name) {
      case 'x':
         vertices = [ new Vertex(pos, -3*size,    size, 1, 0, 0),
                      new Vertex(pos,    size, -3*size, 1, 0, 0),
                      new Vertex(pos,    size,    size, 1, 0, 0) ];
         break;
      case 'y':
         vertices = [ new Vertex(-3*size,  pos,    size, 0, 1, 0),
                      new Vertex(   size,  pos,    size, 0, 1, 0),
                      new Vertex(   size,  pos, -3*size, 0, 1, 0) ];
         break;
      // case 'z':
      default:
         vertices = [ new Vertex(-3*size,    size, pos, 0, 0, 1),
                      new Vertex(   size, -3*size, pos, 0, 0, 1),
                      new Vertex(   size,    size, pos, 0, 0, 1) ];
   }

   let node = new Node([ new Polygon(vertices) ]);

   return new Geometry(node);
}

let cfg = {
   GradPerSegm: 6,       // grad per segment in cylinder/spherical symmetry shapes
   CompressComp: true    // use faces compression in composite shapes
};

function geoCfg(name, value) {
   if (value === undefined)
      return cfg[name];

   cfg[name] = value;
}


const kindGeo = 0,    // TGeoNode / TGeoShape
      kindEve = 1,    // TEveShape / TEveGeoShapeExtract
      kindShape = 2;  // special kind for single shape handling

/** @summary TGeo-related bits
  * @private */
const geoBITS = {
   kVisOverride   : BIT(0),  // volume's vis. attributes are overwritten
   kVisNone       : BIT(1),  // the volume/node is invisible, as well as daughters
   kVisThis       : BIT(2),  // this volume/node is visible
   kVisDaughters  : BIT(3),  // all leaves are visible
   kVisOneLevel   : BIT(4),  // first level daughters are visible (not used)
   kVisStreamed   : BIT(5),  // true if attributes have been streamed
   kVisTouched    : BIT(6),  // true if attributes are changed after closing geom
   kVisOnScreen   : BIT(7),  // true if volume is visible on screen
   kVisContainers : BIT(12), // all containers visible
   kVisOnly       : BIT(13), // just this visible
   kVisBranch     : BIT(14), // only a given branch visible
   kVisRaytrace   : BIT(15)  // raytracing flag
};

const clTGeoBBox = 'TGeoBBox',
      clTGeoArb8 = 'TGeoArb8',
      clTGeoCone = 'TGeoCone',
      clTGeoConeSeg = 'TGeoConeSeg',
      clTGeoTube = 'TGeoTube',
      clTGeoTubeSeg = 'TGeoTubeSeg',
      clTGeoCtub = 'TGeoCtub',
      clTGeoTrd1 = 'TGeoTrd1',
      clTGeoTrd2 = 'TGeoTrd2',
      clTGeoPara = 'TGeoPara',
      clTGeoParaboloid = 'TGeoParaboloid',
      clTGeoPcon = 'TGeoPcon',
      clTGeoPgon = 'TGeoPgon',
      clTGeoShapeAssembly = 'TGeoShapeAssembly',
      clTGeoSphere = 'TGeoSphere',
      clTGeoTorus = 'TGeoTorus',
      clTGeoXtru = 'TGeoXtru',
      clTGeoTrap = 'TGeoTrap',
      clTGeoGtra = 'TGeoGtra',
      clTGeoEltu = 'TGeoEltu',
      clTGeoHype = 'TGeoHype',
      clTGeoCompositeShape = 'TGeoCompositeShape',
      clTGeoHalfSpace = 'TGeoHalfSpace',
      clTGeoScaledShape = 'TGeoScaledShape';

/** @summary Test fGeoAtt bits
  * @private */
function testGeoBit(volume, f) {
   let att = volume.fGeoAtt;
   return att === undefined ? false : ((att & f) !== 0);
}

/** @summary Set fGeoAtt bit
  * @private */
function setGeoBit(volume, f, value) {
   if (volume.fGeoAtt === undefined) return;
   volume.fGeoAtt = value ? (volume.fGeoAtt | f) : (volume.fGeoAtt & ~f);
}

/** @summary Toggle fGeoAttBit
  * @private */
function toggleGeoBit(volume, f) {
   if (volume.fGeoAtt !== undefined)
      volume.fGeoAtt = volume.fGeoAtt ^ (f & 0xffffff);
}

/** @summary Implementation of TGeoVolume::InvisibleAll
  * @private */
function setInvisibleAll(volume, flag) {
   if (flag === undefined) flag = true;

   setGeoBit(volume, geoBITS.kVisThis, !flag);
   // setGeoBit(this, geoBITS.kVisDaughters, !flag);

   if (volume.fNodes)
      for (let n = 0; n < volume.fNodes.arr.length; ++n) {
         let sub = volume.fNodes.arr[n].fVolume;
         setGeoBit(sub, geoBITS.kVisThis, !flag);
         // setGeoBit(sub, geoBITS.kVisDaughters, !flag);
      }
}

const _warn_msgs = {};

/** @summary method used to avoid duplication of warnings
 * @private */
function geoWarn(msg) {
   if (_warn_msgs[msg] !== undefined) return;
   _warn_msgs[msg] = true;
   console.warn(msg);
}

/** @summary Analyze TGeo node kind
 *  @desc  0 - TGeoNode
 *         1 - TEveGeoNode
 *        -1 - unsupported
 * @return detected node kind
 * @private */
function getNodeKind(obj) {
   if (!isObject(obj)) return -1;
   return ('fShape' in obj) && ('fTrans' in obj) ? kindEve : kindGeo;
}

/** @summary Returns number of shapes
  * @desc Used to count total shapes number in composites
  * @private */
function countNumShapes(shape) {
   if (!shape) return 0;
   if (shape._typename !== clTGeoCompositeShape) return 1;
   return countNumShapes(shape.fNode.fLeft) + countNumShapes(shape.fNode.fRight);
}


/** @summary Returns geo object name
  * @desc Can appends some special suffixes
  * @private */
function getObjectName(obj) {
   return obj?.fName ? (obj.fName + (obj.$geo_suffix || '')) : '';
}

/** @summary Check duplicates
  * @private */
function checkDuplicates(parent, chlds) {
   if (parent) {
      if (parent.$geo_checked) return;
      parent.$geo_checked = true;
   }

   let names = [], cnts = [];
   for (let k = 0; k < chlds.length; ++k) {
      let chld = chlds[k];
      if (!chld?.fName) continue;
      if (!chld.$geo_suffix) {
         let indx = names.indexOf(chld.fName);
         if (indx >= 0) {
            let cnt = cnts[indx] || 1;
            while(names.indexOf(chld.fName+'#'+cnt) >= 0) ++cnt;
            chld.$geo_suffix = '#' + cnt;
            cnts[indx] = cnt+1;
         }
      }
      names.push(getObjectName(chld));
   }
}


/** @summary Create normal to plane, defined with three points
  * @private */
function produceNormal(x1,y1,z1, x2,y2,z2, x3,y3,z3) {

   let pA = new Vector3(x1,y1,z1),
       pB = new Vector3(x2,y2,z2),
       pC = new Vector3(x3,y3,z3),
       cb = new Vector3(),
       ab = new Vector3();

   cb.subVectors(pC, pB);
   ab.subVectors(pA, pB);
   cb.cross(ab);

   return cb;
}

// ==========================================================================

/**
  * @summary Helper class for geometry creation
  *
  * @private
  */

class GeometryCreator {
   /** @summary Constructor
     * @param numfaces - number of faces */
   constructor(numfaces) {
      this.nfaces = numfaces;
      this.indx = 0;
      this.pos = new Float32Array(numfaces*9);
      this.norm = new Float32Array(numfaces*9);
   }

   /** @summary Add face with 3 vertices */
   addFace3(x1,y1,z1, x2,y2,z2, x3,y3,z3) {
      let indx = this.indx, pos = this.pos;
      pos[indx] = x1;
      pos[indx+1] = y1;
      pos[indx+2] = z1;
      pos[indx+3] = x2;
      pos[indx+4] = y2;
      pos[indx+5] = z2;
      pos[indx+6] = x3;
      pos[indx+7] = y3;
      pos[indx+8] = z3;
      this.last4 = false;
      this.indx = indx + 9;
   }

   /** @summary Start polygon */
   startPolygon() {}

   /** @summary Stop polygon */
   stopPolygon() {}

   /** @summary Add face with 4 vertices
     * @desc From four vertices one normally creates two faces (1,2,3) and (1,3,4)
     * if (reduce == 1), first face is reduced
     * if (reduce == 2), second face is reduced*/
   addFace4(x1,y1,z1, x2,y2,z2, x3,y3,z3, x4,y4,z4, reduce) {
      let indx = this.indx, pos = this.pos;

      if (reduce !== 1) {
         pos[indx] = x1;
         pos[indx+1] = y1;
         pos[indx+2] = z1;
         pos[indx+3] = x2;
         pos[indx+4] = y2;
         pos[indx+5] = z2;
         pos[indx+6] = x3;
         pos[indx+7] = y3;
         pos[indx+8] = z3;
         indx+=9;
      }

      if (reduce !== 2) {
         pos[indx] = x1;
         pos[indx+1] = y1;
         pos[indx+2] = z1;
         pos[indx+3] = x3;
         pos[indx+4] = y3;
         pos[indx+5] = z3;
         pos[indx+6] = x4;
         pos[indx+7] = y4;
         pos[indx+8] = z4;
         indx+=9;
      }

      this.last4 = (indx !== this.indx + 9);
      this.indx = indx;
   }

   /** @summary Specify normal for face with 4 vertices
     * @desc same as addFace4, assign normals for each individual vertex
     * reduce has same meaning and should be the same */
   setNormal4(nx1,ny1,nz1, nx2,ny2,nz2, nx3,ny3,nz3, nx4,ny4,nz4, reduce) {
      if (this.last4 && reduce)
         return console.error('missmatch between addFace4 and setNormal4 calls');

      let indx = this.indx - (this.last4 ? 18 : 9), norm = this.norm;

      if (reduce!==1) {
         norm[indx] = nx1;
         norm[indx+1] = ny1;
         norm[indx+2] = nz1;
         norm[indx+3] = nx2;
         norm[indx+4] = ny2;
         norm[indx+5] = nz2;
         norm[indx+6] = nx3;
         norm[indx+7] = ny3;
         norm[indx+8] = nz3;
         indx+=9;
      }

      if (reduce!==2) {
         norm[indx] = nx1;
         norm[indx+1] = ny1;
         norm[indx+2] = nz1;
         norm[indx+3] = nx3;
         norm[indx+4] = ny3;
         norm[indx+5] = nz3;
         norm[indx+6] = nx4;
         norm[indx+7] = ny4;
         norm[indx+8] = nz4;
      }
   }

   /** @summary Recalculate Z with provided func */
   recalcZ(func) {
      let pos = this.pos,
          last = this.indx,
          indx = last - (this.last4 ? 18 : 9);

      while (indx < last) {
         pos[indx+2] = func(pos[indx], pos[indx+1], pos[indx+2]);
         indx+=3;
      }
   }

   /** @summary Caclualte normal */
   calcNormal() {
      if (!this.cb) {
         this.pA = new Vector3();
         this.pB = new Vector3();
         this.pC = new Vector3();
         this.cb = new Vector3();
         this.ab = new Vector3();
      }

      this.pA.fromArray(this.pos, this.indx - 9);
      this.pB.fromArray(this.pos, this.indx - 6);
      this.pC.fromArray(this.pos, this.indx - 3);

      this.cb.subVectors(this.pC, this.pB);
      this.ab.subVectors(this.pA, this.pB);
      this.cb.cross(this.ab);

      this.setNormal(this.cb.x, this.cb.y, this.cb.z);
   }

   /** @summary Set normal */
   setNormal(nx,ny,nz) {
      let indx = this.indx - 9, norm = this.norm;

      norm[indx]   = norm[indx+3] = norm[indx+6] = nx;
      norm[indx+1] = norm[indx+4] = norm[indx+7] = ny;
      norm[indx+2] = norm[indx+5] = norm[indx+8] = nz;

      if (this.last4) {
         indx -= 9;
         norm[indx]   = norm[indx+3] = norm[indx+6] = nx;
         norm[indx+1] = norm[indx+4] = norm[indx+7] = ny;
         norm[indx+2] = norm[indx+5] = norm[indx+8] = nz;
      }
   }

   /** @summary Set normal
     * @desc special shortcut, when same normals can be applied for 1-2 point and 3-4 point */
   setNormal_12_34(nx12,ny12,nz12, nx34,ny34,nz34, reduce) {
      if (reduce === undefined) reduce = 0;

      let indx = this.indx - ((reduce > 0) ? 9 : 18), norm = this.norm;

      if (reduce!==1) {
         norm[indx]   = nx12;
         norm[indx+1] = ny12;
         norm[indx+2] = nz12;
         norm[indx+3] = nx12;
         norm[indx+4] = ny12;
         norm[indx+5] = nz12;
         norm[indx+6] = nx34;
         norm[indx+7] = ny34;
         norm[indx+8] = nz34;
         indx+=9;
      }

      if (reduce!==2) {
         norm[indx]   = nx12;
         norm[indx+1] = ny12;
         norm[indx+2] = nz12;
         norm[indx+3] = nx34;
         norm[indx+4] = ny34;
         norm[indx+5] = nz34;
         norm[indx+6] = nx34;
         norm[indx+7] = ny34;
         norm[indx+8] = nz34;
         indx+=9;
      }
   }

   /** @summary Create geometry */
   create() {
      if (this.nfaces !== this.indx/9)
         console.error(`Mismatch with created ${this.nfaces} and filled ${this.indx/9} number of faces`);

      let geometry = new BufferGeometry();
      geometry.setAttribute('position', new BufferAttribute(this.pos, 3));
      geometry.setAttribute('normal', new BufferAttribute(this.norm, 3));
      return geometry;
   }
}

// ================================================================================

/** @summary Helper class for CsgGeometry creation
  *
  * @private
  */

class PolygonsCreator{

   /** @summary constructor */
   constructor() {
      this.polygons = [];
   }

   /** @summary Start polygon */
   startPolygon(normal) {
      this.multi = 1;
      this.mnormal = normal;
   }

   /** @summary Stop polygon */
   stopPolygon() {
      if (!this.multi) return;
      this.multi = 0;
      console.error('Polygon should be already closed at this moment');
   }

   /** @summary Add face with 3 vertices */
   addFace3(x1,y1,z1, x2,y2,z2, x3,y3,z3) {
      this.addFace4(x1,y1,z1, x2,y2,z2, x3,y3,z3, x3,y3,z3, 2);
   }

   /** @summary Add face with 4 vertices
     * @desc From four vertices one normally creates two faces (1,2,3) and (1,3,4)
     * if (reduce == 1), first face is reduced
     * if (reduce == 2), second face is reduced */
   addFace4(x1,y1,z1, x2,y2,z2, x3,y3,z3, x4,y4,z4, reduce) {
      if (reduce === undefined) reduce = 0;

      this.v1 = new Vertex(x1,y1,z1, 0,0,0);
      this.v2 = (reduce === 1) ? null : new Vertex(x2,y2,z2, 0,0,0);
      this.v3 = new Vertex(x3,y3,z3, 0,0,0);
      this.v4 = (reduce === 2) ? null : new Vertex(x4,y4,z4, 0,0,0);

      this.reduce = reduce;

      if (this.multi) {

         if (reduce!==2) console.error('polygon not supported for not-reduced faces');

         let polygon;

         if (this.multi++ === 1) {
            polygon = new Polygon;

            polygon.vertices.push(this.mnormal ? this.v2 : this.v3);
            this.polygons.push(polygon);
         } else {
            polygon = this.polygons[this.polygons.length-1];
            // check that last vertice equals to v2
            let last = this.mnormal ? polygon.vertices[polygon.vertices.length-1] : polygon.vertices[0],
                comp = this.mnormal ? this.v2 : this.v3;

            if (comp.diff(last) > 1e-12)
               console.error('vertex missmatch when building polygon');
         }

         let first = this.mnormal ? polygon.vertices[0] : polygon.vertices[polygon.vertices.length-1],
             next = this.mnormal ? this.v3 : this.v2;

         if (next.diff(first) < 1e-12) {
            //console.log(`polygon closed!!! nvertices = ${polygon.vertices.length}`);
            this.multi = 0;
         } else
         if (this.mnormal) {
            polygon.vertices.push(this.v3);
         } else {
            polygon.vertices.unshift(this.v2);
         }

         return;

      }

      let polygon = new Polygon;

      switch (reduce) {
         case 0: polygon.vertices.push(this.v1, this.v2, this.v3, this.v4); break;
         case 1: polygon.vertices.push(this.v1, this.v3, this.v4); break;
         case 2: polygon.vertices.push(this.v1, this.v2, this.v3); break;
      }

      this.polygons.push(polygon);
   }

   /** @summary Specify normal for face with 4 vertices
     * @desc same as addFace4, assign normals for each individual vertex
     * reduce has same meaning and should be the same */
   setNormal4(nx1,ny1,nz1, nx2,ny2,nz2, nx3,ny3,nz3, nx4,ny4,nz4) {
      this.v1.setnormal(nx1,ny1,nz1);
      if (this.v2) this.v2.setnormal(nx2,ny2,nz2);
      this.v3.setnormal(nx3,ny3,nz3);
      if (this.v4) this.v4.setnormal(nx4,ny4,nz4);
   }

   /** @summary Set normal
     * @desc special shortcut, when same normals can be applied for 1-2 point and 3-4 point */
   setNormal_12_34(nx12,ny12,nz12, nx34,ny34,nz34) {
      this.v1.setnormal(nx12,ny12,nz12);
      if (this.v2) this.v2.setnormal(nx12,ny12,nz12);
      this.v3.setnormal(nx34,ny34,nz34);
      if (this.v4) this.v4.setnormal(nx34,ny34,nz34);
   }

   /** @summary Calculate normal */
   calcNormal() {

      if (!this.cb) {
         this.pA = new Vector3();
         this.pB = new Vector3();
         this.pC = new Vector3();
         this.cb = new Vector3();
         this.ab = new Vector3();
      }

      this.pA.set( this.v1.x, this.v1.y, this.v1.z);

      if (this.reduce !== 1) {
         this.pB.set( this.v2.x, this.v2.y, this.v2.z);
         this.pC.set( this.v3.x, this.v3.y, this.v3.z);
      } else {
         this.pB.set( this.v3.x, this.v3.y, this.v3.z);
         this.pC.set( this.v4.x, this.v4.y, this.v4.z);
      }

      this.cb.subVectors(this.pC, this.pB);
      this.ab.subVectors(this.pA, this.pB);
      this.cb.cross(this.ab);

      this.setNormal(this.cb.x, this.cb.y, this.cb.z);
   }

   /** @summary Set normal*/
   setNormal(nx,ny,nz) {
      this.v1.setnormal(nx,ny,nz);
      if (this.v2) this.v2.setnormal(nx,ny,nz);
      this.v3.setnormal(nx,ny,nz);
      if (this.v4) this.v4.setnormal(nx,ny,nz);
   }

   /** @summary Recalculate Z with provided func */
   recalcZ(func) {
      this.v1.z = func(this.v1.x, this.v1.y, this.v1.z);
      if (this.v2) this.v2.z = func(this.v2.x, this.v2.y, this.v2.z);
      this.v3.z = func(this.v3.x, this.v3.y, this.v3.z);
      if (this.v4) this.v4.z = func(this.v4.x, this.v4.y, this.v4.z);
   }

   /** @summary Create geometry
     * @private */
   create() {
      return { polygons: this.polygons };
   }
}

// ================= all functions to create geometry ===================================

/** @summary Creates cube geometrey
  * @private */
function createCubeBuffer(shape, faces_limit) {

   if (faces_limit < 0) return 12;

   let dx = shape.fDX, dy = shape.fDY, dz = shape.fDZ,
       creator = faces_limit ? new PolygonsCreator : new GeometryCreator(12);

   creator.addFace4(dx,dy,dz, dx,-dy,dz, dx,-dy,-dz, dx,dy,-dz); creator.setNormal(1,0,0);

   creator.addFace4(-dx,dy,-dz, -dx,-dy,-dz, -dx,-dy,dz, -dx,dy,dz); creator.setNormal(-1,0,0);

   creator.addFace4(-dx,dy,-dz, -dx,dy,dz, dx,dy,dz, dx,dy,-dz); creator.setNormal(0,1,0);

   creator.addFace4(-dx,-dy,dz, -dx,-dy,-dz, dx,-dy,-dz, dx,-dy,dz); creator.setNormal(0,-1,0);

   creator.addFace4(-dx,dy,dz, -dx,-dy,dz, dx,-dy,dz, dx,dy,dz); creator.setNormal(0,0,1);

   creator.addFace4(dx,dy,-dz, dx,-dy,-dz, -dx,-dy,-dz, -dx,dy,-dz); creator.setNormal(0,0,-1);

   return creator.create();
}

/** @summary Creates 8 edges geometry
  * @private */
function create8edgesBuffer( v, faces_limit ) {

   let indicies = [4,7,6,5, 0,3,7,4, 4,5,1,0, 6,2,1,5, 7,3,2,6, 1,2,3,0],
        creator = (faces_limit > 0) ? new PolygonsCreator : new GeometryCreator(12);

   for (let n = 0; n < indicies.length; n += 4) {
      let i1 = indicies[n]*3,
          i2 = indicies[n+1]*3,
          i3 = indicies[n+2]*3,
          i4 = indicies[n+3]*3;
      creator.addFace4(v[i1], v[i1+1], v[i1+2], v[i2], v[i2+1], v[i2+2],
                       v[i3], v[i3+1], v[i3+2], v[i4], v[i4+1], v[i4+2]);
      if (n === 0)
         creator.setNormal(0,0,1);
      else if (n === 20)
         creator.setNormal(0,0,-1);
      else
         creator.calcNormal();
   }

   return creator.create();
}

/** @summary Creates PARA geometrey
  * @private */
function createParaBuffer( shape, faces_limit ) {

   if (faces_limit < 0) return 12;

   let txy = shape.fTxy, txz = shape.fTxz, tyz = shape.fTyz, v = [
       -shape.fZ*txz-txy*shape.fY-shape.fX, -shape.fY-shape.fZ*tyz, -shape.fZ,
       -shape.fZ*txz+txy*shape.fY-shape.fX,  shape.fY-shape.fZ*tyz, -shape.fZ,
       -shape.fZ*txz+txy*shape.fY+shape.fX,  shape.fY-shape.fZ*tyz, -shape.fZ,
       -shape.fZ*txz-txy*shape.fY+shape.fX, -shape.fY-shape.fZ*tyz, -shape.fZ,
        shape.fZ*txz-txy*shape.fY-shape.fX, -shape.fY+shape.fZ*tyz,  shape.fZ,
        shape.fZ*txz+txy*shape.fY-shape.fX,  shape.fY+shape.fZ*tyz,  shape.fZ,
        shape.fZ*txz+txy*shape.fY+shape.fX,  shape.fY+shape.fZ*tyz,  shape.fZ,
        shape.fZ*txz-txy*shape.fY+shape.fX, -shape.fY+shape.fZ*tyz,  shape.fZ ];

   return create8edgesBuffer(v, faces_limit );
}

/** @summary Creates Ttrapezoid geometrey
  * @private */
function createTrapezoidBuffer( shape, faces_limit ) {

   if (faces_limit < 0) return 12;

   let y1, y2;
   if (shape._typename == clTGeoTrd1) {
      y1 = y2 = shape.fDY;
   } else {
      y1 = shape.fDy1; y2 = shape.fDy2;
   }

   let v = [
      -shape.fDx1,  y1, -shape.fDZ,
       shape.fDx1,  y1, -shape.fDZ,
       shape.fDx1, -y1, -shape.fDZ,
      -shape.fDx1, -y1, -shape.fDZ,
      -shape.fDx2,  y2,  shape.fDZ,
       shape.fDx2,  y2,  shape.fDZ,
       shape.fDx2, -y2,  shape.fDZ,
      -shape.fDx2, -y2,  shape.fDZ
   ];

   return create8edgesBuffer(v, faces_limit );
}


/** @summary Creates arb8 geometrey
  * @private */
function createArb8Buffer( shape, faces_limit ) {

   if (faces_limit < 0) return 12;

   let vertices = [
      shape.fXY[0][0], shape.fXY[0][1], -shape.fDZ,
      shape.fXY[1][0], shape.fXY[1][1], -shape.fDZ,
      shape.fXY[2][0], shape.fXY[2][1], -shape.fDZ,
      shape.fXY[3][0], shape.fXY[3][1], -shape.fDZ,
      shape.fXY[4][0], shape.fXY[4][1],  shape.fDZ,
      shape.fXY[5][0], shape.fXY[5][1],  shape.fDZ,
      shape.fXY[6][0], shape.fXY[6][1],  shape.fDZ,
      shape.fXY[7][0], shape.fXY[7][1],  shape.fDZ
   ];
   const indicies = [
         4,7,6,  6,5,4,  3,7,4,  4,0,3,
         5,1,0,  0,4,5,  6,2,1,  1,5,6,
         7,3,2,  2,6,7,  1,2,3,  3,0,1 ];

   // detect same vertices on both Z-layers
   for (let side = 0; side < vertices.length; side += vertices.length/2)
      for (let n1 = side; n1 < side + vertices.length/2 - 3 ; n1+=3)
         for (let n2 = n1+3; n2 < side + vertices.length/2 ; n2+=3)
            if ((vertices[n1] === vertices[n2]) &&
                (vertices[n1+1] === vertices[n2+1]) &&
                (vertices[n1+2] === vertices[n2+2])) {
                   for (let k=0;k<indicies.length;++k)
                     if (indicies[k] === n2/3) indicies[k] = n1/3;
               }


   let map = [], // list of existing faces (with all rotations)
       numfaces = 0;

   for (let k = 0; k < indicies.length; k += 3) {
      let id1 = indicies[k]*100   + indicies[k+1]*10 + indicies[k+2],
          id2 = indicies[k+1]*100 + indicies[k+2]*10 + indicies[k],
          id3 = indicies[k+2]*100 + indicies[k]*10   + indicies[k+1];

      if ((indicies[k] == indicies[k+1]) || (indicies[k] == indicies[k+2]) || (indicies[k+1] == indicies[k+2]) ||
          (map.indexOf(id1) >= 0) || (map.indexOf(id2) >= 0) || (map.indexOf(id3) >= 0)) {
         indicies[k] = indicies[k+1] = indicies[k+2] = -1;
      } else {
         map.push(id1,id2,id3);
         numfaces++;
      }
   }

   let creator = faces_limit ? new PolygonsCreator : new GeometryCreator(numfaces);

   for (let n = 0; n < indicies.length; n += 6) {
      let i1 = indicies[n]   * 3,
          i2 = indicies[n+1] * 3,
          i3 = indicies[n+2] * 3,
          i4 = indicies[n+3] * 3,
          i5 = indicies[n+4] * 3,
          i6 = indicies[n+5] * 3,
          norm = null;

      if ((i1 >= 0) && (i4 >= 0) && faces_limit) {
         // try to identify two faces with same normal - very useful if one can create face4
         if (n === 0)
            norm = new Vector3(0,0,1);
         else if (n === 30)
            norm = new Vector3(0,0,-1);
         else {
            let norm1 = produceNormal(vertices[i1], vertices[i1+1], vertices[i1+2],
                                      vertices[i2], vertices[i2+1], vertices[i2+2],
                                      vertices[i3], vertices[i3+1], vertices[i3+2]);

            norm1.normalize();

            let norm2 = produceNormal(vertices[i4], vertices[i4+1], vertices[i4+2],
                                      vertices[i5], vertices[i5+1], vertices[i5+2],
                                      vertices[i6], vertices[i6+1], vertices[i6+2]);

            norm2.normalize();

            if (norm1.distanceToSquared(norm2) < 1e-12) norm = norm1;
         }
      }

      if (norm !== null) {
         creator.addFace4(vertices[i1], vertices[i1+1], vertices[i1+2],
                          vertices[i2], vertices[i2+1], vertices[i2+2],
                          vertices[i3], vertices[i3+1], vertices[i3+2],
                          vertices[i5], vertices[i5+1], vertices[i5+2]);
         creator.setNormal(norm.x, norm.y, norm.z);
      }  else {
         if (i1 >= 0) {
            creator.addFace3(vertices[i1], vertices[i1+1], vertices[i1+2],
                             vertices[i2], vertices[i2+1], vertices[i2+2],
                             vertices[i3], vertices[i3+1], vertices[i3+2]);
            creator.calcNormal();
         }
         if (i4 >= 0) {
            creator.addFace3(vertices[i4], vertices[i4+1], vertices[i4+2],
                             vertices[i5], vertices[i5+1], vertices[i5+2],
                             vertices[i6], vertices[i6+1], vertices[i6+2]);
            creator.calcNormal();
         }
      }
   }

   return creator.create();
}

/** @summary Creates sphere geometrey
  * @private */
function createSphereBuffer( shape, faces_limit ) {
   let radius = [shape.fRmax, shape.fRmin],
       phiStart = shape.fPhi1,
       phiLength = shape.fPhi2 - shape.fPhi1,
       thetaStart = shape.fTheta1,
       thetaLength = shape.fTheta2 - shape.fTheta1,
       widthSegments = shape.fNseg,
       heightSegments = shape.fNz,
       noInside = (radius[1] <= 0);

   if (faces_limit > 0) {
      let fact = (noInside ? 2 : 4) * widthSegments * heightSegments / faces_limit;

      if (fact > 1.) {
         widthSegments = Math.max(4, Math.floor(widthSegments/Math.sqrt(fact)));
         heightSegments = Math.max(4, Math.floor(heightSegments/Math.sqrt(fact)));
      }
   }

   let numoutside = widthSegments * heightSegments * 2,
       numtop = widthSegments * 2,
       numbottom = widthSegments * 2,
       numcut = phiLength === 360 ? 0 : heightSegments * (noInside ? 2 : 4),
       epsilon = 1e-10;

   if (noInside) numbottom = numtop = widthSegments;

   if (faces_limit < 0) return numoutside * (noInside ? 1 : 2) + numtop + numbottom + numcut;

   let _sinp = new Float32Array(widthSegments+1),
       _cosp = new Float32Array(widthSegments+1),
       _sint = new Float32Array(heightSegments+1),
       _cost = new Float32Array(heightSegments+1);

   for (let n = 0; n <= heightSegments; ++n) {
      let theta = (thetaStart + thetaLength/heightSegments*n)*Math.PI/180;
      _sint[n] = Math.sin(theta);
      _cost[n] = Math.cos(theta);
   }

   for (let n = 0; n <= widthSegments; ++n) {
      let phi = (phiStart + phiLength/widthSegments*n)*Math.PI/180;
      _sinp[n] = Math.sin(phi);
      _cosp[n] = Math.cos(phi);
   }

   if (Math.abs(_sint[0]) <= epsilon) { numoutside -= widthSegments; numtop = 0; }
   if (Math.abs(_sint[heightSegments]) <= epsilon) { numoutside -= widthSegments; numbottom = 0; }

   let numfaces = numoutside * (noInside ? 1 : 2) + numtop + numbottom + numcut,
       creator = faces_limit ? new PolygonsCreator : new GeometryCreator(numfaces);

   for (let side = 0; side < 2; ++side) {
      if ((side === 1) && noInside) break;

      let r = radius[side],
          s = (side === 0) ? 1 : -1,
          d1 = 1 - side, d2 = 1 - d1;

      // use direct algorithm for the sphere - here normals and position can be calculated directly
      for (let k = 0; k < heightSegments; ++k) {

         let k1 = k + d1, k2 = k + d2, skip = 0;
         if (Math.abs(_sint[k1]) <= epsilon) skip = 1; else
         if (Math.abs(_sint[k2]) <= epsilon) skip = 2;

         for (let n=0;n<widthSegments;++n) {
            creator.addFace4(
                  r*_sint[k1]*_cosp[n],   r*_sint[k1] *_sinp[n],   r*_cost[k1],
                  r*_sint[k1]*_cosp[n+1], r*_sint[k1] *_sinp[n+1], r*_cost[k1],
                  r*_sint[k2]*_cosp[n+1], r*_sint[k2] *_sinp[n+1], r*_cost[k2],
                  r*_sint[k2]*_cosp[n],   r*_sint[k2] *_sinp[n],   r*_cost[k2],
                  skip);
            creator.setNormal4(
                  s*_sint[k1]*_cosp[n],   s*_sint[k1] *_sinp[n],   s*_cost[k1],
                  s*_sint[k1]*_cosp[n+1], s*_sint[k1] *_sinp[n+1], s*_cost[k1],
                  s*_sint[k2]*_cosp[n+1], s*_sint[k2] *_sinp[n+1], s*_cost[k2],
                  s*_sint[k2]*_cosp[n],   s*_sint[k2] *_sinp[n],   s*_cost[k2],
                  skip);
         }
      }
   }

   // top/bottom
   for (let side = 0; side <= heightSegments; side += heightSegments)
      if (Math.abs(_sint[side]) >= epsilon) {
         let ss = _sint[side], cc = _cost[side],
             d1 = (side === 0) ? 0 : 1, d2 = 1 - d1;
         for (let n = 0; n < widthSegments; ++n) {
            creator.addFace4(
                  radius[1] * ss * _cosp[n+d1], radius[1] * ss * _sinp[n+d1], radius[1] * cc,
                  radius[0] * ss * _cosp[n+d1], radius[0] * ss * _sinp[n+d1], radius[0] * cc,
                  radius[0] * ss * _cosp[n+d2], radius[0] * ss * _sinp[n+d2], radius[0] * cc,
                  radius[1] * ss * _cosp[n+d2], radius[1] * ss * _sinp[n+d2], radius[1] * cc,
                  noInside ? 2 : 0);
            creator.calcNormal();
         }
      }

   // cut left/right sides
   if (phiLength < 360) {
      for (let side=0;side<=widthSegments;side+=widthSegments) {
         let ss = _sinp[side], cc = _cosp[side],
             d1 = (side === 0) ? 1 : 0, d2 = 1 - d1;

         for (let k=0;k<heightSegments;++k) {
            creator.addFace4(
                  radius[1] * _sint[k+d1] * cc, radius[1] * _sint[k+d1] * ss, radius[1] * _cost[k+d1],
                  radius[0] * _sint[k+d1] * cc, radius[0] * _sint[k+d1] * ss, radius[0] * _cost[k+d1],
                  radius[0] * _sint[k+d2] * cc, radius[0] * _sint[k+d2] * ss, radius[0] * _cost[k+d2],
                  radius[1] * _sint[k+d2] * cc, radius[1] * _sint[k+d2] * ss, radius[1] * _cost[k+d2],
                  noInside ? 2 : 0);
            creator.calcNormal();
         }
      }
   }

   return creator.create();
}

/** @summary Creates tube geometrey
  * @private */
function createTubeBuffer( shape, faces_limit) {
   let outerR, innerR; // inner/outer tube radius
   if ((shape._typename == clTGeoCone) || (shape._typename == clTGeoConeSeg)) {
      outerR = [ shape.fRmax2, shape.fRmax1 ];
      innerR = [ shape.fRmin2, shape.fRmin1 ];
   } else {
      outerR = [ shape.fRmax, shape.fRmax ];
      innerR = [ shape.fRmin, shape.fRmin ];
   }

   let hasrmin = (innerR[0] > 0) || (innerR[1] > 0),
       thetaStart = 0, thetaLength = 360;

   if ((shape._typename == clTGeoConeSeg) || (shape._typename == clTGeoTubeSeg) || (shape._typename == clTGeoCtub)) {
      thetaStart = shape.fPhi1;
      thetaLength = shape.fPhi2 - shape.fPhi1;
   }

   let radiusSegments = Math.max(4, Math.round(thetaLength/cfg.GradPerSegm));

   // external surface
   let numfaces = radiusSegments * (((outerR[0] <= 0) || (outerR[1] <= 0)) ? 1 : 2);

   // internal surface
   if (hasrmin)
      numfaces += radiusSegments * (((innerR[0] <= 0) || (innerR[1] <= 0)) ? 1 : 2);

   // upper cap
   if (outerR[0] > 0) numfaces += radiusSegments * ((innerR[0] > 0) ? 2 : 1);
   // bottom cup
   if (outerR[1] > 0) numfaces += radiusSegments * ((innerR[1] > 0) ? 2 : 1);

   if (thetaLength < 360)
      numfaces += ((outerR[0] > innerR[0]) ? 2 : 0) + ((outerR[1] > innerR[1]) ? 2 : 0);

   if (faces_limit < 0) return numfaces;

   let phi0 = thetaStart*Math.PI/180,
       dphi = thetaLength/radiusSegments*Math.PI/180,
       _sin = new Float32Array(radiusSegments+1),
       _cos = new Float32Array(radiusSegments+1);

   for (let seg = 0; seg <= radiusSegments; ++seg) {
      _cos[seg] = Math.cos(phi0+seg*dphi);
      _sin[seg] = Math.sin(phi0+seg*dphi);
   }

   let creator = faces_limit ? new PolygonsCreator : new GeometryCreator(numfaces);

   const calcZ = (shape._typename !== clTGeoCtub) ? null : (x,y,z) => {
      let arr = (z < 0) ? shape.fNlow : shape.fNhigh;
      return ((z < 0) ? -shape.fDz : shape.fDz) - (x*arr[0] + y*arr[1]) / arr[2];
   };

   // create outer/inner tube
   for (let side = 0; side < 2; ++side) {
      if ((side === 1) && !hasrmin) break;

      let R = (side === 0) ? outerR : innerR,
          d1 = side, d2 = 1 - side, nxy = 1., nz = 0;

      if (R[0] !== R[1]) {
         let angle = Math.atan2((R[1]-R[0]), 2*shape.fDZ);
         nxy = Math.cos(angle);
         nz = Math.sin(angle);
      }

      if (side === 1) { nxy *= -1; nz *= -1; }
      let reduce = (R[0] <= 0) ? 2 : ((R[1] <= 0) ? 1 : 0);

      for (let seg = 0; seg < radiusSegments; ++seg) {
         creator.addFace4(
               R[0] * _cos[seg+d1], R[0] * _sin[seg+d1],  shape.fDZ,
               R[1] * _cos[seg+d1], R[1] * _sin[seg+d1], -shape.fDZ,
               R[1] * _cos[seg+d2], R[1] * _sin[seg+d2], -shape.fDZ,
               R[0] * _cos[seg+d2], R[0] * _sin[seg+d2],  shape.fDZ,
               reduce );

         if (calcZ) creator.recalcZ(calcZ);

         creator.setNormal_12_34(nxy*_cos[seg+d1], nxy*_sin[seg+d1], nz,
                                 nxy*_cos[seg+d2], nxy*_sin[seg+d2], nz,
                                 reduce);
      }
   }

   // create upper/bottom part
   for (let side = 0; side < 2; ++side) {
      if (outerR[side] <= 0) continue;

      let d1 = side, d2 = 1- side,
          sign = (side == 0) ? 1 : -1,
          reduce = (innerR[side] <= 0) ? 2 : 0;
      if ((reduce === 2) && (thetaLength === 360) && !calcZ)
         creator.startPolygon(side === 0);
      for (let seg = 0; seg < radiusSegments; ++seg) {
         creator.addFace4(
               innerR[side] * _cos[seg+d1], innerR[side] * _sin[seg+d1], sign*shape.fDZ,
               outerR[side] * _cos[seg+d1], outerR[side] * _sin[seg+d1], sign*shape.fDZ,
               outerR[side] * _cos[seg+d2], outerR[side] * _sin[seg+d2], sign*shape.fDZ,
               innerR[side] * _cos[seg+d2], innerR[side] * _sin[seg+d2], sign*shape.fDZ,
               reduce);
         if (calcZ) {
            creator.recalcZ(calcZ);
            creator.calcNormal();
         } else {
            creator.setNormal(0,0,sign);
         }
      }

      creator.stopPolygon();
   }

   // create cut surfaces
   if (thetaLength < 360) {
      creator.addFace4(innerR[1] * _cos[0], innerR[1] * _sin[0], -shape.fDZ,
                       outerR[1] * _cos[0], outerR[1] * _sin[0], -shape.fDZ,
                       outerR[0] * _cos[0], outerR[0] * _sin[0],  shape.fDZ,
                       innerR[0] * _cos[0], innerR[0] * _sin[0],  shape.fDZ,
                       (outerR[0] === innerR[0]) ? 2 : ((innerR[1]===outerR[1]) ? 1 : 0));
      if (calcZ) creator.recalcZ(calcZ);
      creator.calcNormal();

      creator.addFace4(innerR[0] * _cos[radiusSegments], innerR[0] * _sin[radiusSegments],  shape.fDZ,
                       outerR[0] * _cos[radiusSegments], outerR[0] * _sin[radiusSegments],  shape.fDZ,
                       outerR[1] * _cos[radiusSegments], outerR[1] * _sin[radiusSegments], -shape.fDZ,
                       innerR[1] * _cos[radiusSegments], innerR[1] * _sin[radiusSegments], -shape.fDZ,
                       (outerR[0] === innerR[0]) ? 1 : ((innerR[1]===outerR[1]) ? 2 : 0));

      if (calcZ) creator.recalcZ(calcZ);
      creator.calcNormal();
   }

   return creator.create();
}

/** @summary Creates eltu geometrey
  * @private */
function createEltuBuffer( shape , faces_limit ) {
   let radiusSegments = Math.max(4, Math.round(360/cfg.GradPerSegm));

   if (faces_limit < 0) return radiusSegments*4;

   // calculate all sin/cos tables in advance
   let x = new Float32Array(radiusSegments+1),
       y = new Float32Array(radiusSegments+1);
   for (let seg=0; seg<=radiusSegments; ++seg) {
       let phi = seg/radiusSegments*2*Math.PI;
       x[seg] = shape.fRmin*Math.cos(phi);
       y[seg] = shape.fRmax*Math.sin(phi);
   }

   let creator = faces_limit ? new PolygonsCreator : new GeometryCreator(radiusSegments*4),
       nx1, ny1, nx2 = 1, ny2 = 0;

   // create tube faces
   for (let seg = 0; seg < radiusSegments; ++seg) {
      creator.addFace4(x[seg],   y[seg],   +shape.fDZ,
                       x[seg],   y[seg],   -shape.fDZ,
                       x[seg+1], y[seg+1], -shape.fDZ,
                       x[seg+1], y[seg+1],  shape.fDZ);

      // calculate normals ourself
      nx1 = nx2; ny1 = ny2;
      nx2 = x[seg+1] * shape.fRmax / shape.fRmin;
      ny2 = y[seg+1] * shape.fRmin / shape.fRmax;
      let dist = Math.sqrt(nx2**2 + ny2**2);
      nx2 = nx2 / dist; ny2 = ny2/dist;

      creator.setNormal_12_34(nx1,ny1,0,nx2,ny2,0);
   }

   // create top/bottom sides
   for (let side = 0; side < 2; ++side) {
      let sign = (side === 0) ? 1 : -1, d1 = side, d2 = 1 - side;
      for (let seg=0; seg<radiusSegments; ++seg) {
         creator.addFace3(0,          0,          sign*shape.fDZ,
                          x[seg+d1],  y[seg+d1],  sign*shape.fDZ,
                          x[seg+d2],  y[seg+d2],  sign*shape.fDZ);
         creator.setNormal(0, 0, sign);
      }
   }

   return creator.create();
}

/** @summary Creates torus geometrey
  * @private */
function createTorusBuffer( shape, faces_limit ) {
   let radius = shape.fR,
       radialSegments = Math.max(6, Math.round(360/cfg.GradPerSegm)),
       tubularSegments = Math.max(8, Math.round(shape.fDphi/cfg.GradPerSegm)),
       numfaces = (shape.fRmin > 0 ? 4 : 2) * radialSegments * (tubularSegments + (shape.fDphi !== 360 ? 1 : 0));

   if (faces_limit < 0) return numfaces;

   if ((faces_limit > 0) && (numfaces > faces_limit)) {
      radialSegments = Math.floor(radialSegments/Math.sqrt(numfaces / faces_limit));
      tubularSegments = Math.floor(tubularSegments/Math.sqrt(numfaces / faces_limit));
      numfaces = (shape.fRmin > 0 ? 4 : 2) * radialSegments * (tubularSegments + (shape.fDphi !== 360 ? 1 : 0));
   }

   let _sinr = new Float32Array(radialSegments+1),
       _cosr = new Float32Array(radialSegments+1),
       _sint = new Float32Array(tubularSegments+1),
       _cost = new Float32Array(tubularSegments+1);

   for (let n = 0; n <= radialSegments; ++n) {
      _sinr[n] = Math.sin(n/radialSegments*2*Math.PI);
      _cosr[n] = Math.cos(n/radialSegments*2*Math.PI);
   }

   for (let t = 0; t <= tubularSegments; ++t) {
      let angle = (shape.fPhi1 + shape.fDphi*t/tubularSegments)/180*Math.PI;
      _sint[t] = Math.sin(angle);
      _cost[t] = Math.cos(angle);
   }

   let creator = faces_limit ? new PolygonsCreator : new GeometryCreator(numfaces),
       // use vectors for normals calculation
       p1 = new Vector3(), p2 = new Vector3(), p3 = new Vector3(), p4 = new Vector3(),
       n1 = new Vector3(), n2 = new Vector3(), n3 = new Vector3(), n4 = new Vector3(),
       center1 = new Vector3(), center2 = new Vector3();

   for (let side = 0; side < 2; ++side) {
      if ((side > 0) && (shape.fRmin <= 0)) break;
      let tube = (side > 0) ? shape.fRmin : shape.fRmax,
          d1 = 1 - side, d2 = 1 - d1, ns = side > 0 ? -1 : 1;

      for (let t = 0; t < tubularSegments; ++t) {
         let t1 = t + d1, t2 = t + d2;
         center1.x = radius * _cost[t1]; center1.y = radius * _sint[t1];
         center2.x = radius * _cost[t2]; center2.y = radius * _sint[t2];

         for (let n = 0; n < radialSegments; ++n) {
            p1.x = (radius + tube * _cosr[n])   * _cost[t1]; p1.y = (radius + tube * _cosr[n])   * _sint[t1]; p1.z = tube*_sinr[n];
            p2.x = (radius + tube * _cosr[n+1]) * _cost[t1]; p2.y = (radius + tube * _cosr[n+1]) * _sint[t1]; p2.z = tube*_sinr[n+1];
            p3.x = (radius + tube * _cosr[n+1]) * _cost[t2]; p3.y = (radius + tube * _cosr[n+1]) * _sint[t2]; p3.z = tube*_sinr[n+1];
            p4.x = (radius + tube * _cosr[n])   * _cost[t2]; p4.y = (radius + tube * _cosr[n])   * _sint[t2]; p4.z = tube*_sinr[n];

            creator.addFace4(p1.x, p1.y, p1.z,
                             p2.x, p2.y, p2.z,
                             p3.x, p3.y, p3.z,
                             p4.x, p4.y, p4.z);

            n1.subVectors( p1, center1 ).normalize();
            n2.subVectors( p2, center1 ).normalize();
            n3.subVectors( p3, center2 ).normalize();
            n4.subVectors( p4, center2 ).normalize();

            creator.setNormal4(ns*n1.x, ns*n1.y, ns*n1.z,
                               ns*n2.x, ns*n2.y, ns*n2.z,
                               ns*n3.x, ns*n3.y, ns*n3.z,
                               ns*n4.x, ns*n4.y, ns*n4.z);
         }
      }
   }

   if (shape.fDphi !== 360)
      for (let t = 0; t <= tubularSegments; t += tubularSegments) {
         let tube1 = shape.fRmax, tube2 = shape.fRmin,
             d1 = (t > 0) ? 0 : 1, d2 = 1 - d1,
             skip = (shape.fRmin) > 0 ?  0 : 1,
             nsign = (t > 0) ? 1 : -1;
         for (let n = 0; n < radialSegments; ++n) {
            creator.addFace4((radius + tube1 * _cosr[n+d1]) * _cost[t], (radius + tube1 * _cosr[n+d1]) * _sint[t], tube1*_sinr[n+d1],
                             (radius + tube2 * _cosr[n+d1]) * _cost[t], (radius + tube2 * _cosr[n+d1]) * _sint[t], tube2*_sinr[n+d1],
                             (radius + tube2 * _cosr[n+d2]) * _cost[t], (radius + tube2 * _cosr[n+d2]) * _sint[t], tube2*_sinr[n+d2],
                             (radius + tube1 * _cosr[n+d2]) * _cost[t], (radius + tube1 * _cosr[n+d2]) * _sint[t], tube1*_sinr[n+d2], skip);
            creator.setNormal(-nsign* _sint[t], nsign * _cost[t], 0);
         }
      }

   return creator.create();
}


/** @summary Creates polygon geometrey
  * @private */
function createPolygonBuffer( shape, faces_limit ) {
   let thetaStart = shape.fPhi1,
       thetaLength = shape.fDphi,
       radiusSegments, factor;

   if (shape._typename == clTGeoPgon) {
      radiusSegments = shape.fNedges;
      factor = 1. / Math.cos(Math.PI/180 * thetaLength / radiusSegments / 2);
   } else {
      radiusSegments = Math.max(5, Math.round(thetaLength/cfg.GradPerSegm));
      factor = 1;
   }

   let usage = new Int16Array(2*shape.fNz), numusedlayers = 0, hasrmin = false;

   for (let layer = 0; layer < shape.fNz; ++layer)
      if (shape.fRmin[layer] > 0) hasrmin = true;

   // return very rough estimation, number of faces may be much less
   if (faces_limit < 0) return (hasrmin ? 4 : 2) * radiusSegments * (shape.fNz-1);

   // coordinate of point on cut edge (x,z)
   let pnts = (thetaLength === 360) ? null : [];

   // first analyse levels - if we need to create all of them
   for (let side = 0; side < 2; ++side) {
      let rside = (side === 0) ? 'fRmax' : 'fRmin';

      for (let layer=0; layer < shape.fNz; ++layer) {

         // first create points for the layer
         let layerz = shape.fZ[layer], rad = shape[rside][layer];

         usage[layer*2+side] = 0;

         if ((layer > 0) && (layer < shape.fNz-1))
            if (((shape.fZ[layer-1] === layerz) && (shape[rside][layer-1] === rad)) ||
                ((shape[rside][layer+1] === rad) && (shape[rside][layer-1] === rad))) {

               // same Z and R as before - ignore
               // or same R before and after

               continue;
            }

         if ((layer > 0) && ((side === 0) || hasrmin)) {
            usage[layer*2+side] = 1;
            numusedlayers++;
         }

         if (pnts !== null) {
            if (side === 0) {
               pnts.push(new Vector2(factor*rad, layerz));
            } else if (rad < shape.fRmax[layer]) {
               pnts.unshift(new Vector2(factor*rad, layerz));
            }
         }
      }
   }

   let numfaces = numusedlayers*radiusSegments*2;
   if (shape.fRmin[0] !== shape.fRmax[0]) numfaces += radiusSegments * (hasrmin ? 2 : 1);
   if (shape.fRmin[shape.fNz-1] !== shape.fRmax[shape.fNz-1]) numfaces += radiusSegments * (hasrmin ? 2 : 1);

   let cut_faces = null;

   if (pnts !== null) {
      if (pnts.length === shape.fNz * 2) {
         // special case - all layers are there, create faces ourself
         cut_faces = [];
         for (let layer = shape.fNz-1; layer > 0; --layer) {
            if (shape.fZ[layer] === shape.fZ[layer-1]) continue;
            let right = 2*shape.fNz - 1 - layer;
            cut_faces.push([right, layer - 1, layer]);
            cut_faces.push([right, right + 1, layer-1]);
         }

      } else {
         // let three.js calculate our faces
         // console.log(`triangulate polygon ${shape.fShapeId}`);
         cut_faces = ShapeUtils.triangulateShape(pnts, []);
      }
      numfaces += cut_faces.length*2;
   }

   let phi0 = thetaStart*Math.PI/180, dphi = thetaLength/radiusSegments*Math.PI/180;

   // calculate all sin/cos tables in advance
   let _sin = new Float32Array(radiusSegments+1),
       _cos = new Float32Array(radiusSegments+1);
   for (let seg=0;seg<=radiusSegments;++seg) {
      _cos[seg] = Math.cos(phi0+seg*dphi);
      _sin[seg] = Math.sin(phi0+seg*dphi);
   }

   let creator = faces_limit ? new PolygonsCreator : new GeometryCreator(numfaces);

   // add sides
   for (let side = 0; side < 2; ++side) {
      let rside = (side === 0) ? 'fRmax' : 'fRmin',
          z1 = shape.fZ[0], r1 = factor*shape[rside][0],
          d1 = 1 - side, d2 = side;

      for (let layer = 0; layer < shape.fNz; ++layer) {

         if (usage[layer*2+side] === 0) continue;

         let z2 = shape.fZ[layer], r2 = factor*shape[rside][layer],
             nxy = 1, nz = 0;

         if ((r2 !== r1)) {
            let angle = Math.atan2((r2-r1), (z2-z1));
            nxy = Math.cos(angle);
            nz = Math.sin(angle);
         }

         if (side > 0) { nxy*=-1; nz*=-1; }

         for (let seg = 0; seg < radiusSegments; ++seg) {
            creator.addFace4(r1 * _cos[seg+d1], r1 * _sin[seg+d1], z1,
                             r2 * _cos[seg+d1], r2 * _sin[seg+d1], z2,
                             r2 * _cos[seg+d2], r2 * _sin[seg+d2], z2,
                             r1 * _cos[seg+d2], r1 * _sin[seg+d2], z1);
            creator.setNormal_12_34(nxy*_cos[seg+d1], nxy*_sin[seg+d1], nz, nxy*_cos[seg+d2], nxy*_sin[seg+d2], nz);
         }

         z1 = z2; r1 = r2;
      }
   }

   // add top/bottom
   for (let layer = 0; layer < shape.fNz; layer += (shape.fNz-1)) {

      let rmin = factor*shape.fRmin[layer], rmax = factor*shape.fRmax[layer];

      if (rmin === rmax) continue;

      let layerz = shape.fZ[layer],
          d1 = (layer === 0) ? 1 : 0, d2 = 1 - d1,
          normalz = (layer === 0) ? -1: 1;

      if (!hasrmin && !cut_faces)
         creator.startPolygon(layer > 0);

      for (let seg = 0; seg < radiusSegments; ++seg) {
         creator.addFace4(rmin * _cos[seg+d1], rmin * _sin[seg+d1], layerz,
                          rmax * _cos[seg+d1], rmax * _sin[seg+d1], layerz,
                          rmax * _cos[seg+d2], rmax * _sin[seg+d2], layerz,
                          rmin * _cos[seg+d2], rmin * _sin[seg+d2], layerz,
                          hasrmin ? 0 : 2);
         creator.setNormal(0, 0, normalz);
      }

      creator.stopPolygon();
   }

   if (cut_faces)
      for (let seg = 0; seg <= radiusSegments; seg += radiusSegments) {
         let d1 = (seg === 0) ? 1 : 2, d2 = 3 - d1;
         for (let n=0;n<cut_faces.length;++n) {
            let a = pnts[cut_faces[n][0]],
                b = pnts[cut_faces[n][d1]],
                c = pnts[cut_faces[n][d2]];

            creator.addFace3(a.x * _cos[seg], a.x * _sin[seg], a.y,
                             b.x * _cos[seg], b.x * _sin[seg], b.y,
                             c.x * _cos[seg], c.x * _sin[seg], c.y);

            creator.calcNormal();
         }
      }

   return creator.create();
}

/** @summary Creates xtru geometrey
  * @private */
function createXtruBuffer( shape, faces_limit ) {
   let nfaces = (shape.fNz-1) * shape.fNvert * 2;

   if (faces_limit < 0) return nfaces + shape.fNvert*3;

   // create points
   let pnts = [];
   for (let vert = 0; vert < shape.fNvert; ++vert)
      pnts.push(new Vector2(shape.fX[vert], shape.fY[vert]));

   let faces = ShapeUtils.triangulateShape(pnts , []);
   if (faces.length < pnts.length-2) {
      geoWarn(`Problem with XTRU shape ${shape.fName} with ${pnts.length} vertices`);
      faces = [];
   } else {
      nfaces += faces.length * 2;
   }

   let creator = faces_limit ? new PolygonsCreator : new GeometryCreator(nfaces);

   for (let layer = 0; layer < shape.fNz-1; ++layer) {
      let z1 = shape.fZ[layer], scale1 = shape.fScale[layer],
          z2 = shape.fZ[layer+1], scale2 = shape.fScale[layer+1],
          x01 = shape.fX0[layer], x02 = shape.fX0[layer+1],
          y01 = shape.fY0[layer], y02 = shape.fY0[layer+1];

      for (let vert1 = 0; vert1 < shape.fNvert; ++vert1) {
         let vert2 = (vert1+1) % shape.fNvert;
         creator.addFace4(scale1 * shape.fX[vert1] + x01, scale1 * shape.fY[vert1] + y01, z1,
                          scale2 * shape.fX[vert1] + x02, scale2 * shape.fY[vert1] + y02, z2,
                          scale2 * shape.fX[vert2] + x02, scale2 * shape.fY[vert2] + y02, z2,
                          scale1 * shape.fX[vert2] + x01, scale1 * shape.fY[vert2] + y01, z1);
         creator.calcNormal();
      }
   }

   for (let layer = 0; layer <= shape.fNz-1; layer += (shape.fNz-1)) {
      let z = shape.fZ[layer], scale = shape.fScale[layer],
          x0 = shape.fX0[layer], y0 = shape.fY0[layer];

      for (let n = 0; n < faces.length; ++n) {
         let face = faces[n],
             pnt1 = pnts[face[0]],
             pnt2 = pnts[face[layer === 0 ? 2 : 1]],
             pnt3 = pnts[face[layer === 0 ? 1 : 2]];

         creator.addFace3(scale * pnt1.x + x0, scale * pnt1.y + y0, z,
                          scale * pnt2.x + x0, scale * pnt2.y + y0, z,
                          scale * pnt3.x + x0, scale * pnt3.y + y0, z);
         creator.setNormal(0,0,layer === 0 ? -1 : 1);
      }
   }

   return creator.create();
}

/** @summary Creates para geometrey
  * @private */
function createParaboloidBuffer( shape, faces_limit ) {

   let radiusSegments = Math.max(4, Math.round(360/cfg.GradPerSegm)),
       heightSegments = 30;

   if (faces_limit > 0) {
      let fact = 2*radiusSegments*(heightSegments+1) / faces_limit;
      if (fact > 1.) {
         radiusSegments = Math.max(5, Math.floor(radiusSegments/Math.sqrt(fact)));
         heightSegments = Math.max(5, Math.floor(heightSegments/Math.sqrt(fact)));
      }
   }

   let zmin = -shape.fDZ, zmax = shape.fDZ, rmin = shape.fRlo, rmax = shape.fRhi;

   // if no radius at -z, find intersection
   if (shape.fA >= 0) {
      if (shape.fB > zmin) zmin = shape.fB;
   } else {
      if (shape.fB < zmax) zmax = shape.fB;
   }

   let ttmin = Math.atan2(zmin, rmin), ttmax = Math.atan2(zmax, rmax);

   let numfaces = (heightSegments+1)*radiusSegments*2;
   if (rmin === 0) numfaces -= radiusSegments*2; // complete layer
   if (rmax === 0) numfaces -= radiusSegments*2; // complete layer

   if (faces_limit < 0) return numfaces;

   // calculate all sin/cos tables in advance
   let _sin = new Float32Array(radiusSegments+1),
       _cos = new Float32Array(radiusSegments+1);
   for (let seg=0;seg<=radiusSegments;++seg) {
      _cos[seg] = Math.cos(seg/radiusSegments*2*Math.PI);
      _sin[seg] = Math.sin(seg/radiusSegments*2*Math.PI);
   }

   let creator = faces_limit ? new PolygonsCreator : new GeometryCreator(numfaces),
       lastz = zmin, lastr = 0, lastnxy = 0, lastnz = -1;

   for (let layer = 0; layer <= heightSegments + 1; ++layer) {

      let layerz = 0, radius = 0, nxy = 0, nz = -1;

      if ((layer === 0) && (rmin === 0)) continue;

      if ((layer === heightSegments + 1) && (lastr === 0)) break;

      switch (layer) {
         case 0: layerz = zmin; radius = rmin; break;
         case heightSegments: layerz = zmax; radius = rmax; break;
         case heightSegments + 1: layerz = zmax; radius = 0; break;
         default: {
            let tt = Math.tan(ttmin + (ttmax-ttmin) * layer / heightSegments),
                delta = tt**2 - 4*shape.fA*shape.fB; // should be always positive (a*b < 0)
            radius = 0.5*(tt+Math.sqrt(delta))/shape.fA;
            if (radius < 1e-6) radius = 0;
            layerz = radius*tt;
         }
      }

      nxy = shape.fA * radius;
      nz = (shape.fA > 0) ? -1 : 1;

      let skip = (lastr === 0) ? 1 : ((radius === 0) ? 2 : 0);

      for (let seg = 0; seg < radiusSegments; ++seg) {
         creator.addFace4(radius*_cos[seg],   radius*_sin[seg], layerz,
                          lastr*_cos[seg],    lastr*_sin[seg], lastz,
                          lastr*_cos[seg+1],  lastr*_sin[seg+1], lastz,
                          radius*_cos[seg+1], radius*_sin[seg+1], layerz, skip);

         // use analytic normal values when open/closing paraboloid around 0
         // cut faces (top or bottom) set with simple normal
         if ((skip === 0) || ((layer === 1) && (rmin === 0)) || ((layer === heightSegments+1) && (rmax === 0)))
            creator.setNormal4(nxy*_cos[seg],       nxy*_sin[seg],       nz,
                               lastnxy*_cos[seg],   lastnxy*_sin[seg],   lastnz,
                               lastnxy*_cos[seg+1], lastnxy*_sin[seg+1], lastnz,
                               nxy*_cos[seg+1],     nxy*_sin[seg+1],     nz, skip);
         else
            creator.setNormal(0, 0, (layer < heightSegments) ? -1 : 1);
      }

      lastz = layerz; lastr = radius;
      lastnxy = nxy; lastnz = nz;
   }

   return creator.create();
}

/** @summary Creates hype geometrey
  * @private */
function createHypeBuffer( shape, faces_limit ) {

   if ((shape.fTin === 0) && (shape.fTout === 0))
      return createTubeBuffer(shape, faces_limit);

   let radiusSegments = Math.max(4, Math.round(360/cfg.GradPerSegm)),
       heightSegments = 30,
       numfaces = radiusSegments * (heightSegments + 1) * ((shape.fRmin > 0) ? 4 : 2);

   if (faces_limit < 0) return numfaces;

   if ((faces_limit > 0) && (faces_limit > numfaces)) {
      radiusSegments = Math.max(4, Math.floor(radiusSegments/Math.sqrt(numfaces/faces_limit)));
      heightSegments = Math.max(4, Math.floor(heightSegments/Math.sqrt(numfaces/faces_limit)));
      numfaces = radiusSegments * (heightSegments + 1) * ((shape.fRmin > 0) ? 4 : 2);
   }

   // calculate all sin/cos tables in advance
   let _sin = new Float32Array(radiusSegments+1), _cos = new Float32Array(radiusSegments+1);
   for (let seg=0;seg<=radiusSegments;++seg) {
      _cos[seg] = Math.cos(seg/radiusSegments*2*Math.PI);
      _sin[seg] = Math.sin(seg/radiusSegments*2*Math.PI);
   }

   let creator = faces_limit ? new PolygonsCreator : new GeometryCreator(numfaces);

   // in-out side
   for (let side = 0; side < 2; ++side) {
      if ((side > 0) && (shape.fRmin <= 0)) break;

      let r0 = (side > 0) ? shape.fRmin : shape.fRmax,
          tsq = (side > 0) ? shape.fTinsq : shape.fToutsq,
          d1 = 1- side, d2 = 1 - d1;

      // vertical layers
      for (let layer = 0; layer < heightSegments; ++layer) {
         let z1 = -shape.fDz + layer/heightSegments*2*shape.fDz,
             z2 = -shape.fDz + (layer+1)/heightSegments*2*shape.fDz,
             r1 = Math.sqrt(r0**2 + tsq*z1**2),
             r2 = Math.sqrt(r0**2 + tsq*z2**2);

         for (let seg = 0; seg < radiusSegments; ++seg) {
            creator.addFace4(r1 * _cos[seg+d1], r1 * _sin[seg+d1], z1,
                             r2 * _cos[seg+d1], r2 * _sin[seg+d1], z2,
                             r2 * _cos[seg+d2], r2 * _sin[seg+d2], z2,
                             r1 * _cos[seg+d2], r1 * _sin[seg+d2], z1);
            creator.calcNormal();
         }
      }
   }

   // add caps
   for (let layer = 0; layer < 2; ++layer) {
      let z = (layer === 0) ? shape.fDz : -shape.fDz,
          r1 = Math.sqrt(shape.fRmax**2 + shape.fToutsq*z**2),
          r2 = (shape.fRmin > 0) ? Math.sqrt(shape.fRmin**2 + shape.fTinsq*z**2) : 0,
          skip = (shape.fRmin > 0) ? 0 : 1,
          d1 = 1 - layer, d2 = 1 - d1;
      for (let seg = 0; seg < radiusSegments; ++seg) {
          creator.addFace4(r1 * _cos[seg+d1], r1 * _sin[seg+d1], z,
                           r2 * _cos[seg+d1], r2 * _sin[seg+d1], z,
                           r2 * _cos[seg+d2], r2 * _sin[seg+d2], z,
                           r1 * _cos[seg+d2], r1 * _sin[seg+d2], z, skip);
          creator.setNormal(0,0, (layer === 0) ? 1 : -1);
       }
   }

   return creator.create();
}

/** @summary Creates tessalated geometrey
  * @private */
function createTessellatedBuffer( shape, faces_limit) {
   let numfaces = 0;

   for (let i = 0; i < shape.fFacets.length; ++i) {
      let f = shape.fFacets[i];
      if (f.fNvert == 4) numfaces += 2;
                    else numfaces += 1;
   }

   if (faces_limit < 0) return numfaces;

   let creator = faces_limit ? new PolygonsCreator : new GeometryCreator(numfaces);

   for (let i = 0; i < shape.fFacets.length; ++i) {
      let f = shape.fFacets[i],
          v0 = shape.fVertices[f.fIvert[0]].fVec,
          v1 = shape.fVertices[f.fIvert[1]].fVec,
          v2 = shape.fVertices[f.fIvert[2]].fVec;

      if (f.fNvert == 4) {
         let v3 = shape.fVertices[f.fIvert[3]].fVec;
         creator.addFace4(v0[0], v0[1], v0[2], v1[0], v1[1], v1[2], v2[0], v2[1], v2[2], v3[0], v3[1], v3[2]);
         creator.calcNormal();
      } else {
         creator.addFace3(v0[0], v0[1], v0[2], v1[0], v1[1], v1[2], v2[0], v2[1], v2[2]);
         creator.calcNormal();
      }
   }

   return creator.create();
}

/** @summary Creates Matrix4 from TGeoMatrix
  * @private */
function createMatrix(matrix) {

   if (!matrix) return null;

   let translation, rotation, scale;

   switch (matrix._typename) {
      case 'TGeoTranslation': translation = matrix.fTranslation; break;
      case 'TGeoRotation': rotation = matrix.fRotationMatrix; break;
      case 'TGeoScale': scale = matrix.fScale; break;
      case 'TGeoGenTrans':
         scale = matrix.fScale; // no break, translation and rotation follows
      case 'TGeoCombiTrans':
         translation = matrix.fTranslation;
         if (matrix.fRotation) rotation = matrix.fRotation.fRotationMatrix;
         break;
      case 'TGeoHMatrix':
         translation = matrix.fTranslation;
         rotation = matrix.fRotationMatrix;
         scale = matrix.fScale;
         break;
      case 'TGeoIdentity':
         break;
      default:
         console.warn(`unsupported matrix ${matrix._typename}`);
   }

   if (!translation && !rotation && !scale) return null;

   let res = new Matrix4();

   if (rotation)
      res.set(rotation[0], rotation[1], rotation[2],  0,
              rotation[3], rotation[4], rotation[5],  0,
              rotation[6], rotation[7], rotation[8],  0,
                        0,           0,           0,  1);

   if (translation)
      res.setPosition(translation[0], translation[1], translation[2]);

   if (scale)
      res.scale(new Vector3(scale[0], scale[1], scale[2]));

   return res;
}

/** @summary Creates transformation matrix for TGeoNode
  * @desc created after node visibility flag is checked and volume cut is performed
  * @private */
function getNodeMatrix(kind, node) {

   let matrix = null;

   if (kind === kindEve) {
      // special handling for EVE nodes

      matrix = new Matrix4();

      if (node.fTrans) {
         matrix.set(node.fTrans[0],  node.fTrans[4],  node.fTrans[8],  0,
                    node.fTrans[1],  node.fTrans[5],  node.fTrans[9],  0,
                    node.fTrans[2],  node.fTrans[6],  node.fTrans[10], 0,
                                 0,               0,               0,  1);
         // second - set position with proper sign
         matrix.setPosition(node.fTrans[12], node.fTrans[13], node.fTrans[14]);
      }
   } else if (node.fMatrix) {
      matrix = createMatrix(node.fMatrix);
   } else if ((node._typename == 'TGeoNodeOffset') && node.fFinder) {
      const kPatternReflected = BIT(14);
      if ((node.fFinder.fBits & kPatternReflected) !== 0)
         geoWarn('Unsupported reflected pattern ' + node.fFinder._typename);

      // if (node.fFinder._typename === 'TGeoPatternCylR') { }
      // if (node.fFinder._typename === 'TGeoPatternSphR') { }
      // if (node.fFinder._typename === 'TGeoPatternSphTheta') { }
      // if (node.fFinder._typename === 'TGeoPatternSphPhi') { }
      // if (node.fFinder._typename === 'TGeoPatternHoneycomb') { }
      switch(node.fFinder._typename) {
        case 'TGeoPatternX':
        case 'TGeoPatternY':
        case 'TGeoPatternZ':
        case 'TGeoPatternParaX':
        case 'TGeoPatternParaY':
        case 'TGeoPatternParaZ':
           let _shift = node.fFinder.fStart + (node.fIndex + 0.5) * node.fFinder.fStep;

           matrix = new Matrix4();

           switch (node.fFinder._typename[node.fFinder._typename.length-1]) {
              case 'X': matrix.setPosition(_shift, 0, 0); break;
              case 'Y': matrix.setPosition(0, _shift, 0); break;
              case 'Z': matrix.setPosition(0, 0, _shift); break;
           }
           break;

        case 'TGeoPatternCylPhi':
           let phi = (Math.PI/180)*(node.fFinder.fStart+(node.fIndex+0.5)*node.fFinder.fStep),
               _cos = Math.cos(phi), _sin = Math.sin(phi);

           matrix = new Matrix4();

           matrix.set(_cos, -_sin,  0,  0,
                      _sin,  _cos,  0,  0,
                         0,     0,  1,  0,
                         0,     0,  0,  1);
           break;

        case 'TGeoPatternCylR':
            // seems to be, require no transformation
            matrix = new Matrix4();
            break;

        case 'TGeoPatternTrapZ':
           let dz = node.fFinder.fStart + (node.fIndex+0.5)*node.fFinder.fStep;
           matrix = new Matrix4();
           matrix.setPosition(node.fFinder.fTxz*dz, node.fFinder.fTyz*dz, dz);
           break;

        default:
           geoWarn(`Unsupported pattern type ${node.fFinder._typename}`);
           break;
      }
   }

   return matrix;
}

/** @summary Returns number of faces for provided geometry
  * @param {Object} geom  - can be BufferGeometry, CsgGeometry or interim array of polygons
  * @private */
function numGeometryFaces(geom) {
   if (!geom) return 0;

   if (geom instanceof Geometry)
      return geom.tree.numPolygons();

   // special array of polygons
   if (geom.polygons)
      return geom.polygons.length;

   let attr = geom.getAttribute('position');
   return attr?.count ? Math.round(attr.count / 3) : 0;
}

/** @summary Returns geometry bounding box
  * @private */
function geomBoundingBox(geom) {
   if (!geom) return null;

   let polygons = null;

   if (geom instanceof Geometry)
      polygons = geom.tree.collectPolygons();
   else if (geom.polygons)
      polygons = geom.polygons;

   if (polygons !== null) {
      let box = new Box3();
      for (let n = 0; n < polygons.length; ++n) {
         let polygon = polygons[n], nvert = polygon.vertices.length;
         for (let k = 0; k < nvert; ++k)
            box.expandByPoint(polygon.vertices[k]);
      }
      return box;
   }

   if (!geom.boundingBox)
      geom.computeBoundingBox();

   return geom.boundingBox.clone();
}

/** @summary Creates half-space geometry for given shape
  * @desc Just big-enough triangle to make BSP calculations
  * @private */
function createHalfSpace(shape, geom) {
   if (!shape?.fN || !shape?.fP) return null;

   let vertex = new Vector3(shape.fP[0], shape.fP[1], shape.fP[2]),
       normal = new Vector3(shape.fN[0], shape.fN[1], shape.fN[2]);

   normal.normalize();

   let sz = 1e10;
   if (geom) {
      // using real size of other geometry, we probably improve precision
      let box = geomBoundingBox(geom);
      if (box) sz = box.getSize(new Vector3()).length() * 1000;
   }

   let v0 = new Vector3(-sz, -sz/2, 0),
       v1 = new Vector3(0, sz, 0),
       v2 = new Vector3(sz, -sz/2, 0),
       v3 = new Vector3(0, 0, -sz),
       geometry = new BufferGeometry(),
       positions = new Float32Array([ v0.x,v0.y,v0.z, v2.x,v2.y,v2.z, v1.x,v1.y,v1.z,
                                      v0.x,v0.y,v0.z, v1.x,v1.y,v1.z, v3.x,v3.y,v3.z,
                                      v1.x,v1.y,v1.z, v2.x,v2.y,v2.z, v3.x,v3.y,v3.z,
                                      v2.x,v2.y,v2.z, v0.x,v0.y,v0.z, v3.x,v3.y,v3.z ]);
   geometry.setAttribute('position', new BufferAttribute(positions, 3));
   geometry.computeVertexNormals();

   geometry.lookAt(normal);
   geometry.computeVertexNormals();

   for(let k = 0; k < positions.length; k += 3) {
      positions[k] = positions[k] + vertex.x;
      positions[k+1] = positions[k+1] + vertex.y;
      positions[k+2] = positions[k+2] + vertex.z;
   }

   return geometry;
}

/** @summary Returns number of faces for provided geometry
  * @param geom  - can be BufferGeometry, CsgGeometry or interim array of polygons
  * @private */
function countGeometryFaces(geom) {
   if (!geom) return 0;

   if (geom instanceof Geometry)
      return geom.tree.numPolygons();

   // special array of polygons
   if (geom.polygons)
      return geom.polygons.length;

   let attr = geom.getAttribute('position');
   return attr?.count ? Math.round(attr.count / 3) : 0;
}

/** @summary Creates geometrey for composite shape
  * @private */
function createComposite( shape, faces_limit ) {

   if (faces_limit < 0)
      return createGeometry(shape.fNode.fLeft, -10) +
             createGeometry(shape.fNode.fRight, -10);

   let geom1, geom2, bsp1, bsp2, return_bsp = false,
       matrix1 = createMatrix(shape.fNode.fLeftMat),
       matrix2 = createMatrix(shape.fNode.fRightMat);

   if (faces_limit === 0) faces_limit = 4000;
                     else return_bsp = true;

   if (matrix1 && (matrix1.determinant() < -0.9))
      geoWarn('Axis reflection in left composite shape - not supported');

   if (matrix2 && (matrix2.determinant() < -0.9))
      geoWarn('Axis reflections in right composite shape - not supported');

   if (shape.fNode.fLeft._typename == clTGeoHalfSpace) {
      geom1 = createHalfSpace(shape.fNode.fLeft);
   } else {
      geom1 = createGeometry(shape.fNode.fLeft, faces_limit);
   }

   if (!geom1) return null;

   let n1 = countGeometryFaces(geom1), n2 = 0;
   if (geom1._exceed_limit) n1 += faces_limit;

   if (n1 < faces_limit) {

      if (shape.fNode.fRight._typename == clTGeoHalfSpace) {
         geom2 = createHalfSpace(shape.fNode.fRight, geom1);
      } else {
         geom2 = createGeometry(shape.fNode.fRight, faces_limit);
      }

      n2 = countGeometryFaces(geom2);
   }

   if ((n1 + n2 >= faces_limit) || !geom2) {
      if (geom1.polygons)
         geom1 = createBufferGeometry(geom1.polygons);
      if (matrix1) geom1.applyMatrix4(matrix1);
      geom1._exceed_limit = true;
      return geom1;
   }

   bsp1 = new Geometry(geom1, matrix1, cfg.CompressComp ? 0 : undefined);

   bsp2 = new Geometry(geom2, matrix2, bsp1.maxid);

   // take over maxid from both geometries
   bsp1.maxid = bsp2.maxid;

   switch(shape.fNode._typename) {
      case 'TGeoIntersection': bsp1.direct_intersect(bsp2);  break; // '*'
      case 'TGeoUnion': bsp1.direct_union(bsp2); break;   // '+'
      case 'TGeoSubtraction': bsp1.direct_subtract(bsp2); break; // '/'
      default:
         geoWarn('unsupported bool operation ' + shape.fNode._typename + ', use first geom');
   }

   if (countGeometryFaces(bsp1) === 0) {
      geoWarn('Zero faces in comp shape'
            + ` left: ${shape.fNode.fLeft._typename} ${countGeometryFaces(geom1)} faces`
            + ` right: ${shape.fNode.fRight._typename} ${countGeometryFaces(geom2)} faces`
            + '  use first');
      bsp1 = new Geometry(geom1, matrix1);
   }

   return return_bsp ? { polygons: bsp1.toPolygons() } : bsp1.toBufferGeometry();
}

/** @summary Try to create projected geometry
  * @private */
function projectGeometry(geom, matrix, projection, position, flippedMesh) {

   if (!geom.boundingBox) geom.computeBoundingBox();

   let box = geom.boundingBox.clone();

   box.applyMatrix4(matrix);

   if (!position) position = 0;

   if (((box.min[projection] >= position) && (box.max[projection] >= position)) ||
       ((box.min[projection] <= position) && (box.max[projection] <= position))) {
      return null; // not interesting
   }

   let bsp1 = new Geometry(geom, matrix, 0, flippedMesh),
       sizex = 2*Math.max(Math.abs(box.min.x), Math.abs(box.max.x)),
       sizey = 2*Math.max(Math.abs(box.min.y), Math.abs(box.max.y)),
       sizez = 2*Math.max(Math.abs(box.min.z), Math.abs(box.max.z)),
       size = 10000;

   switch (projection) {
      case 'x': size = Math.max(sizey,sizez); break;
      case 'y': size = Math.max(sizex,sizez); break;
      case 'z': size = Math.max(sizex,sizey); break;
   }

   let bsp2 = createNormal(projection, position, size);

   bsp1.cut_from_plane(bsp2);

   return bsp2.toBufferGeometry();
}

/** @summary Creates geometry model for the provided shape
  * @param {Object} shape - instance of TGeoShape object
  * @param {Number} limit - defines return value, see details
  * @desc
  *  - if limit === 0 (or undefined) returns BufferGeometry
  *  - if limit < 0 just returns estimated number of faces
  *  - if limit > 0 return list of CsgPolygons (used only for composite shapes)
  * @private */
function createGeometry(shape, limit) {
   if (limit === undefined) limit = 0;

   try {
      switch (shape._typename) {
         case clTGeoBBox: return createCubeBuffer( shape, limit );
         case clTGeoPara: return createParaBuffer( shape, limit );
         case clTGeoTrd1:
         case clTGeoTrd2: return createTrapezoidBuffer( shape, limit );
         case clTGeoArb8:
         case clTGeoTrap:
         case clTGeoGtra: return createArb8Buffer( shape, limit );
         case clTGeoSphere: return createSphereBuffer( shape , limit );
         case clTGeoCone:
         case clTGeoConeSeg:
         case clTGeoTube:
         case clTGeoTubeSeg:
         case clTGeoCtub: return createTubeBuffer( shape, limit );
         case clTGeoEltu: return createEltuBuffer( shape, limit );
         case clTGeoTorus: return createTorusBuffer( shape, limit );
         case clTGeoPcon:
         case clTGeoPgon: return createPolygonBuffer( shape, limit );
         case clTGeoXtru: return createXtruBuffer( shape, limit );
         case clTGeoParaboloid: return createParaboloidBuffer( shape, limit );
         case clTGeoHype: return createHypeBuffer( shape, limit );
         case 'TGeoTessellated': return createTessellatedBuffer( shape, limit );
         case clTGeoCompositeShape: return createComposite( shape, limit );
         case clTGeoShapeAssembly: break;
         case clTGeoScaledShape: {
            let res = createGeometry(shape.fShape, limit);
            if (shape.fScale && (limit >= 0) && isFunc(res?.scale))
               res.scale(shape.fScale.fScale[0], shape.fScale.fScale[1], shape.fScale.fScale[2]);
            return res;
         }
         case clTGeoHalfSpace:
            if (limit < 0) return 1; // half space if just plane used in composite
            // no break here - warning should appear
         default: geoWarn(`unsupported shape type ${shape._typename}`);
      }
   } catch(e) {
      let place = '';
      if (e.stack !== undefined) {
         place = e.stack.split('\n')[0];
         if (place.indexOf(e.message) >= 0) place = e.stack.split('\n')[1];
                                       else place = 'at: ' + place;
      }
      geoWarn(`${shape._typename} err: ${e.message} ${place}`);
   }

   return limit < 0 ? 0 : null;
}


/** @summary Create single shape from EVE7 render date
  * @private */
function makeEveGeometry(rd) {

   let off = 0;

   if (rd.sz[0]) {
      rd.vtxBuff = new Float32Array(rd.raw.buffer, off, rd.sz[0]);
      off += rd.sz[0]*4;
   }

   if (rd.sz[1]) {
      // normals were not used
      // rd.nrmBuff = new Float32Array(rd.raw.buffer, off, rd.sz[1]);
      off += rd.sz[1]*4;
   }

   if (rd.sz[2]) {
      // these are special values in the buffer begin
      rd.prefixBuf = new Uint32Array(rd.raw.buffer, off, 2);
      off += 2*4;
      rd.idxBuff = new Uint32Array(rd.raw.buffer, off, rd.sz[2]-2);
      off += (rd.sz[2]-2)*4;
   }

   const GL_TRIANGLES = 4; // same as in EVE7

   if (rd.prefixBuf[0] != GL_TRIANGLES)
      throw 'Expect triangles first.';

   let nVert = 3 * rd.prefixBuf[1]; // number of vertices to draw

   if (rd.idxBuff.length != nVert)
      throw 'Expect single list of triangles in index buffer.';

   let body = new BufferGeometry();
   body.setAttribute('position', new BufferAttribute(rd.vtxBuff, 3));
   body.setIndex(new BufferAttribute(rd.idxBuff, 1));
   body.computeVertexNormals();

   return body;
}

/** @summary Create single shape from geometry veiwer render date
  * @private */
function makeViewerGeometry(rd) {

   let vtxBuff = new Float32Array(rd.raw.buffer, 0, rd.raw.buffer.byteLength/4);

   let body = new BufferGeometry();
   body.setAttribute('position', new BufferAttribute(vtxBuff, 3));
   body.setIndex(new BufferAttribute(new Uint32Array(rd.idx), 1));
   body.computeVertexNormals();
   return body;
}

/** @summary Create single shape from provided raw data from web viewer.
  * @desc If nsegm changed, shape will be recreated
  * @private */
function createServerGeometry(rd, nsegm) {

   if (rd.server_shape && ((rd.nsegm === nsegm) || !rd.shape))
      return rd.server_shape;

   rd.nsegm = nsegm;

   let g = null;

   if (rd.shape) {
      // case when TGeoShape provided as is
      g = createGeometry(rd.shape);
   } else {

      if (!rd.raw?.buffer) {
         console.error('No raw data at all');
         return null;
      }

      if (rd.sz)
         g = makeEveGeometry(rd);
      else
         g = makeViewerGeometry(rd);

   }

   // shape handle is similar to created in JSROOT.GeoPainter
   return {
      _typename: '$$Shape$$', // indicate that shape can be used as is
      ready: true,
      geom: g,
      nfaces: numGeometryFaces(g)
   }
}

/** @summary Provides info about geo object, used for tooltip info
  * @param {Object} obj - any kind of TGeo-related object like shape or node or volume
  * @private */
function provideObjectInfo(obj) {
   let info = [], shape = null;

   if (obj.fVolume !== undefined)
      shape = obj.fVolume.fShape;
   else if (obj.fShape !== undefined)
      shape = obj.fShape;
   else if ((obj.fShapeBits !== undefined) && (obj.fShapeId !== undefined))
      shape = obj;

   if (!shape) {
      info.push(obj._typename);
      return info;
   }

   let sz = Math.max(shape.fDX, shape.fDY, shape.fDZ),
       useexp = (sz > 1e7) || (sz < 1e-7),
       conv = (v) => {
          if (v === undefined) return '???';
          if ((v == Math.round(v) && v < 1e7)) return Math.round(v);
          return useexp ? v.toExponential(4) : v.toPrecision(7);
       };

   info.push(shape._typename);

   info.push(`DX=${conv(shape.fDX)} DY=${conv(shape.fDY)} DZ=${conv(shape.fDZ)}`);

   switch (shape._typename) {
      case clTGeoBBox: break;
      case clTGeoPara: info.push(`Alpha=${shape.fAlpha} Phi=${shape.fPhi} Theta=${shape.fTheta}`); break;
      case clTGeoTrd2: info.push(`Dy1=${conv(shape.fDy1)} Dy2=${conv(shape.fDy1)}`); // no break
      case clTGeoTrd1: info.push(`Dx1=${conv(shape.fDx1)} Dx2=${conv(shape.fDx1)}`); break;
      case clTGeoArb8: break;
      case clTGeoTrap: break;
      case clTGeoGtra: break;
      case clTGeoSphere:
         info.push(`Rmin=${conv(shape.fRmin)} Rmax=${conv(shape.fRmax)}`,
                   `Phi1=${shape.fPhi1} Phi2=${shape.fPhi2}`,
                   `Theta1=${shape.fTheta1} Theta2=${shape.fTheta2}`);
         break;
      case clTGeoConeSeg:
         info.push(`Phi1=${shape.fPhi1} Phi2=${shape.fPhi2}`);
         // no break;
      case clTGeoCone:
         info.push(`Rmin1=${conv(shape.fRmin1)} Rmax1=${conv(shape.fRmax1)}`,
                   `Rmin2=${conv(shape.fRmin2)} Rmax2=${conv(shape.fRmax2)}`);
         break;
      case clTGeoCtub:
      case clTGeoTubeSeg:
         info.push(`Phi1=${shape.fPhi1} Phi2=${shape.fPhi2}`);
         // no break
      case clTGeoEltu:
      case clTGeoTube:
         info.push(`Rmin=${conv(shape.fRmin)} Rmax=${conv(shape.fRmax)}`);
         break;
      case clTGeoTorus:
         info.push(`Rmin=${conv(shape.fRmin)} Rmax=${conv(shape.fRmax)}`,
                   `Phi1=${shape.fPhi1} Dphi=${shape.fDphi}`);
         break;
      case clTGeoPcon:
      case clTGeoPgon: break;
      case clTGeoXtru: break;
      case clTGeoParaboloid:
         info.push(`Rlo=${conv(shape.fRlo)} Rhi=${conv(shape.fRhi)}`,
                   `A=${conv(shape.fA)} B=${conv(shape.fB)}`);
         break;
      case clTGeoHype:
         info.push(`Rmin=${conv(shape.fRmin)} Rmax=${conv(shape.fRmax)}`,
                   `StIn=${conv(shape.fStIn)} StOut=${conv(shape.fStOut)}`);
         break;
      case clTGeoCompositeShape: break;
      case clTGeoShapeAssembly: break;
      case clTGeoScaledShape:
         info = provideObjectInfo(shape.fShape);
         if (shape.fScale)
            info.unshift(`Scale X=${shape.fScale.fScale[0]} Y=${shape.fScale.fScale[1]} Z=${shape.fScale.fScale[2]}`);
         break;
   }

   return info;
}

/** @summary Creates projection matrix for the camera
  * @private */
function createProjectionMatrix(camera) {
   let cameraProjectionMatrix = new Matrix4();

   camera.updateMatrixWorld();

   camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
   cameraProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse);

   return cameraProjectionMatrix;
}

/** @summary Creates frustum
  * @private */
function createFrustum(source) {
   if (!source) return null;

   if (source instanceof PerspectiveCamera)
      source = createProjectionMatrix(source);

   let frustum = new Frustum();
   frustum.setFromProjectionMatrix(source);

   frustum.corners = new Float32Array([
       1,  1,  1,
       1,  1, -1,
       1, -1,  1,
       1, -1, -1,
      -1,  1,  1,
      -1,  1, -1,
      -1, -1,  1,
      -1, -1, -1,
       0,  0,  0 // also check center of the shape
   ]);

   frustum.test = new Vector3(0,0,0);

   frustum.CheckShape = function(matrix, shape) {
      let pnt = this.test, len = this.corners.length, corners = this.corners, i;

      for (i = 0; i < len; i+=3) {
         pnt.x = corners[i] * shape.fDX;
         pnt.y = corners[i+1] * shape.fDY;
         pnt.z = corners[i+2] * shape.fDZ;
         if (this.containsPoint(pnt.applyMatrix4(matrix))) return true;
     }

     return false;
   };

   frustum.CheckBox = function(box) {
      let pnt = this.test, cnt = 0;
      pnt.set(box.min.x, box.min.y, box.min.z);
      if (this.containsPoint(pnt)) cnt++;
      pnt.set(box.min.x, box.min.y, box.max.z);
      if (this.containsPoint(pnt)) cnt++;
      pnt.set(box.min.x, box.max.y, box.min.z);
      if (this.containsPoint(pnt)) cnt++;
      pnt.set(box.min.x, box.max.y, box.max.z);
      if (this.containsPoint(pnt)) cnt++;
      pnt.set(box.max.x, box.max.y, box.max.z);
      if (this.containsPoint(pnt)) cnt++;
      pnt.set(box.max.x, box.min.y, box.max.z);
      if (this.containsPoint(pnt)) cnt++;
      pnt.set(box.max.x, box.max.y, box.min.z);
      if (this.containsPoint(pnt)) cnt++;
      pnt.set(box.max.x, box.max.y, box.max.z);
      if (this.containsPoint(pnt)) cnt++;
      return cnt > 5; // only if 6 edges and more are seen, we think that box is fully visible
   };

   return frustum;
}

/** @summary Checks if two stack arrays are identical
  * @private */
function isSameStack(stack1, stack2) {
   if (!stack1 || !stack2) return false;
   if (stack1 === stack2) return true;
   if (stack1.length !== stack2.length) return false;
   for (let k = 0; k < stack1.length; ++k)
      if (stack1[k] !== stack2[k]) return false;
   return true;
}


/**
  * @summary class for working with cloned nodes
  *
  * @private
  */

class ClonedNodes {

   /** @summary Constructor */
   constructor(obj, clones) {
      this.toplevel = true; // indicate if object creates top-level structure with Nodes and Volumes folder
      this.name_prefix = ''; // name prefix used for nodes names
      this.maxdepth = 1;  // maximal hierarchy depth, required for transparency
      this.vislevel = 4;  // maximal depth of nodes visibility aka gGeoManager->SetVisLevel, same default
      this.maxnodes = 10000; // maximal number of visisble nodes aka gGeoManager->fMaxVisNodes

      if (obj) {
         if (obj.$geoh) this.toplevel = false;
         this.createClones(obj);
      } else if (clones) {
         this.nodes = clones;
      }
   }

   /** @summary Set maximal depth for nodes visibility */
   setVisLevel(lvl) {
      this.vislevel = lvl && Number.isInteger(lvl) ? lvl : 4;
   }

   /** @summary Returns maximal depth for nodes visibility */
   getVisLevel() {
      return this.vislevel;
   }

   /** @summary Set maximal number of visible nodes */
   setMaxVisNodes(v) {
      this.maxnodes = Number.isFinite(v) ? v : 10000;
   }

   /** @summary Returns configured maximal number of visible nodes */
   getMaxVisNodes() {
      return this.maxnodes;
   }

   /** @summary Insert node into existing array */
   updateNode(node) {
      if (node && Number.isInteger(node.id) && (node.id < this.nodes.length))
         this.nodes[node.id] = node;
   }

   /** @summary Returns TGeoShape for element with given indx */
   getNodeShape(indx) {
      if (!this.origin || !this.nodes) return null;
      let obj = this.origin[indx], clone = this.nodes[indx];
      if (!obj || !clone) return null;
      if (clone.kind === kindGeo) {
         if (obj.fVolume) return obj.fVolume.fShape;
      } else {
         return obj.fShape;
      }
      return null;
   }

   /** @summary function to cleanup as much as possible structures
     * @desc Provided parameters drawnodes and drawshapes are arrays created during building of geometry */
   cleanup(drawnodes, drawshapes) {

      if (drawnodes) {
         for (let n = 0; n < drawnodes.length; ++n) {
            delete drawnodes[n].stack;
            drawnodes[n] = undefined;
         }
      }

      if (drawshapes) {
         for (let n = 0; n < drawshapes.length; ++n) {
            delete drawshapes[n].geom;
            drawshapes[n] = undefined;
         }
      }

      if (this.nodes) {
         for (let n = 0; n < this.nodes.length; ++n) {
            if (this.nodes[n])
               delete this.nodes[n].chlds;
         }
      }

      delete this.nodes;
      delete this.origin;

      delete this.sortmap;
   }

   /** @summary Create complete description for provided Geo object */
   createClones(obj, sublevel, kind) {
      if (!sublevel) {

         if (obj && obj._typename == '$$Shape$$')
            return this.createClonesForShape(obj);

         this.origin = [];
         sublevel = 1;
         kind = getNodeKind(obj);
      }

      if ((kind < 0) || !obj || ('_refid' in obj)) return;

      obj._refid = this.origin.length;
      this.origin.push(obj);
      if (sublevel > this.maxdepth) this.maxdepth = sublevel;

      let chlds = null;
      if (kind === kindGeo)
         chlds = (obj.fVolume && obj.fVolume.fNodes) ? obj.fVolume.fNodes.arr : null;
      else
         chlds = obj.fElements ? obj.fElements.arr : null;

      if (chlds !== null) {
         checkDuplicates(obj, chlds);
         for (let i = 0; i < chlds.length; ++i)
            this.createClones(chlds[i], sublevel + 1, kind);
      }

      if (sublevel > 1) return;

      this.nodes = [];

      let sortarr = [];

      // first create nodes objects
      for (let id = 0; id < this.origin.length; ++id) {
         // let obj = this.origin[id];
         let node = { id, kind, vol: 0, nfaces: 0 };
         this.nodes.push(node);
         sortarr.push(node); // array use to produce sortmap
      }

      // than fill children lists
      for (let n = 0; n < this.origin.length; ++n) {
         let obj = this.origin[n], clone = this.nodes[n],
             chlds = null, shape = null;

         if (kind === kindEve) {
            shape = obj.fShape;
            if (obj.fElements) chlds = obj.fElements.arr;
         } else if (obj.fVolume) {
            shape = obj.fVolume.fShape;
            if (obj.fVolume.fNodes) chlds = obj.fVolume.fNodes.arr;
         }

         let matrix = getNodeMatrix(kind, obj);
         if (matrix) {
            clone.matrix = matrix.elements; // take only matrix elements, matrix will be constructed in worker
            if (clone.matrix[0] === 1) {
               let issimple = true;
               for (let k = 1; (k < clone.matrix.length) && issimple; ++k)
                  issimple = (clone.matrix[k] === ((k === 5) || (k === 10) || (k === 15) ? 1 : 0));
               if (issimple) delete clone.matrix;
            }
            if (clone.matrix && (kind == kindEve)) clone.abs_matrix = true;
         }
         if (shape) {
            clone.fDX = shape.fDX;
            clone.fDY = shape.fDY;
            clone.fDZ = shape.fDZ;
            clone.vol = shape.fDX * shape.fDY * shape.fDZ;
            if (shape.$nfaces === undefined)
               shape.$nfaces = createGeometry(shape, -1);
            clone.nfaces = shape.$nfaces;
            if (clone.nfaces <= 0) clone.vol = 0;
         }

         if (!chlds) continue;

         // in cloned object children is only list of ids
         clone.chlds = new Array(chlds.length);
         for (let k = 0; k < chlds.length; ++k)
            clone.chlds[k] = chlds[k]._refid;
      }

      // remove _refid identifiers from original objects
      for (let n = 0; n < this.origin.length; ++n)
         delete this.origin[n]._refid;

      // do sorting once
      sortarr.sort((a, b) => b.vol - a.vol);

      // remember sort map and also sortid
      this.sortmap = new Array(this.nodes.length);
      for (let n = 0; n < this.nodes.length; ++n) {
         this.sortmap[n] = sortarr[n].id;
         sortarr[n].sortid = n;
      }
   }

   /** @summary Create elementary item with single already existing shape
     * @desc used by details view of geometry shape */
   createClonesForShape(obj) {
      this.origin = [];

      // indicate that just plain shape is used
      this.plain_shape = obj;

      let node = {
            id: 0, sortid: 0, kind: kindShape,
            name: 'Shape',
            nfaces: obj.nfaces,
            fDX: 1, fDY: 1, fDZ: 1, vol: 1,
            vis: true
         };

      this.nodes = [ node ];
   }

   /** @summary Count all visisble nodes */
   countVisibles() {
      let cnt = 0, len = this.nodes?.length || 0;
      for (let k = 0; k < len; ++k)
          if (this.nodes[k].vis) cnt++;
      return cnt;
   }

   /** @summary Mark visisble nodes.
     * @desc Set only basic flags, actual visibility depends from hierarchy */
   markVisibles(on_screen, copy_bits, hide_top_volume) {
      if (this.plain_shape) return 1;
      if (!this.origin || !this.nodes) return 0;

      let res = 0;

      for (let n = 0; n < this.nodes.length; ++n) {
         let clone = this.nodes[n], obj = this.origin[n];

         clone.vis = 0; // 1 - only with last level
         delete clone.nochlds;

         if (clone.kind === kindGeo) {
            if (obj.fVolume) {
               if (on_screen) {
                  // on screen bits used always, childs always checked
                  clone.vis = testGeoBit(obj.fVolume, geoBITS.kVisOnScreen) ? 99 : 0;

                  if ((n == 0) && clone.vis && hide_top_volume) clone.vis = 0;

                  if (copy_bits) {
                     setGeoBit(obj.fVolume, geoBITS.kVisNone, false);
                     setGeoBit(obj.fVolume, geoBITS.kVisThis, (clone.vis > 0));
                     setGeoBit(obj.fVolume, geoBITS.kVisDaughters, true);
                     setGeoBit(obj, geoBITS.kVisDaughters, true);
                  }

               } else {
                  clone.vis = !testGeoBit(obj.fVolume, geoBITS.kVisNone) &&
                               testGeoBit(obj.fVolume, geoBITS.kVisThis) ? 99 : 0;

                  if (!testGeoBit(obj, geoBITS.kVisDaughters) ||
                      !testGeoBit(obj.fVolume, geoBITS.kVisDaughters)) clone.nochlds = true;

                  // node with childs only shown in case if it is last level in hierarchy
                  if ((clone.vis > 0) && clone.chlds && !clone.nochlds) clone.vis = 1;

                  // special handling for top node
                  if (n === 0) {
                     if (hide_top_volume) clone.vis = 0;
                     delete clone.nochlds;
                  }
               }
            }
         } else {
            clone.vis = obj.fRnrSelf ? 99 : 0;

            // when the only node is selected, draw it
            if ((n === 0) && (this.nodes.length === 1)) clone.vis = 99;

            this.vislevel = 9999; // automatically take all volumes
         }

         // shape with zero volume or without faces will not be observed
         if ((clone.vol <= 0) || (clone.nfaces <= 0)) clone.vis = 0;

         if (clone.vis) res++;
      }

      return res;
   }

   /** @summary After visibility flags is set, produce idshift for all nodes as it would be maximum level */
   produceIdShifts() {
      for (let k = 0; k < this.nodes.length; ++k)
         this.nodes[k].idshift = -1;

      function scan_func(nodes, node) {
         if (node.idshift < 0) {
            node.idshift = 0;
            if (node.chlds)
               for(let k = 0; k<node.chlds.length; ++k)
                  node.idshift += scan_func(nodes, nodes[node.chlds[k]]);
         }

         return node.idshift + 1;
      }

      scan_func(this.nodes, this.nodes[0]);
   }

   /** @summary Extract only visibility flags
     * @desc Used to transfer them to the worker */
   getVisibleFlags() {
      let res = new Array(this.nodes.length);
      for (let n=0;n<this.nodes.length;++n)
         res[n] = { vis: this.nodes[n].vis, nochlds: this.nodes[n].nochlds };
      return res;
   }

   /** @summary Assign only visibility flags, extracted with getVisibleFlags */
   setVisibleFlags(flags) {
      if (!this.nodes || !flags || !flags.length != this.nodes.length)
         return 0;

      let res = 0;
      for (let n=0;n<this.nodes.length;++n) {
         let clone = this.nodes[n];

         clone.vis = flags[n].vis;
         clone.nochlds = flags[n].nochlds;
         if (clone.vis) res++;
      }

      return res;
   }

   /** @summary Scan visible nodes in hierarchy, starting from nodeid
     * @desc Each entry in hierarchy get its unique id, which is not changed with visibility flags */
   scanVisible(arg, vislvl) {

      if (!this.nodes) return 0;

      if (vislvl === undefined) {
         if (!arg) arg = {};

         vislvl = arg.vislvl || this.vislevel || 4; // default 3 in ROOT
         if (vislvl > 88) vislvl = 88;

         arg.stack = new Array(100); // current stack
         arg.nodeid = 0;
         arg.counter = 0; // sequence ID of the node, used to identify it later
         arg.last = 0;
         arg.CopyStack = function(factor) {
            let entry = { nodeid: this.nodeid, seqid: this.counter, stack: new Array(this.last) };
            if (factor) entry.factor = factor; // factor used to indicate importance of entry, will be built as first
            for (let n=0;n<this.last;++n) entry.stack[n] = this.stack[n+1]; // copy stack
            return entry;
         };

         if (arg.domatrix) {
            arg.matrices = [];
            arg.mpool = [ new Matrix4() ]; // pool of Matrix objects to avoid permanent creation
            arg.getmatrix = function() { return this.matrices[this.last]; };
         }
      }

      let res = 0, node = this.nodes[arg.nodeid];

      if (arg.domatrix) {
         if (!arg.mpool[arg.last+1])
            arg.mpool[arg.last+1] = new Matrix4();

         let prnt = (arg.last > 0) ? arg.matrices[arg.last-1] : new Matrix4();
         if (node.matrix) {
            arg.matrices[arg.last] = arg.mpool[arg.last].fromArray(prnt.elements);
            arg.matrices[arg.last].multiply(arg.mpool[arg.last+1].fromArray(node.matrix));
         } else {
            arg.matrices[arg.last] = prnt;
         }
      }

      if (node.nochlds) vislvl = 0;

      if (node.vis > vislvl) {
         if (!arg.func || arg.func(node)) res++;
      }

      arg.counter++;

      if ((vislvl > 0) && node.chlds) {
         arg.last++;
         for (let i = 0; i < node.chlds.length; ++i) {
            arg.nodeid = node.chlds[i];
            arg.stack[arg.last] = i; // in the stack one store index of child, it is path in the hierarchy
            res += this.scanVisible(arg, vislvl-1);
         }
         arg.last--;
      } else {
         arg.counter += (node.idshift || 0);
      }

      if (arg.last === 0) {
         delete arg.last;
         delete arg.stack;
         delete arg.CopyStack;
         delete arg.counter;
         delete arg.matrices;
         delete arg.mpool;
         delete arg.getmatrix;
      }

      return res;
   }

   /** @summary Return node name with given id.
    * @desc Either original object or description is used */
   getNodeName(nodeid) {
      if (this.origin) {
         let obj = this.origin[nodeid];
         return obj ? getObjectName(obj) : '';
      }
      let node = this.nodes[nodeid];
      return node ? node.name : '';
   }

   /** @summary Returns description for provide stack */
   resolveStack(stack, withmatrix) {

      let res = { id: 0, obj: null, node: this.nodes[0], name: this.name_prefix };

      // if (!this.toplevel || (this.nodes.length === 1) || (res.node.kind === 1)) res.name = '';

      if (withmatrix) {
         res.matrix = new Matrix4();
         if (res.node.matrix) res.matrix.fromArray(res.node.matrix);
      }

      if (this.origin)
         res.obj = this.origin[0];

      //if (!res.name)
      //   res.name = this.getNodeName(0);

      if (stack)
         for(let lvl = 0; lvl < stack.length; ++lvl) {
            res.id = res.node.chlds[stack[lvl]];
            res.node = this.nodes[res.id];

            if (this.origin)
               res.obj = this.origin[res.id];

            let subname = this.getNodeName(res.id);
            if (subname) {
               if (res.name) res.name += '/';
               res.name += subname;
            }

            if (withmatrix && res.node.matrix)
               res.matrix.multiply(new Matrix4().fromArray(res.node.matrix));
         }

      return res;
   }

   /** @summary Create stack array based on nodes ids array.
    * @desc Ids list should correspond to existing nodes hierarchy */
   buildStackByIds(ids) {
      if (!ids) return null;

      if (ids[0] !== 0) {
         console.error('wrong ids - first should be 0');
         return null;
      }

      let node = this.nodes[0], stack = [];

      for (let k = 1; k < ids.length; ++k) {
         let nodeid = ids[k];
         if (!node) return null;
         let chindx = node.chlds.indexOf(nodeid);
         if (chindx < 0) {
            console.error(`wrong nodes ids ${ids[k]} is not child of ${ids[k-1]}`);
            return null;
         }

         stack.push(chindx);
         node = this.nodes[nodeid];
      }

      return stack;
   }

   /** @summary Retuns ids array which correspond to the stack */
   buildIdsByStack(stack) {
      if (!stack) return null;
      let node = this.nodes[0], ids = [0];
      for (let k = 0; k < stack.length; ++k) {
         let id = node.chlds[stack[k]];
         ids.push(id);
         node = this.nodes[id];
      }
      return ids;
   }

   /** @summary Returns true if stack includes at any place provided nodeid */
   isIdInStack(nodeid, stack) {

      if (!nodeid) return true;

      let node = this.nodes[0], id = 0;

      for(let lvl = 0; lvl < stack.length; ++lvl) {
         id = node.chlds[stack[lvl]];
         if (id == nodeid) return true;
         node = this.nodes[id];
      }

      return false;
   }

   /** @summary Find stack by name which include names of all parents */
   findStackByName(fullname) {

      let names = fullname.split('/'), currid = 0, stack = [];

      if (this.getNodeName(currid) !== names[0]) return null;

      for (let n = 1; n < names.length; ++n) {
         let node = this.nodes[currid];
         if (!node.chlds) return null;

         for (let k=0;k<node.chlds.length;++k) {
            let chldid = node.chlds[k];
            if (this.getNodeName(chldid) === names[n]) { stack.push(k); currid = chldid; break; }
         }

         // no new entry - not found stack
         if (stack.length === n - 1) return null;
      }

      return stack;
   }

   /** @summary Set usage of default ROOT colors */
   setDefaultColors(on) {
      this.use_dflt_colors = on;
      if (this.use_dflt_colors && !this.dflt_table) {

         let dflt = { kWhite: 0,  kBlack: 1, kGray: 920,
                      kRed: 632, kGreen: 416, kBlue: 600, kYellow: 400, kMagenta: 616, kCyan: 432,
                      kOrange: 800, kSpring: 820, kTeal: 840, kAzure: 860, kViolet: 880, kPink: 900 };

         let nmax = 110, col = [];
         for (let i=0;i<nmax;i++) col.push(dflt.kGray);

         //  here we should create a new TColor with the same rgb as in the default
         //  ROOT colors used below
         col[ 3] = dflt.kYellow-10;
         col[ 4] = col[ 5] = dflt.kGreen-10;
         col[ 6] = col[ 7] = dflt.kBlue-7;
         col[ 8] = col[ 9] = dflt.kMagenta-3;
         col[10] = col[11] = dflt.kRed-10;
         col[12] = dflt.kGray+1;
         col[13] = dflt.kBlue-10;
         col[14] = dflt.kOrange+7;
         col[16] = dflt.kYellow+1;
         col[20] = dflt.kYellow-10;
         col[24] = col[25] = col[26] = dflt.kBlue-8;
         col[29] = dflt.kOrange+9;
         col[79] = dflt.kOrange-2;

         this.dflt_table = col;
      }
   }

   /** @summary Provide different properties of draw entry nodeid
     * @desc Only if node visible, material will be created */
   getDrawEntryProperties(entry, root_colors) {

      let clone = this.nodes[entry.nodeid];

      if (clone.kind === kindShape) {
         let prop = { name: clone.name, nname: clone.name, shape: null, material: null, chlds: null },
            _opacity = entry.opacity || 1;
         prop.fillcolor = new Color$1( entry.color ? `rgb(${entry.color})` : 'blue' );
         prop.material = new MeshLambertMaterial({ transparent: _opacity < 1,
                          opacity: _opacity, wireframe: false, color: prop.fillcolor,
                          side: FrontSide, vertexColors: false,
                          depthWrite: _opacity == 1 });
         prop.material.inherentOpacity = _opacity;

         return prop;
      }

      if (!this.origin) {
         console.error('origin not there - kind', clone.kind, entry.nodeid, clone);
         return null;
      }

      let node = this.origin[entry.nodeid];

      if (clone.kind === kindEve) {
         // special handling for EVE nodes

         let prop = { name: getObjectName(node), nname: getObjectName(node), shape: node.fShape, material: null, chlds: null };

         if (node.fElements !== null) prop.chlds = node.fElements.arr;

         {
            let opacity = Math.min(1, node.fRGBA[3]);
            prop.fillcolor = new Color$1( node.fRGBA[0], node.fRGBA[1], node.fRGBA[2] );
            prop.material = new MeshLambertMaterial({ transparent: opacity < 1,
                             opacity, wireframe: false, color: prop.fillcolor,
                             side: FrontSide, vertexColors: false, depthWrite: opacity == 1 });
            prop.material.inherentOpacity = opacity;
         }

         return prop;
      }

      let volume = node.fVolume;

      let prop = { name: getObjectName(volume), nname: getObjectName(node), volume: node.fVolume, shape: volume.fShape, material: null, chlds: null };

      if (node.fVolume.fNodes !== null) prop.chlds = node.fVolume.fNodes.arr;

      if (volume) prop.linewidth = volume.fLineWidth;

      {

         // TODO: maybe correctly extract ROOT colors here?
         let _opacity = 1.0;
         if (!root_colors) root_colors = ['white', 'black', 'red', 'green', 'blue', 'yellow', 'magenta', 'cyan'];

         if (entry.custom_color)
            prop.fillcolor = entry.custom_color;
         else if ((volume.fFillColor > 1) && (volume.fLineColor == 1))
            prop.fillcolor = root_colors[volume.fFillColor];
         else if (volume.fLineColor >= 0)
            prop.fillcolor = root_colors[volume.fLineColor];

         let mat = volume?.fMedium?.fMaterial;

         if (mat) {
            let fillstyle = mat.fFillStyle,
                transparency = (fillstyle >= 3000 && fillstyle <= 3100) ? fillstyle - 3000 : 0;

            if (this.use_dflt_colors) {
               let matZ = Math.round(mat.fZ), icol = this.dflt_table[matZ];
               prop.fillcolor = root_colors[icol];
               if (mat.fDensity < 0.1) transparency = 60;
            }

            if (transparency > 0)
               _opacity = (100.0 - transparency) / 100.0;
            if (prop.fillcolor === undefined)
               prop.fillcolor = root_colors[mat.fFillColor];
         }
         if (prop.fillcolor === undefined)
            prop.fillcolor = 'lightgrey';

         prop.material = new MeshLambertMaterial({ transparent: _opacity < 1,
                              opacity: _opacity, wireframe: false, color: prop.fillcolor,
                              side: FrontSide, vertexColors: false,
                              depthWrite: _opacity == 1 });
         prop.material.inherentOpacity = _opacity;
      }

      return prop;
   }

   /** @summary Creates hierarchy of Object3D for given stack entry
     * @desc Such hierarchy repeats hierarchy of TGeoNodes and set matrix for the objects drawing
     * also set renderOrder, required to handle transparency */
   createObject3D(stack, toplevel, options) {

      let node = this.nodes[0], three_prnt = toplevel, draw_depth = 0,
          force = isObject(options) || (options === 'force');

      for(let lvl = 0; lvl <= stack.length; ++lvl) {
         let nchld = (lvl > 0) ? stack[lvl-1] : 0;
         // extract current node
         if (lvl > 0)  node = this.nodes[node.chlds[nchld]];

         let obj3d = undefined;

         if (three_prnt.children)
            for (let i = 0; i < three_prnt.children.length; ++i) {
               if (three_prnt.children[i].nchld === nchld) {
                  obj3d = three_prnt.children[i];
                  break;
               }
            }

         if (obj3d) {
            three_prnt = obj3d;
            if (obj3d.$jsroot_drawable) draw_depth++;
            continue;
         }

         if (!force) return null;

         obj3d = new Object3D();

         if (node.abs_matrix) {
            obj3d.absMatrix = new Matrix4();
            obj3d.absMatrix.fromArray(node.matrix);
         } else if (node.matrix) {
            obj3d.matrix.fromArray(node.matrix);
            obj3d.matrix.decompose( obj3d.position, obj3d.quaternion, obj3d.scale );
         }

         // this.accountNodes(obj3d);
         obj3d.nchld = nchld; // mark index to find it again later

         // add the mesh to the scene
         three_prnt.add(obj3d);

         // this is only for debugging - test inversion of whole geometry
         if ((lvl == 0) && isObject(options) && options.scale) {
            if ((options.scale.x < 0) || (options.scale.y < 0) || (options.scale.z < 0)) {
               obj3d.scale.copy(options.scale);
               obj3d.updateMatrix();
            }
         }

         obj3d.updateMatrixWorld();

         three_prnt = obj3d;
      }

      if ((options === 'mesh') || (options === 'delete_mesh')) {
         let mesh = null;
         if (three_prnt)
            for (let n = 0; (n < three_prnt.children.length) && !mesh; ++n) {
               let chld = three_prnt.children[n];
               if ((chld.type === 'Mesh') && (chld.nchld === undefined)) mesh = chld;
            }

         if ((options === 'mesh') || !mesh) return mesh;

         let res = three_prnt;
         while (mesh && (mesh !== toplevel)) {
            three_prnt = mesh.parent;
            three_prnt.remove(mesh);
            mesh = (three_prnt.children.length == 0) ? three_prnt : null;
         }

         return res;
      }

      if (three_prnt) {
         three_prnt.$jsroot_drawable = true;
         three_prnt.$jsroot_depth = draw_depth;
      }

      return three_prnt;
   }

   /** @summary Get volume boundary */
   getVolumeBoundary(viscnt, facelimit, nodeslimit) {

      let result = { min: 0, max: 1, sortidcut: 0 };

      if (!this.sortmap) {
         console.error('sorting map do not exist');
         return result;
      }

      let maxNode, currNode, cnt=0, facecnt=0;

      for (let n = 0; (n < this.sortmap.length) && (cnt < nodeslimit) && (facecnt < facelimit); ++n) {
         let id = this.sortmap[n];
         if (viscnt[id] === 0) continue;
         currNode = this.nodes[id];
         if (!maxNode) maxNode = currNode;
         cnt += viscnt[id];
         facecnt += viscnt[id] * currNode.nfaces;
      }

      if (!currNode) {
         console.error('no volumes selected');
         return result;
      }

      // console.log(`Volume boundary ${currNode.vol}  cnt=${cnt}  faces=${facecnt}`);
      result.max = maxNode.vol;
      result.min = currNode.vol;
      result.sortidcut = currNode.sortid; // latest node is not included
      return result;
   }

   /** @summary Collects visible nodes, using maxlimit
     * @desc One can use map to define cut based on the volume or serious of cuts */
   collectVisibles(maxnumfaces, frustum) {

      // in simple case shape as it is
      if (this.plain_shape)
         return { lst: [ { nodeid: 0, seqid: 0, stack: [], factor: 1, shapeid: 0, server_shape: this.plain_shape } ], complete: true };

      let arg = {
         facecnt: 0,
         viscnt: new Array(this.nodes.length), // counter for each node
         vislvl: this.getVisLevel(),
         reset() {
            this.total = 0;
            this.facecnt = 0;
            this.viscnt.fill(0);
         },
         // nodes: this.nodes,
         func(node) {
            this.total++;
            this.facecnt += node.nfaces;
            this.viscnt[node.id]++;
            return true;
         }
      };

      arg.reset();

      let total = this.scanVisible(arg),
          maxnumnodes = this.getMaxVisNodes();

      if (maxnumnodes > 0) {
         while ((total > maxnumnodes) && (arg.vislvl > 1)) {
            arg.vislvl--;
            arg.reset();
            total = this.scanVisible(arg);
         }
      }

      this.actual_level = arg.vislvl; // not used, can be shown somewhere in the gui

      let minVol = 0, maxVol = 0, camVol = -1, camFact = 10, sortidcut = this.nodes.length + 1;

      console.log(`Total visible nodes ${total} numfaces ${arg.facecnt}`);

      if (arg.facecnt > maxnumfaces) {

         let bignumfaces = maxnumfaces * (frustum ? 0.8 : 1.0),
             bignumnodes = maxnumnodes * (frustum ? 0.8 : 1.0);

         // define minimal volume, which always to shown
         let boundary = this.getVolumeBoundary(arg.viscnt, bignumfaces, bignumnodes);

         minVol = boundary.min;
         maxVol = boundary.max;
         sortidcut = boundary.sortidcut;

         if (frustum) {
             arg.domatrix = true;
             arg.frustum = frustum;
             arg.totalcam = 0;
             arg.func = function(node) {
                if (node.vol <= minVol) // only small volumes are interesting
                   if (this.frustum.CheckShape(this.getmatrix(), node)) {
                      this.viscnt[node.id]++;
                      this.totalcam += node.nfaces;
                   }

                return true;
             };

             for (let n=0;n<arg.viscnt.length;++n) arg.viscnt[n] = 0;

             this.scanVisible(arg);

             if (arg.totalcam > maxnumfaces*0.2)
                camVol = this.getVolumeBoundary(arg.viscnt, maxnumfaces*0.2, maxnumnodes*0.2).min;
             else
                camVol = 0;

             camFact = maxVol / ((camVol > 0) ? (camVol > 0) : minVol);

             // console.log(`Limit for camera ${camVol}  faces in camera view ${arg.totalcam}`);
         }
      }

      arg.items = [];

      arg.func = function(node) {
         if (node.sortid < sortidcut) {
            this.items.push(this.CopyStack());
         } else if ((camVol >= 0) && (node.vol > camVol)) {
            if (this.frustum.CheckShape(this.getmatrix(), node))
               this.items.push(this.CopyStack(camFact));
         }
         return true;
      };

      this.scanVisible(arg);

      return { lst: arg.items, complete: minVol === 0 };
   }

   /** @summary Merge list of drawn objects
     * @desc In current list we should mark if object already exists
     * from previous list we should collect objects which are not there */
   mergeVisibles(current, prev) {

      let indx2 = 0, del = [];
      for (let indx1 = 0; (indx1 < current.length) && (indx2 < prev.length); ++indx1) {

         while ((indx2 < prev.length) && (prev[indx2].seqid < current[indx1].seqid)) {
            del.push(prev[indx2++]); // this entry should be removed
         }

         if ((indx2 < prev.length) && (prev[indx2].seqid === current[indx1].seqid)) {
            if (prev[indx2].done) current[indx1].done = true; // copy ready flag
            indx2++;
         }
      }

      // remove rest
      while (indx2 < prev.length)
         del.push(prev[indx2++]);

      return del;
   }

   /** @summary Collect all uniques shapes which should be built
    *  @desc Check if same shape used many times for drawing */
   collectShapes(lst) {

      // nothing else - just that single shape
      if (this.plain_shape)
         return [ this.plain_shape ];

      let shapes = [];

      for (let i=0;i<lst.length;++i) {
         let entry = lst[i];
         let shape = this.getNodeShape(entry.nodeid);

         if (!shape) continue; // strange, but avoid misleading

         if (shape._id === undefined) {
            shape._id = shapes.length;

            shapes.push({ id: shape._id, shape: shape, vol: this.nodes[entry.nodeid].vol, refcnt: 1, factor: 1, ready: false });

            // shapes.push( { obj: shape, vol: this.nodes[entry.nodeid].vol });
         } else {
            shapes[shape._id].refcnt++;
         }

         entry.shape = shapes[shape._id]; // remember shape used

         // use maximal importance factor to push element to the front
         if (entry.factor && (entry.factor>entry.shape.factor))
            entry.shape.factor = entry.factor;
      }

      // now sort shapes in volume decrease order
      shapes.sort((a,b) => b.vol*b.factor - a.vol*a.factor);

      // now set new shape ids according to the sorted order and delete temporary field
      for (let n = 0; n < shapes.length; ++n) {
         let item = shapes[n];
         item.id = n; // set new ID
         delete item.shape._id; // remove temporary field
      }

      // as last action set current shape id to each entry
      for (let i = 0; i < lst.length; ++i) {
         let entry = lst[i];
         if (entry.shape) {
            entry.shapeid = entry.shape.id; // keep only id for the entry
            delete entry.shape; // remove direct references
         }
      }

      return shapes;
   }

   /** @summary Merge shape lists */
   mergeShapesLists(oldlst, newlst) {

      if (!oldlst) return newlst;

      // set geometry to shape object itself
      for (let n = 0; n < oldlst.length; ++n) {
         let item = oldlst[n];

         item.shape._geom = item.geom;
         delete item.geom;

         if (item.geomZ !== undefined) {
            item.shape._geomZ = item.geomZ;
            delete item.geomZ;
         }
      }

      // take from shape (if match)
      for (let n = 0; n < newlst.length; ++n) {
         let item = newlst[n];

         if (item.shape._geom !== undefined) {
            item.geom = item.shape._geom;
            delete item.shape._geom;
         }

         if (item.shape._geomZ !== undefined) {
            item.geomZ = item.shape._geomZ;
            delete item.shape._geomZ;
         }
      }

      // now delete all unused geometries
      for (let n = 0; n < oldlst.length; ++n) {
         let item = oldlst[n];
         delete item.shape._geom;
         delete item.shape._geomZ;
      }

      return newlst;
   }

   /** @summary Build shapes */
   buildShapes(lst, limit, timelimit) {

      let created = 0,
          tm1 = new Date().getTime(),
          res = { done: false, shapes: 0, faces: 0, notusedshapes: 0 };

      for (let n = 0; n < lst.length; ++n) {
         let item = lst[n];

         // if enough faces are produced, nothing else is required
         if (res.done) { item.ready = true; continue; }

         if (!item.ready) {
            item._typename = '$$Shape$$'; // let reuse item for direct drawing
            item.ready = true;
            if (item.geom === undefined) {
               item.geom = createGeometry(item.shape);
               if (item.geom) created++; // indicate that at least one shape was created
            }
            item.nfaces = countGeometryFaces(item.geom);
         }

         res.shapes++;
         if (!item.used) res.notusedshapes++;
         res.faces += item.nfaces*item.refcnt;

         if (res.faces >= limit) {
            res.done = true;
         } else if ((created > 0.01*lst.length) && (timelimit !== undefined)) {
            let tm2 = new Date().getTime();
            if (tm2-tm1 > timelimit) return res;
         }
      }

      res.done = true;

      return res;
   }

   /** @summary Format REveGeomNode data to be able use it in list of clones
     * @private */
   static formatServerElement(elem) {
      elem.kind = 2; // special element for geom viewer, used in TGeoPainter
      elem.vis = 2; // visibility is alwys on
      let m = elem.matr;
      delete elem.matr;
      if (!m?.length) return elem;

      if (m.length == 16) {
         elem.matrix = m;
      } else {
         let nm = elem.matrix = new Array(16);
         nm.fill(0);
         nm[0] = nm[5] = nm[10] = nm[15] = 1;

         if (m.length == 3) {
            // translation martix
            nm[12] = m[0]; nm[13] = m[1]; nm[14] = m[2];
         } else if (m.length == 4) {
            // scale matrix
            nm[0] = m[0]; nm[5] = m[1]; nm[10] = m[2]; nm[15] = m[3];
         } else if (m.length == 9) {
            // rotation matrix
            nm[0] = m[0]; nm[4] = m[1]; nm[8] = m[2];
            nm[1] = m[3]; nm[5] = m[4]; nm[9] = m[5];
            nm[2] = m[6]; nm[6] = m[7]; nm[10] = m[8];
         } else {
            console.error(`wrong number of elements ${m.length} in the matrix`);
         }
      }
      return elem;
   }
}

/** @summary Create flipped mesh for the shape
  * @desc When transformation matrix includes one or several inversion of axis,
  * one should inverse geometry object, otherwise three.js cannot correctly draw it
  * @param {Object} shape - TGeoShape object
  * @param {Object} material - material
  * @private */
function createFlippedMesh(shape, material) {

   let flip =  new Vector3(1,1,-1);

   if (shape.geomZ === undefined) {

      let pos = shape.geom.getAttribute('position').array,
          norm = shape.geom.getAttribute('normal').array,
          index = shape.geom.getIndex();

      if (index) {
         // we need to unfold all points to
         let arr = index.array,
             i0 = shape.geom.drawRange.start,
             ilen = shape.geom.drawRange.count;
         if (i0 + ilen > arr.length) ilen = arr.length - i0;

         let dpos = new Float32Array(ilen*3), dnorm = new Float32Array(ilen*3);
         for (let ii = 0; ii < ilen; ++ii) {
            let k = arr[i0 + ii];
            if ((k < 0) || (k*3 >= pos.length))
               console.log(`strange index ${k*3} totallen = ${pos.length}`);
            dpos[ii*3] = pos[k*3];
            dpos[ii*3+1] = pos[k*3+1];
            dpos[ii*3+2] = pos[k*3+2];
            dnorm[ii*3] = norm[k*3];
            dnorm[ii*3+1] = norm[k*3+1];
            dnorm[ii*3+2] = norm[k*3+2];
         }

         pos = dpos; norm = dnorm;
      }

      let len = pos.length, n, shift = 0,
          newpos = new Float32Array(len),
          newnorm = new Float32Array(len);

      // we should swap second and third point in each face
      for (n = 0; n < len; n += 3) {
         newpos[n]   = pos[n+shift];
         newpos[n+1] = pos[n+1+shift];
         newpos[n+2] = -pos[n+2+shift];

         newnorm[n]   = norm[n+shift];
         newnorm[n+1] = norm[n+1+shift];
         newnorm[n+2] = -norm[n+2+shift];

         shift+=3; if (shift===6) shift=-3; // values 0,3,-3
      }

      shape.geomZ = new BufferGeometry();
      shape.geomZ.setAttribute('position', new BufferAttribute(newpos, 3));
      shape.geomZ.setAttribute('normal', new BufferAttribute(newnorm, 3));
      // normals are calculated with normal geometry and correctly scaled
      // geom.computeVertexNormals();
   }

   let mesh = new Mesh( shape.geomZ, material );
   mesh.scale.copy(flip);
   mesh.updateMatrix();

   mesh._flippedMesh = true;

   return mesh;
}

/** @summary extract code of Box3.expandByObject
  * @desc Major difference - do not traverse hierarchy
  * @private */
function getBoundingBox(node, box3, local_coordinates) {
   if (!node?.geometry) return box3;

   if (!box3) box3 = new Box3().makeEmpty();

   if (!local_coordinates) node.updateWorldMatrix(false, false);

   let v1 = new Vector3(), attribute = node.geometry.attributes?.position;

   if ( attribute !== undefined )
      for (let i = 0, l = attribute.count; i < l; i++) {
         // v1.fromAttribute( attribute, i ).applyMatrix4( node.matrixWorld );
         v1.fromBufferAttribute( attribute, i );
         if (!local_coordinates) v1.applyMatrix4( node.matrixWorld );
         box3.expandByPoint( v1 );
      }

   return box3;
}

/** @summary Cleanup shape entity
  * @private */
function cleanupShape(shape) {
   if (!shape) return;

   if (isFunc(shape.geom?.dispose))
      shape.geom.dispose();

   if (isFunc(shape.geomZ?.dispose))
      shape.geomZ.dispose();

   delete shape.geom;
   delete shape.geomZ;
}

/** @summary Set rendering order for created hierarchy
  * @desc depending from provided method sort differently objects
  * @param toplevel - top element
  * @param origin - camera position used to provide sorting
  * @param method - name of sorting method like 'pnt', 'ray', 'size', 'dflt'  */
function produceRenderOrder(toplevel, origin, method, clones) {

   let raycast = new Raycaster();

   function setdefaults(top) {
      if (!top) return;
      top.traverse(obj => {
         obj.renderOrder = obj.defaultOrder || 0;
         if (obj.material) obj.material.depthWrite = true; // by default depthWriting enabled
      });
   }

   function traverse(obj, lvl, arr) {
      // traverse hierarchy and extract all children of given level
      // if (obj.$jsroot_depth === undefined) return;

      if (!obj.children) return;

      for (let k = 0; k < obj.children.length; ++k) {
         let chld = obj.children[k];
         if (chld.$jsroot_order === lvl) {
            if (chld.material) {
               if (chld.material.transparent) {
                  chld.material.depthWrite = false; // disable depth writing for transparent
                  arr.push(chld);
               } else {
                  setdefaults(chld);
               }
            }
         } else if ((obj.$jsroot_depth === undefined) || (obj.$jsroot_depth < lvl)) {
            traverse(chld, lvl, arr);
         }
      }
   }

   function sort(arr, minorder, maxorder) {
      // resort meshes using ray caster and camera position
      // idea to identify meshes which are in front or behind

      if (arr.length > 1000) {
         // too many of them, just set basic level and exit
         for (let i = 0; i < arr.length; ++i)
            arr[i].renderOrder = (minorder + maxorder)/2;
         return false;
      }

      let tmp_vect = new Vector3();

      // first calculate distance to the camera
      // it gives preliminary order of volumes

      for (let i = 0; i < arr.length; ++i) {
         let mesh = arr[i],
             box3 = mesh.$jsroot_box3;

         if (!box3)
            mesh.$jsroot_box3 = box3 = getBoundingBox(mesh);

         if (method === 'size') {
            let sz = box3.getSize(new Vector3());
            mesh.$jsroot_distance = sz.x*sz.y*sz.z;
            continue;
         }

         if (method === 'pnt') {
            mesh.$jsroot_distance = origin.distanceTo(box3.getCenter(tmp_vect));
            continue;
         }

         let dist = Math.min(origin.distanceTo(box3.min), origin.distanceTo(box3.max)),
             pnt = new Vector3(box3.min.x, box3.min.y, box3.max.z);

         dist = Math.min(dist, origin.distanceTo(pnt));
         pnt.set(box3.min.x, box3.max.y, box3.min.z);
         dist = Math.min(dist, origin.distanceTo(pnt));
         pnt.set(box3.max.x, box3.min.y, box3.min.z);
         dist = Math.min(dist, origin.distanceTo(pnt));
         pnt.set(box3.max.x, box3.max.y, box3.min.z);
         dist = Math.min(dist, origin.distanceTo(pnt));
         pnt.set(box3.max.x, box3.min.y, box3.max.z);
         dist = Math.min(dist, origin.distanceTo(pnt));
         pnt.set(box3.min.x, box3.max.y, box3.max.z);
         dist = Math.min(dist, origin.distanceTo(pnt));

         mesh.$jsroot_distance = dist;
      }

      arr.sort((a,b) => a.$jsroot_distance - b.$jsroot_distance);

      let resort = new Array(arr.length);

      for (let i = 0; i < arr.length; ++i) {
         arr[i].$jsroot_index = i;
         resort[i] = arr[i];
      }

      if (method === 'ray')
         for (let i=arr.length - 1; i >= 0; --i) {
            let mesh = arr[i], intersects,
                box3 = mesh.$jsroot_box3,
                direction = box3.getCenter(tmp_vect);

            for(let ntry = 0; ntry < 2; ++ntry) {

               direction.sub(origin).normalize();

               raycast.set( origin, direction );

               intersects = raycast.intersectObjects(arr, false) || []; // only plain array
               let unique = [];

               for (let k1 = 0; k1 < intersects.length; ++k1) {
                  if (unique.indexOf(intersects[k1].object) < 0)
                     unique.push(intersects[k1].object);
                  // if (intersects[k1].object === mesh) break; // trace until object itself
               }

               intersects = unique;

               if ((intersects.indexOf(mesh) < 0) && (ntry > 0))
                  console.log(`MISS ${clones?.resolveStack(mesh.stack)?.name}`);

               if ((intersects.indexOf(mesh) >= 0) || (ntry > 0)) break;

               let pos = mesh.geometry.attributes.position.array;

               direction = new Vector3((pos[0]+pos[3]+pos[6])/3, (pos[1]+pos[4]+pos[7])/3, (pos[2]+pos[5]+pos[8])/3);

               direction.applyMatrix4(mesh.matrixWorld);
            }

            // now push first object in intersects to the front
            for (let k1 = 0; k1 < intersects.length - 1; ++k1) {
               let mesh1 = intersects[k1], mesh2 = intersects[k1+1],
                   i1 = mesh1.$jsroot_index, i2 = mesh2.$jsroot_index;
               if (i1 < i2) continue;
               for (let ii = i2; ii < i1; ++ii) {
                  resort[ii] = resort[ii+1];
                  resort[ii].$jsroot_index = ii;
               }
               resort[i1] = mesh2;
               mesh2.$jsroot_index = i1;
            }
         }

      for (let i = 0; i < resort.length; ++i) {
         resort[i].renderOrder = Math.round( maxorder - (i+1) / (resort.length+1) * (maxorder-minorder));
         delete resort[i].$jsroot_index;
         delete resort[i].$jsroot_distance;
      }

      return true;
   }

   function process(obj, lvl, minorder, maxorder) {
      let arr = [], did_sort = false;

      traverse(obj, lvl, arr);

      if (!arr.length) return;

      if (minorder === maxorder) {
         for (let k = 0; k < arr.length; ++k)
            arr[k].renderOrder = minorder;
      } else {
        did_sort = sort(arr, minorder, maxorder);
        if (!did_sort) minorder = maxorder = (minorder + maxorder) / 2;
      }

      for (let k = 0; k < arr.length; ++k) {
         let next = arr[k].parent, min = minorder, max = maxorder;

         if (did_sort) {
            max = arr[k].renderOrder;
            min = max - (maxorder - minorder) / (arr.length + 2);
         }

         process(next, lvl+1, min, max);
      }
   }

   if (!method || (method == 'dflt'))
      setdefaults(toplevel);
   else
      process(toplevel, 0, 1, 1000000);
}

/** @summary provide icon name for the shape
  * @private */
function getShapeIcon(shape) {
   switch (shape._typename) {
      case clTGeoArb8: return 'img_geoarb8';
      case clTGeoCone: return 'img_geocone';
      case clTGeoConeSeg: return 'img_geoconeseg';
      case clTGeoCompositeShape: return 'img_geocomposite';
      case clTGeoTube: return 'img_geotube';
      case clTGeoTubeSeg: return 'img_geotubeseg';
      case clTGeoPara: return 'img_geopara';
      case clTGeoParaboloid: return 'img_geoparab';
      case clTGeoPcon: return 'img_geopcon';
      case clTGeoPgon: return 'img_geopgon';
      case clTGeoShapeAssembly: return 'img_geoassembly';
      case clTGeoSphere: return 'img_geosphere';
      case clTGeoTorus: return 'img_geotorus';
      case clTGeoTrd1: return 'img_geotrd1';
      case clTGeoTrd2: return 'img_geotrd2';
      case clTGeoXtru: return 'img_geoxtru';
      case clTGeoTrap: return 'img_geotrap';
      case clTGeoGtra: return 'img_geogtra';
      case clTGeoEltu: return 'img_geoeltu';
      case clTGeoHype: return 'img_geohype';
      case clTGeoCtub: return 'img_geoctub';
   }
   return 'img_geotube';
}

const _ENTIRE_SCENE = 0, _BLOOM_SCENE = 1,
      clTGeoManager = 'TGeoManager', clTEveGeoShapeExtract = 'TEveGeoShapeExtract',
      clTGeoOverlap = 'TGeoOverlap', clTGeoVolumeAssembly = 'TGeoVolumeAssembly',
      clTEveTrack = 'TEveTrack', clTEvePointSet = 'TEvePointSet',
      clREveGeoShapeExtract = 'ROOT::Experimental::REveGeoShapeExtract';

/** @summary Function used to build hierarchy of elements of overlap object
  * @private */
function buildOverlapVolume(overlap) {

   let vol = create$1(clTGeoVolume);

   setGeoBit(vol, geoBITS.kVisDaughters, true);
   vol.$geoh = true; // workaround, let know browser that we are in volumes hierarchy
   vol.fName = '';

   let node1 = create$1(clTGeoNodeMatrix);
   node1.fName = overlap.fVolume1.fName || 'Overlap1';
   node1.fMatrix = overlap.fMatrix1;
   node1.fVolume = overlap.fVolume1;
   // node1.fVolume.fLineColor = 2; // color assigned with _splitColors

   let node2 = create$1(clTGeoNodeMatrix);
   node2.fName = overlap.fVolume2.fName || 'Overlap2';
   node2.fMatrix = overlap.fMatrix2;
   node2.fVolume = overlap.fVolume2;
   // node2.fVolume.fLineColor = 3;  // color assigned with _splitColors

   vol.fNodes = create$1(clTList);
   vol.fNodes.Add(node1);
   vol.fNodes.Add(node2);

   return vol;
}

let $comp_col_cnt = 0;

/** @summary Function used to build hierarchy of elements of composite shapes
  * @private */
function buildCompositeVolume(comp, maxlvl, side) {

   if (maxlvl === undefined) maxlvl = 1;
   if (!side) {
      $comp_col_cnt = 0;
      side = '';
   }

   let vol = create$1(clTGeoVolume);
   setGeoBit(vol, geoBITS.kVisThis, true);
   setGeoBit(vol, geoBITS.kVisDaughters, true);

   if ((side && (comp._typename !== clTGeoCompositeShape)) || (maxlvl <= 0)) {
      vol.fName = side;
      vol.fLineColor = ($comp_col_cnt++ % 8) + 2;
      vol.fShape = comp;
      return vol;
   }

   if (side) side += '/';
   vol.$geoh = true; // workaround, let know browser that we are in volumes hierarchy
   vol.fName = '';

   let node1 = create$1(clTGeoNodeMatrix);
   setGeoBit(node1, geoBITS.kVisThis, true);
   setGeoBit(node1, geoBITS.kVisDaughters, true);
   node1.fName = 'Left';
   node1.fMatrix = comp.fNode.fLeftMat;
   node1.fVolume = buildCompositeVolume(comp.fNode.fLeft, maxlvl-1, side + 'Left');

   let node2 = create$1(clTGeoNodeMatrix);
   setGeoBit(node2, geoBITS.kVisThis, true);
   setGeoBit(node2, geoBITS.kVisDaughters, true);
   node2.fName = 'Right';
   node2.fMatrix = comp.fNode.fRightMat;
   node2.fVolume = buildCompositeVolume(comp.fNode.fRight, maxlvl-1, side + 'Right');

   vol.fNodes = create$1(clTList);
   vol.fNodes.Add(node1);
   vol.fNodes.Add(node2);

   if (!side) $comp_col_cnt = 0;

   return vol;
}


/** @summary create list entity for geo object
  * @private */
function createList(parent, lst, name, title) {

   if (!lst?.arr?.length) return;

   let list_item = {
       _name: name,
       _kind: 'ROOT.' + clTList,
       _title: title,
       _more: true,
       _geoobj: lst,
       _parent: parent,
       _get(item /*, itemname */) {
          return Promise.resolve(item._geoobj || null);
       },
       _expand(node, lst) {
          // only childs

          if (lst.fVolume)
             lst = lst.fVolume.fNodes;

          if (!lst.arr) return false;

          node._childs = [];

          checkDuplicates(null, lst.arr);

          for (let n in lst.arr)
             createItem(node, lst.arr[n]);

          return true;
       }
   };

   if (!parent._childs)
      parent._childs = [];
   parent._childs.push(list_item);
}


/** @summary Expand geo object
  * @private */
function expandGeoObject(parent, obj) {
   injectGeoStyle();

   if (!parent || !obj) return false;

   let isnode = (obj._typename.indexOf(clTGeoNode) === 0),
       isvolume = (obj._typename.indexOf(clTGeoVolume) === 0),
       ismanager = (obj._typename === clTGeoManager),
       iseve = ((obj._typename === clTEveGeoShapeExtract) || (obj._typename === clREveGeoShapeExtract)),
       isoverlap = (obj._typename === clTGeoOverlap);

   if (!isnode && !isvolume && !ismanager && !iseve && !isoverlap) return false;

   if (parent._childs) return true;

   if (ismanager) {
      createList(parent, obj.fMaterials, 'Materials', 'list of materials');
      createList(parent, obj.fMedia, 'Media', 'list of media');
      createList(parent, obj.fTracks, 'Tracks', 'list of tracks');
      createList(parent, obj.fOverlaps, 'Overlaps', 'list of detected overlaps');
      createItem(parent, obj.fMasterVolume);
      return true;
   }

   if (isoverlap) {
      createItem(parent, obj.fVolume1);
      createItem(parent, obj.fVolume2);
      createItem(parent, obj.fMarker, 'Marker');
      return true;
   }

   let volume, subnodes, shape;

   if (iseve) {
      subnodes = obj.fElements?.arr;
      shape = obj.fShape;
   } else {
      volume = isnode ? obj.fVolume : obj;
      subnodes = volume?.fNodes?.arr;
      shape = volume?.fShape;
   }

   if (!subnodes && (shape?._typename === clTGeoCompositeShape) && shape?.fNode) {
      if (!parent._childs) {
         createItem(parent, shape.fNode.fLeft, 'Left');
         createItem(parent, shape.fNode.fRight, 'Right');
      }

      return true;
   }

   if (!subnodes) return false;

   checkDuplicates(obj, subnodes);

   for (let i = 0; i < subnodes.length; ++i)
      createItem(parent, subnodes[i]);

   return true;
}


/** @summary find item with 3d painter
  * @private */
function findItemWithPainter(hitem, funcname) {
   while (hitem) {
      if (hitem._painter?._camera) {
         if (funcname && isFunc(hitem._painter[funcname]))
            hitem._painter[funcname]();
         return hitem;
      }
      hitem = hitem._parent;
   }
   return null;
}

/** @summary provide css style for geo object
  * @private */
function provideVisStyle(obj) {
   if ((obj._typename === clTEveGeoShapeExtract) || (obj._typename === clREveGeoShapeExtract))
      return obj.fRnrSelf ? ' geovis_this' : '';

   let vis = !testGeoBit(obj, geoBITS.kVisNone) &&
              testGeoBit(obj, geoBITS.kVisThis),
       chld = testGeoBit(obj, geoBITS.kVisDaughters);

   if (chld && (!obj.fNodes || (obj.fNodes.arr.length === 0))) chld = false;

   if (vis && chld) return ' geovis_all';
   if (vis) return ' geovis_this';
   if (chld) return ' geovis_daughters';
   return '';
}


/** @summary update icons
  * @private */
function updateBrowserIcons(obj, hpainter) {
   if (!obj || !hpainter) return;

   hpainter.forEachItem(m => {
      // update all items with that volume
      if ((obj === m._volume) || (obj === m._geoobj)) {
         m._icon = m._icon.split(' ')[0] + provideVisStyle(obj);
         hpainter.updateTreeNode(m);
      }
   });
}


/**
  * @summary Toolbar for geometry painter
  *
  * @private
  */

class Toolbar {

   /** @summary constructor */
   constructor(container, bright) {
      this.bright = bright;

      this.element = container.append('div').attr('class','geo_toolbar_group');

      injectStyle(
         `.geo_toolbar_group { float: left; box-sizing: border-box; position: relative; bottom: 23px; vertical-align: middle; white-space: nowrap; }
          .geo_toolbar_group:first-child { margin-left: 2px; }
          .geo_toolbar_group a { position: relative; font-size: 16px; padding: 3px 1px; cursor: pointer; line-height: normal; box-sizing: border-box; }
          .geo_toolbar_group a svg { position: relative; top: 2px; }
          .geo_toolbar_btn path { fill: rgba(0, 31, 95, 0.2); }
          .geo_toolbar_btn path .active,
          .geo_toolbar_btn path:hover { fill: rgba(0, 22, 72, 0.5); }
          .geo_toolbar_btn_bright path { fill: rgba(255, 224, 160, 0.2); }
          .geo_toolbar_btn_bright path .active,
          .geo_toolbar_btn_bright path:hover { fill: rgba(255, 233, 183, 0.5); }`, this.element.node());
   }

   /** @summary add buttons */
   addButtons(buttons) {
      this.buttonsNames = [];

      buttons.forEach(buttonConfig => {
         let buttonName = buttonConfig.name;
         if (!buttonName)
            throw new Error('must provide button name in button config');
         if (this.buttonsNames.indexOf(buttonName) !== -1)
            throw new Error(`button name ${buttonName} is taken`);

         this.buttonsNames.push(buttonName);

         let title = buttonConfig.title || buttonConfig.name;

         if (!isFunc(buttonConfig.click))
            throw new Error('must provide button click() function in button config');

         let button = this.element.append('a')
                           .attr('class', this.bright ? 'geo_toolbar_btn_bright' : 'geo_toolbar_btn')
                           .attr('rel', 'tooltip')
                           .attr('data-title', title)
                           .on('click', buttonConfig.click);

         ToolbarIcons.createSVG(button, ToolbarIcons[buttonConfig.icon], 16, title);
      });

   }

   /** @summary change brightness */
   changeBrightness(bright) {
      this.bright = bright;
      if (this.element)
         this.element.selectAll(bright ? '.geo_toolbar_btn' : '.geo_toolbar_btn_bright')
                     .attr('class', !bright ? 'geo_toolbar_btn' : 'geo_toolbar_btn_bright');
   }

   /** @summary cleanup toolbar */
   cleanup() {
      if (this.element) {
         this.element.remove();
         delete this.element;
      }
   }

} // class ToolBar


/**
  * @summary geometry drawing control
  *
  * @private
  */

class GeoDrawingControl extends InteractiveControl {

   constructor(mesh, bloom) {
      super();
      this.mesh = (mesh && mesh.material) ? mesh : null;
      this.bloom = bloom;
   }

   /** @summary set highlight */
   setHighlight(col, indx) {
      return this.drawSpecial(col, indx);
   }

   /** @summary draw special */
   drawSpecial(col /*, indx*/) {
      let c = this.mesh;
      if (!c || !c.material) return;

      if (col) {
         if (!c.origin)
            c.origin = {
              color: c.material.color,
              emissive: c.material.emissive,
              opacity: c.material.opacity,
              width: c.material.linewidth,
              size: c.material.size
           };
         if (this.bloom) {
            c.layers.enable(_BLOOM_SCENE);
            c.material.emissive = new Color$1(0x00ff00);
         } else {
            c.material.color = new Color$1( col );
            c.material.opacity = 1.;
         }

         if (c.hightlightWidthScale && !browser$1.isWin)
            c.material.linewidth = c.origin.width * c.hightlightWidthScale;
         if (c.highlightScale)
            c.material.size = c.origin.size * c.highlightScale;
         return true;
      } else if (c.origin) {
         if (this.bloom) {
            c.material.emissive = c.origin.emissive;
            c.layers.enable(_ENTIRE_SCENE);
         } else {
            c.material.color = c.origin.color;
            c.material.opacity = c.origin.opacity;
         }
         if (c.hightlightWidthScale)
            c.material.linewidth = c.origin.width;
         if (c.highlightScale)
            c.material.size = c.origin.size;
         return true;
      }
   }

} // class GeoDrawingControl


const stageInit = 0, stageCollect = 1, stageWorkerCollect = 2, stageAnalyze = 3, stageCollShapes = 4,
      stageStartBuild = 5, stageWorkerBuild = 6, stageBuild = 7, stageBuildReady = 8, stageWaitMain = 9, stageBuildProj = 10;

/**
 * @summary Painter class for geometries drawing
 *
 * @private
 */

class TGeoPainter extends ObjectPainter {

   /** @summary Constructor
     * @param {object|string} dom - DOM element for drawing or element id
     * @param {object} obj - supported TGeo object */
   constructor(dom, obj) {

      let gm;
      if (obj?._typename === clTGeoManager) {
         gm = obj;
         obj = obj.fMasterVolume;
      }

      if (obj?._typename && (obj._typename.indexOf(clTGeoVolume) === 0))
         obj = { _typename: clTGeoNode, fVolume: obj, fName: obj.fName, $geoh: obj.$geoh, _proxy: true };

      super(dom, obj);

      if (gm) this.geo_manager = gm;

      this.no_default_title = true; // do not set title to main DIV
      this.mode3d = true; // indication of 3D mode
      this.drawing_stage = stageInit; //
      this.drawing_log = 'Init';
      this.ctrl = {
         clipIntersect: true,
         clip: [{ name: 'x', enabled: false, value: 0, min: -100, max: 100 },
                { name: 'y', enabled: false, value: 0, min: -100, max: 100 },
                { name: 'z', enabled: false, value: 0, min: -100, max: 100 }],
         ssao: { enabled: false, output: SSAOPass.OUTPUT.Default, kernelRadius: 0, minDistance: 0.001, maxDistance: 0.1 },
         bloom: { enabled: true, strength: 1.5 },
         info: { num_meshes: 0, num_faces: 0, num_shapes: 0 },
         highlight: false,
         highlight_scene: false,
         depthTest: true,
         depthMethod: 'dflt',
         select_in_view: false,
         update_browser: true,
         light: { kind: 'points', top: false, bottom: false, left: false, right: false, front: false, specular: true, power: 1 },
         trans_radial: 0,
         trans_z: 0
      };

      this.ctrl.depthMethodItems = [
         { name: 'Default', value: 'dflt' },
         { name: 'Raytraicing', value: 'ray' },
         { name: 'Boundary box', value: 'box' },
         { name: 'Mesh size', value: 'size' },
         { name: 'Central point', value: 'pnt' }
       ];

      this.ctrl.ssao.outputItems = [
         { name: 'Default', value: SSAOPass.OUTPUT.Default },
         { name: 'SSAO Only', value: SSAOPass.OUTPUT.SSAO },
         { name: 'SSAO Only + Blur', value: SSAOPass.OUTPUT.Blur },
         { name: 'Beauty', value: SSAOPass.OUTPUT.Beauty },
         { name: 'Depth', value: SSAOPass.OUTPUT.Depth },
         { name: 'Normal', value: SSAOPass.OUTPUT.Normal }
      ];

      this.cleanup(true);
   }

   /** @summary Change drawing stage
     * @private */
   changeStage(value, msg) {
      this.drawing_stage = value;
      if (!msg)
         switch(value) {
            case stageInit: msg = 'Building done'; break;
            case stageCollect: msg = 'collect visibles'; break;
            case stageWorkerCollect: msg = 'worker collect visibles'; break;
            case stageAnalyze: msg = 'Analyse visibles'; break;
            case stageCollShapes: msg = 'collect shapes for building'; break;
            case stageStartBuild: msg = 'Start build shapes'; break;
            case stageWorkerBuild: msg = 'Worker build shapes'; break;
            case stageBuild: msg = 'Build shapes'; break;
            case stageBuildReady: msg = 'Build ready'; break;
            case stageWaitMain: msg = 'Wait for main painter'; break;
            case stageBuildProj: msg = 'Build projection'; break;
            default: msg = `stage ${value}`;
         }
      this.drawing_log = msg;
   }

   /** @summary Check drawing stage */
   isStage(value) { return value === this.drawing_stage; }

   /** @summary Create toolbar */
   createToolbar() {
      if (this._toolbar || !this._webgl || this.ctrl.notoolbar || isBatchMode()) return;
      let buttonList = [{
         name: 'toImage',
         title: 'Save as PNG',
         icon: 'camera',
         click: () => this.createSnapshot()
      }, {
         name: 'control',
         title: 'Toggle control UI',
         icon: 'rect',
         click: () => this.showControlOptions('toggle')
      }, {
         name: 'enlarge',
         title: 'Enlarge geometry drawing',
         icon: 'circle',
         click: () => this.toggleEnlarge()
      }];

      // Only show VR icon if WebVR API available.
      if (navigator.getVRDisplays) {
         buttonList.push({
            name: 'entervr',
            title: 'Enter VR (It requires a VR Headset connected)',
            icon: 'vrgoggles',
            click: () => this.toggleVRMode()
         });
         this.initVRMode();
      }

      if (settings.ContextMenu)
      buttonList.push({
         name: 'menu',
         title: 'Show context menu',
         icon: 'question',
         click: evnt => {

            evnt.preventDefault();
            evnt.stopPropagation();

            if (closeMenu()) return;

            createMenu$1(evnt, this).then(menu => {
                menu.painter.fillContextMenu(menu);
                menu.show();
            });
         }
      });

      let bkgr = new Color$1(this.ctrl.background);

      this._toolbar = new Toolbar(this.selectDom(), (bkgr.r + bkgr.g + bkgr.b) < 1);

      this._toolbar.addButtons(buttonList);
   }

   /** @summary Initialize VR mode */
   initVRMode() {
      // Dolly contains camera and controllers in VR Mode
      // Allows moving the user in the scene
      this._dolly = new Group();
      this._scene.add(this._dolly);
      this._standingMatrix = new Matrix4();

      // Raycaster temp variables to avoid one per frame allocation.
      this._raycasterEnd = new Vector3();
      this._raycasterOrigin = new Vector3();

      navigator.getVRDisplays().then(displays => {
         let vrDisplay = displays[0];
         if (!vrDisplay) return;
         this._renderer.vr.setDevice(vrDisplay);
         this._vrDisplay = vrDisplay;
         if (vrDisplay.stageParameters) {
            this._standingMatrix.fromArray(vrDisplay.stageParameters.sittingToStandingTransform);
         }
         this.initVRControllersGeometry();
      });
   }

   /** @summary Init VR controllers geometry
     * @private */
   initVRControllersGeometry() {
      let geometry = new SphereGeometry(0.025, 18, 36),
          material = new MeshBasicMaterial({ color: 'grey', vertexColors: false }),
          rayMaterial = new MeshBasicMaterial({ color: 'fuchsia', vertexColors: false }),
          rayGeometry = new BoxGeometry(0.001, 0.001, 2),
          ray1Mesh = new Mesh(rayGeometry, rayMaterial),
          ray2Mesh = new Mesh(rayGeometry, rayMaterial),
          sphere1 = new Mesh(geometry, material),
          sphere2 = new Mesh(geometry, material);

      this._controllersMeshes = [];
      this._controllersMeshes.push(sphere1);
      this._controllersMeshes.push(sphere2);
      ray1Mesh.position.z -= 1;
      ray2Mesh.position.z -= 1;
      sphere1.add(ray1Mesh);
      sphere2.add(ray2Mesh);
      this._dolly.add(sphere1);
      this._dolly.add(sphere2);
      // Controller mesh hidden by default
      sphere1.visible = false;
      sphere2.visible = false;
   }

   /** @summary Update VR controllers list
     * @private */
   updateVRControllersList() {
      let gamepads = navigator.getGamepads && navigator.getGamepads();
      // Has controller list changed?
      if (this.vrControllers && (gamepads.length === this.vrControllers.length)) { return; }
      // Hide meshes.
      this._controllersMeshes.forEach(mesh => { mesh.visible = false; });
      this._vrControllers = [];
      for (let i = 0; i < gamepads.length; ++i) {
         if (!gamepads[i] || !gamepads[i].pose) { continue; }
         this._vrControllers.push({
            gamepad: gamepads[i],
            mesh: this._controllersMeshes[i]
         });
         this._controllersMeshes[i].visible = true;
      }
   }

   /** @summary Process VR controller intersection
     * @private */
   processVRControllerIntersections() {
      let intersects = [];
      for (let i = 0; i < this._vrControllers.length; ++i) {
         let controller = this._vrControllers[i].mesh,
             end = controller.localToWorld(this._raycasterEnd.set(0, 0, -1)),
             origin = controller.localToWorld(this._raycasterOrigin.set(0, 0, 0));
         end.sub(origin).normalize();
         intersects = intersects.concat(this._controls.getOriginDirectionIntersects(origin, end));
      }
      // Remove duplicates.
      intersects = intersects.filter(function (item, pos) {return intersects.indexOf(item) === pos});
      this._controls.processMouseMove(intersects);
   }

   /** @summary Update VR controllers
     * @private */
   updateVRControllers() {
      this.updateVRControllersList();
      // Update pose.
      for (let i = 0; i < this._vrControllers.length; ++i) {
         let controller = this._vrControllers[i],
             orientation = controller.gamepad.pose.orientation,
             position = controller.gamepad.pose.position,
             controllerMesh = controller.mesh;
         if (orientation) { controllerMesh.quaternion.fromArray(orientation); }
         if (position) { controllerMesh.position.fromArray(position); }
         controllerMesh.updateMatrix();
         controllerMesh.applyMatrix4(this._standingMatrix);
         controllerMesh.matrixWorldNeedsUpdate = true;
      }
      this.processVRControllerIntersections();
   }

   /** @summary Toggle VR mode
     * @private */
   toggleVRMode() {
      if (!this._vrDisplay) return;
      // Toggle VR mode off
      if (this._vrDisplay.isPresenting) {
         this.exitVRMode();
         return;
      }
      this._previousCameraPosition = this._camera.position.clone();
      this._previousCameraRotation = this._camera.rotation.clone();
      this._vrDisplay.requestPresent([{ source: this._renderer.domElement }]).then(() => {
         this._previousCameraNear = this._camera.near;
         this._dolly.position.set(this._camera.position.x/4, - this._camera.position.y/8, - this._camera.position.z/4);
         this._camera.position.set(0,0,0);
         this._dolly.add(this._camera);
         this._camera.near = 0.1;
         this._camera.updateProjectionMatrix();
         this._renderer.vr.enabled = true;
         this._renderer.setAnimationLoop(() => {
            this.updateVRControllers();
            this.render3D(0);
         });
      });
      this._renderer.vr.enabled = true;

      window.addEventListener( 'keydown', evnt => {
         // Esc Key turns VR mode off
         if (evnt.code == 'Escape') this.exitVRMode();
      });
   }

   /** @summary Exit VR mode
     * @private */
   exitVRMode() {
      if (!this._vrDisplay.isPresenting) return;
      this._renderer.vr.enabled = false;
      this._dolly.remove(this._camera);
      this._scene.add(this._camera);
      // Restore Camera pose
      this._camera.position.copy(this._previousCameraPosition);
      this._previousCameraPosition = undefined;
      this._camera.rotation.copy(this._previousCameraRotation);
      this._previousCameraRotation = undefined;
      this._camera.near = this._previousCameraNear;
      this._camera.updateProjectionMatrix();
      this._vrDisplay.exitPresent();
   }

   /** @summary Returns main geometry object */
   getGeometry() {
      return this.getObject();
   }

   /** @summary Modify visibility of provided node by name */
   modifyVisisbility(name, sign) {
      if (getNodeKind(this.getGeometry()) !== 0) return;

      if (!name)
         return setGeoBit(this.getGeometry().fVolume, geoBITS.kVisThis, (sign === '+'));

      let regexp, exact = false;

      //arg.node.fVolume
      if (name.indexOf('*') < 0) {
         regexp = new RegExp('^'+name+'$');
         exact = true;
      } else {
         regexp = new RegExp('^' + name.split('*').join('.*') + '$');
         exact = false;
      }

      this.findNodeWithVolume(regexp, function(arg) {
         setInvisibleAll(arg.node.fVolume, (sign !== '+'));
         return exact ? arg : null; // continue search if not exact expression provided
      });
   }

   /** @summary Decode drawing options */
   decodeOptions(opt) {
      if (!isStr(opt)) opt = '';

      let res = { _grid: false, _bound: false, _debug: false,
                  _full: false, _axis: 0,
                  _count: false, wireframe: false,
                   scale: new Vector3(1,1,1), zoom: 1.0, rotatey: 0, rotatez: 0,
                   more: 1, maxlimit: 100000,
                   vislevel: undefined, maxnodes: undefined, dflt_colors: false,
                   use_worker: false, show_controls: false,
                   highlight: false, highlight_scene: false, no_screen: false,
                   project: '', is_main: false, tracks: false, showtop: false, can_rotate: true, ortho_camera: false,
                   clipx: false, clipy: false, clipz: false, usessao: false, usebloom: true, outline: false,
                   script_name: '', transparency: 0, rotate: false, background: '#FFFFFF',
                   depthMethod: 'dflt', mouse_tmout: 50, trans_radial: 0, trans_z: 0 };

      let dd = decodeUrl();
      if (dd.get('_grid') == 'true') res._grid = true;
      let _opt = dd.get('_debug');
      if (_opt == 'true') { res._debug = true; res._grid = true; }
      if (_opt == 'bound') { res._debug = true; res._grid = true; res._bound = true; }
      if (_opt == 'full') { res._debug = true; res._grid = true; res._full = true; res._bound = true; }

      let macro = opt.indexOf('macro:');
      if (macro >= 0) {
         let separ = opt.indexOf(';', macro+6);
         if (separ < 0) separ = opt.length;
         res.script_name = opt.slice(macro+6, separ);
         opt = opt.slice(0, macro) + opt.slice(separ+1);
         console.log(`script ${res.script_name} rest ${opt}`);
      }

      while (true) {
         let pp = opt.indexOf('+'), pm = opt.indexOf('-');
         if ((pp < 0) && (pm < 0)) break;
         let p1 = pp, sign = '+';
         if ((p1 < 0) || ((pm >= 0) && (pm < pp))) { p1 = pm; sign = '-'; }

         let p2 = p1+1, regexp = new RegExp('[,; .]');
         while ((p2 < opt.length) && !regexp.test(opt[p2]) && (opt[p2]!='+') && (opt[p2]!='-')) p2++;

         let name = opt.substring(p1+1, p2);
         opt = opt.slice(0,p1) + opt.slice(p2);
         // console.log(`Modify visibility ${sign} : ${name}`);

         this.modifyVisisbility(name, sign);
      }

      let d = new DrawOptions(opt);

      if (d.check('MAIN')) res.is_main = true;

      if (d.check('TRACKS')) res.tracks = true; // only for TGeoManager
      if (d.check('SHOWTOP')) res.showtop = true; // only for TGeoManager
      if (d.check('NO_SCREEN')) res.no_screen = true; // ignore kVisOnScreen bits for visibility

      if (d.check('ORTHO_CAMERA_ROTATE')) { res.ortho_camera = true; res.can_rotate = true; }
      if (d.check('ORTHO_CAMERA')) { res.ortho_camera = true; res.can_rotate = false; }
      if (d.check('MOUSE_CLICK')) res.mouse_click = true;

      if (d.check('DEPTHRAY') || d.check('DRAY')) res.depthMethod = 'ray';
      if (d.check('DEPTHBOX') || d.check('DBOX')) res.depthMethod = 'box';
      if (d.check('DEPTHPNT') || d.check('DPNT')) res.depthMethod = 'pnt';
      if (d.check('DEPTHSIZE') || d.check('DSIZE')) res.depthMethod = 'size';
      if (d.check('DEPTHDFLT') || d.check('DDFLT')) res.depthMethod = 'dflt';

      if (d.check('ZOOM', true)) res.zoom = d.partAsFloat(0, 100) / 100;
      if (d.check('ROTY', true)) res.rotatey = d.partAsFloat();
      if (d.check('ROTZ', true)) res.rotatez = d.partAsFloat();
      if (d.check('VISLVL', true)) res.vislevel = d.partAsInt();

      if (d.check('BLACK')) res.background = '#000000';
      if (d.check('WHITE')) res.background = '#FFFFFF';

      if (d.check('BKGR_', true)) {
         let bckgr = null;
         if (d.partAsInt(1) > 0) {
           bckgr = getColor(d.partAsInt());
         } else {
            for (let col = 0; col < 8; ++col)
               if (getColor(col).toUpperCase() === d.part)
                  bckgr = getColor(col);
         }
         if (bckgr) res.background = '#' + new Color$1(bckgr).getHexString();
      }

      if (d.check('R3D_', true))
         res.Render3D = constants$1.Render3D.fromString(d.part.toLowerCase());

      if (d.check('MORE3')) res.more = 3;
      if (d.check('MORE')) res.more = 2;
      if (d.check('ALL')) { res.more = 10; res.vislevel = 9; }

      if (d.check('CONTROLS') || d.check('CTRL')) res.show_controls = true;

      if (d.check('CLIPXYZ')) res.clipx = res.clipy = res.clipz = true;
      if (d.check('CLIPX')) res.clipx = true;
      if (d.check('CLIPY')) res.clipy = true;
      if (d.check('CLIPZ')) res.clipz = true;
      if (d.check('CLIP')) res.clipx = res.clipy = res.clipz = true;

      if (d.check('PROJX', true)) { res.project = 'x'; if (d.partAsInt(1) > 0) res.projectPos = d.partAsInt(); res.can_rotate = false; }
      if (d.check('PROJY', true)) { res.project = 'y'; if (d.partAsInt(1) > 0) res.projectPos = d.partAsInt(); res.can_rotate = false; }
      if (d.check('PROJZ', true)) { res.project = 'z'; if (d.partAsInt(1) > 0) res.projectPos = d.partAsInt(); res.can_rotate = false; }

      if (d.check('DFLT_COLORS') || d.check('DFLT')) res.dflt_colors = true;
      if (d.check('SSAO')) res.usessao = true;
      if (d.check('NOBLOOM')) res.usebloom = false;
      if (d.check('BLOOM')) res.usebloom = true;
      if (d.check('OUTLINE')) res.outline = true;

      if (d.check('NOWORKER')) res.use_worker = -1;
      if (d.check('WORKER')) res.use_worker = 1;

      if (d.check('NOHIGHLIGHT') || d.check('NOHIGH')) res.highlight_scene = res.highlight = 0;
      if (d.check('HIGHLIGHT')) res.highlight_scene = res.highlight = true;
      if (d.check('HSCENEONLY')) { res.highlight_scene = true; res.highlight = 0; }
      if (d.check('NOHSCENE')) res.highlight_scene = 0;
      if (d.check('HSCENE')) res.highlight_scene = true;

      if (d.check('WIREFRAME') || d.check('WIRE')) res.wireframe = true;
      if (d.check('ROTATE')) res.rotate = true;

      if (d.check('INVX') || d.check('INVERTX')) res.scale.x = -1;
      if (d.check('INVY') || d.check('INVERTY')) res.scale.y = -1;
      if (d.check('INVZ') || d.check('INVERTZ')) res.scale.z = -1;

      if (d.check('COUNT')) res._count = true;

      if (d.check('TRANSP',true))
         res.transparency = d.partAsInt(0,100)/100;

      if (d.check('OPACITY',true))
         res.transparency = 1 - d.partAsInt(0,100)/100;

      if (d.check('AXISCENTER') || d.check('AC')) res._axis = 2;

      if (d.check('TRR',true)) res.trans_radial = d.partAsInt()/100;
      if (d.check('TRZ',true)) res.trans_z = d.partAsInt()/100;

      if (d.check('AXIS') || d.check('A')) res._axis = true;

      if (d.check('D')) res._debug = true;
      if (d.check('G')) res._grid = true;
      if (d.check('B')) res._bound = true;
      if (d.check('W')) res.wireframe = true;
      if (d.check('F')) res._full = true;
      if (d.check('Y')) res._yup = true;
      if (d.check('Z')) res._yup = false;

      // when drawing geometry without TCanvas, yup = true by default
      if (res._yup === undefined)
         res._yup = this.getCanvSvg().empty();

      return res;
   }

   /** @summary Activate specified items in the browser */
   activateInBrowser(names, force) {

      if (isStr(names)) names = [ names ];

      if (this._hpainter) {
         // show browser if it not visible

         this._hpainter.activateItems(names, force);

         // if highlight in the browser disabled, suppress in few seconds
         if (!this.ctrl.update_browser)
            setTimeout(() => this._hpainter.activateItems([]), 2000);
      }
   }

   /** @summary  method used to check matrix calculations performance with current three.js model */
   testMatrixes() {

      let errcnt = 0, totalcnt = 0, totalmax = 0;

      let arg = {
            domatrix: true,
            func: (/*node*/) => {

               let m2 = this.getmatrix();

               let entry = this.CopyStack();

               let mesh = this._clones.createObject3D(entry.stack, this._toplevel, 'mesh');

               if (!mesh) return true;

               totalcnt++;

               let m1 = mesh.matrixWorld, flip;

               if (m1.equals(m2)) return true;
               if ((m1.determinant() > 0) && (m2.determinant()<-0.9)) {
                  flip = new Vector3(1,1,-1);
                  m2 = m2.clone().scale(flip);
                  if (m1.equals(m2)) return true;
               }

               let max = 0;
               for (let k = 0; k < 16; ++k)
                  max = Math.max(max, Math.abs(m1.elements[k] - m2.elements[k]));

               totalmax = Math.max(max, totalmax);

               if (max < 1e-4) return true;

               console.log(`${this._clones.resolveStack(entry.stack).name} maxdiff ${max} determ ${m1.determinant()} ${m2.determinant()}`);

               errcnt++;

               return false;
            }
         };


      let tm1 = new Date().getTime();

      /* let cnt = */ this._clones.scanVisible(arg);

      let tm2 = new Date().getTime();

      console.log(`Compare matrixes total ${totalcnt} errors ${errcnt} takes ${tm2-tm1} maxdiff ${totalmax}`);
   }

   /** @summary Fill context menu */
   fillContextMenu(menu) {
      menu.add('header: Draw options');

      menu.addchk(this.ctrl.update_browser, 'Browser update', () => {
         this.ctrl.update_browser = !this.ctrl.update_browser;
         if (!this.ctrl.update_browser) this.activateInBrowser([]);
      });
      menu.addchk(this.ctrl.show_controls, 'Show Controls', () => this.showControlOptions('toggle'));

      menu.addchk(this.ctrl._axis, 'Show axes', () => this.setAxesDraw('toggle'));

      if (this.geo_manager)
         menu.addchk(this.ctrl.showtop, 'Show top volume', () => this.setShowTop(!this.ctrl.showtop));

      menu.addchk(this.ctrl.wireframe, 'Wire frame', () => this.toggleWireFrame());

      menu.addchk(this.ctrl.highlight, 'Highlight volumes', () => {
         this.ctrl.highlight = !this.ctrl.highlight;
      });
      menu.addchk(this.ctrl.highlight_scene, 'Highlight scene', () => {
         this.ctrl.highlight_scene = !this.ctrl.highlight_scene;
      });
      menu.add('Reset camera position', () => this.focusCamera());

      if (!this._geom_viewer)
         menu.add('Get camera position', () => menu.info('Position (as url)', '&opt=' + this.produceCameraUrl()));

      if (!this.ctrl.project)
         menu.addchk(this.ctrl.rotate, 'Autorotate', () => this.setAutoRotate(!this.ctrl.rotate));
      menu.addchk(this.ctrl.select_in_view, 'Select in view', () => {
         this.ctrl.select_in_view = !this.ctrl.select_in_view;
         if (this.ctrl.select_in_view) this.startDrawGeometry();
      });
   }

   /** @summary Method used to set transparency for all geometrical shapes
     * @param {number|Function} transparency - one could provide function
     * @param {boolean} [skip_render] - if specified, do not perform rendering */
   changedGlobalTransparency(transparency, skip_render) {
      let func = isFunc(transparency) ? transparency : null;
      if (func || (transparency === undefined)) transparency = this.ctrl.transparency;
      this._toplevel.traverse( node => {
         if (node?.material?.inherentOpacity !== undefined) {
            let t = func ? func(node) : undefined;
            if (t !== undefined)
               node.material.opacity = 1 - t;
            else
               node.material.opacity = Math.min(1 - (transparency || 0), node.material.inherentOpacity);
            node.material.transparent = node.material.opacity < 1;
         }
      });
      if (!skip_render)
         this.render3D(-1);
   }

   /** @summary Reset transformation */
   resetTransformation() {
      this.changedTransformation('reset');
   }

   /** @summary Method should be called when transformation parameters were changed */
   changedTransformation(arg) {
      if (!this._toplevel) return;

      let ctrl = this.ctrl,
          translation = new Matrix4(),
          vect2 = new Vector3();

      if (arg == 'reset')
         ctrl.trans_z = ctrl.trans_radial = 0;

      this._toplevel.traverse(mesh => {
         if (mesh.stack === undefined) return;

         let node = mesh.parent;

         if (arg == 'reset') {
            if (node.matrix0) {
               node.matrix.copy(node.matrix0);
               node.matrix.decompose( node.position, node.quaternion, node.scale );
               node.matrixWorldNeedsUpdate = true;
            }
            delete node.matrix0;
            delete node.vect0;
            delete node.vect1;
            delete node.minvert;
            return;
         }

         if (node.vect0 === undefined) {
            node.matrix0 = node.matrix.clone();
            node.minvert = new Matrix4().copy(node.matrixWorld).invert();

            let box3 = getBoundingBox(mesh, null, true),
                signz = mesh._flippedMesh ? -1 : 1;

            // real center of mesh in local coordinates
            node.vect0 = new Vector3((box3.max.x  + box3.min.x) / 2, (box3.max.y  + box3.min.y) / 2, signz * (box3.max.z  + box3.min.z) / 2).applyMatrix4(node.matrixWorld);
            node.vect1 = new Vector3(0,0,0).applyMatrix4(node.minvert);
         }

         vect2.set(ctrl.trans_radial * node.vect0.x, ctrl.trans_radial * node.vect0.y, ctrl.trans_z * node.vect0.z).applyMatrix4(node.minvert).sub(node.vect1);

         node.matrix.multiplyMatrices(node.matrix0, translation.makeTranslation(vect2.x, vect2.y, vect2.z));
         node.matrix.decompose( node.position, node.quaternion, node.scale );
         node.matrixWorldNeedsUpdate = true;
      });

      this._toplevel.updateMatrixWorld();

      // axes drawing always triggers rendering
      if (arg != 'norender')
         this.drawSimpleAxis();
   }

   /** @summary Should be called when autorotate property changed */
   changedAutoRotate() {
      this.autorotate(2.5);
   }

   /** @summary Method should be called when changing axes drawing */
   changedAxes() {
      if (isStr(this.ctrl._axis))
         this.ctrl._axis = parseInt(this.ctrl._axis);

      this.drawSimpleAxis();
   }

   /** @summary Method should be called to change background color */
   changedBackground(val) {
      if (val !== undefined)
         this.ctrl.background = val;
      this._scene.background = new Color$1(this.ctrl.background);
      this._renderer.setClearColor(this._scene.background, 1);
      this.render3D(0);

      if (this._toolbar) {
         let bkgr = new Color$1(this.ctrl.background);
         this._toolbar.changeBrightness((bkgr.r + bkgr.g + bkgr.b) < 1);
      }
   }

   /** @summary Method called when SSAO configuration changed via GUI */
   changedSSAO() {
      if (!this.ctrl.ssao.enabled) {
         this.removeSSAO();
      } else {
         this.createSSAO();

         this._ssaoPass.output = parseInt(this.ctrl.ssao.output);
         this._ssaoPass.kernelRadius = this.ctrl.ssao.kernelRadius;
         this._ssaoPass.minDistance = this.ctrl.ssao.minDistance;
         this._ssaoPass.maxDistance = this.ctrl.ssao.maxDistance;
      }

      this.updateClipping();

      if (this._slave_painters)
         this._slave_painters.forEach(p => {
            Object.assign(p.ctrl.ssao, this.ctrl.ssao);
            p.changedSSAO();
         });
   }

   /** @summary Display control GUI */
   showControlOptions(on) {
      // while complete geo drawing can be removed until dat is loaded - just check and ignore callback
      if (!this.ctrl) return;

      if (on === 'toggle') {
         on = !this._datgui;
      } else if (on === undefined) {
         on = this.ctrl.show_controls;
      }

      this.ctrl.show_controls = on;

      if (this._datgui) {
         if (!on) {
            this._datgui.domElement.remove();
            this._datgui.destroy();
            delete this._datgui;
         }
         return;
      }

      if (on)
         Promise.resolve().then(function () { return dat_gui; }).then(h => this.buildDatGui(h));
   }

   /** @summary build dat.gui elements
     * @private */
   buildDatGui(dat) {
      // can happen when dat gui loaded after drawing is already cleaned
      if (!this._renderer) return;

      if (!dat)
         throw Error('Fail to load dat.gui');

      this._datgui = new dat.GUI({ autoPlace: false, width: Math.min(650, this._renderer.domElement.width / 2) });

      let main = this.selectDom();
      if (main.style('position') == 'static') main.style('position','relative');

      let dom = this._datgui.domElement;
      dom.style.position = 'absolute';
      dom.style.top = 0;
      dom.style.right = 0;
      main.node().appendChild(dom);

      this._datgui.painter = this;

      if (this.ctrl.project) {

         let bound = this.getGeomBoundingBox(this.getProjectionSource(), 0.01),
             axis = this.ctrl.project;

         if (this.ctrl.projectPos === undefined)
            this.ctrl.projectPos = (bound.min[axis] + bound.max[axis])/2;

         this._datgui.add(this.ctrl, 'projectPos', bound.min[axis], bound.max[axis])
             .name(axis.toUpperCase() + ' projection')
             .onChange(() => this.startDrawGeometry());

      } else {
         // Clipping Options

         let clipFolder = this._datgui.addFolder('Clipping'),
             clip_handler = () => this.changedClipping(-1);

         for (let naxis = 0; naxis < 3; ++naxis) {
            let cc = this.ctrl.clip[naxis],
                axisC = cc.name.toUpperCase();

            clipFolder.add(cc, 'enabled')
                .name('Enable ' + axisC)
                .listen() // react if option changed outside
                .onChange(clip_handler);

            clipFolder.add(cc, 'value', cc.min, cc.max)
                .name(axisC + ' position')
                .onChange(this.changedClipping.bind(this, naxis));
         }

         clipFolder.add(this.ctrl, 'clipIntersect').name('Clip intersection')
                   .listen().onChange(clip_handler);

      }

      // Appearance Options

      let appearance = this._datgui.addFolder('Appearance');

      appearance.add(this.ctrl, 'highlight').name('Highlight Selection')
                .listen().onChange(() => this.changedHighlight());

      appearance.add(this.ctrl, 'transparency', 0.0, 1.0, 0.001)
                     .listen().onChange(value => this.changedGlobalTransparency(value));

      appearance.addColor(this.ctrl, 'background').name('Background')
                .onChange(col => this.changedBackground(col));

      appearance.add(this.ctrl, 'wireframe').name('Wireframe')
                     .listen().onChange(() => this.changedWireFrame());

      this.ctrl._axis_cfg = 0;
      appearance.add(this.ctrl, '_axis', { 'none': 0, 'show': 1, 'center': 2 }).name('Axes')
                    .onChange(() => this.changedAxes());

      if (!this.ctrl.project)
         appearance.add(this.ctrl, 'rotate').name('Autorotate')
                      .listen().onChange(() => this.changedAutoRotate());

      appearance.add(this, 'focusCamera').name('Reset camera position');

      // Advanced Options

      if (this._webgl) {
         let advanced = this._datgui.addFolder('Advanced'), depthcfg = {};
         this.ctrl.depthMethodItems.forEach(i => { depthcfg[i.name] = i.value; });

         advanced.add(this.ctrl, 'depthTest').name('Depth test')
            .listen().onChange(() => this.changedDepthTest());

         advanced.add( this.ctrl, 'depthMethod', depthcfg)
             .name('Rendering order')
             .onChange(method => this.changedDepthMethod(method));

         advanced.add(this.ctrl, 'ortho_camera').name('Orhographic camera')
                 .listen().onChange(() => this.changeCamera());

        advanced.add(this, 'resetAdvanced').name('Reset');
      }

      // Transformation Options
      if (!this.ctrl.project) {
         let transform = this._datgui.addFolder('Transform');
         transform.add(this.ctrl, 'trans_z', 0., 3., 0.01)
                     .name('Z axis')
                     .listen().onChange(() => this.changedTransformation());
         transform.add(this.ctrl, 'trans_radial', 0., 3., 0.01)
                  .name('Radial')
                  .listen().onChange(() => this.changedTransformation());

         transform.add(this, 'resetTransformation').name('Reset');

         if (this.ctrl.trans_z || this.ctrl.trans_radial) transform.open();
      }

      // no SSAO folder if outline is enabled
      if (this.ctrl.outline) return;

      let ssaofolder = this._datgui.addFolder('Smooth Lighting (SSAO)'),
          ssao_handler = () => this.changedSSAO(), ssaocfg = {};

      this.ctrl.ssao.outputItems.forEach(i => { ssaocfg[i.name] = i.value; });

      ssaofolder.add(this.ctrl.ssao, 'enabled').name('Enable SSAO')
                .listen().onChange(ssao_handler);

      ssaofolder.add( this.ctrl.ssao, 'output', ssaocfg)
                .listen().onChange(ssao_handler);

      ssaofolder.add( this.ctrl.ssao, 'kernelRadius', 0, 32)
                .listen().onChange(ssao_handler);

      ssaofolder.add( this.ctrl.ssao, 'minDistance', 0.001, 0.02)
                .listen().onChange(ssao_handler);

      ssaofolder.add( this.ctrl.ssao, 'maxDistance', 0.01, 0.3)
                .listen().onChange(ssao_handler);

      let blooming = this._datgui.addFolder('Unreal Bloom'),
          bloom_handler = () => this.changedBloomSettings();

      blooming.add(this.ctrl.bloom, 'enabled').name('Enable Blooming')
              .listen().onChange(bloom_handler);

      blooming.add( this.ctrl.bloom, 'strength', 0.0, 3.0).name('Strength')
               .listen().onChange(bloom_handler);
   }

   /** @summary Method called when bloom configuration changed via GUI */
   changedBloomSettings() {
      if (this.ctrl.bloom.enabled) {
         this.createBloom();
         this._bloomPass.strength = this.ctrl.bloom.strength;
      } else {
         this.removeBloom();
      }

      if (this._slave_painters)
         this._slave_painters.forEach(p => {
            Object.assign(p.ctrl.bloom, this.ctrl.bloom);
            p.changedBloomSettings();
         });
   }

   /** @summary Handle change of camera kind */
   changeCamera() {
      // force control recreation
      if (this._controls) {
          this._controls.cleanup();
          delete this._controls;
       }

       this.removeBloom();
       this.removeSSAO();

      // recreate camera
      this.createCamera();

      this.createSpecialEffects();

      this._first_drawing = true;
      this.startDrawGeometry(true);
   }

   /** @summary create bloom effect */
   createBloom() {
      if (this._bloomPass) return;

      this._camera.layers.enable( _BLOOM_SCENE );
      this._bloomComposer = new EffectComposer( this._renderer );
      this._bloomComposer.addPass( new RenderPass( this._scene, this._camera ) );
      this._bloomPass = new UnrealBloomPass(new Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85);
      this._bloomPass.threshold = 0;
      this._bloomPass.strength = this.ctrl.bloom.strength;
      this._bloomPass.radius = 0;
      this._bloomPass.renderToScreen = true;
      this._bloomComposer.addPass( this._bloomPass );
      this._renderer.autoClear = false;
   }

   /** @summary Remove bloom highlight */
   removeBloom() {
      if (!this._bloomPass) return;
      delete this._bloomPass;
      delete this._bloomComposer;
      this._renderer.autoClear = true;
      this._camera.layers.disable( _BLOOM_SCENE );
   }

   /** @summary Remove composer */
   removeSSAO() {
      // we cannot remove pass from composer - just disable it
      delete this._ssaoPass;
      delete this._effectComposer;
   }

   /** @summary create SSAO */
   createSSAO() {
      if (!this._webgl) return;

      // this._depthRenderTarget = new WebGLRenderTarget(this._scene_width, this._scene_height, { minFilter: LinearFilter, magFilter: LinearFilter });
      // Setup SSAO pass
      if (!this._ssaoPass) {
         if (!this._effectComposer) {
            this._effectComposer = new EffectComposer( this._renderer );
            this._effectComposer.addPass(new RenderPass( this._scene, this._camera));
         }

         this._ssaoPass = new SSAOPass( this._scene, this._camera, this._scene_width, this._scene_height );
         this._ssaoPass.kernelRadius = 16;
         this._ssaoPass.renderToScreen = true;

         // Add pass to effect composer
         this._effectComposer.addPass( this._ssaoPass );
      }
   }

   /** @summary Show context menu for orbit control
     * @private */
   orbitContext(evnt, intersects) {

      createMenu$1(evnt, this).then(menu => {
         let numitems = 0, numnodes = 0, cnt = 0;
         if (intersects)
            for (let n = 0; n < intersects.length; ++n) {
               if (intersects[n].object.stack) numnodes++;
               if (intersects[n].object.geo_name) numitems++;
            }

         if (numnodes + numitems === 0) {
            this.fillContextMenu(menu);
         } else {
            let many = (numnodes + numitems) > 1;

            if (many) menu.add('header:' + ((numitems > 0) ? 'Items' : 'Nodes'));

            for (let n = 0; n < intersects.length; ++n) {
               let obj = intersects[n].object,
                   name, itemname, hdr;

               if (obj.geo_name) {
                  itemname = obj.geo_name;
                  if (itemname.indexOf('<prnt>') == 0)
                     itemname = (this.getItemName() || 'top') + itemname.slice(6);
                  name = itemname.slice(itemname.lastIndexOf('/')+1);
                  if (!name) name = itemname;
                  hdr = name;
               } else if (obj.stack) {
                  name = this._clones.resolveStack(obj.stack).name;
                  itemname = this.getStackFullName(obj.stack);
                  hdr = this.getItemName();
                  if (name.indexOf('Nodes/') === 0)
                     hdr = name.slice(6);
                  else if (name)
                     hdr = name;
                  else if (!hdr)
                     hdr = 'header';

               } else
                  continue;

               menu.add((many ? 'sub:' : 'header:') + hdr, itemname, arg => this.activateInBrowser([arg], true));

               menu.add('Browse', itemname, arg => this.activateInBrowser([arg], true));

               if (this._hpainter)
                  menu.add('Inspect', itemname, arg => this._hpainter.display(arg, 'inspect'));

               if (obj.geo_name) {
                  menu.add('Hide', n, indx => {
                     let mesh = intersects[indx].object;
                     mesh.visible = false; // just disable mesh
                     if (mesh.geo_object) mesh.geo_object.$hidden_via_menu = true; // and hide object for further redraw
                     menu.painter.render3D();
                  });

                  if (many) menu.add('endsub:');

                  continue;
               }

               let wireframe = this.accessObjectWireFrame(obj);

               if (wireframe !== undefined)
                  menu.addchk(wireframe, 'Wireframe', n, function(indx) {
                     let m = intersects[indx].object.material;
                     m.wireframe = !m.wireframe;
                     this.render3D();
                  });

               if (++cnt > 1)
                  menu.add('Manifest', n, function(indx) {

                     if (this._last_manifest)
                        this._last_manifest.wireframe = !this._last_manifest.wireframe;

                     if (this._last_hidden)
                        this._last_hidden.forEach(obj => { obj.visible = true; });

                     this._last_hidden = [];

                     for (let i = 0; i < indx; ++i)
                        this._last_hidden.push(intersects[i].object);

                     this._last_hidden.forEach(obj => { obj.visible = false; });

                     this._last_manifest = intersects[indx].object.material;

                     this._last_manifest.wireframe = !this._last_manifest.wireframe;

                     this.render3D();
                  });


               menu.add('Focus', n, function(indx) {
                  this.focusCamera(intersects[indx].object);
               });

               if (!this._geom_viewer)
               menu.add('Hide', n, function(indx) {
                  let resolve = menu.painter._clones.resolveStack(intersects[indx].object.stack);
                  if (resolve.obj && (resolve.node.kind === kindGeo) && resolve.obj.fVolume) {
                     setGeoBit(resolve.obj.fVolume, geoBITS.kVisThis, false);
                     updateBrowserIcons(resolve.obj.fVolume, this._hpainter);
                  } else if (resolve.obj && (resolve.node.kind === kindEve)) {
                     resolve.obj.fRnrSelf = false;
                     updateBrowserIcons(resolve.obj, this._hpainter);
                  }

                  this.testGeomChanges();// while many volumes may disappear, recheck all of them
               });

               if (many) menu.add('endsub:');
            }
         }
         menu.show();
      });
   }

   /** @summary Filter some objects from three.js intersects array */
   filterIntersects(intersects) {

      if (!intersects.length) return intersects;

      // check redirections
      for (let n = 0; n < intersects.length; ++n)
         if (intersects[n].object.geo_highlight)
            intersects[n].object = intersects[n].object.geo_highlight;

      // remove all elements without stack - indicator that this is geometry object
      // also remove all objects which are mostly transparent
      for (let n = intersects.length - 1; n >= 0; --n) {

         let obj = intersects[n].object,
            unique = (obj.stack !== undefined) || (obj.geo_name !== undefined);

         if (unique && obj.material && (obj.material.opacity !== undefined))
            unique = (obj.material.opacity >= 0.1);

         if (obj.jsroot_special) unique = false;

         for (let k = 0; (k < n) && unique;++k)
            if (intersects[k].object === obj) unique = false;

         if (!unique) intersects.splice(n,1);
      }

      let clip = this.ctrl.clip;

      if (clip[0].enabled || clip[1].enabled || clip[2].enabled) {
         let clippedIntersects = [];

         for (let i = 0; i < intersects.length; ++i) {
            let point = intersects[i].point, special = (intersects[i].object.type == 'Points'), clipped = true;

            if (clip[0].enabled && ((this._clipPlanes[0].normal.dot(point) > this._clipPlanes[0].constant) ^ special)) clipped = false;
            if (clip[1].enabled && ((this._clipPlanes[1].normal.dot(point) > this._clipPlanes[1].constant) ^ special)) clipped = false;
            if (clip[2].enabled && (this._clipPlanes[2].normal.dot(point) > this._clipPlanes[2].constant)) clipped = false;

            if (!clipped) clippedIntersects.push(intersects[i]);
         }

         intersects = clippedIntersects;
      }

      return intersects;
   }

   /** @summary test camera position
     * @desc function analyzes camera position and start redraw of geometry
     *  if objects in view may be changed */
   testCameraPositionChange() {

      if (!this.ctrl.select_in_view || this._draw_all_nodes) return;

      let matrix = createProjectionMatrix(this._camera),
          frustum = createFrustum(matrix);

      // check if overall bounding box seen
      if (!frustum.CheckBox(this.getGeomBoundingBox(this._toplevel)))
         this.startDrawGeometry();
   }

   /** @summary Resolve stack */
   resolveStack(stack) {
      return this._clones && stack ? this._clones.resolveStack(stack) : null;
   }

   /** @summary Returns stack full name
     * @desc Includes item name of top geo object */
   getStackFullName(stack) {
      let mainitemname = this.getItemName(),
          sub = this.resolveStack(stack);
      if (!sub || !sub.name) return mainitemname;
      return mainitemname ? mainitemname + '/' + sub.name : sub.name;
   }

   /** @summary Add handler which will be called when element is highlighted in geometry drawing
     * @desc Handler should have highlightMesh function with same arguments as TGeoPainter  */
   addHighlightHandler(handler) {
      if (!isFunc(handler?.highlightMesh)) return;
      if (!this._highlight_handlers)
         this._highlight_handlers = [];
      this._highlight_handlers.push(handler);
   }

   /** @summary perform mesh highlight */
   highlightMesh(active_mesh, color, geo_object, geo_index, geo_stack, no_recursive) {

      if (geo_object) {
         active_mesh = active_mesh ? [ active_mesh ] : [];
         let extras = this.getExtrasContainer();
         if (extras)
            extras.traverse(obj3d => {
               if ((obj3d.geo_object === geo_object) && (active_mesh.indexOf(obj3d) < 0)) active_mesh.push(obj3d);
            });
      } else if (geo_stack && this._toplevel) {
         active_mesh = [];
         this._toplevel.traverse(mesh => {
            if ((mesh instanceof Mesh) && isSameStack(mesh.stack, geo_stack)) active_mesh.push(mesh);
         });
      } else {
         active_mesh = active_mesh ? [ active_mesh ] : [];
      }

      if (!active_mesh.length) active_mesh = null;

      if (active_mesh) {
         // check if highlight is disabled for correspondent objects kinds
         if (active_mesh[0].geo_object) {
            if (!this.ctrl.highlight_scene) active_mesh = null;
         } else {
            if (!this.ctrl.highlight) active_mesh = null;
         }
      }

      if (!no_recursive) {
         // check all other painters

         if (active_mesh) {
            if (!geo_object) geo_object = active_mesh[0].geo_object;
            if (!geo_stack) geo_stack = active_mesh[0].stack;
         }

         let lst = this._highlight_handlers || (!this._main_painter ? this._slave_painters : this._main_painter._slave_painters.concat([this._main_painter]));

         for (let k = 0; k < lst.length; ++k)
            if (lst[k] !== this)
               lst[k].highlightMesh(null, color, geo_object, geo_index, geo_stack, true);
      }

      let curr_mesh = this._selected_mesh, same = false;

      if (!curr_mesh && !active_mesh) return false;

      const get_ctrl = mesh => mesh.get_ctrl ? mesh.get_ctrl() : new GeoDrawingControl(mesh, this.ctrl.bloom.enabled);

      // check if selections are the same
      if (curr_mesh && active_mesh && (curr_mesh.length == active_mesh.length)) {
         same = true;
         for (let k = 0; (k < curr_mesh.length) && same; ++k) {
            if ((curr_mesh[k] !== active_mesh[k]) || get_ctrl(curr_mesh[k]).checkHighlightIndex(geo_index)) same = false;
         }
      }
      if (same) return !!curr_mesh;

      if (curr_mesh)
         for (let k = 0; k < curr_mesh.length; ++k)
            get_ctrl(curr_mesh[k]).setHighlight();

      this._selected_mesh = active_mesh;

      if (active_mesh)
         for (let k = 0; k < active_mesh.length; ++k)
            get_ctrl(active_mesh[k]).setHighlight(color || 0x00ff00, geo_index);

      this.render3D(0);

      return !!active_mesh;
   }

   /** @summary handle mouse click event */
   processMouseClick(pnt, intersects, evnt) {
      if (!intersects.length) return;

      let mesh = intersects[0].object;
      if (!mesh.get_ctrl) return;

      let ctrl = mesh.get_ctrl(),
          click_indx = ctrl.extractIndex(intersects[0]);

      ctrl.evnt = evnt;

      if (ctrl.setSelected('blue', click_indx))
         this.render3D();

      ctrl.evnt = null;
   }

   /** @summary Configure mouse delay, required for complex geometries */
   setMouseTmout(val) {
      if (this.ctrl)
         this.ctrl.mouse_tmout = val;

      if (this._controls)
         this._controls.mouse_tmout = val;
   }

   /** @summary Configure depth method, used for render order production.
     * @param {string} method - Allowed values: 'ray', 'box','pnt', 'size', 'dflt' */
   setDepthMethod(method) {
      if (this.ctrl)
         this.ctrl.depthMethod = method;
   }

   /** @summary Add orbit control */
   addOrbitControls() {

      if (this._controls || !this._webgl || isBatchMode()) return;

      this.setTooltipAllowed(settings.Tooltip);

      this._controls = createOrbitControl(this, this._camera, this._scene, this._renderer, this._lookat);

      this._controls.mouse_tmout = this.ctrl.mouse_tmout; // set larger timeout for geometry processing

      if (!this.ctrl.can_rotate) this._controls.enableRotate = false;

      this._controls.contextMenu = this.orbitContext.bind(this);

      this._controls.processMouseMove = intersects => {

         // painter already cleaned up, ignore any incoming events
         if (!this.ctrl || !this._controls) return;

         let active_mesh = null, tooltip = null, resolve = null, names = [], geo_object, geo_index;

         // try to find mesh from intersections
         for (let k = 0; k < intersects.length; ++k) {
            let obj = intersects[k].object, info = null;
            if (!obj) continue;
            if (obj.geo_object)
               info = obj.geo_name;
            else if (obj.stack)
               info = this.getStackFullName(obj.stack);
            if (!info) continue;

            if (info.indexOf('<prnt>') == 0)
               info = this.getItemName() + info.slice(6);

            names.push(info);

            if (!active_mesh) {
               active_mesh = obj;
               tooltip = info;
               geo_object = obj.geo_object;
               if (obj.get_ctrl) {
                  geo_index = obj.get_ctrl().extractIndex(intersects[k]);
                  if ((geo_index !== undefined) && isStr(tooltip))
                     tooltip += ' indx:' + JSON.stringify(geo_index);
               }
               if (active_mesh.stack) resolve = this.resolveStack(active_mesh.stack);
            }
         }

         this.highlightMesh(active_mesh, undefined, geo_object, geo_index);

         if (this.ctrl.update_browser) {
            if (this.ctrl.highlight && tooltip) names = [ tooltip ];
            this.activateInBrowser(names);
         }

         if (!resolve || !resolve.obj) return tooltip;

         let lines = provideObjectInfo(resolve.obj);
         lines.unshift(tooltip);

         return { name: resolve.obj.fName, title: resolve.obj.fTitle || resolve.obj._typename, lines: lines };
      };

      this._controls.processMouseLeave = function() {
         this.processMouseMove([]); // to disable highlight and reset browser
      };

      this._controls.processDblClick = () => {
         // painter already cleaned up, ignore any incoming events
         if (!this.ctrl || !this._controls) return;

         if (this._last_manifest) {
            this._last_manifest.wireframe = !this._last_manifest.wireframe;
            if (this._last_hidden)
               this._last_hidden.forEach(obj => { obj.visible = true; });
            delete this._last_hidden;
            delete this._last_manifest;
            this.render3D();
         } else {
            this.adjustCameraPosition();
         }
      };
   }

   /** @summary add transformation control */
   addTransformControl() {
      if (this._tcontrols) return;

      if (!this.ctrl._debug && !this.ctrl._grid) return;

      this._tcontrols = new TransformControls(this._camera, this._renderer.domElement);
      this._scene.add(this._tcontrols);
      this._tcontrols.attach(this._toplevel);
      //this._tcontrols.setSize( 1.1 );

      window.addEventListener( 'keydown', event => {
         switch ( event.key ) {
         case 'q':
            this._tcontrols.setSpace( this._tcontrols.space === 'local' ? 'world' : 'local' );
            break;
         case 'Control':
            this._tcontrols.setTranslationSnap( Math.ceil( this._overall_size ) / 50 );
            this._tcontrols.setRotationSnap( MathUtils.degToRad( 15 ) );
            break;
         case 't': // Translate
            this._tcontrols.setMode( 'translate' );
            break;
         case 'r': // Rotate
            this._tcontrols.setMode( 'rotate' );
            break;
         case 's': // Scale
            this._tcontrols.setMode( 'scale' );
            break;
         case '+':
            this._tcontrols.setSize(this._tcontrols.size + 0.1);
            break;
         case '-':
            this._tcontrols.setSize(Math.max(this._tcontrols.size - 0.1, 0.1));
            break;
         }
      });
      window.addEventListener( 'keyup', event => {
         if (event.key == 'Control') {
            this._tcontrols.setTranslationSnap(null);
            this._tcontrols.setRotationSnap(null);
         }
      });

      this._tcontrols.addEventListener('change', () => this.render3D(0));
   }

   /** @summary Main function in geometry creation loop
     * @desc Returns:
     * - false when nothing todo
     * - true if one could perform next action immediately
     * - 1 when call after short timeout required
     * - 2 when call must be done from processWorkerReply */
   nextDrawAction() {

      if (!this._clones || this.isStage(stageInit)) return false;

      if (this.isStage(stageCollect)) {

         if (this._geom_viewer) {
            this._draw_all_nodes = false;
            this.changeStage(stageAnalyze);
            return true;
         }

         // wait until worker is really started
         if (this.ctrl.use_worker > 0) {
            if (!this._worker) { this.startWorker(); return 1; }
            if (!this._worker_ready) return 1;
         }

         // first copy visibility flags and check how many unique visible nodes exists
         let numvis = this._first_drawing ? this._clones.countVisibles() : 0,
             matrix = null, frustum = null;

         if (!numvis)
            numvis = this._clones.markVisibles(false, false, !!this.geo_manager && !this.ctrl.showtop);

         if (this.ctrl.select_in_view && !this._first_drawing) {
            // extract camera projection matrix for selection

            matrix = createProjectionMatrix(this._camera);

            frustum = createFrustum(matrix);

            // check if overall bounding box seen
            if (frustum.CheckBox(this.getGeomBoundingBox(this._toplevel))) {
               matrix = null; // not use camera for the moment
               frustum = null;
            }
         }

         this._current_face_limit = this.ctrl.maxlimit;
         if (matrix) this._current_face_limit *= 1.25;

         // here we decide if we need worker for the drawings
         // main reason - too large geometry and large time to scan all camera positions
         let need_worker = !isBatchMode() && browser$1.isChrome && ((numvis > 10000) || (matrix && (this._clones.scanVisible() > 1e5)));

         // worker does not work when starting from file system
         if (need_worker && exports.source_dir.indexOf('file://') == 0) {
            console.log('disable worker for jsroot from file system');
            need_worker = false;
         }

         if (need_worker && !this._worker && (this.ctrl.use_worker >= 0))
            this.startWorker(); // we starting worker, but it may not be ready so fast

         if (!need_worker || !this._worker_ready) {
            let res = this._clones.collectVisibles(this._current_face_limit, frustum);
            this._new_draw_nodes = res.lst;
            this._draw_all_nodes = res.complete;
            this.changeStage(stageAnalyze);
            return true;
         }

         let job = {
            collect: this._current_face_limit,   // indicator for the command
            flags: this._clones.getVisibleFlags(),
            matrix: matrix ? matrix.elements : null
         };

         this.submitToWorker(job);

         this.changeStage(stageWorkerCollect);

         return 2; // we now waiting for the worker reply
      }

      if (this.isStage(stageWorkerCollect)) {
         // do nothing, we are waiting for worker reply
         return 2;
      }

      if (this.isStage(stageAnalyze)) {
         // here we merge new and old list of nodes for drawing,
         // normally operation is fast and can be implemented with one c

         if (this._new_append_nodes) {

            this._new_draw_nodes = this._draw_nodes.concat(this._new_append_nodes);

            delete this._new_append_nodes;

         } else if (this._draw_nodes) {

            let del;
            if (this._geom_viewer)
               del = this._draw_nodes;
            else
               del = this._clones.mergeVisibles(this._new_draw_nodes, this._draw_nodes);

            // remove should be fast, do it here
            for (let n = 0; n < del.length; ++n)
               this._clones.createObject3D(del[n].stack, this._toplevel, 'delete_mesh');

            if (del.length > 0)
               this.drawing_log = `Delete ${del.length} nodes`;
         }

         this._draw_nodes = this._new_draw_nodes;
         delete this._new_draw_nodes;
         this.changeStage(stageCollShapes);
         return true;
      }

      if (this.isStage(stageCollShapes)) {

         // collect shapes
         let shapes = this._clones.collectShapes(this._draw_nodes);

         // merge old and new list with produced shapes
         this._build_shapes = this._clones.mergeShapesLists(this._build_shapes, shapes);

         this.changeStage(stageStartBuild);
         return true;
      }

      if (this.isStage(stageStartBuild)) {
         // this is building of geometries,
         // one can ask worker to build them or do it ourself

         if (this.canSubmitToWorker()) {
            let job = { limit: this._current_face_limit, shapes: [] }, cnt = 0;
            for (let n = 0; n < this._build_shapes.length; ++n) {
               let cl = null, item = this._build_shapes[n];
               // only submit not-done items
               if (item.ready || item.geom) {
                  // this is place holder for existing geometry
                  cl = { id: item.id, ready: true, nfaces: countGeometryFaces(item.geom), refcnt: item.refcnt };
               } else {
                  cl = clone(item, null, true);
                  cnt++;
               }

               job.shapes.push(cl);
            }

            if (cnt > 0) {
               /// only if some geom missing, submit job to the worker
               this.submitToWorker(job);
               this.changeStage(stageWorkerBuild);
               return 2;
            }
         }

         this.changeStage(stageBuild);
      }

      if (this.isStage(stageWorkerBuild)) {
         // waiting shapes from the worker, worker should activate our code
         return 2;
      }

      if (this.isStage(stageBuild) || this.isStage(stageBuildReady)) {

         if (this.isStage(stageBuild)) {
            // building shapes
            let res = this._clones.buildShapes(this._build_shapes, this._current_face_limit, 500);
            if (res.done) {
               this.ctrl.info.num_shapes = this._build_shapes.length;
               this.changeStage(stageBuildReady);
            } else {
               this.ctrl.info.num_shapes = res.shapes;
               this.drawing_log = `Creating: ${res.shapes} / ${this._build_shapes.length} shapes,  ${res.faces} faces`;
               if (res.notusedshapes < 30) return true;
            }
         }

         // final stage, create all meshes

         let tm0 = new Date().getTime(), ready = true,
             toplevel = this.ctrl.project ? this._full_geom : this._toplevel;

         for (let n = 0; n < this._draw_nodes.length; ++n) {
            let entry = this._draw_nodes[n];
            if (entry.done) continue;

            /// shape can be provided with entry itself
            let shape = entry.server_shape || this._build_shapes[entry.shapeid];
            if (!shape.ready) {
               if (this.isStage(stageBuildReady)) console.warn('shape marked as not ready when should');
               ready = false;
               continue;
            }

            entry.done = true;
            shape.used = true; // indicate that shape was used in building

            if (this.createEntryMesh(entry, shape, toplevel)) {
               this.ctrl.info.num_meshes++;
               this.ctrl.info.num_faces += shape.nfaces;
            }

            let tm1 = new Date().getTime();
            if (tm1 - tm0 > 500) { ready = false; break; }
         }

         if (ready) {
            if (this.ctrl.project) {
               this.changeStage(stageBuildProj);
               return true;
            }
            this.changeStage(stageInit);
            return false;
         }

         if (!this.isStage(stageBuild))
            this.drawing_log = `Building meshes ${this.ctrl.info.num_meshes} / ${this.ctrl.info.num_faces}`;
         return true;
      }

      if (this.isStage(stageWaitMain)) {
         // wait for main painter to be ready

         if (!this._main_painter) {
            this.changeStage(stageInit, 'Lost main painter');
            return false;
         }
         if (!this._main_painter._drawing_ready) return 1;

         this.changeStage(stageBuildProj); // just do projection
      }

      if (this.isStage(stageBuildProj)) {
         this.doProjection();
         this.changeStage(stageInit);
         return false;
      }

      console.error(`never come here, stage ${this.drawing_stage}`);

      return false;
   }

   /** @summary Insert appropriate mesh for given entry */
   createEntryMesh(entry, shape, toplevel) {

      if (!shape.geom || (shape.nfaces === 0)) {
         // node is visible, but shape does not created
         this._clones.createObject3D(entry.stack, toplevel, 'delete_mesh');
         return false;
      }

      // workaround for the TGeoOverlap, where two branches should get predefined color
      if (this._splitColors && entry.stack) {
         if (entry.stack[0] === 0)
            entry.custom_color = 'green';
         else if (entry.stack[0] === 1)
            entry.custom_color = 'blue';
      }

      let prop = this._clones.getDrawEntryProperties(entry, getRootColors()),
          obj3d = this._clones.createObject3D(entry.stack, toplevel, this.ctrl),
          matrix = obj3d.absMatrix || obj3d.matrixWorld, mesh;

      prop.material.wireframe = this.ctrl.wireframe;

      prop.material.side = this.ctrl.bothSides ? DoubleSide : FrontSide;

      if (matrix.determinant() > -0.9) {
         mesh = new Mesh(shape.geom, prop.material);
      } else {
         mesh = createFlippedMesh(shape, prop.material);
      }

      obj3d.add(mesh);

      if (obj3d.absMatrix) {
         mesh.matrix.copy(obj3d.absMatrix);
         mesh.matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);
         mesh.updateMatrixWorld();
      }

      // keep full stack of nodes
      mesh.stack = entry.stack;
      mesh.renderOrder = this._clones.maxdepth - entry.stack.length; // order of transparency handling

      // keep hierarchy level
      mesh.$jsroot_order = obj3d.$jsroot_depth;

      // set initial render order, when camera moves, one must refine it
      //mesh.$jsroot_order = mesh.renderOrder =
      //   this._clones.maxdepth - ((obj3d.$jsroot_depth !== undefined) ? obj3d.$jsroot_depth : entry.stack.length);

      if (this.ctrl._debug || this.ctrl._full) {
         let wfg = new WireframeGeometry( mesh.geometry ),
             wfm = new LineBasicMaterial({ color: prop.fillcolor, linewidth: prop.linewidth || 1 }),
             helper = new LineSegments(wfg, wfm);
         obj3d.add(helper);
      }

      if (this.ctrl._bound || this.ctrl._full) {
         let boxHelper = new BoxHelper( mesh );
         obj3d.add( boxHelper );
      }

      return true;
   }

   /** @summary used by geometry viewer to show more nodes
     * @desc These nodes excluded from selection logic and always inserted into the model
     * Shape already should be created and assigned to the node */
   appendMoreNodes(nodes, from_drawing) {

      if (!this.isStage(stageInit) && !from_drawing) {
         this._provided_more_nodes = nodes;
         return;
      }

      // delete old nodes
      if (this._more_nodes)
         for (let n = 0; n < this._more_nodes.length; ++n) {
            let entry = this._more_nodes[n],
                obj3d = this._clones.createObject3D(entry.stack, this._toplevel, 'delete_mesh');
            disposeThreejsObject(obj3d);
            cleanupShape(entry.server_shape);
            delete entry.server_shape;
         }

      delete this._more_nodes;

      if (!nodes) return;

      let real_nodes = [];

      for (let k = 0; k < nodes.length; ++k) {
         let entry = nodes[k],
             shape = entry.server_shape;
         if (!shape?.ready) continue;

         entry.done = true;
         shape.used = true; // indicate that shape was used in building

         if (this.createEntryMesh(entry, shape, this._toplevel))
            real_nodes.push(entry);
      }

      // remember additional nodes only if they include shape - otherwise one can ignore them
      if (real_nodes.length > 0)
         this._more_nodes = real_nodes;

      if (!from_drawing) this.render3D();
   }

   /** @summary Returns hierarchy of 3D objects used to produce projection.
     * @desc Typically external master painter is used, but also internal data can be used */
   getProjectionSource() {
      if (this._clones_owner)
         return this._full_geom;
      if (!this._main_painter) {
         console.warn('MAIN PAINTER DISAPPER');
         return null;
      }
      if (!this._main_painter._drawing_ready) {
         console.warn('MAIN PAINTER NOT READY WHEN DO PROJECTION');
         return null;
      }
      return this._main_painter._toplevel;
   }

   /** @summary Calculate geometry bounding box */
   getGeomBoundingBox(topitem, scalar) {
      let box3 = new Box3(), check_any = !this._clones;

      if (!topitem) {
         box3.min.x = box3.min.y = box3.min.z = -1;
         box3.max.x = box3.max.y = box3.max.z = 1;
         return box3;
      }

      box3.makeEmpty();

      topitem.traverse(mesh => {
         if (check_any || (mesh.stack && (mesh instanceof Mesh)) ||
             (mesh.main_track && (mesh instanceof LineSegments)))
            getBoundingBox(mesh, box3);
      });

      if (scalar !== undefined)
         box3.expandByVector(box3.getSize(new Vector3()).multiplyScalar(scalar));

      return box3;
   }

   /** @summary Create geometry projection */
   doProjection() {
      let toplevel = this.getProjectionSource();

      if (!toplevel) return false;

      disposeThreejsObject(this._toplevel, true);

      // let axis = this.ctrl.project;

      if (this.ctrl.projectPos === undefined) {

         let bound = this.getGeomBoundingBox(toplevel),
             min = bound.min[this.ctrl.project], max = bound.max[this.ctrl.project],
             mean = (min+max)/2;

         if ((min < 0) && (max > 0) && (Math.abs(mean) < 0.2*Math.max(-min,max))) mean = 0; // if middle is around 0, use 0

         this.ctrl.projectPos = mean;
      }

      toplevel.traverse(mesh => {
         if (!(mesh instanceof Mesh) || !mesh.stack) return;

         let geom2 = projectGeometry(mesh.geometry, mesh.parent.absMatrix || mesh.parent.matrixWorld, this.ctrl.project, this.ctrl.projectPos, mesh._flippedMesh);

         if (!geom2) return;

         let mesh2 = new Mesh(geom2, mesh.material.clone());

         this._toplevel.add(mesh2);

         mesh2.stack = mesh.stack;
      });

      return true;
   }

   /** @summary Should be invoked when light configuration changed */
   changedLight(box) {
      if (!this._camera) return;

      let need_render = !box;

      if (!box) box = this.getGeomBoundingBox(this._toplevel);

      let sizex = box.max.x - box.min.x,
          sizey = box.max.y - box.min.y,
          sizez = box.max.z - box.min.z,
          plights = [], p = this.ctrl.light.power;

      if (p === undefined) p = 1;

      if (this._camera._lights != this.ctrl.light.kind) {
         // remove all childs and recreate only necessary lights
         disposeThreejsObject(this._camera, true);

         this._camera._lights = this.ctrl.light.kind;

         switch (this._camera._lights) {
            case 'ambient' : this._camera.add(new AmbientLight(0xefefef, p)); break;
            case 'hemisphere' : this._camera.add(new HemisphereLight(0xffffbb, 0x080820, p)); break;
            default: // 6 point lights
               for (let n = 0; n < 6; ++n)
                  this._camera.add(new PointLight(0xefefef, p));
         }
      }

      for (let k = 0; k < this._camera.children.length; ++k) {
         let light = this._camera.children[k], enabled = false;
         if (light.isAmbientLight || light.isHemisphereLight) {
            light.intensity = p;
            continue;
         }

         if (!light.isPointLight) continue;
         switch (k) {
            case 0: light.position.set(sizex/5, sizey/5, sizez/5); enabled = this.ctrl.light.specular; break;
            case 1: light.position.set(0, 0, sizez/2); enabled = this.ctrl.light.front; break;
            case 2: light.position.set(0, 2*sizey, 0); enabled = this.ctrl.light.top; break;
            case 3: light.position.set(0, -2*sizey, 0); enabled = this.ctrl.light.bottom; break;
            case 4: light.position.set(-2*sizex, 0, 0); enabled = this.ctrl.light.left; break;
            case 5: light.position.set(2*sizex, 0, 0); enabled = this.ctrl.light.right; break;
         }
         light.power = enabled ? p*Math.PI*4 : 0;
         if (enabled) plights.push(light);
      }

      // keep light power of all soources constant
      plights.forEach(ll => { ll.power = p*4*Math.PI/plights.length; });

      if (need_render) this.render3D();
   }

   /** @summary Create configured camera */
   createCamera() {

      if (this._camera) {
          this._scene.remove(this._camera);
          disposeThreejsObject(this._camera);
          delete this._camera;
       }

      if (this.ctrl.ortho_camera) {
         this._camera = new OrthographicCamera(-this._scene_width/2, this._scene_width/2, this._scene_height/2, -this._scene_height/2, 1, 10000);
      } else {
         this._camera = new PerspectiveCamera(25, this._scene_width / this._scene_height, 1, 10000);
         this._camera.up = this.ctrl._yup ? new Vector3(0,1,0) : new Vector3(0,0,1);
      }

      // Light - add default point light, adjust later
      let light = new PointLight(0xefefef, 1);
      light.position.set(10, 10, 10);
      this._camera.add(light);

      this._scene.add(this._camera);
   }

   /** @summary Create special effects */
   createSpecialEffects() {
      // Smooth Lighting Shader (Screen Space Ambient Occlusion)
      // http://threejs.org/examples/webgl_postprocessing_ssao.html

      if (this._webgl && (this.ctrl.ssao.enabled || this.ctrl.outline)) {

         if (this.ctrl.outline && isFunc(this.createOutline)) {
            this._effectComposer = new EffectComposer(this._renderer);
            this._effectComposer.addPass(new RenderPass(this._scene, this._camera));
            this.createOutline(this._scene_width, this._scene_height);
         } else if (this.ctrl.ssao.enabled) {
            this.createSSAO();
         }
      }

      if (this._webgl && this.ctrl.bloom.enabled)
         this.createBloom();
   }

   /** @summary Initial scene creation */
   async createScene(w, h) {
      // three.js 3D drawing
      this._scene = new Scene();
      this._scene.fog = new Fog(0xffffff, 1, 10000);
      this._scene.overrideMaterial = new MeshLambertMaterial({ color: 0x7000ff, vertexColors: false, transparent: true, opacity: 0.2, depthTest: false });

      this._scene_width = w;
      this._scene_height = h;

      this.createCamera();

      this._selected_mesh = null;

      this._overall_size = 10;

      this._toplevel = new Object3D();

      this._scene.add(this._toplevel);

      this._scene.background = new Color$1(this.ctrl.background);

      return createRender3D(w, h, this.options.Render3D, { antialias: true, logarithmicDepthBuffer: false, preserveDrawingBuffer: true }).then(r => {

         this._renderer = r;

         this._webgl = (this._renderer.jsroot_render3d === constants$1.Render3D.WebGL);

         if (this._renderer.setPixelRatio && !isNodeJs())
            this._renderer.setPixelRatio(window.devicePixelRatio);
         this._renderer.setSize(w, h, !this._fit_main_area);
         this._renderer.localClippingEnabled = true;

         this._renderer.setClearColor(this._scene.background, 1);

         if (this._fit_main_area && this._webgl) {
            this._renderer.domElement.style.width = '100%';
            this._renderer.domElement.style.height = '100%';
            let main = this.selectDom();
            if (main.style('position') == 'static')
               main.style('position', 'relative');
         }

         this._animating = false;

         this.ctrl.bothSides = false; // both sides need for clipping
         this.createSpecialEffects();

         if (this._fit_main_area && !this._webgl) {
            // create top-most SVG for geomtery drawings
            let doc = getDocument(),
                svg = doc.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', w);
            svg.setAttribute('height', h);
            svg.appendChild(this._renderer.jsroot_dom);
            return svg;
         }

         return this._renderer.jsroot_dom;
      });
   }

   /** @summary Start geometry drawing */
   startDrawGeometry(force) {

      if (!force && !this.isStage(stageInit)) {
         this._draw_nodes_again = true;
         return;
      }

      if (this._clones_owner && this._clones)
         this._clones.setDefaultColors(this.ctrl.dflt_colors);

      this._startm = new Date().getTime();
      this._last_render_tm = this._startm;
      this._last_render_meshes = 0;
      this.changeStage(stageCollect);
      this._drawing_ready = false;
      this.ctrl.info.num_meshes = 0;
      this.ctrl.info.num_faces = 0;
      this.ctrl.info.num_shapes = 0;
      this._selected_mesh = null;

      if (this.ctrl.project) {
         if (this._clones_owner) {
            if (this._full_geom) {
               this.changeStage(stageBuildProj);
            } else {
               this._full_geom = new Object3D();
            }
         } else {
            this.changeStage(stageWaitMain);
         }
      }

      delete this._last_manifest;
      delete this._last_hidden; // clear list of hidden objects

      delete this._draw_nodes_again; // forget about such flag

      this.continueDraw();
   }

   /** @summary reset all kind of advanced features like SSAO or depth test changes */
   resetAdvanced() {
      this.ctrl.ssao.kernelRadius = 16;
      this.ctrl.ssao.output = SSAOPass.OUTPUT.Default;

      this.ctrl.depthTest = true;
      this.ctrl.clipIntersect = true;
      this.ctrl.depthMethod = 'ray';

      this.changedDepthMethod('norender');
      this.changedDepthTest();
   }

   /** @summary returns maximal dimension */
   getOverallSize(force) {
      if (!this._overall_size || force) {
         let box = this.getGeomBoundingBox(this._toplevel);

         // if detect of coordinates fails - ignore
         if (!Number.isFinite(box.min.x)) return 1000;

         this._overall_size = 2 * Math.max(box.max.x - box.min.x, box.max.y - box.min.y, box.max.z - box.min.z);
      }

      return this._overall_size;
   }

   /** @summary Create png image with drawing snapshot. */
   createSnapshot(filename) {
      if (!this._renderer) return;
      this.render3D(0);
      let dataUrl = this._renderer.domElement.toDataURL('image/png');
      if (filename === 'asis') return dataUrl;
      dataUrl.replace('image/png', 'image/octet-stream');
      let doc = getDocument(),
          link = doc.createElement('a');
      if (isStr(link.download)) {
         doc.body.appendChild(link); //Firefox requires the link to be in the body
         link.download = filename || 'geometry.png';
         link.href = dataUrl;
         link.click();
         doc.body.removeChild(link); //remove the link when done
      }
   }

   /** @summary Returns url parameters defining camera position.
     * @desc It is zoom, roty, rotz parameters
     * These parameters applied from default position which is shift along X axis */
   produceCameraUrl(prec) {

      if (!this._lookat || !this._camera0pos || !this._camera || !this.ctrl) return;

      let pos1 = new Vector3().add(this._camera0pos).sub(this._lookat),
          pos2 = new Vector3().add(this._camera.position).sub(this._lookat),
          zoom = Math.min(10000, Math.max(1, this.ctrl.zoom * pos2.length() / pos1.length() * 100));

      pos1.normalize();
      pos2.normalize();

      let quat = new Quaternion(), euler = new Euler();

      quat.setFromUnitVectors(pos1, pos2);
      euler.setFromQuaternion(quat, 'YZX');

      let roty = euler.y / Math.PI * 180,
          rotz = euler.z / Math.PI * 180;

      if (roty < 0) roty += 360;
      if (rotz < 0) rotz += 360;
      prec = prec || 0;

      return `roty${roty.toFixed(prec)},rotz${rotz.toFixed(prec)},zoom${zoom.toFixed(prec)}`;
   }

   /** @summary Calculates current zoom factor */
   calculateZoom() {
      if (this._camera0pos && this._camera && this._lookat) {
         let pos1 = new Vector3().add(this._camera0pos).sub(this._lookat),
             pos2 = new Vector3().add(this._camera.position).sub(this._lookat);
         return pos2.length() / pos1.length();
      }

      return 0;
   }

   /** @summary Place camera to default position */
   adjustCameraPosition(first_time, keep_zoom) {
      if (!this._toplevel) return;

      let box = this.getGeomBoundingBox(this._toplevel);

      // let box2 = new Box3().makeEmpty();
      // box2.expandByObject(this._toplevel, true);
      // console.log('min,max', box.min.x, box.max.x, box2.min.x, box2.max.x);

      // if detect of coordinates fails - ignore
      if (!Number.isFinite(box.min.x)) return;

      let sizex = box.max.x - box.min.x,
          sizey = box.max.y - box.min.y,
          sizez = box.max.z - box.min.z,
          midx = (box.max.x + box.min.x)/2,
          midy = (box.max.y + box.min.y)/2,
          midz = (box.max.z + box.min.z)/2;

      this._overall_size = 2 * Math.max(sizex, sizey, sizez);

      this._camera.near = this._overall_size / 350;
      this._camera.far = this._overall_size * 12;
      this._scene.fog.near = this._overall_size * 2;
      this._scene.fog.far = this._overall_size * 12;

      if (first_time)
         for (let naxis = 0; naxis < 3; ++naxis) {
            let cc = this.ctrl.clip[naxis];
            cc.min = box.min[cc.name];
            cc.max = box.max[cc.name];
            let sz = cc.max - cc.min;
            cc.max += sz*0.01;
            cc.min -= sz*0.01;
            if (!cc.value)
               cc.value = (cc.min + cc.max) / 2;
            else if (cc.value < cc.min)
               cc.value = cc.min;
            else if (cc.value > cc.max)
               cc.value = cc.max;
         }

      if (this.ctrl.ortho_camera) {
         this._camera.left = box.min.x;
         this._camera.right = box.max.x;
         this._camera.top = box.max.y;
         this._camera.bottom = box.min.y;
      }

      // this._camera.far = 100000000000;

      this._camera.updateProjectionMatrix();

      let k = 2*this.ctrl.zoom,
          max_all = Math.max(sizex,sizey,sizez);

      if ((this.ctrl.rotatey || this.ctrl.rotatez) && this.ctrl.can_rotate) {

         let prev_zoom = this.calculateZoom();
         if (keep_zoom && prev_zoom) k = 2*prev_zoom;

         let euler = new Euler(0, this.ctrl.rotatey/180.*Math.PI, this.ctrl.rotatez/180.*Math.PI, 'YZX');

         this._camera.position.set(-k*max_all, 0, 0);
         this._camera.position.applyEuler(euler);
         this._camera.position.add(new Vector3(midx,midy,midz));

         if (keep_zoom && prev_zoom) {
            let actual_zoom = this.calculateZoom();
            k *= prev_zoom/actual_zoom;

            this._camera.position.set(-k*max_all, 0, 0);
            this._camera.position.applyEuler(euler);
            this._camera.position.add(new Vector3(midx,midy,midz));
         }

      } else if (this.ctrl.ortho_camera) {
         this._camera.position.set(midx, midy, Math.max(sizex,sizey));
      } else if (this.ctrl.project) {
         switch (this.ctrl.project) {
            case 'x': this._camera.position.set(k*1.5*Math.max(sizey,sizez), 0, 0); break;
            case 'y': this._camera.position.set(0, k*1.5*Math.max(sizex,sizez), 0); break;
            case 'z': this._camera.position.set(0, 0, k*1.5*Math.max(sizex,sizey)); break;
         }
      } else if (this.ctrl._yup) {
         this._camera.position.set(midx-k*Math.max(sizex,sizez), midy+k*sizey, midz-k*Math.max(sizex,sizez));
      } else {
         this._camera.position.set(midx-k*Math.max(sizex,sizey), midy-k*Math.max(sizex,sizey), midz+k*sizez);
      }

      this._lookat = new Vector3(midx, midy, midz);
      this._camera0pos = new Vector3(-2*max_all, 0, 0); // virtual 0 position, where rotation starts
      this._camera.lookAt(this._lookat);

      this.changedLight(box);

      if (this._controls) {
         this._controls.target.copy(this._lookat);
         this._controls.update();
      }

      // recheck which elements to draw
      if (this.ctrl.select_in_view)
         this.startDrawGeometry();
   }

   /** @summary Specifies camera position */
   setCameraPosition(rotatey, rotatez, zoom) {
      if (!this.ctrl) return;
      this.ctrl.rotatey = rotatey || 0;
      this.ctrl.rotatez = rotatez || 0;
      let preserve_zoom = false;
      if (zoom && Number.isFinite(zoom)) {
         this.ctrl.zoom = zoom;
      } else {
         preserve_zoom = true;
      }
      this.adjustCameraPosition(false, preserve_zoom);
   }

   /** @summary focus on item */
   focusOnItem(itemname) {

      if (!itemname || !this._clones) return;

      let stack = this._clones.findStackByName(itemname);

      if (stack)
         this.focusCamera(this._clones.resolveStack(stack, true), false);
   }

   /** @summary focus camera on speicifed position */
   focusCamera( focus, autoClip ) {

      if (this.ctrl.project || this.ctrl.ortho_camera)
         return this.adjustCameraPosition();

      let box = new Box3();
      if (focus === undefined) {
         box = this.getGeomBoundingBox(this._toplevel);
      } else if (focus instanceof Mesh) {
         box.setFromObject(focus);
      } else {
         let center = new Vector3().setFromMatrixPosition(focus.matrix),
             node = focus.node,
             halfDelta = new Vector3(node.fDX, node.fDY, node.fDZ).multiplyScalar(0.5);
         box.min = center.clone().sub(halfDelta);
         box.max = center.clone().add(halfDelta);
      }

      let sizex = box.max.x - box.min.x,
          sizey = box.max.y - box.min.y,
          sizez = box.max.z - box.min.z,
          midx = (box.max.x + box.min.x)/2,
          midy = (box.max.y + box.min.y)/2,
          midz = (box.max.z + box.min.z)/2;

      let position;
      if (this.ctrl._yup)
         position = new Vector3(midx-2*Math.max(sizex,sizez), midy+2*sizey, midz-2*Math.max(sizex,sizez));
      else
         position = new Vector3(midx-2*Math.max(sizex,sizey), midy-2*Math.max(sizex,sizey), midz+2*sizez);

      let target = new Vector3(midx, midy, midz),
          oldTarget = this._controls.target,
          // probably, reduce number of frames
          frames = 50, step = 0,
          // Amount to change camera position at each step
          posIncrement = position.sub(this._camera.position).divideScalar(frames),
          // Amount to change 'lookAt' so it will end pointed at target
          targetIncrement = target.sub(oldTarget).divideScalar(frames);

      autoClip = autoClip && this._webgl;

      // Automatic Clipping
      if (autoClip) {
         for (let axis = 0; axis < 3; ++axis) {
            let cc = this.ctrl.clip[axis];
            if (!cc.enabled) { cc.value = cc.min; cc.enabled = true; }
            cc.inc = ((cc.min + cc.max) / 2 - cc.value) / frames;
         }
         this.updateClipping();
      }

      this._animating = true;

      // Interpolate //

      const animate = () => {
         if (this._animating === undefined) return;

         if (this._animating) {
            requestAnimationFrame(animate);
         } else {
            if (!this._geom_viewer)
               this.startDrawGeometry();
         }
         let smoothFactor = -Math.cos((2.0*Math.PI*step)/frames) + 1.0;
         this._camera.position.add(posIncrement.clone().multiplyScalar(smoothFactor));
         oldTarget.add(targetIncrement.clone().multiplyScalar(smoothFactor));
         this._lookat = oldTarget;
         this._camera.lookAt(this._lookat);
         this._camera.updateProjectionMatrix();

         let tm1 = new Date().getTime();
         if (autoClip) {
            for (let axis = 0; axis < 3; ++axis)
               this.ctrl.clip[axis].value += this.ctrl.clip[axis].inc * smoothFactor;
            this.updateClipping();
         } else {
            this.render3D(0);
         }
         let tm2 = new Date().getTime();
         if ((step == 0) && (tm2-tm1 > 200)) frames = 20;
         step++;
         this._animating = step < frames;
      };

      animate();

   //   this._controls.update();
   }

   /** @summary actiavte auto rotate */
   autorotate(speed) {

      let rotSpeed = (speed === undefined) ? 2.0 : speed,
          last = new Date();

      const animate = () => {
         if (!this._renderer || !this.ctrl) return;

         let current = new Date();

         if (this.ctrl.rotate)
            requestAnimationFrame(animate);

         if (this._controls) {
            this._controls.autoRotate = this.ctrl.rotate;
            this._controls.autoRotateSpeed = rotSpeed * ( current.getTime() - last.getTime() ) / 16.6666;
            this._controls.update();
         }
         last = new Date();
         this.render3D(0);
      };

      if (this._webgl) animate();
   }

   /** @summary called at the end of scene drawing */
   completeScene() {

      if ( this.ctrl._debug || this.ctrl._grid ) {
         if ( this.ctrl._full ) {
            let boxHelper = new BoxHelper(this._toplevel);
            this._scene.add( boxHelper );
         }
         this._scene.add(new AxesHelper(2 * this._overall_size));
         this._scene.add(new GridHelper(Math.ceil(this._overall_size), Math.ceil(this._overall_size)/50));
         this.helpText("<font face='verdana' size='1' color='red'><center>Transform Controls<br>" +
               "'T' translate | 'R' rotate | 'S' scale<br>" +
               "'+' increase size | '-' decrease size<br>" +
               "'W' toggle wireframe/solid display<br>"+
               "keep 'Ctrl' down to snap to grid</center></font>");
      }
   }

   /** @summary Drawing with 'count' option
     * @desc Scans hieararchy and check for unique nodes
     * @return {Promise} with object drawing ready */
   async drawCount(unqievis, clonetm) {

      const makeTime = tm => (isBatchMode() ? 'anytime' : tm.toString()) + ' ms';

      let res = [ 'Unique nodes: ' + this._clones.nodes.length,
                  'Unique visible: ' + unqievis,
                  'Time to clone: ' + makeTime(clonetm) ];

      // need to fill cached value line numvischld
      this._clones.scanVisible();

      let nshapes = 0, arg = {
         clones: this._clones,
         cnt: [],
         func(node) {
            if (this.cnt[this.last] === undefined)
               this.cnt[this.last] = 1;
            else
               this.cnt[this.last]++;

            nshapes += countNumShapes(this.clones.getNodeShape(node.id));
            return true;
         }
      };

      let tm1 = new Date().getTime(),
          numvis = this._clones.scanVisible(arg),
          tm2 = new Date().getTime();

      res.push(`Total visible nodes: ${numvis}`, `Total shapes: ${nshapes}`);

      for (let lvl = 0; lvl < arg.cnt.length; ++lvl) {
         if (arg.cnt[lvl] !== undefined)
            res.push(`  lvl${lvl}: ${arg.cnt[lvl]}`);
      }

      res.push(`Time to scan: ${makeTime(tm2-tm1)}`, '', 'Check timing for matrix calculations ...');

      let elem = this.selectDom().style('overflow', 'auto');

      if (isBatchMode())
         elem.property('_json_object_', res);
      else
         res.forEach(str => elem.append('p').text(str));

      return new Promise(resolveFunc => {
         setTimeout(() => {
            arg.domatrix = true;
            tm1 = new Date().getTime();
            numvis = this._clones.scanVisible(arg);
            tm2 = new Date().getTime();

            let last_str = `Time to scan with matrix: ${makeTime(tm2-tm1)}`;
            if (isBatchMode())
               res.push(last_str);
            else
               elem.append('p').text(last_str);
            resolveFunc(this);
         }, 100);
      });
   }

   /** @summary Handle drop operation
     * @desc opt parameter can include function name like opt$func_name
     * Such function should be possible to find via {@link findFunction}
     * Function has to return Promise with objects to draw on geometry
     * By default function with name 'extract_geo_tracks' is checked
     * @return {Promise} handling of drop operation */
   async performDrop(obj, itemname, hitem, opt) {

      if (obj?.$kind === 'TTree') {
         // drop tree means function call which must extract tracks from provided tree

         let funcname = 'extract_geo_tracks';

         if (opt && opt.indexOf('$') > 0) {
            funcname = opt.slice(0, opt.indexOf('$'));
            opt = opt.slice(opt.indexOf('$')+1);
         }

         let func = findFunction(funcname);

         if (!func) return Promise.reject(Error(`Function ${funcname} not found`));

         return func(obj, opt).then(tracks => {
            if (!tracks) return this;

            // FIXME: probably tracks should be remembered?
            return this.drawExtras(tracks, '', false).then(()=> {
               this.updateClipping(true);
               return this.render3D(100);
            });
         });
      }

      return this.drawExtras(obj, itemname).then(is_any => {
         if (!is_any) return this;

         if (hitem) hitem._painter = this; // set for the browser item back pointer

         return this.render3D(100);
      });
   }

   /** @summary function called when mouse is going over the item in the browser */
   mouseOverHierarchy(on, itemname, hitem) {
      if (!this.ctrl) return; // protection for cleaned-up painter

      let obj = hitem._obj;
      if (this.ctrl._debug)
         console.log(`Mouse over ${on} ${itemname} ${obj?._typename}`);

      // let's highlight tracks and hits only for the time being
      if (!obj || (obj._typename !== clTEveTrack && obj._typename !== clTEvePointSet && obj._typename !== clTPolyMarker3D)) return;

      this.highlightMesh(null, 0x00ff00, on ? obj : null);
   }

   /** @summary clear extra drawn objects like tracks or hits */
   clearExtras() {
      this.getExtrasContainer('delete');
      delete this._extraObjects; // workaround, later will be normal function
      this.render3D();
   }

   /** @summary Register extra objects like tracks or hits
    * @desc Rendered after main geometry volumes are created
    * Check if object already exists to prevent duplication */
   addExtra(obj, itemname) {
      if (this._extraObjects === undefined)
         this._extraObjects = create$1(clTList);

      if (this._extraObjects.arr.indexOf(obj) >= 0) return false;

      this._extraObjects.Add(obj, itemname);

      delete obj.$hidden_via_menu; // remove previous hidden property

      return true;
   }

   /** @summary manipulate visisbility of extra objects, used for HierarchyPainter
     * @private */
   extraObjectVisible(hpainter, hitem, toggle) {
      if (!this._extraObjects) return;

      let itemname = hpainter.itemFullName(hitem),
          indx = this._extraObjects.opt.indexOf(itemname);

      if ((indx < 0) && hitem._obj) {
         indx = this._extraObjects.arr.indexOf(hitem._obj);
         // workaround - if object found, replace its name
         if (indx >= 0) this._extraObjects.opt[indx] = itemname;
      }

      if (indx < 0) return;

      let obj = this._extraObjects.arr[indx],
          res = obj.$hidden_via_menu ? false : true;

      if (toggle) {
         obj.$hidden_via_menu = res; res = !res;

         let mesh = null;
         // either found painted object or just draw once again
         this._toplevel.traverse(node => { if (node.geo_object === obj) mesh = node; });

         if (mesh) {
            mesh.visible = res;
            this.render3D();
         } else if (res) {
            this.drawExtras(obj, '', false).then(() => {
               this.updateClipping(true);
               this.render3D();
            });
         }
      }

      return res;
   }

   /** @summary Draw extra object like tracks
     * @return {Promise} for ready */
   async drawExtras(obj, itemname, add_objects) {
      // if object was hidden via menu, do not redraw it with next draw call
      if (!obj?._typename || (!add_objects && obj.$hidden_via_menu))
         return false;

      let do_render = false;
      if (add_objects === undefined) {
         add_objects = true;
         do_render = true;
      }

      let promise = false;

      if ((obj._typename === clTList) || (obj._typename === clTObjArray)) {
         if (!obj.arr) return false;
         let parr = [];
         for (let n = 0; n < obj.arr.length; ++n) {
            let sobj = obj.arr[n], sname = obj.opt ? obj.opt[n] : '';
            if (!sname) sname = (itemname || '<prnt>') + `/[${n}]`;
            parr.push(this.drawExtras(sobj, sname, add_objects));
         }
         promise = Promise.all(parr).then(ress => ress.indexOf(true) >= 0);
      } else if (obj._typename === 'Mesh') {
         // adding mesh as is
         this.addToExtrasContainer(obj);
         promise = Promise.resolve(true);
      } else if (obj._typename === 'TGeoTrack') {
         if (!add_objects || this.addExtra(obj, itemname))
            promise = this.drawGeoTrack(obj, itemname);
      } else if (obj._typename === clTPolyLine3D) {
         if (!add_objects || this.addExtra(obj, itemname))
            promise = this.drawPolyLine(obj, itemname);
      } else if ((obj._typename === clTEveTrack) || (obj._typename === 'ROOT::Experimental::REveTrack')) {
         if (!add_objects || this.addExtra(obj, itemname))
            promise = this.drawEveTrack(obj, itemname);
      } else if ((obj._typename === clTEvePointSet) || (obj._typename === 'ROOT::Experimental::REvePointSet') || (obj._typename === clTPolyMarker3D)) {
         if (!add_objects || this.addExtra(obj, itemname))
            promise = this.drawHit(obj, itemname);
      } else if ((obj._typename === clTEveGeoShapeExtract) || (obj._typename === clREveGeoShapeExtract)) {
         if (!add_objects || this.addExtra(obj, itemname))
            promise = this.drawExtraShape(obj, itemname);
      }

      return getPromise(promise).then(is_any => {
         if (!is_any || !do_render) return is_any;

         this.updateClipping(true);
         return this.render3D(100);
      });
   }

   /** @summary returns container for extra objects */
   getExtrasContainer(action, name) {
      if (!this._toplevel) return null;

      if (!name) name = 'tracks';

      let extras = null, lst = [];
      for (let n = 0; n < this._toplevel.children.length; ++n) {
         let chld = this._toplevel.children[n];
         if (!chld._extras) continue;
         if (action == 'collect') { lst.push(chld); continue; }
         if (chld._extras === name) { extras = chld; break; }
      }

      if (action == 'collect') {
         for (let k = 0; k < lst.length; ++k)
            this._toplevel.remove(lst[k]);
         return lst;
      }

      if (action == 'delete') {
         if (extras) this._toplevel.remove(extras);
         disposeThreejsObject(extras);
         return null;
      }

      if ((action !== 'get') && !extras) {
         extras = new Object3D();
         extras._extras = name;
         this._toplevel.add(extras);
      }

      return extras;
   }

   /** @summary add object to extras container.
     * @desc If fail, dispose object */
   addToExtrasContainer(obj, name) {
      let container = this.getExtrasContainer('', name);
      if (container) {
         container.add(obj);
      } else {
         console.warn('Fail to add object to extras');
         disposeThreejsObject(obj);
      }
   }

   /** @summary drawing TGeoTrack */
   drawGeoTrack(track, itemname) {
      if (!track?.fNpoints) return false;

      let linewidth = browser$1.isWin ? 1 : (track.fLineWidth || 1), // line width not supported on windows
          color = getColor(track.fLineColor) || '#ff00ff',
          npoints = Math.round(track.fNpoints/4), // each track point has [x,y,z,t] coordinate
          buf = new Float32Array((npoints-1)*6),
          pos = 0, projv = this.ctrl.projectPos,
          projx = (this.ctrl.project === 'x'),
          projy = (this.ctrl.project === 'y'),
          projz = (this.ctrl.project === 'z');

      for (let k = 0; k < npoints-1; ++k) {
         buf[pos]   = projx ? projv : track.fPoints[k*4];
         buf[pos+1] = projy ? projv : track.fPoints[k*4+1];
         buf[pos+2] = projz ? projv : track.fPoints[k*4+2];
         buf[pos+3] = projx ? projv : track.fPoints[k*4+4];
         buf[pos+4] = projy ? projv : track.fPoints[k*4+5];
         buf[pos+5] = projz ? projv : track.fPoints[k*4+6];
         pos+=6;
      }

      let lineMaterial = new LineBasicMaterial({ color, linewidth }),
          line = createLineSegments(buf, lineMaterial);

      line.defaultOrder = line.renderOrder = 1000000; // to bring line to the front
      line.geo_name = itemname;
      line.geo_object = track;
      line.hightlightWidthScale = 2;

      if (itemname && itemname.indexOf('<prnt>/Tracks') == 0)
         line.main_track = true;

      this.addToExtrasContainer(line);

      return true;
   }

   /** @summary drawing TPolyLine3D */
   drawPolyLine(line, itemname) {
      if (!line) return false;

      let linewidth = browser$1.isWin ? 1 : (line.fLineWidth || 1),
          color = getColor(line.fLineColor) || '#ff00ff',
          npoints = line.fN,
          fP = line.fP,
          buf = new Float32Array((npoints-1)*6),
          pos = 0, projv = this.ctrl.projectPos,
          projx = (this.ctrl.project === 'x'),
          projy = (this.ctrl.project === 'y'),
          projz = (this.ctrl.project === 'z');

      for (let k = 0; k < npoints-1; ++k) {
         buf[pos]   = projx ? projv : fP[k*3];
         buf[pos+1] = projy ? projv : fP[k*3+1];
         buf[pos+2] = projz ? projv : fP[k*3+2];
         buf[pos+3] = projx ? projv : fP[k*3+3];
         buf[pos+4] = projy ? projv : fP[k*3+4];
         buf[pos+5] = projz ? projv : fP[k*3+5];
         pos += 6;
      }

      let lineMaterial = new LineBasicMaterial({ color, linewidth }),
          line3d = createLineSegments(buf, lineMaterial);

      line3d.defaultOrder = line3d.renderOrder = 1000000; // to bring line to the front
      line3d.geo_name = itemname;
      line3d.geo_object = line;
      line3d.hightlightWidthScale = 2;

      this.addToExtrasContainer(line3d);

      return true;
   }

   /** @summary Drawing TEveTrack */
   drawEveTrack(track, itemname) {
      if (!track || (track.fN <= 0)) return false;

      let linewidth = browser$1.isWin ? 1 : (track.fLineWidth || 1),
          color = getColor(track.fLineColor) || '#ff00ff',
          buf = new Float32Array((track.fN-1)*6), pos = 0,
          projv = this.ctrl.projectPos,
          projx = (this.ctrl.project === 'x'),
          projy = (this.ctrl.project === 'y'),
          projz = (this.ctrl.project === 'z');

      for (let k = 0; k < track.fN-1; ++k) {
         buf[pos]   = projx ? projv : track.fP[k*3];
         buf[pos+1] = projy ? projv : track.fP[k*3+1];
         buf[pos+2] = projz ? projv : track.fP[k*3+2];
         buf[pos+3] = projx ? projv : track.fP[k*3+3];
         buf[pos+4] = projy ? projv : track.fP[k*3+4];
         buf[pos+5] = projz ? projv : track.fP[k*3+5];
         pos+=6;
      }

      let lineMaterial = new LineBasicMaterial({ color, linewidth }),
          line = createLineSegments(buf, lineMaterial);

      line.defaultOrder = line.renderOrder = 1000000; // to bring line to the front
      line.geo_name = itemname;
      line.geo_object = track;
      line.hightlightWidthScale = 2;

      this.addToExtrasContainer(line);

      return true;
   }

   /** @summary Drawing different hits types like TPolyMarker3D */
   async drawHit(hit, itemname) {
      if (!hit || !hit.fN || (hit.fN < 0))
         return false;

      // make hit size scaling factor of overall geometry size
      // otherwise it is not possible to correctly see hits at all
      let hit_size = Math.max(hit.fMarkerSize * this.getOverallSize() * 0.005, 0.2),
          nhits = hit.fN,
          projv = this.ctrl.projectPos,
          projx = (this.ctrl.project === 'x'),
          projy = (this.ctrl.project === 'y'),
          projz = (this.ctrl.project === 'z'),
          style = hit.fMarkerStyle;

      // FIXME: styles 2 and 4 does not work properly, see Misc/basic3d demo
      // style 4 is very bad for hits representation
      if ((style == 4) || (style == 2)) { style = 7; hit_size *= 1.5; }

      let pnts = new PointsCreator(nhits, this._webgl, hit_size);

      for (let i = 0; i < nhits; i++)
         pnts.addPoint(projx ? projv : hit.fP[i*3],
                       projy ? projv : hit.fP[i*3+1],
                       projz ? projv : hit.fP[i*3+2]);

      return pnts.createPoints({ color: getColor(hit.fMarkerColor) || '#0000ff', style }).then(mesh => {
         mesh.defaultOrder = mesh.renderOrder = 1000000; // to bring points to the front
         mesh.highlightScale = 2;
         mesh.geo_name = itemname;
         mesh.geo_object = hit;
         this.addToExtrasContainer(mesh);
         return true; // indicate that rendering should be done
      });
   }

   /** @summary Draw extra shape on the geometry */
   drawExtraShape(obj, itemname) {
      let mesh = build(obj);
      if (!mesh) return false;

      mesh.geo_name = itemname;
      mesh.geo_object = obj;

      this.addToExtrasContainer(mesh);
      return true;
   }

   /** @summary Serach for specified node
     * @private */
   findNodeWithVolume(name, action, prnt, itemname, volumes) {

      let first_level = false, res = null;

      if (!prnt) {
         prnt = this.getGeometry();
         if (!prnt && (getNodeKind(prnt) !== 0)) return null;
         itemname = this.geo_manager ? prnt.fName : '';
         first_level = true;
         volumes = [];
      } else {
         if (itemname) itemname += '/';
         itemname += prnt.fName;
      }

      if (!prnt.fVolume || prnt.fVolume._searched) return null;

      if (name.test(prnt.fVolume.fName)) {
         res = action({ node: prnt, item: itemname });
         if (res) return res;
      }

      prnt.fVolume._searched = true;
      volumes.push(prnt.fVolume);

      if (prnt.fVolume.fNodes)
         for (let n = 0, len = prnt.fVolume.fNodes.arr.length; n < len; ++n) {
            res = this.findNodeWithVolume(name, action, prnt.fVolume.fNodes.arr[n], itemname, volumes);
            if (res) break;
         }

      if (first_level)
         for (let n = 0, len = volumes.length; n < len; ++n)
            delete volumes[n]._searched;

      return res;
   }

   /** @summary Process script option - load and execute some gGeoManager-related calls */
   async loadMacro(script_name) {

      let result = { obj: this.getGeometry(), prefix: '' };

      if (this.geo_manager)
         result.prefix = result.obj.fName;

      if (!script_name || (script_name.length < 3) || (getNodeKind(result.obj) !== 0))
         return result;

      let mgr = {
            GetVolume: name => {
               let regexp = new RegExp('^'+name+'$'),
                   currnode = this.findNodeWithVolume(regexp, arg => arg);

               if (!currnode) console.log(`Did not found ${name} volume`);

               // return proxy object with several methods, typically used in ROOT geom scripts
               return {
                   found: currnode,
                   fVolume: currnode?.node?.fVolume,
                   InvisibleAll(flag) {
                      setInvisibleAll(this.fVolume, flag);
                   },
                   Draw() {
                      if (!this.found || !this.fVolume) return;
                      result.obj = this.found.node;
                      result.prefix = this.found.item;
                      console.log(`Select volume for drawing ${this.fVolume.fName} ${result.prefix}`);
                   },
                   SetTransparency(lvl) {
                     if (this.fVolume?.fMedium?.fMaterial)
                        this.fVolume.fMedium.fMaterial.fFillStyle = 3000 + lvl;
                   },
                   SetLineColor(col) {
                      if (this.fVolume) this.fVolume.fLineColor = col;
                   }
                };
            },

            DefaultColors: () => {
               this.ctrl.dflt_colors = true;
            },

            SetMaxVisNodes: limit => {
               if (!this.ctrl.maxnodes)
                  this.ctrl.maxnodes = pasrseInt(limit) || 0;
            },

            SetVisLevel: limit => {
               if (!this.ctrl.vislevel)
                  this.ctrl.vislevel = parseInt(limit) || 0;
            }
          };

      showProgress('Loading macro ' + script_name);

      return httpRequest(script_name, 'text').then(script => {
         let lines = script.split('\n'), indx = 0;

         while (indx < lines.length) {
            let line = lines[indx++].trim();

            if (line.indexOf('//') == 0) continue;

            if (line.indexOf('gGeoManager') < 0) continue;
            line = line.replace('->GetVolume','.GetVolume');
            line = line.replace('->InvisibleAll','.InvisibleAll');
            line = line.replace('->SetMaxVisNodes','.SetMaxVisNodes');
            line = line.replace('->DefaultColors','.DefaultColors');
            line = line.replace('->Draw','.Draw');
            line = line.replace('->SetTransparency','.SetTransparency');
            line = line.replace('->SetLineColor','.SetLineColor');
            line = line.replace('->SetVisLevel','.SetVisLevel');
            if (line.indexOf('->') >= 0) continue;

            try {
               let func = new Function('gGeoManager', line);
               func(mgr);
            } catch(err) {
               console.error(`Problem by processing ${line}`);
            }
         }

         return result;
      }).catch(() => {
         console.error(`Fail to load ${script_name}`);
         return result;
      });
   }

   /** @summary Assign clones, created outside.
     * @desc Used by geometry painter, where clones are handled by the server */
   assignClones(clones) {
      this._clones_owner = true;
      this._clones = clones;
   }

    /** @summary Extract shapes from draw message of geometry painter
      * @desc For the moment used in batch production */
   extractRawShapes(draw_msg, recreate) {
      let nodes = null, old_gradpersegm = 0;

      // array for descriptors for each node
      // if array too large (>1M), use JS object while only ~1K nodes are expected to be used
      if (recreate) {
         // if (draw_msg.kind !== "draw") return false;
         nodes = (draw_msg.numnodes > 1e6) ? { length: draw_msg.numnodes } : new Array(draw_msg.numnodes); // array for all nodes
      }

      draw_msg.nodes.forEach(node => {
         node = ClonedNodes.formatServerElement(node);
         if (nodes)
            nodes[node.id] = node;
         else
            this._clones.updateNode(node);
      });

      if (recreate) {
         this._clones_owner = true;
         this._clones = new ClonedNodes(null, nodes);
         this._clones.name_prefix = this._clones.getNodeName(0);
         // normally only need when making selection, not used in geo viewer
         // this.geo_clones.setMaxVisNodes(draw_msg.maxvisnodes);
         // this.geo_clones.setVisLevel(draw_msg.vislevel);
         // parameter need for visualization with transparency
         // TODO: provide from server
         this._clones.maxdepth = 20;
      }

      let nsegm = 0;
      if (draw_msg.cfg)
         nsegm = draw_msg.cfg.nsegm;

      if (nsegm) {
         old_gradpersegm = geoCfg("GradPerSegm");
         geoCfg("GradPerSegm", 360 / Math.max(nsegm,6));
      }

      for (let cnt = 0; cnt < draw_msg.visibles.length; ++cnt) {
         let item = draw_msg.visibles[cnt], rd = item.ri;

         // entry may be provided without shape - it is ok
         if (rd)
            item.server_shape = rd.server_shape = createServerGeometry(rd, nsegm);
      }

      if (old_gradpersegm)
         geoCfg("GradPerSegm", old_gradpersegm);

      return true;
   }

   /** @summary Prepare drawings
     * @desc Return value used as promise for painter */
   async prepareObjectDraw(draw_obj, name_prefix) {
      // if did cleanup - ignore all kind of activity
      if (this.did_cleanup)
         return null;

      if (name_prefix == '__geom_viewer_append__') {
         this._new_append_nodes = draw_obj;
         this.ctrl.use_worker = 0;
         this._geom_viewer = true; // indicate that working with geom viewer
      } else if ((name_prefix == '__geom_viewer_selection__') && this._clones) {
         // these are selection done from geom viewer
         this._new_draw_nodes = draw_obj;
         this.ctrl.use_worker = 0;
         this._geom_viewer = true; // indicate that working with geom viewer
      } else if (this._main_painter) {
         this._clones_owner = false;
         this._clones = this._main_painter._clones;
         console.log(`Reuse clones ${this._clones.nodes.length} from main painter`);
      } else if (!draw_obj) {
         this._clones_owner = false;
         this._clones = null;
      } else {
         this._start_drawing_time = new Date().getTime();
         this._clones_owner = true;
         this._clones = new ClonedNodes(draw_obj);
         let lvl = this.ctrl.vislevel, maxnodes = this.ctrl.maxnodes;
         if (this.geo_manager) {
            if (!lvl && this.geo_manager.fVisLevel)
               lvl = this.geo_manager.fVisLevel;
            if (!maxnodes)
               maxnodes = this.geo_manager.fMaxVisNodes;
         }
         this._clones.setVisLevel(lvl);
         this._clones.setMaxVisNodes(maxnodes);

         this._clones.name_prefix = name_prefix;

         let hide_top_volume = !!this.geo_manager && !this.ctrl.showtop,
             uniquevis = this.ctrl.no_screen ? 0 : this._clones.markVisibles(true, false, hide_top_volume);

         if (uniquevis <= 0)
            uniquevis = this._clones.markVisibles(false, false, hide_top_volume);
         else
            uniquevis = this._clones.markVisibles(true, true, hide_top_volume); // copy bits once and use normal visibility bits

         this._clones.produceIdShifts();

         let spent = new Date().getTime() - this._start_drawing_time;

         if (!this._scene)
            console.log(`Creating clones ${this._clones.nodes.length} takes ${spent} ms uniquevis ${uniquevis}`);

         if (this.options._count)
            return this.drawCount(uniquevis, spent);
      }

      let promise = Promise.resolve(true);

      if (!this._scene) {
         this._first_drawing = true;

         let pp = this.getPadPainter();

         this._on_pad = !!pp;

         if (this._on_pad) {
            let size, render3d, fp;
            promise = ensureTCanvas(this,'3d').then(() => {
               if (pp.fillatt?.color)
                  this.ctrl.background = pp.fillatt.color;
               fp = this.getFramePainter();

               render3d = getRender3DKind();
               assign3DHandler(fp);
               fp.mode3d = true;

               size = fp.getSizeFor3d(undefined, render3d);

               this._fit_main_area = (size.can3d === -1);

               return this.createScene(size.width, size.height)
                          .then(dom => fp.add3dCanvas(size, dom, render3d === constants$1.Render3D.WebGL));
            });

         } else {
            // activate worker
            if (this.ctrl.use_worker > 0)
               this.startWorker();

            assign3DHandler(this);

            let size = this.getSizeFor3d(undefined, getRender3DKind(this.options.Render3D));

            this._fit_main_area = (size.can3d === -1);

            promise = this.createScene(size.width, size.height)
                          .then(dom => this.add3dCanvas(size, dom, this._webgl));
         }
      }

      return promise.then(() => {

         // this is limit for the visible faces, number of volumes does not matter
         if (this._first_drawing)
            this.ctrl.maxlimit = (this._webgl ? 200000 : 100000) * this.ctrl.more;

         // set top painter only when first child exists
         this.setAsMainPainter();

         this.createToolbar();

         // just draw extras and complete drawing if there are no main model
         if (!this._clones)
            return this.completeDraw();

         return new Promise(resolveFunc => {
            this._resolveFunc = resolveFunc;
            this.showDrawInfo('Drawing geometry');
            this.startDrawGeometry(true);
         });
      });
   }

   /** @summary methods show info when first geometry drawing is performed */
   showDrawInfo(msg) {
      if (isBatchMode() || !this._first_drawing || !this._start_drawing_time) return;

      let main = this._renderer.domElement.parentNode,
          info = main.querySelector('.geo_info');

      if (!msg) {
         info.remove();
      } else {
         let spent = (new Date().getTime() - this._start_drawing_time)*1e-3;
         if (!info) {
            info = document.createElement('p');
            info.setAttribute('class', 'geo_info');
            info.setAttribute('style', 'position: absolute; text-align: center; vertical-align: middle; top: 45%; left: 40%; color: red; font-size: 150%;');
            main.append(info);
         }
         info.innerHTML = `${msg}, ${spent.toFixed(1)}s`;
      }
   }

   /** @summary Reentrant method to perform geometry drawing step by step */
   continueDraw() {

      // nothing to do - exit
      if (this.isStage(stageInit)) return;

      let tm0 = new Date().getTime(),
          interval = this._first_drawing ? 1000 : 200,
          now = tm0;

      while(true) {

         let res = this.nextDrawAction();
         if (!res) break;

         now = new Date().getTime();

         // stop creation after 100 sec, render as is
         if (now - this._startm > 1e5) {
            this.changeStage(stageInit, 'Abort build after 100s');
            break;
         }

         // if we are that fast, do next action
         if ((res === true) && (now - tm0 < interval)) continue;

         if ((now - tm0 > interval) || (res === 1) || (res === 2)) {

            showProgress(this.drawing_log);

            this.showDrawInfo(this.drawing_log);

            if (this._first_drawing && this._webgl && (this._num_meshes - this._last_render_meshes > 100) && (now - this._last_render_tm > 2.5*interval)) {
               this.adjustCameraPosition();
               this.render3D(-1);
               this._last_render_meshes = this.ctrl.info.num_meshes;
            }
            if (res !== 2) setTimeout(() => this.continueDraw(), (res === 1) ? 100 : 1);

            return;
         }
      }

      let take_time = now - this._startm;

      if (this._first_drawing || this._full_redrawing)
         console.log(`Create tm = ${take_time} meshes ${this.ctrl.info.num_meshes} faces ${this.ctrl.info.num_faces}`);

      if (take_time > 300) {
         showProgress('Rendering geometry');
         this.showDrawInfo('Rendering');
         return setTimeout(() => this.completeDraw(true), 10);
      }

      this.completeDraw(true);
   }

   /** @summary Checks camera position and recalculate rendering order if needed
     * @param force - if specified, forces calculations of render order */
   testCameraPosition(force) {
      this._camera.updateMatrixWorld();
      let origin = this._camera.position.clone();

      if (!force && this._last_camera_position) {
         // if camera position does not changed a lot, ignore such change
         let dist = this._last_camera_position.distanceTo(origin);
         if (dist < (this._overall_size || 1000)*1e-4) return;
      }

      this._last_camera_position = origin; // remember current camera position

      if (!this.ctrl.project)
         produceRenderOrder(this._toplevel, origin, this.ctrl.depthMethod, this._clones);
   }

   /** @summary Call 3D rendering of the geometry
     * @param tmout - specifies delay, after which actual rendering will be invoked
     * @param [measure] - when true, for the first time printout rendering time
     * @return {Promise} when tmout bigger than 0 is specified
     * @desc Timeout used to avoid multiple rendering of the picture when several 3D drawings
     * superimposed with each other. If tmeout <= 0, rendering performed immediately
     * Several special values are used:
     *   -1    - force recheck of rendering order based on camera position */
   render3D(tmout, measure) {

      if (!this._renderer) {
         if (!this.did_cleanup)
            console.warn('renderer object not exists - check code');
         else
            console.warn('try to render after cleanup');
         return this;
      }

      let ret_promise = (tmout !== undefined) && (tmout > 0);

      if (tmout === undefined) tmout = 5; // by default, rendering happens with timeout

      if ((tmout > 0) && this._webgl /* && !isBatchMode() */) {
         if (isBatchMode()) tmout = 1; // use minimal timeout in batch mode
         if (ret_promise)
            return new Promise(resolveFunc => {
               if (!this._render_resolveFuncs) this._render_resolveFuncs = [];
               this._render_resolveFuncs.push(resolveFunc);
               if (!this.render_tmout)
                  this.render_tmout = setTimeout(() => this.render3D(0, measure), tmout);
            });

         if (!this.render_tmout)
            this.render_tmout = setTimeout(() => this.render3D(0, measure), tmout);
         return this;
      }

      if (this.render_tmout) {
         clearTimeout(this.render_tmout);
         delete this.render_tmout;
      }

      beforeRender3D(this._renderer);

      let tm1 = new Date();

      this.testCameraPosition(tmout === -1);

      // its needed for outlinePass - do rendering, most consuming time
      if (this._webgl && this._effectComposer && (this._effectComposer.passes.length > 0)) {
         this._effectComposer.render();
      } else if (this._webgl && this._bloomComposer && (this._bloomComposer.passes.length > 0)) {
         this._renderer.clear();
         this._camera.layers.set( _BLOOM_SCENE );
         this._bloomComposer.render();
         this._renderer.clearDepth();
         this._camera.layers.set( _ENTIRE_SCENE );
         this._renderer.render(this._scene, this._camera);
      } else {
    //     this._renderer.logarithmicDepthBuffer = true;
         this._renderer.render(this._scene, this._camera);
      }

      let tm2 = new Date();

      this.last_render_tm = tm2.getTime();

      if ((this.first_render_tm === 0) && measure) {
         this.first_render_tm = tm2.getTime() - tm1.getTime();
         console.log(`three.js r${REVISION}, first render tm = ${this.first_render_tm}`);
      }

      afterRender3D(this._renderer);

      if (this._render_resolveFuncs) {
         this._render_resolveFuncs.forEach(func => func(this));
         delete this._render_resolveFuncs;
      }
   }

   /** @summary Start geo worker */
   startWorker() {

      if (this._worker) return;

      this._worker_ready = false;
      this._worker_jobs = 0; // counter how many requests send to worker

      // TODO: modules not yet working, see https://www.codedread.com/blog/archives/2017/10/19/web-workers-can-be-es6-modules-too/
      this._worker = new Worker(exports.source_dir + 'scripts/geoworker.js' /*, { type: 'module' } */);

      this._worker.onmessage = e => {

         if (!isObject(e.data)) return;

         if ('log' in e.data)
            return console.log(`geo: ${e.data.log}`);

         if ('progress' in e.data)
            return showProgress(e.data.progress);

         e.data.tm3 = new Date().getTime();

         if ('init' in e.data) {
            this._worker_ready = true;
            console.log(`Worker ready: ${e.data.tm3 - e.data.tm0}`);
         } else {
            this.processWorkerReply(e.data);
         }
      };

      // send initialization message with clones
      this._worker.postMessage({
         init: true,   // indicate init command for worker
         browser: browser$1,
         tm0: new Date().getTime(),
         vislevel: this._clones.getVisLevel(),
         maxvisnodes: this._clones.getMaxVisNodes(),
         clones: this._clones.nodes,
         sortmap: this._clones.sortmap
      });
   }

   /** @summary check if one can submit request to worker
     * @private */
   canSubmitToWorker(force) {
      if (!this._worker) return false;

      return this._worker_ready && ((this._worker_jobs == 0) || force);
   }

   /** @summary submit request to worker
     * @private */
   submitToWorker(job) {
      if (!this._worker) return false;

      this._worker_jobs++;
      job.tm0 = new Date().getTime();
      this._worker.postMessage(job);
   }

   /** @summary process reply from worker
     * @private */
   processWorkerReply(job) {
      this._worker_jobs--;

      if ('collect' in job) {
         this._new_draw_nodes = job.new_nodes;
         this._draw_all_nodes = job.complete;
         this.changeStage(stageAnalyze);
         // invoke methods immediately
         return this.continueDraw();
      }

      if ('shapes' in job) {

         for (let n=0;n<job.shapes.length;++n) {
            let item = job.shapes[n],
                origin = this._build_shapes[n];

            // let shape = this._clones.getNodeShape(item.nodeid);

            if (item.buf_pos && item.buf_norm) {
               if (item.buf_pos.length === 0) {
                  origin.geom = null;
               } else if (item.buf_pos.length !== item.buf_norm.length) {
                  console.error(`item.buf_pos.length ${item.buf_pos.length} != item.buf_norm.length ${item.buf_norm.length}`);
                  origin.geom = null;
               } else {
                  origin.geom = new BufferGeometry();

                  origin.geom.setAttribute('position', new BufferAttribute(item.buf_pos, 3));
                  origin.geom.setAttribute('normal', new BufferAttribute(item.buf_norm, 3));
               }

               origin.ready = true;
               origin.nfaces = item.nfaces;
            }
         }

         job.tm4 = new Date().getTime();

         this.changeStage(stageBuild); // first check which shapes are used, than build meshes

         // invoke methods immediately
         return this.continueDraw();
      }
   }

   /** @summary start draw geometries on master and all slaves
     * @private */
   testGeomChanges() {
      if (this._main_painter) {
         console.warn('Get testGeomChanges call for slave painter');
         return this._main_painter.testGeomChanges();
      }
      this.startDrawGeometry();
      for (let k = 0; k < this._slave_painters.length; ++k)
         this._slave_painters[k].startDrawGeometry();
   }

   /** @summary Draw axes if configured, otherwise just remove completely
     * @return {Promise} when norender not specified */
   drawSimpleAxis(norender) {
      this.getExtrasContainer('delete', 'axis');

      if (!this.ctrl._axis)
         return norender ? null : this.render3D();

      let box = this.getGeomBoundingBox(this._toplevel),
          container = this.getExtrasContainer('create', 'axis'),
          text_size = 0.02 * Math.max((box.max.x - box.min.x), (box.max.y - box.min.y), (box.max.z - box.min.z)),
          center = [0,0,0],
          names = ['x','y','z'],
          labels = ['X','Y','Z'],
          colors = ['red','green','blue'],
          ortho = this.ctrl.ortho_camera,
          yup = [this.ctrl._yup, this.ctrl._yup, this.ctrl._yup],
          numaxis = 3;

      if (this.ctrl._axis == 2)
         for (let naxis = 0; naxis < 3; ++naxis) {
            let name = names[naxis];
            if ((box.min[name] <= 0) && (box.max[name] >= 0)) continue;
            center[naxis] = (box.min[name] + box.max[name])/2;
         }

      // only two dimensions are seen by ortho camera, X draws Z, can be configured better later
      if (this.ctrl.ortho_camera) {
         numaxis = 2;
         labels[0] = labels[2];
         colors[0] = colors[2];
         yup[0] = yup[2];
         ortho = true;
      }

      for (let naxis = 0; naxis < numaxis; ++naxis) {

         let buf = new Float32Array(6),
             color = colors[naxis],
             name = names[naxis];

         const Convert = value => {
            let range = box.max[name] - box.min[name];
            if (range < 2) return value.toFixed(3);
            return (Math.abs(value) > 1e5) ? value.toExponential(3) : Math.round(value).toString();
         };

         let lbl = Convert(box.max[name]);

         buf[0] = box.min.x;
         buf[1] = box.min.y;
         buf[2] = box.min.z;

         buf[3] = box.min.x;
         buf[4] = box.min.y;
         buf[5] = box.min.z;

         switch (naxis) {
           case 0: buf[3] = box.max.x; if (yup[0] && !ortho) lbl = labels[0] + ' ' + lbl; else lbl += ' ' + labels[0]; break;
           case 1: buf[4] = box.max.y; if (yup[1]) lbl += ' ' + labels[1]; else lbl = labels[1] + ' ' + lbl; break;
           case 2: buf[5] = box.max.z; lbl += ' ' + labels[2]; break;
         }

         if (this.ctrl._axis == 2)
            for (let k = 0; k < 6; ++k)
               if ((k % 3) !== naxis) buf[k] = center[k%3];

         let lineMaterial = new LineBasicMaterial({ color }),
             mesh = createLineSegments(buf, lineMaterial);

         mesh._axis_draw = true; // skip from clipping

         container.add(mesh);

         let textMaterial = new MeshBasicMaterial({ color, vertexColors: false });

         if ((center[naxis] === 0) && (center[naxis] >= box.min[name]) && (center[naxis] <= box.max[name]))
           if ((this.ctrl._axis != 2) || (naxis === 0)) {
               let geom = ortho ? new CircleGeometry(text_size*0.25) :
                                  new SphereGeometry(text_size*0.25);
               mesh = new Mesh(geom, textMaterial);
               mesh.translateX(naxis === 0 ? center[0] : buf[0]);
               mesh.translateY(naxis === 1 ? center[1] : buf[1]);
               mesh.translateZ(naxis === 2 ? center[2] : buf[2]);
               container.add(mesh);
           }

         let text3d = new TextGeometry(lbl, { font: HelveticerRegularFont, size: text_size, height: 0, curveSegments: 5 });
         mesh = new Mesh(text3d, textMaterial);
         mesh._axis_draw = true; // skip from clipping
         let textbox = new Box3().setFromObject(mesh);

         mesh.translateX(buf[3]);
         mesh.translateY(buf[4]);
         mesh.translateZ(buf[5]);

         if (yup[naxis]) {
            switch (naxis) {
               case 0:
                  if (!ortho) {
                     mesh.rotateY(Math.PI);
                     mesh.translateX(-textbox.max.x-text_size*0.5);
                  } else {
                     mesh.translateX(text_size*0.5);
                  }
                  mesh.translateY(-textbox.max.y/2);
                  break;
               case 1:
                  if (!ortho) {
                     mesh.rotateX(-Math.PI/2);
                     mesh.rotateY(-Math.PI/2);
                  } else {
                     mesh.rotateZ(Math.PI/2);
                  }
                  mesh.translateX(text_size*0.5);
                  mesh.translateY(-textbox.max.y/2);
                  break;
               case 2: mesh.rotateY(-Math.PI/2); mesh.translateX(text_size*0.5); mesh.translateY(-textbox.max.y/2); break;
           }
         } else {
            switch (naxis) {
               case 0: mesh.rotateX(Math.PI/2); mesh.translateY(-textbox.max.y/2); mesh.translateX(text_size*0.5); break;
               case 1: mesh.rotateX(Math.PI/2); mesh.rotateY(-Math.PI/2); mesh.translateX(-textbox.max.x-text_size*0.5); mesh.translateY(-textbox.max.y/2); break;
               case 2: mesh.rotateX(Math.PI/2); mesh.rotateZ(Math.PI/2); mesh.translateX(text_size*0.5); mesh.translateY(-textbox.max.y/2); break;
            }
         }

         container.add(mesh);

         text3d = new TextGeometry(Convert(box.min[name]), { font: HelveticerRegularFont, size: text_size, height: 0, curveSegments: 5 });

         mesh = new Mesh(text3d, textMaterial);
         mesh._axis_draw = true; // skip from clipping
         textbox = new Box3().setFromObject(mesh);

         mesh.translateX(buf[0]);
         mesh.translateY(buf[1]);
         mesh.translateZ(buf[2]);

         if (yup[naxis]) {
            switch (naxis) {
               case 0:
                  if (!ortho) {
                     mesh.rotateY(Math.PI);
                     mesh.translateX(text_size*0.5);
                  } else {
                     mesh.translateX(-textbox.max.x-text_size*0.5);
                  }
                  mesh.translateY(-textbox.max.y/2);
                  break;
               case 1:
                  if (!ortho) {
                     mesh.rotateX(-Math.PI/2);
                     mesh.rotateY(-Math.PI/2);
                  } else {
                     mesh.rotateZ(Math.PI/2);
                  }
                  mesh.translateY(-textbox.max.y/2);
                  mesh.translateX(-textbox.max.x-text_size*0.5);
                  break;
               case 2: mesh.rotateY(-Math.PI/2);  mesh.translateX(-textbox.max.x-text_size*0.5); mesh.translateY(-textbox.max.y/2); break;
            }
         } else {
            switch (naxis) {
               case 0: mesh.rotateX(Math.PI/2); mesh.translateX(-textbox.max.x-text_size*0.5); mesh.translateY(-textbox.max.y/2); break;
               case 1: mesh.rotateX(Math.PI/2); mesh.rotateY(-Math.PI/2); mesh.translateY(-textbox.max.y/2); mesh.translateX(text_size*0.5); break;
               case 2: mesh.rotateX(Math.PI/2); mesh.rotateZ(Math.PI/2);  mesh.translateX(-textbox.max.x-text_size*0.5); mesh.translateY(-textbox.max.y/2); break;
            }
         }

         container.add(mesh);
      }

      // after creating axes trigger rendering and recalculation of depth
      return this.changedDepthMethod(norender ? 'norender' : undefined);
   }

   /** @summary Set axes visibility 0 - off, 1 - on, 2 - centered */
   setAxesDraw(on) {
      if (on === 'toggle')
         this.ctrl._axis = this.ctrl._axis ? 0 : 1;
      else
         this.ctrl._axis = (typeof on == 'number') ? on : (on ? 1 : 0);
      return this.drawSimpleAxis();
   }

   /** @summary Set auto rotate mode */
   setAutoRotate(on) {
      if (this.ctrl.project) return;
      if (on !== undefined) this.ctrl.rotate = on;
      this.autorotate(2.5);
   }

   /** @summary Toggle wireframe mode */
   toggleWireFrame() {
      this.ctrl.wireframe = !this.ctrl.wireframe;
      this.changedWireFrame();
   }

   /** @summary Specify wireframe mode */
   setWireFrame(on) {
      this.ctrl.wireframe = on ? true : false;
      this.changedWireFrame();
   }

   /** @summary Specify showtop draw options, relevant only for TGeoManager */
   setShowTop(on) {
      this.ctrl.showtop = on ? true : false;
      this.redrawObject('same');
   }

   /** @summary Should be called when configuration of particular axis is changed */
   changedClipping(naxis) {
      let clip = this.ctrl.clip;

      if ((naxis !== undefined) && (naxis >= 0)) {
         if (!clip[naxis].enabled) return;
      }

      if (clip[0].enabled || clip[1].enabled || clip[2].enabled) {
         this.ctrl.ssao.enabled = false;
         this.removeSSAO();
      }

      this.updateClipping(false, true);
   }

   /** @summary Should be called when depth test flag is changed */
   changedDepthTest() {
      if (!this._toplevel) return;
      let flag = this.ctrl.depthTest;
      this._toplevel.traverse(node => {
         if (node instanceof Mesh) {
            node.material.depthTest = flag;
         }
      });

      this.render3D(0);
   }

   /** @summary Should be called when depth method is changed */
   changedDepthMethod(arg) {
      // force recalculatiion of render order
      delete this._last_camera_position;
      if (arg !== 'norender')
         return this.render3D();
   }

   /** @summary Should be called when configuration of highlight is changed */
   changedHighlight() {
      if (!this.ctrl.highlight)
         this.highlightMesh(null);
   }

   /** @summary Assign clipping attributes to the meshes - supported only for webgl */
   updateClipping(without_render, force_traverse) {
      // do not try clipping with SVG renderer
      if (this._renderer?.jsroot_render3d === constants$1.Render3D.SVG) return;

      if (!this._clipPlanes)
         this._clipPlanes = [ new Plane(new Vector3(1, 0, 0), 0),
                              new Plane(new Vector3(0, this.ctrl._yup ? -1 : 1, 0), 0),
                              new Plane(new Vector3(0, 0, this.ctrl._yup ? 1 : -1), 0) ];

      let clip = this.ctrl.clip, panels = [], changed = false,
          clip_constants = [ -1 * clip[0].value, clip[1].value, (this.ctrl._yup ? -1 : 1) * clip[2].value ],
          clip_cfg = this.ctrl.clipIntersect ? 16 : 0;

      for (let k = 0; k < 3; ++k) {
         if (clip[k].enabled)
            clip_cfg += 2 << k;
         if (this._clipPlanes[k].constant !== clip_constants[k]) {
            if (clip[k].enabled) changed = true;
            this._clipPlanes[k].constant = clip_constants[k];
         }
      }

      if (!this.ctrl.ssao.enabled) {
         if (clip[0].enabled) panels.push(this._clipPlanes[0]);
         if (clip[1].enabled) panels.push(this._clipPlanes[1]);
         if (clip[2].enabled) panels.push(this._clipPlanes[2]);
         clip_cfg += panels.length*1000;
      }
      if (panels.length == 0) panels = null;

      if (this._clipCfg !== clip_cfg) changed = true;

      this._clipCfg = clip_cfg;

      let any_clipping = !!panels, ci = this.ctrl.clipIntersect,
          material_side = any_clipping ? DoubleSide : FrontSide;

      if (force_traverse || changed)
         this._scene.traverse(node => {
            if (!node._axis_draw && node.hasOwnProperty('material') && (node.material?.clippingPlanes !== undefined)) {

               if (node.material.clippingPlanes !== panels) {
                  node.material.clipIntersection = ci;
                  node.material.clippingPlanes = panels;
                  node.material.needsUpdate = true;
               }

               if (node.material.emissive !== undefined) {
                  if (node.material.side != material_side) {
                     node.material.side = material_side;
                     node.material.needsUpdate = true;
                  }
               }
            }
         });

      this.ctrl.bothSides = any_clipping;

      if (!without_render) this.render3D(0);

      return changed;
   }

   /** @summary Assign callback, invoked every time when drawing is completed
     * @desc Used together with web-based geometry viewer
     * @private */
   setCompleteHandler(callback) {
      this._complete_handler = callback;
   }

   /** @summary Completes drawing procedure
     * @return {Promise} for ready */
   async completeDraw(close_progress) {

      let first_time = false, full_redraw = false, check_extras = true;

      if (!this.ctrl) {
         console.warn('ctrl object does not exist in completeDraw - something went wrong');
         return this;
      }

      let promise = Promise.resolve(true);

      if (!this._clones) {
         check_extras = false;
         // if extra object where append, redraw them at the end
         this.getExtrasContainer('delete'); // delete old container
         let extras = (this._main_painter ? this._main_painter._extraObjects : null) || this._extraObjects;
         promise = this.drawExtras(extras, '', false);
      } else if (this._first_drawing || this._full_redrawing) {
         if (this.ctrl.tracks && this.geo_manager)
            promise = this.drawExtras(this.geo_manager.fTracks, '<prnt>/Tracks');
      }

      return promise.then(() => {

         if (this._full_redrawing) {
            this.adjustCameraPosition(true);
            this._full_redrawing = false;
            full_redraw = true;
            this.changedDepthMethod('norender');
         }

         if (this._first_drawing) {
            this.adjustCameraPosition(true);
            this.showDrawInfo();
            this._first_drawing = false;
            first_time = true;
            full_redraw = true;
         }

         if (this.ctrl.transparency !== 0)
            this.changedGlobalTransparency(this.ctrl.transparency, true);

         if (first_time)
            this.completeScene();

         if (full_redraw && (this.ctrl.trans_radial || this.ctrl.trans_z))
            this.changedTransformation('norender');

         if (full_redraw && this.ctrl._axis)
            this.drawSimpleAxis(true);

         this._scene.overrideMaterial = null;

         if (this._provided_more_nodes !== undefined) {
            this.appendMoreNodes(this._provided_more_nodes, true);
            delete this._provided_more_nodes;
         }

         if (check_extras) {
            // if extra object where append, redraw them at the end
            this.getExtrasContainer('delete'); // delete old container
            let extras = (this._main_painter ? this._main_painter._extraObjects : null) || this._extraObjects;
            return this.drawExtras(extras, '', false);
         }
      }).then(() => {

         this.updateClipping(true); // do not render

         this.render3D(0, true);

         if (close_progress) showProgress();

         this.addOrbitControls();

         this.addTransformControl();

         if (first_time) {

            // after first draw check if highlight can be enabled
            if (this.ctrl.highlight === false)
               this.ctrl.highlight = (this.first_render_tm < 1000);

            // also highlight of scene object can be assigned at the first draw
            if (this.ctrl.highlight_scene === false)
               this.ctrl.highlight_scene = this.ctrl.highlight;

            // if rotation was enabled, do it
            if (this._webgl && this.ctrl.rotate && !this.ctrl.project) this.autorotate(2.5);
            if (this._webgl && this.ctrl.show_controls && !isBatchMode()) this.showControlOptions(true);
         }

         this.setAsMainPainter();

         if (isFunc(this._resolveFunc)) {
            this._resolveFunc(this);
            delete this._resolveFunc;
         }

         if (isFunc(this._complete_handler))
            this._complete_handler(this);

         if (this._draw_nodes_again)
            this.startDrawGeometry(); // relaunch drawing
         else
            this._drawing_ready = true; // indicate that drawing is completed

         return this;
      });
   }

   /** @summary Returns true if geometry drawing is completed */
   isDrawingReady() {
      return this._drawing_ready || false;
   }

   /** @summary Remove already drawn node. Used by geom viewer */
   removeDrawnNode(nodeid) {
      if (!this._draw_nodes) return;

      let new_nodes = [];

      for (let n = 0; n < this._draw_nodes.length; ++n) {
         let entry = this._draw_nodes[n];
         if ((entry.nodeid === nodeid) || this._clones.isIdInStack(nodeid, entry.stack)) {
            this._clones.createObject3D(entry.stack, this._toplevel, 'delete_mesh');
         } else {
            new_nodes.push(entry);
         }
      }

      if (new_nodes.length < this._draw_nodes.length) {
         this._draw_nodes = new_nodes;
         this.render3D();
      }
   }

   /** @summary Cleanup geometry painter */
   cleanup(first_time) {

      if (!first_time) {

         this.removeSSAO();

         this.clearTopPainter(); // remove as pointer

         let can3d = 0;
         if (this._on_pad) {
            let fp = this.getFramePainter();
            if (fp?.mode3d) {
               fp.clear3dCanvas();
               fp.mode3d = false;
            }
         } else {
            can3d = this.clear3dCanvas(); // remove 3d canvas from main HTML element
         }

         if (this._toolbar) this._toolbar.cleanup(); // remove toolbar

         this.helpText();

         disposeThreejsObject(this._scene);

         disposeThreejsObject(this._full_geom);

         if (this._tcontrols)
            this._tcontrols.dispose();

         if (this._controls)
            this._controls.cleanup();

         if (this._context_menu)
            this._renderer.domElement.removeEventListener( 'contextmenu', this._context_menu, false );

         if (this._datgui)
            this._datgui.destroy();

         if (this._worker) this._worker.terminate();

         delete this._animating;

         let obj = this.getGeometry();
         if (obj && this.ctrl.is_main) {
            if (obj.$geo_painter===this) delete obj.$geo_painter; else
            if (obj.fVolume && obj.fVolume.$geo_painter===this) delete obj.fVolume.$geo_painter;
         }

         if (this._main_painter) {
            let pos = this._main_painter._slave_painters.indexOf(this);
            if (pos >= 0) this._main_painter._slave_painters.splice(pos,1);
         }

         for (let k = 0; k < this._slave_painters.length;++k) {
            let slave = this._slave_painters[k];
            if (slave && (slave._main_painter===this)) slave._main_painter = null;
         }

         delete this.geo_manager;
         delete this._highlight_handlers;

         super.cleanup();

         delete this.ctrl;
         delete this.options;

         this.did_cleanup = true;

         if (can3d < 0) this.selectDom().html('');
      }

      if (this._slave_painters)
         for (let k in this._slave_painters) {
            let slave = this._slave_painters[k];
            slave._main_painter = null;
            if (slave._clones === this._clones) slave._clones = null;
         }

      this._main_painter = null;
      this._slave_painters = [];

      if (this._render_resolveFuncs) {
         this._render_resolveFuncs.forEach(func => func(this));
         delete this._render_resolveFuncs;
      }

      cleanupRender3D(this._renderer);

      delete this._scene;
      this._scene_width = 0;
      this._scene_height = 0;
      this._renderer = null;
      this._toplevel = null;
      delete this._full_geom;
      delete this._camera;
      delete this._camera0pos;
      delete this._lookat;
      delete this._selected_mesh;

      if (this._clones && this._clones_owner)
         this._clones.cleanup(this._draw_nodes, this._build_shapes);
      delete this._clones;
      delete this._clones_owner;
      delete this._draw_nodes;
      delete this._drawing_ready;
      delete this._build_shapes;
      delete this._new_draw_nodes;
      delete this._new_append_nodes;
      delete this._last_camera_position;

      this.first_render_tm = 0; // time needed for first rendering
      this.last_render_tm = 0;

      this.changeStage(stageInit, 'cleanup');
      delete this.drawing_log;

      delete this._datgui;
      delete this._controls;
      delete this._context_menu;
      delete this._tcontrols;
      delete this._toolbar;

      delete this._worker;
   }

   /** @summary show message in progress area
     * @private */
   helpText(msg) {
      showProgress(msg);
   }

   /** @summary perform resize */
   performResize(width, height) {
      if ((this._scene_width === width) && (this._scene_height === height)) return false;
      if ((width < 10) || (height < 10)) return false;

      this._scene_width = width;
      this._scene_height = height;

      if (this._camera && this._renderer) {
         if (this._camera.type == 'PerspectiveCamera')
            this._camera.aspect = this._scene_width / this._scene_height;
         this._camera.updateProjectionMatrix();
         this._renderer.setSize( this._scene_width, this._scene_height, !this._fit_main_area );
         if (this._effectComposer)
            this._effectComposer.setSize( this._scene_width, this._scene_height );
         if (this._bloomComposer)
            this._bloomComposer.setSize( this._scene_width, this._scene_height );

         if (this.isStage(stageInit))
            this.render3D();
      }

      return true;
   }

   /** @summary Check if HTML element was resized and drawing need to be adjusted */
   checkResize(arg) {
      let cp = this.getCanvPainter();

      // firefox is the only browser which correctly supports resize of embedded canvas,
      // for others we should force canvas redrawing at every step
      if (cp && !cp.checkCanvasResize(arg)) return false;

      let sz = this.getSizeFor3d();

      return this.performResize(sz.width, sz.height);
   }

   /** @summary Toggle enlarge state */
   toggleEnlarge() {
      if (this.enlargeMain('toggle'))
        this.checkResize();
   }

   /** @summary check if element belongs to trnasform control
     * @private */
   ownedByTransformControls(child) {
      let obj = child.parent;
      while (obj && !(obj instanceof TransformControls) )
         obj = obj.parent;
      return obj && (obj instanceof TransformControls);
   }

   /** @summary either change mesh wireframe or return current value
     * @return undefined when wireframe cannot be accessed
     * @private */
   accessObjectWireFrame(obj, on) {
      if (!obj.hasOwnProperty('material') || (obj instanceof GridHelper)) return;

      if (this.ownedByTransformControls(obj)) return;

      if ((on !== undefined) && obj.stack)
         obj.material.wireframe = on;

      return obj.material.wireframe;
   }

   /** @summary handle wireframe flag change in GUI
     * @private */
   changedWireFrame() {
      if (!this._scene) return;

      let on = this.ctrl.wireframe;

      this._scene.traverse(obj => this.accessObjectWireFrame(obj, on));

      this.render3D();
   }

   /** @summary Update object in geo painter */
   updateObject(obj) {
      if ((obj === 'same') || !obj?._typename)
         return false;
      if (obj === this.getObject())
         return true;

      let gm;
      if (obj._typename === clTGeoManager) {
         gm = obj;
         obj = obj.fMasterVolume;
      }

      if (obj._typename.indexOf(clTGeoVolume) === 0)
         obj = { _typename: clTGeoNode, fVolume: obj, fName: obj.fName, $geoh: obj.$geoh, _proxy: true };

      if (this.geo_manager && gm) {
         this.geo_manager = gm;
         this.assignObject(obj);
         this._did_update = true;
         return true;
      }

      if (!this.matchObjectType(obj._typename))
         return false;

      this.assignObject(obj);
      this._did_update = true;
      return true;
   }

   /** @summary Cleanup TGeo drawings */
   clearDrawings() {
      if (this._clones && this._clones_owner)
         this._clones.cleanup(this._draw_nodes, this._build_shapes);
      delete this._clones;
      delete this._clones_owner;
      delete this._draw_nodes;
      delete this._drawing_ready;
      delete this._build_shapes;

      delete this._extraObjects;
      delete this._clipCfg;

      // only remove all childs from top level object
      disposeThreejsObject(this._toplevel, true);

      this._full_redrawing = true;
   }

    /** @summary Redraw TGeo object inside TPad */
   redraw() {
      if (this._did_update)
         return this.startRedraw();

      let main = this._on_pad ? this.getFramePainter() : null;
      if (!main)
         return Promise.resolve(false);
      let sz = main.getSizeFor3d(main.access3dKind());
      main.apply3dSize(sz);
      return this.performResize(sz.width, sz.height);
   }

   /** @summary Redraw TGeo object */
   redrawObject(obj, opt) {
      if (!this.updateObject(obj, opt))
         return false;

      return this.startRedraw();
   }

   /** @summary Start geometry redraw */
   startRedraw() {
      delete this._did_update;

      this.clearDrawings();
      let draw_obj = this.getGeometry(), name_prefix = '';
      if (this.geo_manager) name_prefix = draw_obj.fName;
      return this.prepareObjectDraw(draw_obj, name_prefix);
   }

  /** @summary draw TGeo object */
   static async draw(dom, obj, opt) {
      if (!obj) return null;

      let shape = null, extras = null, extras_path = '', is_eve = false;

      if (('fShapeBits' in obj) && ('fShapeId' in obj)) {
         shape = obj; obj = null;
      } else if ((obj._typename === clTGeoVolumeAssembly) || (obj._typename === clTGeoVolume)) {
         shape = obj.fShape;
      } else if ((obj._typename === clTEveGeoShapeExtract) || (obj._typename === clREveGeoShapeExtract)) {
         shape = obj.fShape; is_eve = true;
      } else if (obj._typename === clTGeoManager) {
         shape = obj.fMasterVolume.fShape;
      } else if (obj._typename === clTGeoOverlap) {
         extras = obj.fMarker; extras_path = '<prnt>/Marker';
         obj = buildOverlapVolume(obj);
         if (!opt) opt = 'wire';
      } else if ('fVolume' in obj) {
         if (obj.fVolume) shape = obj.fVolume.fShape;
      } else {
         obj = null;
      }

      if (isStr(opt) && opt.indexOf('comp') == 0 && shape && (shape._typename == clTGeoCompositeShape) && shape.fNode) {
         let maxlvl = 1;
         opt = opt.slice(4);
         if (opt[0] == 'x') {  maxlvl = 999; opt = opt.slice(1) + '_vislvl999'; }
         obj = buildCompositeVolume(shape, maxlvl);
      }

      if (!obj && shape)
         obj = Object.assign(create$1(clTNamed),
                   { _typename: clTEveGeoShapeExtract, fTrans: null, fShape: shape, fRGBA: [0, 1, 0, 1], fElements: null, fRnrSelf: true });

      if (!obj) return null;

      let painter = createGeoPainter(dom, obj, opt);

      if (painter.ctrl.is_main && !obj.$geo_painter)
         obj.$geo_painter = painter;

      if (!painter.ctrl.is_main && painter.ctrl.project && obj.$geo_painter) {
         painter._main_painter = obj.$geo_painter;
         painter._main_painter._slave_painters.push(painter);
      }

      if (is_eve && !painter.ctrl.vislevel || (painter.ctrl.vislevel < 9))
         painter.ctrl.vislevel = 9;

      if (extras) {
         painter._splitColors = true;
         painter.addExtra(extras, extras_path);
      }

      return painter.loadMacro(painter.ctrl.script_name).then(arg => painter.prepareObjectDraw(arg.obj, arg.prefix));
   }

} // class TGeoPainter


let add_settings = false;

/** @summary Create geo-related css entries
  * @private */
function injectGeoStyle() {

   if (!add_settings && isFunc(internals.addDrawFunc)) {
      add_settings = true;
      // indication that draw and hierarchy is loaded, create css
      internals.addDrawFunc({ name: clTEvePointSet, icon_get: getBrowserIcon, icon_click: browserIconClick });
      internals.addDrawFunc({ name: clTEveTrack, icon_get: getBrowserIcon, icon_click: browserIconClick });
   }

   function img(name,code) {
      return `.jsroot .img_${name} { display: inline-block; height: 16px; width: 16px; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQ${code}'); }`;
   }

   injectStyle(`
${img('geoarb8','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAAB1SURBVBjTdY6rEYAwEETTy6lzK8/Fo+Jj18dTAjUgaQGfGiggtRDE8RtY93Zu514If2nzk2ux9c5TZkwXbiWTUavzws69oBfpYBrMT4r0Jhsw+QfRgQSw+CaKRsKsnV+SaF8MN49RBSgPUxO85PMl5n4tfGUH2gghs2uPAeQAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMTItMDJUMTQ6MjY6MjkrMDE6MDDARtd2AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE0LTExLTEyVDA4OjM5OjE5KzAxOjAwO3ydwwAAAABJRU5ErkJggg==')}
${img('geocombi','CAQAAAC1+jfqAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJiS0dEAP+Hj8y/AAAACXBIWXMAAABIAAAASABGyWs+AAAAlUlEQVQoz5VQMQ4CMQyzEUNnBqT7Bo+4nZUH8gj+welWJsQDkHoCEYakTXMHSFiq2jqu4xRAEl2A7w4myWzpzCSZRZ658ldKu1hPnFsequBIc/hcLli3l52MAIANtpWrDsv8waGTW6BPuFtsdZArXyFuj33TQpazGEQF38phipnLgItxRcAoOeNpzv4PTXnC42fb//AGI5YqfQAU8dkAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMTItMDJUMTQ6MjY6MjkrMDE6MDDARtd2AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE0LTExLTEyVDA4OjM5OjE5KzAxOjAwO3ydwwAAAABJRU5ErkJggg==')}
${img('geocone','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAACRSURBVBjTdY+xDcNACEVvEm/ggo6Olva37IB0C3iEzJABvAHFTXBDeJRwthMnUvylk44vPjxK+afeokX0flQhJO7L4pafSOMxzaxIKc/Tc7SIjNLyieyZSjBzc4DqMZI0HTMonWPBNlogOLeuewbg9c0hOiIqH7DKmTCuFykjHe4XOzQ58XVMGxzt575tKzd6AX9yMkcWyPlsAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTEyLTAyVDE0OjI2OjI5KzAxOjAwwEbXdgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNC0xMS0xMlQwODozOToxOSswMTowMDt8ncMAAAAASUVORK5CYII=')}
${img('geogtra','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAACCSURBVBjTVc+hDQMxDAVQD1FyqCQk0MwsCwQEG3+eCW6B0FvheDboFMGepTlVitPP/Cz5y0S/mNkw8pySU9INJDDH4vM4Usm5OrQXasXtkA+tQF+zxfcDY8EVwgNeiwmA37TEccK5oLOwQtuCj7BM2Fq7iGrxVqJbSsH+GzXs+798AThwKMh3/6jDAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTEyLTAyVDE0OjI2OjI5KzAxOjAwwEbXdgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNC0xMS0xMlQwODozOToxOSswMTowMDt8ncMAAAAASUVORK5CYII=')}
${img('geomedium','BAMAAADt3eJSAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAABVQTFRFAAAAAAAAMDAww8PDWKj/////gICAG0/C4AAAAAF0Uk5TAEDm2GYAAAABYktHRAX4b+nHAAAACXBIWXMAAABIAAAASABGyWs+AAAAXElEQVQI102MwRGAMAgEuQ6IDwvQCjQdhAl/H7ED038JHhkd3dcOLAgESFARaAqnEB3yrj6QSEym1RbbOKinN+8q2Esui1GaX7VXSi4RUbxHRbER8X6O5Pg/fLgBBzMN8HfXD3AAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMTItMDJUMTQ6MjY6MjkrMDE6MDDARtd2AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE0LTExLTEyVDA4OjM5OjE5KzAxOjAwO3ydwwAAAABJRU5ErkJggg==')}
${img('geopara','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAABtSURBVBjTY2DADq5MT7+CzD9kaKjp+QhJYIWqublhMbKAgpOnZxWSQJdsVJTndCSBKoWoAM/VSALpqlEBAYeQBKJAAsi2BGgCBZDdEWUYFZCOLFBlGOWJ7AyGFeaotjIccopageK3R12PGHABACTYHWd0tGw6AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTEyLTAyVDE0OjI2OjI5KzAxOjAwwEbXdgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNC0xMS0xMlQwODozOToxOSswMTowMDt8ncMAAAAASUVORK5CYII=')}
${img('georotation','CAQAAAC1+jfqAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJiS0dEAP+Hj8y/AAAACXBIWXMAAABIAAAASABGyWs+AAAAiklEQVQoz2NgYGBgYGDg+A/BmIAFIvyDEbs0AwMTAwHACLPiB5QVBTdpGSOSCZjScDcgc4z+32BgYGBgEGIQw3QDLkdCTZD8/xJFeBfDVxQT/j9n/MeIrMCNIRBJwX8GRuzGM/yHKMAljeILNFOuMTyEisEUMKIqucrwB2oyIhyQpH8y/MZrLWkAAHFzIHIc0Q5yAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTEyLTAyVDE0OjI2OjI5KzAxOjAwwEbXdgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNC0xMS0xMlQwODozOToxOSswMTowMDt8ncMAAAAASUVORK5CYII=')}
${img('geotranslation','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAABESURBVBjTY2DgYGAAYzjgAAIQgSLAgSwAAcrWUUCAJBAVhSpgBAQumALGCJPAAsriHIS0IAQ4UAU4cGphQBWwZSAOAADGJBKdZk/rHQAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNS0xMi0wMlQxNDoyNjoyOSswMTowMMBG13YAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTQtMTEtMTJUMDg6Mzk6MTkrMDE6MDA7fJ3DAAAAAElFTkSuQmCC')}
${img('geotrd2','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAABsSURBVBjTbY+xDcAwCARZx6UraiaAmpoRvIIb75PWI2QITxIiRQKk0CCO/xcA/NZ9LRs7RkJEYg3QxczUwoGsXiMAoe8lAelqRWFNKpiNXZLAalRDd0f3TMgeMckABKsCDmu+442RddeHz9cf9jUkW8smGn8AAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMTItMDJUMTQ6MjY6MjkrMDE6MDDARtd2AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE0LTExLTEyVDA4OjM5OjE5KzAxOjAwO3ydwwAAAABJRU5ErkJggg==')}
${img('geovolume','BAMAAADt3eJSAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAB5QTFRFAAAAMDAw///Ay8uc/7+Q/4BgmJh4gIDgAAD/////CZb2ugAAAAF0Uk5TAEDm2GYAAAABYktHRAnx2aXsAAAACXBIWXMAAABIAAAASABGyWs+AAAAR0lEQVQI12NggAEBIBAEQgYGQUYQAyIGIhgwAZMSGCgwMJuEKimFOhswsKWAGG4JDGxJIBk1EEO9o6NIDVkEpgauC24ODAAASQ8Pkj/retYAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMTItMDJUMTQ6MjY6MjkrMDE6MDDARtd2AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE0LTExLTEyVDA4OjM5OjE5KzAxOjAwO3ydwwAAAABJRU5ErkJggg==')}
${img('geoassembly','BAMAAADt3eJSAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAA9QTFRFAAAAMDAw/wAAAAD/////jEo0BQAAAAF0Uk5TAEDm2GYAAAABYktHRASPaNlRAAAACXBIWXMAAABIAAAASABGyWs+AAAAOklEQVQI12NggAFGRgEgEBRgEBSAMhgYGQQEgAR+oARGDIwCIAYjUL0A2DQQg9nY2ABVBKoGrgsDAADxzgNboMz8zQAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNS0xMi0wMlQxNDoyNjoyOSswMTowMMBG13YAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTQtMTEtMTJUMDg6Mzk6MTkrMDE6MDA7fJ3DAAAAAElFTkSuQmCC')}
${img('geocomposite','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAABuSURBVBjTY2AgF2hqgQCCr+0V4O7hFmgCF7CJyKysKkmxhfGNLaw9SppqAi2gfMuY5Agrl+ZaC6iAUXRJZX6Ic0klTMA5urapPFY5NRcmYKFqWl8S5RobBRNg0PbNT3a1dDGH8RlM3LysTRjIBwAG6xrzJt11BAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNS0xMi0wMlQxNDoyNjoyOSswMTowMMBG13YAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTQtMTEtMTJUMDg6Mzk6MTkrMDE6MDA7fJ3DAAAAAElFTkSuQmCC')}
${img('geoctub','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAACESURBVBjTdc+xDcMwDARA7cKKHTuWX37LHaw+vQbQAJomA7j2DB7FhCMFCZB8pxPwJEv5kQcZW+3HencRBekak4aaMQIi8YJdAQ1CMeE0UBkuaLMETklQ9Alhka0JzzXWqLVBuQYPpWcVuBbZjZafNRYcDk9o/b07bvhINz+/zxu1/M0FSRcmAk/HaIcAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMTItMDJUMTQ6MjY6MjkrMDE6MDDARtd2AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE0LTExLTEyVDA4OjM5OjE5KzAxOjAwO3ydwwAAAABJRU5ErkJggg==')}
${img('geohype','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAACKSURBVBjTbU+rFQQhDKQSDDISEYuMREfHx6eHKMpYuf5qoIQt5bgDblfcuJk3nySEhSvceDV3c/ejT66lspopE9pXyIlkCrHMBACpu1DClekQAREi/loviCnF/NhRwJLaQ6hVhPjB8bOCsjlnNnNl0FWJVWxAqGzHONRHpu5Ml+nQ+8GzNW9n+Is3eg80Nk0iiwoAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMTItMDJUMTQ6MjY6MjkrMDE6MDDARtd2AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE0LTExLTEyVDA4OjM5OjE5KzAxOjAwO3ydwwAAAABJRU5ErkJggg==')}
${img('geomixture','BAMAAADt3eJSAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAACFQTFRFAAAAAAAAKysrVVUA//8B//8AgICAqqpV398gv79A////VYJtlwAAAAF0Uk5TAEDm2GYAAAABYktHRApo0PRWAAAACXBIWXMAAABIAAAASABGyWs+AAAAXklEQVQI12NgwASCQsJCgoZAhoADq1tKIJAhEpDGxpYIZKgxsLElgBhibAkOCY4gKTaGkPRGIEPUIYEBrEaAIY0tDawmgYWNgREkkjCVjRWkWCUhLY0FJCIIBljsBgCZTAykgaRiRwAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNS0xMi0wMlQxNDoyNjoyOSswMTowMMBG13YAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTQtMTEtMTJUMDg6Mzk6MTkrMDE6MDA7fJ3DAAAAAElFTkSuQmCC')}
${img('geopcon','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAACJSURBVBjTdc+hGcQwCIZhhjl/rkgWiECj8XgGyAbZoD5LdIRMkEnKkV575n75Pp8AgLU54dmh6mauelyAL2Qzxfe2sklioq6FacFAcRFXYhwJHdU5rDD2hEYB/CmoJVRMiIJqgtENuoqA8ltAlYAqRH4d1tGkwzTqN2gA7Nv+fUwkgZ/3mg34txM+szzATJS1HQAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNS0xMi0wMlQxNDoyNjoyOSswMTowMMBG13YAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTQtMTEtMTJUMDg6Mzk6MTkrMDE6MDA7fJ3DAAAAAElFTkSuQmCC')}
${img('geosphere','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAACFSURBVBjTdY+xEcQwCAQp5QNFjpQ5vZACFBFTADFFfKYCXINzlUAJruXll2ekxDAEt9zcANFbXb2mqm56dxsymAH0yccAJaeNi0h5QGyfxGJmivMPjj0nmLsbRmyFCss3rlbpcUjfS8wLUNRcJyCF6uqg2IvYCnoKC7f1kSbA6riTz7evfwj3Ml+H3KBqAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTEyLTAyVDE0OjI2OjI5KzAxOjAwwEbXdgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNC0xMS0xMlQwODozOToxOSswMTowMDt8ncMAAAAASUVORK5CYII=')}
${img('geotrap','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAAB5SURBVBjTbY+hFYAwDETZB1OJi4yNPp0JqjtAZ2AELL5DdABmIS2PtLxHXH7u7l2W5W+uHMHpGiCHLYR1yw4SCZMIXBOJWVSjK7QDDAu4g8OBmAKK4sAEDdR3rw8YmcUcrEijKKhl7lN1IQPn9ExlgU6/WEyc75+5AYK0KY5oHBDfAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTEyLTAyVDE0OjI2OjI5KzAxOjAwwEbXdgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNC0xMS0xMlQwODozOToxOSswMTowMDt8ncMAAAAASUVORK5CYII=')}
${img('geotubeseg','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAACBSURBVBjTdc+hEcQwDARA12P6QFBQ9LDwcXEVkA7SQTr4BlJBakgpsWdsh/wfux3NSCrlV86Mlrxmz1pBWq3bAHwETohxABVmDZADQp1BE+wDNnGywzHgmHDOreJNTDH3Xn3CVX0dpu2MHcIFBkYp/gKsQ8SCQ72V+36/+2aWf3kAQfgshnpXF0wAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMTItMDJUMTQ6MjY6MjkrMDE6MDDARtd2AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE0LTExLTEyVDA4OjM5OjE5KzAxOjAwO3ydwwAAAABJRU5ErkJggg==')}
${img('geoxtru','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAABcSURBVBjTY2AgEmhpeZV56vmWwQW00QUYwAJlSAI6XmVqukh8PT1bT03PchhXX09Pr9wQIQDiJ+ZowgWAXD3bck+QQDlCQTkDQgCoxA/ERBKwhbDglgA1lDMQDwCc/Rvq8nYsWgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNS0xMi0wMlQxNDoyNjoyOSswMTowMMBG13YAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTQtMTEtMTJUMDg6Mzk6MTkrMDE6MDA7fJ3DAAAAAElFTkSuQmCC')}
${img('geobbox','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAAB/SURBVBjTVc+hEYAwDAXQLlNRF1tVGxn9NRswQiSSCdgDyQBM0FlIIb2WuL77uf6E8E0N02wKYRwDciTKREVvB04GuZSyOMCABRB1WGzF3uDNQTvs/RcDtJXT4fSEXA5XoiQt0ttVSm8Co2psIOvoimjAOqBmFtH5wEP2373TPIvTK1nrpULXAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTEyLTAyVDE0OjI2OjI5KzAxOjAwwEbXdgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNC0xMS0xMlQwODozOToxOSswMTowMDt8ncMAAAAASUVORK5CYII=')}
${img('geoconeseg','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAAB4SURBVBjTdc6hEcAgDAXQbFNZXHQkFlkd/30myAIMwAws0gmYpVzvoFyv/S5P/B+izzQ387ZA2pkDnvsU1SQLVIFrOM4JFmEaYp2gCQbmPEGODhJ8jt7Am47hwgrzInGAifa/elUZnQLY00iU30BZAV+BWi2VfnIBv1osbHH8jX0AAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMTItMDJUMTQ6MjY6MjkrMDE6MDDARtd2AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE0LTExLTEyVDA4OjM5OjE5KzAxOjAwO3ydwwAAAABJRU5ErkJggg==')}
${img('geoeltu','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAACGSURBVBjTdY+hFYUwDEU7xq9CIXC4uNjY6KczQXeoYgVMR2ABRmCGjvIp/6dgiEruueedvBDuOR57LQnKyc8CJmKO+N8bieIUPtmBWjIIx8XDBHYCipsnql1g2D0UP2OoDqwBncf+RdZmzFMHizRjog7KZYzawd4Ay93lEAPWR7WAvNbwMl/XwSxBV8qCjgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNS0xMi0wMlQxNDoyNjoyOSswMTowMMBG13YAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTQtMTEtMTJUMDg6Mzk6MTkrMDE6MDA7fJ3DAAAAAElFTkSuQmCC')}
${img('geomaterial','CAQAAAC1+jfqAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJiS0dEAP+Hj8y/AAAACXBIWXMAAABIAAAASABGyWs+AAAAbElEQVQoz62QMRbAIAhDP319Xon7j54qHSyCtaMZFCUkRjgDIdRU9yZUCfg8ut5aAHdcxtoNurmgA3ABNKIR9KimhSukPe2qxcCYC0pfFXx/aFWo7i42KKItOpopqvvnLzJmtlZTS7EfGAfwAM4EQbLIGV0sAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTEyLTAyVDE0OjI2OjI5KzAxOjAwwEbXdgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNC0xMS0xMlQwODozOToxOSswMTowMDt8ncMAAAAASUVORK5CYII=')}
${img('geoparab','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAAB/SURBVBjTbY+xDYAwDAQ9UAp3X7p0m9o9dUZgA9oMwAjpMwMzMAnYBAQSX9mn9+tN9KOtzsWsLOvYCziUGNX3nnCLJRzKPgeYrhPW7FJNLUB3YJazYKQKTnBaxgXRzNmJcrt7XCHQp9kEB1wfELEir/KGj4Foh8A+/zW1nf51AFabKZuWK+mNAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTEyLTAyVDE0OjI2OjI5KzAxOjAwwEbXdgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNC0xMS0xMlQwODozOToxOSswMTowMDt8ncMAAAAASUVORK5CYII=')}
${img('geopgon','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAABwSURBVBjTY2AgDlwAAzh3sX1sPRDEeuwDc+8V2dsHgQQ8LCzq74HkLSzs7Yva2tLt7S3sN4MNiDUGKQmysCi6BzWkzcI+PdY+aDPCljZlj1iFOUjW1tvHLjYuQhJIt5/DcAFZYLH9YnSn7iPST9gAACbsJth21haFAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTEyLTAyVDE0OjI2OjI5KzAxOjAwwEbXdgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNC0xMS0xMlQwODozOToxOSswMTowMDt8ncMAAAAASUVORK5CYII=')}
${img('geotorus','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAACGSURBVBjTjY+hFcMwDEQ9SkFggXGIoejhw+LiGkBDlHoAr+AhgjNL5byChuXeE7gvPelUyjOds/f5Zw0ggfj5KVCPMBWeyx+SbQ1XUriAC2XfpWWxjQQEZasRtRHiCUAj3qN4JaolUJppzh4q7dUTdHFXW/tH9OuswWm3nI7tc08+/eGLl758ey9KpKrNOQAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNS0xMi0wMlQxNDoyNjoyOSswMTowMMBG13YAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTQtMTEtMTJUMDg6Mzk6MTkrMDE6MDA7fJ3DAAAAAElFTkSuQmCC')}
${img('geotrd1','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAAB/SURBVBjTbc6xDQMhDAVQ9qH6lUtal65/zQ5IDMAMmYAZrmKGm4FJzlEQQUo+bvwkG4fwm9lbodV7w40Y4WGfSxQiXiJlQfZOjWRb8Ioi3tKuBQMCo7+9N72BzPsfAuoTdUP9QN8wgOQwvsfWmHzpeT5BKydMNW0nhJGvGf7mAc5WKO9e5N2dAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTEyLTAyVDE0OjI2OjI5KzAxOjAwwEbXdgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNC0xMS0xMlQwODozOToxOSswMTowMDt8ncMAAAAASUVORK5CYII=')}
${img('geotube','CAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAACGSURBVBjTRc+tEcAwCAXgLFNbWeSzSDQazw5doWNUZIOM0BEyS/NHy10E30HyklKvWnJ+0le3sJoKn3X2z7GRuvG++YRyMMDt0IIKUXMzxbnugJi5m9K1gNnGBOUFElAWGMaKIKI4xoQggl00gT+A9hXWgDwnfqgsHRAx2m+8bfjfdyrx5AtsSjpwu+M2RgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNS0xMi0wMlQxNDoyNjoyOSswMTowMMBG13YAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTQtMTEtMTJUMDg6Mzk6MTkrMDE6MDA7fJ3DAAAAAElFTkSuQmCC')}
${img('evepoints','BAMAAADt3eJSAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAABJQTFRF////n4mJcEdKRDMzcEdH////lLE/CwAAAAF0Uk5TAEDm2GYAAAABYktHRACIBR1IAAAACXBIWXMAAABIAAAASABGyWs+AAAAI0lEQVQI12NgIAowIpgKEJIZLiAgAKWZGQzQ9UGlWIizBQgAN4IAvGtVrTcAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTYtMDktMDJUMTU6MDQ6MzgrMDI6MDDPyc7hAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE2LTA5LTAyVDE1OjA0OjM4KzAyOjAwvpR2XQAAAABJRU5ErkJggg==')}
${img('evetrack', 'CAQAAAC1+jfqAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJiS0dEAP+Hj8y/AAAACXBIWXMAAABIAAAASABGyWs+AAAAqElEQVQoz32RMQrCQBBFf4IgSMB0IpGkMpVHCFh7BbHIGTyVhU0K8QYewEKsbVJZaCUiPAsXV8Puzhaz7H8zs5+JUDjikLilQr5zpCRl5xMXZNScQE5gSMGaz70jjUAJcw5c3UBMTsUe+9Kzf065SbropeLXimWfDIgoab/tOyPGzOhz53+oSWcSGh7UdB2ZNKXBZdgAuUdEKJYmrEILyVgG6pE2tEHgDfe42rbjYzSHAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE2LTA5LTAyVDE1OjA0OjQ3KzAyOjAwM0S3EQAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNi0wOS0wMlQxNTowNDo0NyswMjowMEIZD60AAAAASUVORK5CYII=')}
.jsroot .geovis_this { background-color: lightgreen; }
.jsroot .geovis_daughters { background-color: lightblue; }
.jsroot .geovis_all { background-color: yellow; }`);
}


/** @summary Create geo painter
  * @private */
function createGeoPainter(dom, obj, opt) {

   injectGeoStyle();

   geoCfg('GradPerSegm', settings.GeoGradPerSegm);
   geoCfg('CompressComp', settings.GeoCompressComp);

   let painter = new TGeoPainter(dom, obj);

   painter.options = painter.decodeOptions(opt); // indicator of initialization

   // copy all attributes from options to control
   Object.assign(painter.ctrl, painter.options);

   painter.ctrl.ssao.enabled = painter.options.usessao;
   painter.ctrl.bloom.enabled = painter.options.usebloom;

   // special handling for array of clips
   painter.ctrl.clip[0].enabled = painter.options.clipx;
   painter.ctrl.clip[1].enabled = painter.options.clipy;
   painter.ctrl.clip[2].enabled = painter.options.clipz;

   return painter;
}


/** @summary provide menu for geo object
  * @private */
function provideMenu(menu, item, hpainter) {

   if (!item._geoobj) return false;

   let obj = item._geoobj, vol = item._volume,
       iseve = ((obj._typename === clTEveGeoShapeExtract) || (obj._typename === clREveGeoShapeExtract));

   if (!vol && !iseve) return false;

   menu.add('separator');

   const ScanEveVisible = (obj, arg, skip_this) => {

      if (!arg) arg = { visible: 0, hidden: 0 };

      if (!skip_this) {
         if (arg.assign !== undefined)
            obj.fRnrSelf = arg.assign;
         else if (obj.fRnrSelf)
            arg.vis++;
         else
            arg.hidden++;
      }

      if (obj.fElements)
         for (let n = 0; n < obj.fElements.arr.length; ++n)
            ScanEveVisible(obj.fElements.arr[n], arg, false);

      return arg;

   }, ToggleEveVisibility = arg => {

      if (arg === 'self') {
         obj.fRnrSelf = !obj.fRnrSelf;
         item._icon = item._icon.split(' ')[0] + provideVisStyle(obj);
         hpainter.updateTreeNode(item);
      } else {
         ScanEveVisible(obj, { assign: (arg === 'true') }, true);
         hpainter.forEachItem(m => {
            // update all child items
            if (m._geoobj && m._icon) {
               m._icon = item._icon.split(' ')[0] + provideVisStyle(m._geoobj);
               hpainter.updateTreeNode(m);
            }
         }, item);
      }

      findItemWithPainter(item, 'testGeomChanges');
   }, ToggleMenuBit = arg => {
      toggleGeoBit(vol, arg);
      let newname = item._icon.split(' ')[0] + provideVisStyle(vol);
      hpainter.forEachItem(m => {
         // update all items with that volume
         if (item._volume === m._volume) {
            m._icon = newname;
            hpainter.updateTreeNode(m);
         }
      });

      hpainter.updateTreeNode(item);
      findItemWithPainter(item, 'testGeomChanges');
   };

   if ((item._geoobj._typename.indexOf(clTGeoNode) === 0) && findItemWithPainter(item))
      menu.add('Focus', function() {

        let drawitem = findItemWithPainter(item);

        if (!drawitem) return;

        let fullname = hpainter.itemFullName(item, drawitem);

        if (isFunc(drawitem._painter?.focusOnItem))
           drawitem._painter.focusOnItem(fullname);
      });

   if (iseve) {
      menu.addchk(obj.fRnrSelf, 'Visible', 'self', ToggleEveVisibility);
      let res = ScanEveVisible(obj, undefined, true);
      if (res.hidden + res.visible > 0)
         menu.addchk((res.hidden == 0), 'Daughters', res.hidden !== 0 ? 'true' : 'false', ToggleEveVisibility);
   } else {
      menu.addchk(testGeoBit(vol, geoBITS.kVisNone), 'Invisible',
            geoBITS.kVisNone, ToggleMenuBit);
      menu.addchk(testGeoBit(vol, geoBITS.kVisThis), 'Visible',
            geoBITS.kVisThis, ToggleMenuBit);
      menu.addchk(testGeoBit(vol, geoBITS.kVisDaughters), 'Daughters',
            geoBITS.kVisDaughters, ToggleMenuBit);
   }

   return true;
}

/** @summary handle click on browser icon
  * @private */
function browserIconClick(hitem, hpainter) {
   if (hitem._volume) {
      if (hitem._more && hitem._volume.fNodes && (hitem._volume.fNodes.arr.length > 0))
         toggleGeoBit(hitem._volume, geoBITS.kVisDaughters);
      else
         toggleGeoBit(hitem._volume, geoBITS.kVisThis);

      updateBrowserIcons(hitem._volume, hpainter);

      findItemWithPainter(hitem, 'testGeomChanges');
      return false; // no need to update icon - we did it ourself
   }

   if (hitem._geoobj && ((hitem._geoobj._typename == clTEveGeoShapeExtract) || (hitem._geoobj._typename == clREveGeoShapeExtract))) {
      hitem._geoobj.fRnrSelf = !hitem._geoobj.fRnrSelf;

      updateBrowserIcons(hitem._geoobj, hpainter);
      findItemWithPainter(hitem, 'testGeomChanges');
      return false; // no need to update icon - we did it ourself
   }


   // first check that geo painter assigned with the item
   let drawitem = findItemWithPainter(hitem);
   if (!drawitem) return false;

   let newstate = drawitem._painter.extraObjectVisible(hpainter, hitem, true);

   // return true means browser should update icon for the item
   return (newstate !== undefined) ? true : false;
}


/** @summary Get icon for the browser
  * @private */
function getBrowserIcon(hitem, hpainter) {
   let icon = '';
   switch(hitem._kind) {
      case 'ROOT.' + clTEveTrack: icon = 'img_evetrack'; break;
      case 'ROOT.' + clTEvePointSet: icon = 'img_evepoints'; break;
      case 'ROOT.' + clTPolyMarker3D: icon = 'img_evepoints'; break;
   }
   if (icon) {
      let drawitem = findItemWithPainter(hitem);
      if (drawitem?._painter && drawitem._painter.extraObjectVisible(hpainter, hitem))
         icon += ' geovis_this';
   }
   return icon;
}


/** @summary create hierarchy item for geo object
  * @private */
function createItem(node, obj, name) {
   let sub = {
      _kind: 'ROOT.' + obj._typename,
      _name: name ? name : getObjectName(obj),
      _title: obj.fTitle,
      _parent: node,
      _geoobj: obj,
      _get(item /* ,itemname */) {
          // mark object as belong to the hierarchy, require to
          if (item._geoobj) item._geoobj.$geoh = true;
          return Promise.resolve(item._geoobj);
      }
   }, volume, shape, subnodes, iseve = false;

   if (obj._typename == 'TGeoMaterial')
      sub._icon = 'img_geomaterial';
   else if (obj._typename == 'TGeoMedium')
      sub._icon = 'img_geomedium';
   else if (obj._typename == 'TGeoMixture')
      sub._icon = 'img_geomixture';
   else if ((obj._typename.indexOf(clTGeoNode) === 0) && obj.fVolume) {
      sub._title = 'node:'  + obj._typename;
      if (obj.fTitle) sub._title += ' ' + obj.fTitle;
      volume = obj.fVolume;
   } else if (obj._typename.indexOf(clTGeoVolume) === 0) {
      volume = obj;
   } else if ((obj._typename == clTEveGeoShapeExtract) || (obj._typename == clREveGeoShapeExtract)) {
      iseve = true;
      shape = obj.fShape;
      subnodes = obj.fElements ? obj.fElements.arr : null;
   } else if ((obj.fShapeBits !== undefined) && (obj.fShapeId !== undefined)) {
      shape = obj;
   }

   if (volume) {
      shape = volume.fShape;
      subnodes = volume.fNodes ? volume.fNodes.arr : null;
   }

   if (volume || shape || subnodes) {
      if (volume) sub._volume = volume;

      if (subnodes) {
         sub._more = true;
         sub._expand = expandGeoObject;
      } else if (shape && (shape._typename === clTGeoCompositeShape) && shape.fNode) {
         sub._more = true;
         sub._shape = shape;
         sub._expand = function(node /*, obj */) {
            createItem(node, node._shape.fNode.fLeft, 'Left');
            createItem(node, node._shape.fNode.fRight, 'Right');
            return true;
         };
      }

      if (!sub._title && (obj._typename != clTGeoVolume))
         sub._title = obj._typename;

      if (shape) {
         if (sub._title == '')
            sub._title = shape._typename;

         sub._icon = getShapeIcon(shape);
      } else {
         sub._icon = sub._more ? 'img_geocombi' : 'img_geobbox';
      }

      if (volume)
         sub._icon += provideVisStyle(volume);
      else if (iseve)
         sub._icon += provideVisStyle(obj);

      sub._menu = provideMenu;
      sub._icon_click  = browserIconClick;
   }

   if (!node._childs) node._childs = [];

   if (!sub._name)
      if (isStr(node._name)) {
         sub._name = node._name;
         if (sub._name.lastIndexOf('s')===sub._name.length-1)
            sub._name = sub._name.slice(0, sub._name.length-1);
         sub._name += '_' + node._childs.length;
      } else {
         sub._name = 'item_' + node._childs.length;
      }

   node._childs.push(sub);

   return sub;
}

/** @summary Draw dummy geometry
  * @private */
async function drawDummy3DGeom(painter) {

   let extra = painter.getObject(),
       min = [-1, -1, -1], max = [1, 1, 1];

   if (extra.fP?.length)
      for(let k = 0; k < extra.fP.length; k += 3)
         for (let i = 0; i < 3; ++i) {
            min[i] = Math.min(min[i], extra.fP[k+i]);
            max[i] = Math.max(max[i], extra.fP[k+i]);
         }


   let shape = create$1(clTNamed);
   shape._typename = clTGeoBBox;
   shape.fDX = max[0] - min[0];
   shape.fDY = max[1] - min[1];
   shape.fDZ = max[2] - min[2];
   shape.fShapeId = 1;
   shape.fShapeBits = 0;
   shape.fOrigin = [0,0,0];

   let obj = Object.assign(create$1(clTNamed),
                { _typename: clTEveGeoShapeExtract,
                  fTrans: [1,0,0,0, 0,1,0,0, 0,0,1,0, (min[0]+max[0])/2, (min[1]+max[1])/2, (min[2]+max[2])/2, 0],
                  fShape: shape, fRGBA: [0, 0, 0, 0], fElements: null, fRnrSelf: false });

   let opt = '', pp = painter.getPadPainter();

   if (pp?.pad?.fFillColor && (pp?.pad?.fFillStyle > 1000))
      opt = 'bkgr_' +  pp.pad.fFillColor;

   return TGeoPainter.draw(painter.getDom(), obj, opt)
                     .then(geop => geop.drawExtras(extra));
}

/** @summary Direct draw function for TAxis3D
  * @private */
function drawAxis3D() {
   let main = this.getMainPainter();

   if (isFunc(main?.setAxesDraw))
      return main.setAxesDraw(true);

   console.error('no geometry painter found to toggle TAxis3D drawing');
}

/** @summary Build three.js model for given geometry object
  * @param {Object} obj - TGeo-related object
  * @param {Object} [opt] - options
  * @param {Number} [opt.vislevel] - visibility level like TGeoManager, when not specified - show all
  * @param {Number} [opt.numnodes=1000] - maximal number of visible nodes
  * @param {Number} [opt.numfaces=100000] - approx maximal number of created triangles
  * @param {boolean} [opt.doubleside=false] - use double-side material
  * @param {boolean} [opt.wireframe=false] - show wireframe for created shapes
  * @param {boolean} [opt.dflt_colors=false] - use default ROOT colors
  * @return {object} Object3D with created model
  * @example
  * import { build } from './path_to_jsroot/modules/geom/TGeoPainter.mjs';
  * let obj3d = build(obj);
  * // this is three.js object and can be now inserted in the scene
  */
function build(obj, opt) {

   if (!obj) return null;

   if (!opt) opt = {};
   if (!opt.numfaces) opt.numfaces = 100000;
   if (!opt.numnodes) opt.numnodes = 1000;
   if (!opt.frustum) opt.frustum = null;

   opt.res_mesh = opt.res_faces = 0;

   let clones = null, visibles = null;

   if (obj.visibles && obj.nodes && obj.numnodes) {
      // case of draw message from geometry viewer

      let nodes = obj.numnodes > 1e6 ? { length: obj.numnodes } : new Array(obj.numnodes);

      obj.nodes.forEach(node => {
         nodes[node.id] = ClonedNodes.formatServerElement(node);
      });

      clones = new ClonedNodes(null, nodes);
      clones.name_prefix = clones.getNodeName(0);
      // normally only need when making selection, not used in geo viewer
      // this.geo_clones.setMaxVisNodes(draw_msg.maxvisnodes);
      // this.geo_clones.setVisLevel(draw_msg.vislevel);
      // parameter need for visualization with transparency
      // TODO: provide from server
      clones.maxdepth = 20;

      let nsegm = obj.cfg?.nsegm || 30;

      for (let cnt = 0; cnt < obj.visibles.length; ++cnt) {
         let item = obj.visibles[cnt], rd = item.ri;

         // entry may be provided without shape - it is ok
         if (rd)
            item.server_shape = rd.server_shape = createServerGeometry(rd, nsegm);
      }

      visibles = obj.visibles;

   } else {
      let shape = null, hide_top = false;

      if (('fShapeBits' in obj) && ('fShapeId' in obj)) {
         shape = obj; obj = null;
      } else if ((obj._typename === clTGeoVolumeAssembly) || (obj._typename === clTGeoVolume)) {
         shape = obj.fShape;
      } else if ((obj._typename === clTEveGeoShapeExtract) || (obj._typename === clREveGeoShapeExtract)) {
         shape = obj.fShape;
      } else if (obj._typename === clTGeoManager) {
         obj = obj.fMasterVolume;
         hide_top = !opt.showtop;
         shape = obj.fShape;
      } else if (obj.fVolume) {
         shape = obj.fVolume.fShape;
      } else {
         obj = null;
      }

      if (opt.composite && shape && (shape._typename == clTGeoCompositeShape) && shape.fNode)
         obj = buildCompositeVolume(shape);

      if (!obj && shape)
         obj = Object.assign(create$1(clTNamed), { _typename: clTEveGeoShapeExtract, fTrans: null, fShape: shape, fRGBA: [0, 1, 0, 1], fElements: null, fRnrSelf: true });

      if (!obj) return null;

      if (obj._typename.indexOf(clTGeoVolume) === 0)
         obj = { _typename: clTGeoNode, fVolume: obj, fName: obj.fName, $geoh: obj.$geoh, _proxy: true };

      clones = new ClonedNodes(obj);
      clones.setVisLevel(opt.vislevel);
      clones.setMaxVisNodes(opt.numnodes);

      if (opt.dflt_colors)
         clones.setDefaultColors(true);

      let uniquevis = opt.no_screen ? 0 : clones.markVisibles(true);
      if (uniquevis <= 0)
         clones.markVisibles(false, false, hide_top);
      else
         clones.markVisibles(true, true, hide_top); // copy bits once and use normal visibility bits

      clones.produceIdShifts();

      // collect visible nodes
      let res = clones.collectVisibles(opt.numfaces, opt.frustum);

      visibles = res.lst;
   }

   // collect shapes
   let shapes = clones.collectShapes(visibles);

   clones.buildShapes(shapes, opt.numfaces);

   let toplevel = new Object3D();

   for (let n = 0; n < visibles.length; ++n) {
      let entry = visibles[n];
      if (entry.done) continue;

      let shape = entry.server_shape || shapes[entry.shapeid];
      if (!shape.ready) {
         console.warn('shape marked as not ready when should');
         break;
      }
      entry.done = true;
      shape.used = true; // indicate that shape was used in building

      if (!shape.geom || (shape.nfaces === 0)) {
         // node is visible, but shape does not created
         clones.createObject3D(entry.stack, toplevel, 'delete_mesh');
         continue;
      }

      let prop = clones.getDrawEntryProperties(entry, getRootColors());

      opt.res_mesh++;
      opt.res_faces += shape.nfaces;

      let obj3d = clones.createObject3D(entry.stack, toplevel, opt);

      prop.material.wireframe = opt.wireframe;

      prop.material.side = opt.doubleside ? DoubleSide : FrontSide;

      let mesh = null, matrix = obj3d.absMatrix || obj3d.matrixWorld;

      if (matrix.determinant() > -0.9) {
         mesh = new Mesh(shape.geom, prop.material);
      } else {
         mesh = createFlippedMesh(shape, prop.material);
      }

      mesh.name = clones.getNodeName(entry.nodeid);

      obj3d.add(mesh);

      if (obj3d.absMatrix) {
         mesh.matrix.copy(obj3d.absMatrix);
         mesh.matrix.decompose( obj3d.position, obj3d.quaternion, obj3d.scale );
         mesh.updateMatrixWorld();
      }

      // specify rendering order, required for transparency handling
      //if (obj3d.$jsroot_depth !== undefined)
      //   mesh.renderOrder = clones.maxdepth - obj3d.$jsroot_depth;
      //else
      //   mesh.renderOrder = clones.maxdepth - entry.stack.length;
   }

   return toplevel;
}

var TGeoPainter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
ClonedNodes: ClonedNodes,
build: build,
TGeoPainter: TGeoPainter,
GeoDrawingControl: GeoDrawingControl,
expandGeoObject: expandGeoObject,
createGeoPainter: createGeoPainter,
drawAxis3D: drawAxis3D,
drawDummy3DGeom: drawDummy3DGeom,
produceRenderOrder: produceRenderOrder
});

const clTStreamerElement = 'TStreamerElement', clTStreamerObject = 'TStreamerObject',
      clTStreamerSTL = 'TStreamerSTL', clTStreamerInfoList = 'TStreamerInfoList',
      clTDirectory = 'TDirectory', clTDirectoryFile = 'TDirectoryFile',
      clTQObject = 'TQObject', clTBasket = 'TBasket',
      nameStreamerInfo = 'StreamerInfo',

      kChar = 1, kShort = 2, kInt = 3, kLong = 4, kFloat = 5, kCounter = 6,
      kCharStar = 7, kDouble = 8, kDouble32 = 9, kLegacyChar = 10,
      kUChar = 11, kUShort = 12, kUInt = 13, kULong = 14, kBits = 15,
      kLong64 = 16, kULong64 = 17, kBool = 18, kFloat16 = 19,

      kBase = 0, kOffsetL = 20, kOffsetP = 40,
      kObject = 61, kAny = 62, kObjectp = 63, kObjectP = 64, kTString = 65,
      kTObject = 66, kTNamed = 67, kAnyp = 68, kAnyP = 69,

      /* kAnyPnoVT: 70, */
      kSTLp = 71,
      /* kSkip = 100, kSkipL = 120, kSkipP = 140, kConv = 200, kConvL = 220, kConvP = 240, */

      kSTL = 300, /* kSTLstring = 365, */

      kStreamer = 500, kStreamLoop = 501,

      kMapOffset = 2, kByteCountMask = 0x40000000, kNewClassTag = 0xFFFFFFFF, kClassMask = 0x80000000,

      // constants of bits in version
      kStreamedMemberWise = BIT(14),

      // constants used for coding type of STL container
      kNotSTL = 0, kSTLvector = 1, kSTLlist = 2, kSTLdeque = 3, kSTLmap = 4, kSTLmultimap = 5,
      kSTLset = 6, kSTLmultiset = 7, kSTLbitset = 8,
      // kSTLforwardlist = 9, kSTLunorderedset = 10, kSTLunorderedmultiset = 11, kSTLunorderedmap = 12,
      // kSTLunorderedmultimap = 13, kSTLend = 14

      // name of base IO types
      BasicTypeNames = ['BASE', 'char', 'short', 'int', 'long', 'float', 'int', 'const char*', 'double', 'Double32_t',
                        'char', 'unsigned  char', 'unsigned short', 'unsigned', 'unsigned long', 'unsigned', 'Long64_t', 'ULong64_t', 'bool', 'Float16_t'],

      // names of STL containers
      StlNames = ['', 'vector', 'list', 'deque', 'map', 'multimap', 'set', 'multiset', 'bitset'],

      // TObject bits
      kIsReferenced = BIT(4), kHasUUID = BIT(5);


/** @summary Custom streamers for root classes
  * @desc map of user-streamer function like func(buf,obj)
  * or alias (classname) which can be used to read that function
  * or list of read functions
  * @private */
const CustomStreamers = {
   TObject(buf, obj) {
      obj.fUniqueID = buf.ntou4();
      obj.fBits = buf.ntou4();
      if (obj.fBits & kIsReferenced) buf.ntou2(); // skip pid
   },

   TNamed: [ {
      basename: clTObject, base: 1, func(buf, obj) {
         if (!obj._typename) obj._typename = clTNamed;
         buf.classStreamer(obj, clTObject);
      }
     },
     { name: 'fName', func(buf, obj) { obj.fName = buf.readTString(); } },
     { name: 'fTitle', func(buf, obj) { obj.fTitle = buf.readTString(); } }
   ],

   TObjString: [ {
      basename: clTObject, base: 1, func(buf, obj) {
         if (!obj._typename) obj._typename = clTObjString;
         buf.classStreamer(obj, clTObject);
      }
     },
     { name: 'fString', func(buf, obj) { obj.fString = buf.readTString(); } }
   ],

   TClonesArray(buf, list) {
      if (!list._typename) list._typename = clTClonesArray;
      list.$kind = clTClonesArray;
      list.name = '';
      const ver = buf.last_read_version;
      if (ver > 2) buf.classStreamer(list, clTObject);
      if (ver > 1) list.name = buf.readTString();
      let classv = buf.readTString(), clv = 0,
          pos = classv.lastIndexOf(';');

      if (pos > 0) {
         clv = parseInt(classv.slice(pos + 1));
         classv = classv.slice(0, pos);
      }

      let nobjects = buf.ntou4();
      if (nobjects < 0) nobjects = -nobjects;  // for backward compatibility

      list.arr = new Array(nobjects);
      list.fLast = nobjects - 1;
      list.fLowerBound = buf.ntou4();

      let streamer = buf.fFile.getStreamer(classv, { val: clv });
      streamer = buf.fFile.getSplittedStreamer(streamer);

      if (!streamer) {
         console.log(`Cannot get member-wise streamer for ${classv}:${clv}`);
      } else {
         // create objects
         for (let n = 0; n < nobjects; ++n)
            list.arr[n] = { _typename: classv };

         // call streamer for all objects member-wise
         for (let k = 0; k < streamer.length; ++k)
            for (let n = 0; n < nobjects; ++n)
               streamer[k].func(buf, list.arr[n]);
      }
   },

   TMap(buf, map) {
      if (!map._typename) map._typename = clTMap;
      map.name = '';
      map.arr = [];
      const ver = buf.last_read_version;
      if (ver > 2) buf.classStreamer(map, clTObject);
      if (ver > 1) map.name = buf.readTString();

      const nobjects = buf.ntou4();
      // create objects
      for (let n = 0; n < nobjects; ++n) {
         let obj = { _typename: 'TPair' };
         obj.first = buf.readObjectAny();
         obj.second = buf.readObjectAny();
         if (obj.first) map.arr.push(obj);
      }
   },

   TTreeIndex(buf, obj) {
      const ver = buf.last_read_version;
      obj._typename = 'TTreeIndex';
      buf.classStreamer(obj, 'TVirtualIndex');
      obj.fMajorName = buf.readTString();
      obj.fMinorName = buf.readTString();
      obj.fN = buf.ntoi8();
      obj.fIndexValues = buf.readFastArray(obj.fN, kLong64);
      if (ver > 1) obj.fIndexValuesMinor = buf.readFastArray(obj.fN, kLong64);
      obj.fIndex = buf.readFastArray(obj.fN, kLong64);
   },

   TRefArray(buf, obj) {
      obj._typename = 'TRefArray';
      buf.classStreamer(obj, clTObject);
      obj.name = buf.readTString();
      const nobj = buf.ntoi4();
      obj.fLast = nobj - 1;
      obj.fLowerBound = buf.ntoi4();
      /*const pidf = */ buf.ntou2();
      obj.fUIDs = buf.readFastArray(nobj, kUInt);
   },

   TCanvas(buf, obj) {
      obj._typename = clTCanvas;
      buf.classStreamer(obj, clTPad);
      obj.fDISPLAY = buf.readTString();
      obj.fDoubleBuffer = buf.ntoi4();
      obj.fRetained = (buf.ntou1() !== 0);
      obj.fXsizeUser = buf.ntoi4();
      obj.fYsizeUser = buf.ntoi4();
      obj.fXsizeReal = buf.ntoi4();
      obj.fYsizeReal = buf.ntoi4();
      obj.fWindowTopX = buf.ntoi4();
      obj.fWindowTopY = buf.ntoi4();
      obj.fWindowWidth = buf.ntoi4();
      obj.fWindowHeight = buf.ntoi4();
      obj.fCw = buf.ntou4();
      obj.fCh = buf.ntou4();
      obj.fCatt = buf.classStreamer({}, clTAttCanvas);
      buf.ntou1(); // ignore b << TestBit(kMoveOpaque);
      buf.ntou1(); // ignore b << TestBit(kResizeOpaque);
      obj.fHighLightColor = buf.ntoi2();
      obj.fBatch = (buf.ntou1() !== 0);
      buf.ntou1();   // ignore b << TestBit(kShowEventStatus);
      buf.ntou1();   // ignore b << TestBit(kAutoExec);
      buf.ntou1();   // ignore b << TestBit(kMenuBar);
   },

   TObjArray(buf, list) {
      if (!list._typename) list._typename = clTObjArray;
      list.$kind = clTObjArray;
      list.name = '';
      const ver = buf.last_read_version;
      if (ver > 2)
         buf.classStreamer(list, clTObject);
      if (ver > 1)
         list.name = buf.readTString();
      const nobjects = buf.ntou4();
      let i = 0;
      list.arr = new Array(nobjects);
      list.fLast = nobjects - 1;
      list.fLowerBound = buf.ntou4();
      while (i < nobjects)
         list.arr[i++] = buf.readObjectAny();
   },

   TPolyMarker3D(buf, marker) {
      const ver = buf.last_read_version;
      buf.classStreamer(marker, clTObject);
      buf.classStreamer(marker, clTAttMarker);
      marker.fN = buf.ntoi4();
      marker.fP = buf.readFastArray(marker.fN * 3, kFloat);
      marker.fOption = buf.readTString();
      marker.fName = (ver > 1) ? buf.readTString() : clTPolyMarker3D;
   },

   TPolyLine3D(buf, obj) {
      buf.classStreamer(obj, clTObject);
      buf.classStreamer(obj, clTAttLine);
      obj.fN = buf.ntoi4();
      obj.fP = buf.readFastArray(obj.fN * 3, kFloat);
      obj.fOption = buf.readTString();
   },

   TStreamerInfo(buf, obj) {
      buf.classStreamer(obj, clTNamed);
      obj.fCheckSum = buf.ntou4();
      obj.fClassVersion = buf.ntou4();
      obj.fElements = buf.readObjectAny();
   },

   TStreamerElement(buf, element) {
      const ver = buf.last_read_version;
      buf.classStreamer(element, clTNamed);
      element.fType = buf.ntou4();
      element.fSize = buf.ntou4();
      element.fArrayLength = buf.ntou4();
      element.fArrayDim = buf.ntou4();
      element.fMaxIndex = buf.readFastArray((ver == 1) ? buf.ntou4() : 5, kUInt);
      element.fTypeName = buf.readTString();

      if ((element.fType === kUChar) && ((element.fTypeName == 'Bool_t') || (element.fTypeName == 'bool')))
         element.fType = kBool;

      element.fXmin = element.fXmax = element.fFactor = 0;
      if (ver === 3) {
         element.fXmin = buf.ntod();
         element.fXmax = buf.ntod();
         element.fFactor = buf.ntod();
      } else if ((ver > 3) && (element.fBits & BIT(6))) { // kHasRange

         let p1 = element.fTitle.indexOf('[');
         if ((p1 >= 0) && (element.fType > kOffsetP)) p1 = element.fTitle.indexOf('[', p1 + 1);
         let p2 = element.fTitle.indexOf(']', p1 + 1);

         if ((p1 >= 0) && (p2 >= p1 + 2)) {

            let arr = element.fTitle.slice(p1+1, p2).split(','), nbits = 32;
            if (!arr || arr.length < 2)
               throw new Error(`Problem to decode range setting from streamer element title ${element.fTitle}`);

            if (arr.length === 3) nbits = parseInt(arr[2]);
            if (!Number.isInteger(nbits) || (nbits < 2) || (nbits > 32)) nbits = 32;

            let parse_range = val => {
               if (!val) return 0;
               if (val.indexOf('pi') < 0) return parseFloat(val);
               val = val.trim();
               let sign = 1.;
               if (val[0] == '-') { sign = -1; val = val.slice(1); }
               switch (val) {
                  case '2pi':
                  case '2*pi':
                  case 'twopi': return sign * 2 * Math.PI;
                  case 'pi/2': return sign * Math.PI / 2;
                  case 'pi/4': return sign * Math.PI / 4;
               }
               return sign * Math.PI;
            };

            element.fXmin = parse_range(arr[0]);
            element.fXmax = parse_range(arr[1]);

            // avoid usage of 1 << nbits, while only works up to 32 bits
            let bigint = ((nbits >= 0) && (nbits < 32)) ? Math.pow(2, nbits) : 0xffffffff;
            if (element.fXmin < element.fXmax)
               element.fFactor = bigint / (element.fXmax - element.fXmin);
            else if (nbits < 15)
               element.fXmin = nbits;
         }
      }
   },

   TStreamerBase(buf, elem) {
      const ver = buf.last_read_version;
      buf.classStreamer(elem, clTStreamerElement);
      if (ver > 2) elem.fBaseVersion = buf.ntou4();
   },

   TStreamerSTL(buf, elem) {
      buf.classStreamer(elem, clTStreamerElement);
      elem.fSTLtype = buf.ntou4();
      elem.fCtype = buf.ntou4();

      if ((elem.fSTLtype === kSTLmultimap) &&
         ((elem.fTypeName.indexOf('std::set') === 0) ||
            (elem.fTypeName.indexOf('set') === 0))) elem.fSTLtype = kSTLset;

      if ((elem.fSTLtype === kSTLset) &&
         ((elem.fTypeName.indexOf('std::multimap') === 0) ||
            (elem.fTypeName.indexOf('multimap') === 0))) elem.fSTLtype = kSTLmultimap;
   },

   TStreamerSTLstring(buf, elem) {
      if (buf.last_read_version > 0)
         buf.classStreamer(elem, clTStreamerSTL);
   },

   TList(buf, obj) {
      // stream all objects in the list from the I/O buffer
      if (!obj._typename) obj._typename = this.typename;
      obj.$kind = clTList; // all derived classes will be marked as well
      if (buf.last_read_version > 3) {
         buf.classStreamer(obj, clTObject);
         obj.name = buf.readTString();
         const nobjects = buf.ntou4();
         obj.arr = new Array(nobjects);
         obj.opt = new Array(nobjects);
         for (let i = 0; i < nobjects; ++i) {
            obj.arr[i] = buf.readObjectAny();
            obj.opt[i] = buf.readTString();
         }
      } else {
         obj.name = '';
         obj.arr = [];
         obj.opt = [];
      }
   },

   THashList: clTList,

   TStreamerLoop(buf, elem)  {
      if (buf.last_read_version > 1) {
         buf.classStreamer(elem, clTStreamerElement);
         elem.fCountVersion = buf.ntou4();
         elem.fCountName = buf.readTString();
         elem.fCountClass = buf.readTString();
      }
   },

   TStreamerBasicPointer: 'TStreamerLoop',

   TStreamerObject(buf, elem) {
      if (buf.last_read_version > 1)
         buf.classStreamer(elem, clTStreamerElement);
   },

   TStreamerBasicType: clTStreamerObject,
   TStreamerObjectAny: clTStreamerObject,
   TStreamerString: clTStreamerObject,
   TStreamerObjectPointer: clTStreamerObject,

   TStreamerObjectAnyPointer(buf, elem) {
      if (buf.last_read_version > 0)
         buf.classStreamer(elem, clTStreamerElement);
   },

   TTree: {
      name: '$file',
      func(buf, obj) { obj.$kind = 'TTree'; obj.$file = buf.fFile; }
   },

   RooRealVar(buf, obj) {
      const v = buf.last_read_version;
      buf.classStreamer(obj, 'RooAbsRealLValue');
      if (v == 1) { buf.ntod(); buf.ntod(); buf.ntoi4(); } // skip fitMin, fitMax, fitBins
      obj._error = buf.ntod();
      obj._asymErrLo = buf.ntod();
      obj._asymErrHi = buf.ntod();
      if (v >= 2) obj._binning = buf.readObjectAny();
      if (v == 3) obj._sharedProp = buf.readObjectAny();
      if (v >= 4) obj._sharedProp = buf.classStreamer({}, 'RooRealVarSharedProperties');
   },

   RooAbsBinning(buf, obj) {
      buf.classStreamer(obj, (buf.last_read_version == 1) ? clTObject : clTNamed);
      buf.classStreamer(obj, 'RooPrintable');
   },

   RooCategory(buf, obj) {
      const v = buf.last_read_version;
      buf.classStreamer(obj, 'RooAbsCategoryLValue');
      obj._sharedProp = (v === 1) ? buf.readObjectAny() : buf.classStreamer({}, 'RooCategorySharedProperties');
   },

   'RooWorkspace::CodeRepo': (buf /*, obj*/) => {
      const sz = (buf.last_read_version == 2) ? 3 : 2;
      for (let i = 0; i < sz; ++i) {
         let cnt = buf.ntoi4() * ((i == 0) ? 4 : 3);
         while (cnt--) buf.readTString();
      }
   },

   RooLinkedList(buf, obj) {
      const v = buf.last_read_version;
      buf.classStreamer(obj, clTObject);
      let size = buf.ntoi4();
      obj.arr = create$1(clTList);
      while (size--)
         obj.arr.Add(buf.readObjectAny());
      if (v > 1) obj._name = buf.readTString();
   },

   TImagePalette: [
      {
         basename: clTObject, base: 1, func(buf, obj) {
            if (!obj._typename) obj._typename = 'TImagePalette';
            buf.classStreamer(obj, clTObject);
         }
      },
      { name: 'fNumPoints', func(buf, obj) { obj.fNumPoints = buf.ntou4(); } },
      { name: 'fPoints', func(buf, obj) { obj.fPoints = buf.readFastArray(obj.fNumPoints, kDouble); } },
      { name: 'fColorRed', func(buf, obj) { obj.fColorRed = buf.readFastArray(obj.fNumPoints, kUShort); } },
      { name: 'fColorGreen', func(buf, obj) { obj.fColorGreen = buf.readFastArray(obj.fNumPoints, kUShort); } },
      { name: 'fColorBlue', func(buf, obj) { obj.fColorBlue = buf.readFastArray(obj.fNumPoints, kUShort); } },
      { name: 'fColorAlpha', func(buf, obj) { obj.fColorAlpha = buf.readFastArray(obj.fNumPoints, kUShort); } }
   ],

   TAttImage: [
      { name: 'fImageQuality', func(buf, obj) { obj.fImageQuality = buf.ntoi4(); } },
      { name: 'fImageCompression', func(buf, obj) { obj.fImageCompression = buf.ntou4(); } },
      { name: 'fConstRatio', func(buf, obj) { obj.fConstRatio = (buf.ntou1() != 0); } },
      { name: 'fPalette', func(buf, obj) { obj.fPalette = buf.classStreamer({}, 'TImagePalette'); } }
   ],

   TASImage(buf, obj) {
      if ((buf.last_read_version == 1) && (buf.fFile.fVersion > 0) && (buf.fFile.fVersion < 50000))
         return console.warn('old TASImage version - not yet supported');

      buf.classStreamer(obj, clTNamed);

      if (buf.ntou1() != 0) {
         const size = buf.ntoi4();
         obj.fPngBuf = buf.readFastArray(size, kUChar);
      } else {
         buf.classStreamer(obj, 'TAttImage');
         obj.fWidth = buf.ntoi4();
         obj.fHeight = buf.ntoi4();
         obj.fImgBuf = buf.readFastArray(obj.fWidth * obj.fHeight, kDouble);
      }
   },

   TMaterial(buf, obj) {
      const v = buf.last_read_version;
      buf.classStreamer(obj, clTNamed);
      obj.fNumber = buf.ntoi4();
      obj.fA = buf.ntof();
      obj.fZ = buf.ntof();
      obj.fDensity = buf.ntof();
      if (v > 2) {
         buf.classStreamer(obj, clTAttFill);
         obj.fRadLength = buf.ntof();
         obj.fInterLength = buf.ntof();
      } else {
         obj.fRadLength = obj.fInterLength = 0;
      }
   },

   TMixture(buf, obj) {
      buf.classStreamer(obj, 'TMaterial');
      obj.fNmixt = buf.ntoi4();
      obj.fAmixt = buf.readFastArray(buf.ntoi4(), kFloat);
      obj.fZmixt = buf.readFastArray(buf.ntoi4(), kFloat);
      obj.fWmixt = buf.readFastArray(buf.ntoi4(), kFloat);
   },

   TVirtualPerfStats: clTObject, // use directly TObject streamer

   TMethodCall: clTObject
};


/** @summary these are streamers which do not handle version regularly
  * @desc used for special classes like TRef or TBasket
  * @private */
const DirectStreamers = {
   // do nothing for these classes
   TQObject() {},
   TGraphStruct() {},
   TGraphNode() {},
   TGraphEdge() {},

   TDatime(buf, obj) {
      obj.fDatime = buf.ntou4();
      //  obj.GetDate = function() {
      //  let res = new Date();
      //  res.setFullYear((this.fDatime >>> 26) + 1995);
      //  res.setMonth((this.fDatime << 6) >>> 28);
      //  res.setDate((this.fDatime << 10) >>> 27);
      //  res.setHours((this.fDatime << 15) >>> 27);
      //  res.setMinutes((this.fDatime << 20) >>> 26);
      //  res.setSeconds((this.fDatime << 26) >>> 26);
      //  res.setMilliseconds(0);
      //  return res;
      //  }
   },

   TKey(buf, key) {
      key.fNbytes = buf.ntoi4();
      key.fVersion = buf.ntoi2();
      key.fObjlen = buf.ntou4();
      key.fDatime = buf.classStreamer({}, 'TDatime');
      key.fKeylen = buf.ntou2();
      key.fCycle = buf.ntou2();
      if (key.fVersion > 1000) {
         key.fSeekKey = buf.ntou8();
         buf.shift(8); // skip seekPdir
      } else {
         key.fSeekKey = buf.ntou4();
         buf.shift(4); // skip seekPdir
      }
      key.fClassName = buf.readTString();
      key.fName = buf.readTString();
      key.fTitle = buf.readTString();
   },

   TDirectory(buf, dir) {
      const version = buf.ntou2();
      dir.fDatimeC = buf.classStreamer({}, 'TDatime');
      dir.fDatimeM = buf.classStreamer({}, 'TDatime');
      dir.fNbytesKeys = buf.ntou4();
      dir.fNbytesName = buf.ntou4();
      dir.fSeekDir = (version > 1000) ? buf.ntou8() : buf.ntou4();
      dir.fSeekParent = (version > 1000) ? buf.ntou8() : buf.ntou4();
      dir.fSeekKeys = (version > 1000) ? buf.ntou8() : buf.ntou4();
      // if ((version % 1000) > 2) buf.shift(18); // skip fUUID
   },

   TBasket(buf, obj) {
      buf.classStreamer(obj, 'TKey');
      const ver = buf.readVersion();
      obj.fBufferSize = buf.ntoi4();
      obj.fNevBufSize = buf.ntoi4();
      obj.fNevBuf = buf.ntoi4();
      obj.fLast = buf.ntoi4();
      if (obj.fLast > obj.fBufferSize) obj.fBufferSize = obj.fLast;
      const flag = buf.ntoi1();

      if (flag === 0) return;

      if ((flag % 10) != 2) {
         if (obj.fNevBuf) {
            obj.fEntryOffset = buf.readFastArray(buf.ntoi4(), kInt);
            if ((20 < flag) && (flag < 40))
               for (let i = 0, kDisplacementMask = 0xFF000000; i < obj.fNevBuf; ++i)
                  obj.fEntryOffset[i] &= ~kDisplacementMask;
         }

         if (flag > 40)
            obj.fDisplacement = buf.readFastArray(buf.ntoi4(), kInt);
      }

      if ((flag === 1) || (flag > 10)) {
         // here is reading of raw data
         const sz = (ver.val <= 1) ? buf.ntoi4() : obj.fLast;

         if (sz > obj.fKeylen) {
            // buffer includes again complete TKey data - exclude it
            let blob = buf.extract([buf.o + obj.fKeylen, sz - obj.fKeylen]);

            obj.fBufferRef = new TBuffer(blob, 0, buf.fFile, sz - obj.fKeylen);
            obj.fBufferRef.fTagOffset = obj.fKeylen;
         }

         buf.shift(sz);
      }
   },

   TRef(buf, obj) {
      buf.classStreamer(obj, clTObject);
      if (obj.fBits & kHasUUID)
         obj.fUUID = buf.readTString();
      else
         obj.fPID = buf.ntou2();
   },

   'TMatrixTSym<float>': (buf, obj) => {
      buf.classStreamer(obj, 'TMatrixTBase<float>');
      obj.fElements = new Float32Array(obj.fNelems);
      let arr = buf.readFastArray((obj.fNrows * (obj.fNcols + 1)) / 2, kFloat), cnt = 0;
      for (let i = 0; i < obj.fNrows; ++i)
         for (let j = i; j < obj.fNcols; ++j)
            obj.fElements[j * obj.fNcols + i] = obj.fElements[i * obj.fNcols + j] = arr[cnt++];
   },

   'TMatrixTSym<double>': (buf, obj) => {
      buf.classStreamer(obj, 'TMatrixTBase<double>');
      obj.fElements = new Float64Array(obj.fNelems);
      let arr = buf.readFastArray((obj.fNrows * (obj.fNcols + 1)) / 2, kDouble), cnt = 0;
      for (let i = 0; i < obj.fNrows; ++i)
         for (let j = i; j < obj.fNcols; ++j)
            obj.fElements[j * obj.fNcols + i] = obj.fElements[i * obj.fNcols + j] = arr[cnt++];
   }
};


/** @summary Returns type id by its name
  * @private */
function getTypeId(typname, norecursion) {
   switch (typname) {
      case 'bool':
      case 'Bool_t': return kBool;
      case 'char':
      case 'signed char':
      case 'Char_t': return kChar;
      case 'Color_t':
      case 'Style_t':
      case 'Width_t':
      case 'short':
      case 'Short_t': return kShort;
      case 'int':
      case 'EErrorType':
      case 'Int_t': return kInt;
      case 'long':
      case 'Long_t': return kLong;
      case 'float':
      case 'Float_t': return kFloat;
      case 'double':
      case 'Double_t': return kDouble;
      case 'unsigned char':
      case 'UChar_t': return kUChar;
      case 'unsigned short':
      case 'UShort_t': return kUShort;
      case 'unsigned':
      case 'unsigned int':
      case 'UInt_t': return kUInt;
      case 'unsigned long':
      case 'ULong_t': return kULong;
      case 'int64_t':
      case 'long long':
      case 'Long64_t': return kLong64;
      case 'uint64_t':
      case 'unsigned long long':
      case 'ULong64_t': return kULong64;
      case 'Double32_t': return kDouble32;
      case 'Float16_t': return kFloat16;
      case 'char*':
      case 'const char*':
      case 'const Char_t*': return kCharStar;
   }

   if (!norecursion) {
      let replace = CustomStreamers[typname];
      if (isStr(replace)) return getTypeId(replace, true);
   }

   return -1;
}

/** @summary create element of the streamer
  * @private  */
function createStreamerElement(name, typename, file) {
   const elem = {
      _typename: 'TStreamerElement', fName: name, fTypeName: typename,
      fType: 0, fSize: 0, fArrayLength: 0, fArrayDim: 0, fMaxIndex: [0, 0, 0, 0, 0],
      fXmin: 0, fXmax: 0, fFactor: 0
   };

   if (isStr(typename)) {
      elem.fType = getTypeId(typename);
      if ((elem.fType < 0) && file && file.fBasicTypes[typename])
         elem.fType = file.fBasicTypes[typename];
   } else {
      elem.fType = typename;
      typename = elem.fTypeName = BasicTypeNames[elem.fType] || 'int';
   }

   if (elem.fType > 0) return elem; // basic type

   // check if there are STL containers
   let stltype = kNotSTL, pos = typename.indexOf('<');
   if ((pos > 0) && (typename.indexOf('>') > pos + 2))
      for (let stl = 1; stl < StlNames.length; ++stl)
         if (typename.slice(0, pos) === StlNames[stl]) {
            stltype = stl; break;
         }

   if (stltype !== kNotSTL) {
      elem._typename = clTStreamerSTL;
      elem.fType = kStreamer;
      elem.fSTLtype = stltype;
      elem.fCtype = 0;
      return elem;
   }

   const isptr = (typename.lastIndexOf('*') === typename.length - 1);

   if (isptr)
      elem.fTypeName = typename = typename.slice(0, typename.length - 1);

   if (getArrayKind(typename) == 0) {
      elem.fType = kTString;
      return elem;
   }

   elem.fType = isptr ? kAnyP : kAny;

   return elem;
}


/** @summary Function creates streamer for std::pair object
  * @private */
function getPairStreamer(si, typname, file) {
   if (!si) {
      if (typname.indexOf('pair') !== 0) return null;

      si = file.findStreamerInfo(typname);

      if (!si) {
         let p1 = typname.indexOf('<'), p2 = typname.lastIndexOf('>');
         function GetNextName() {
            let res = '', p = p1 + 1, cnt = 0;
            while ((p < p2) && (cnt >= 0)) {
               switch (typname[p]) {
                  case '<': cnt++; break;
                  case ',': if (cnt === 0) cnt--; break;
                  case '>': cnt--; break;
               }
               if (cnt >= 0) res += typname[p];
               p++;
            }
            p1 = p - 1;
            return res.trim();
         }
         si = { _typename: 'TStreamerInfo', fVersion: 1, fName: typname, fElements: create$1(clTList) };
         si.fElements.Add(createStreamerElement('first', GetNextName(), file));
         si.fElements.Add(createStreamerElement('second', GetNextName(), file));
      }
   }

   let streamer = file.getStreamer(typname, null, si);

   if (!streamer) return null;

   if (streamer.length !== 2) {
      console.error(`Streamer for pair class contains ${streamer.length} elements`);
      return null;
   }

   for (let nn = 0; nn < 2; ++nn)
      if (streamer[nn].readelem && !streamer[nn].pair_name) {
         streamer[nn].pair_name = (nn == 0) ? 'first' : 'second';
         streamer[nn].func = function(buf, obj) {
            obj[this.pair_name] = this.readelem(buf);
         };
      }

   return streamer;
}


/** @summary create member entry for streamer element
  * @desc used for reading of data
  * @private */
function createMemberStreamer(element, file) {
   let member = {
      name: element.fName, type: element.fType,
      fArrayLength: element.fArrayLength,
      fArrayDim: element.fArrayDim,
      fMaxIndex: element.fMaxIndex
   };

   if (element.fTypeName === 'BASE') {
      if (getArrayKind(member.name) > 0) {
         // this is workaround for arrays as base class
         // we create 'fArray' member, which read as any other data member
         member.name = 'fArray';
         member.type = kAny;
      } else {
         // create streamer for base class
         member.type = kBase;
         // this.getStreamer(element.fName);
      }
   }

   switch (member.type) {
      case kBase:
         member.base = element.fBaseVersion; // indicate base class
         member.basename = element.fName; // keep class name
         member.func = function(buf, obj) { buf.classStreamer(obj, this.basename); };
         break;
      case kShort:
         member.func = function(buf, obj) { obj[this.name] = buf.ntoi2(); }; break;
      case kInt:
      case kCounter:
         member.func = function(buf, obj) { obj[this.name] = buf.ntoi4(); }; break;
      case kLong:
      case kLong64:
         member.func = function(buf, obj) { obj[this.name] = buf.ntoi8(); }; break;
      case kDouble:
         member.func = function(buf, obj) { obj[this.name] = buf.ntod(); }; break;
      case kFloat:
         member.func = function(buf, obj) { obj[this.name] = buf.ntof(); }; break;
      case kLegacyChar:
      case kUChar:
         member.func = function(buf, obj) { obj[this.name] = buf.ntou1(); }; break;
      case kUShort:
         member.func = function(buf, obj) { obj[this.name] = buf.ntou2(); }; break;
      case kBits:
      case kUInt:
         member.func = function(buf, obj) { obj[this.name] = buf.ntou4(); }; break;
      case kULong64:
      case kULong:
         member.func = function(buf, obj) { obj[this.name] = buf.ntou8(); }; break;
      case kBool:
         member.func = function(buf, obj) { obj[this.name] = buf.ntou1() != 0; }; break;
      case kOffsetL + kBool:
      case kOffsetL + kInt:
      case kOffsetL + kCounter:
      case kOffsetL + kDouble:
      case kOffsetL + kUChar:
      case kOffsetL + kShort:
      case kOffsetL + kUShort:
      case kOffsetL + kBits:
      case kOffsetL + kUInt:
      case kOffsetL + kULong:
      case kOffsetL + kULong64:
      case kOffsetL + kLong:
      case kOffsetL + kLong64:
      case kOffsetL + kFloat:
         if (element.fArrayDim < 2) {
            member.arrlength = element.fArrayLength;
            member.func = function(buf, obj) {
               obj[this.name] = buf.readFastArray(this.arrlength, this.type - kOffsetL);
            };
         } else {
            member.arrlength = element.fMaxIndex[element.fArrayDim - 1];
            member.minus1 = true;
            member.func = function(buf, obj) {
               obj[this.name] = buf.readNdimArray(this, (buf, handle) =>
                  buf.readFastArray(handle.arrlength, handle.type - kOffsetL));
            };
         }
         break;
      case kOffsetL + kChar:
         if (element.fArrayDim < 2) {
            member.arrlength = element.fArrayLength;
            member.func = function(buf, obj) {
               obj[this.name] = buf.readFastString(this.arrlength);
            };
         } else {
            member.minus1 = true; // one dimension used for char*
            member.arrlength = element.fMaxIndex[element.fArrayDim - 1];
            member.func = function(buf, obj) {
               obj[this.name] = buf.readNdimArray(this, (buf, handle) =>
                  buf.readFastString(handle.arrlength));
            };
         }
         break;
      case kOffsetP + kBool:
      case kOffsetP + kInt:
      case kOffsetP + kDouble:
      case kOffsetP + kUChar:
      case kOffsetP + kShort:
      case kOffsetP + kUShort:
      case kOffsetP + kBits:
      case kOffsetP + kUInt:
      case kOffsetP + kULong:
      case kOffsetP + kULong64:
      case kOffsetP + kLong:
      case kOffsetP + kLong64:
      case kOffsetP + kFloat:
         member.cntname = element.fCountName;
         member.func = function(buf, obj) {
            obj[this.name] = (buf.ntou1() === 1) ? buf.readFastArray(obj[this.cntname], this.type - kOffsetP) : [];
         };
         break;
      case kOffsetP + kChar:
         member.cntname = element.fCountName;
         member.func = function(buf, obj) {
            obj[this.name] = (buf.ntou1() === 1) ? buf.readFastString(obj[this.cntname]) : null;
         };
         break;
      case kDouble32:
      case kOffsetL + kDouble32:
      case kOffsetP + kDouble32:
         member.double32 = true;
      case kFloat16:
      case kOffsetL + kFloat16:
      case kOffsetP + kFloat16:
         if (element.fFactor !== 0) {
            member.factor = 1. / element.fFactor;
            member.min = element.fXmin;
            member.read = function(buf) { return buf.ntou4() * this.factor + this.min; };
         } else
            if ((element.fXmin === 0) && member.double32) {
               member.read = function(buf) { return buf.ntof(); };
            } else {
               member.nbits = Math.round(element.fXmin);
               if (member.nbits === 0) member.nbits = 12;
               member.dv = new DataView(new ArrayBuffer(8), 0); // used to cast from uint32 to float32
               member.read = function(buf) {
                  let theExp = buf.ntou1(), theMan = buf.ntou2();
                  this.dv.setUint32(0, (theExp << 23) | ((theMan & ((1 << (this.nbits + 1)) - 1)) << (23 - this.nbits)));
                  return ((1 << (this.nbits + 1) & theMan) ? -1 : 1) * this.dv.getFloat32(0);
               };
            }

         member.readarr = function(buf, len) {
            let arr = this.double32 ? new Float64Array(len) : new Float32Array(len);
            for (let n = 0; n < len; ++n) arr[n] = this.read(buf);
            return arr;
         };

         if (member.type < kOffsetL) {
            member.func = function(buf, obj) { obj[this.name] = this.read(buf); };
         } else
            if (member.type > kOffsetP) {
               member.cntname = element.fCountName;
               member.func = function(buf, obj) {
                  obj[this.name] = (buf.ntou1() === 1) ? this.readarr(buf, obj[this.cntname]) : null;
               };
            } else
               if (element.fArrayDim < 2) {
                  member.arrlength = element.fArrayLength;
                  member.func = function(buf, obj) { obj[this.name] = this.readarr(buf, this.arrlength); };
               } else {
                  member.arrlength = element.fMaxIndex[element.fArrayDim - 1];
                  member.minus1 = true;
                  member.func = function(buf, obj) {
                     obj[this.name] = buf.readNdimArray(this, (buf, handle) => handle.readarr(buf, handle.arrlength));
                  };
               }
         break;

      case kAnyP:
      case kObjectP:
         member.func = function(buf, obj) {
            obj[this.name] = buf.readNdimArray(this, buf => buf.readObjectAny());
         };
         break;

      case kAny:
      case kAnyp:
      case kObjectp:
      case kObject: {
         let classname = (element.fTypeName === 'BASE') ? element.fName : element.fTypeName;
         if (classname[classname.length - 1] == '*')
            classname = classname.slice(0, classname.length - 1);

         const arrkind = getArrayKind(classname);

         if (arrkind > 0) {
            member.arrkind = arrkind;
            member.func = function(buf, obj) { obj[this.name] = buf.readFastArray(buf.ntou4(), this.arrkind); };
         } else if (arrkind === 0) {
            member.func = function(buf, obj) { obj[this.name] = buf.readTString(); };
         } else {
            member.classname = classname;

            if (element.fArrayLength > 1) {
               member.func = function(buf, obj) {
                  obj[this.name] = buf.readNdimArray(this, (buf, handle) => buf.classStreamer({}, handle.classname));
               };
            } else {
               member.func = function(buf, obj) {
                  obj[this.name] = buf.classStreamer({}, this.classname);
               };
            }
         }
         break;
      }
      case kOffsetL + kObject:
      case kOffsetL + kAny:
      case kOffsetL + kAnyp:
      case kOffsetL + kObjectp: {
         let classname = element.fTypeName;
         if (classname[classname.length - 1] == '*')
            classname = classname.slice(0, classname.length - 1);

         member.arrkind = getArrayKind(classname);
         if (member.arrkind < 0) member.classname = classname;
         member.func = function(buf, obj) {
            obj[this.name] = buf.readNdimArray(this, (buf, handle) => {
               if (handle.arrkind > 0) return buf.readFastArray(buf.ntou4(), handle.arrkind);
               if (handle.arrkind === 0) return buf.readTString();
               return buf.classStreamer({}, handle.classname);
            });
         };
         break;
      }
      case kChar:
         member.func = function(buf, obj) { obj[this.name] = buf.ntoi1(); }; break;
      case kCharStar:
         member.func = function(buf, obj) {
            const len = buf.ntoi4();
            obj[this.name] = buf.substring(buf.o, buf.o + len);
            buf.o += len;
         };
         break;
      case kTString:
         member.func = function(buf, obj) { obj[this.name] = buf.readTString(); };
         break;
      case kTObject:
      case kTNamed:
         member.typename = element.fTypeName;
         member.func = function(buf, obj) { obj[this.name] = buf.classStreamer({}, this.typename); };
         break;
      case kOffsetL + kTString:
      case kOffsetL + kTObject:
      case kOffsetL + kTNamed:
         member.typename = element.fTypeName;
         member.func = function(buf, obj) {
            const ver = buf.readVersion();
            obj[this.name] = buf.readNdimArray(this, (buf, handle) => {
               if (handle.typename === clTString) return buf.readTString();
               return buf.classStreamer({}, handle.typename);
            });
            buf.checkByteCount(ver, this.typename + '[]');
         };
         break;
      case kStreamLoop:
      case kOffsetL + kStreamLoop:
         member.typename = element.fTypeName;
         member.cntname = element.fCountName;

         if (member.typename.lastIndexOf('**') > 0) {
            member.typename = member.typename.slice(0, member.typename.lastIndexOf('**'));
            member.isptrptr = true;
         } else {
            member.typename = member.typename.slice(0, member.typename.lastIndexOf('*'));
            member.isptrptr = false;
         }

         if (member.isptrptr) {
            member.readitem = function(buf) { return buf.readObjectAny(); };
         } else {
            member.arrkind = getArrayKind(member.typename);
            if (member.arrkind > 0)
               member.readitem = function(buf) { return buf.readFastArray(buf.ntou4(), this.arrkind); };
            else if (member.arrkind === 0)
               member.readitem = function(buf) { return buf.readTString(); };
            else
               member.readitem = function(buf) { return buf.classStreamer({}, this.typename); };
         }

         if (member.readitem !== undefined) {
            member.read_loop = function(buf, cnt) {
               return buf.readNdimArray(this, (buf2, member2) => {
                  let itemarr = new Array(cnt);
                  for (let i = 0; i < cnt; ++i)
                     itemarr[i] = member2.readitem(buf2);
                  return itemarr;
               });
            };

            member.func = function(buf, obj) {
               const ver = buf.readVersion(),
                     res = this.read_loop(buf, obj[this.cntname]);
               obj[this.name] = buf.checkByteCount(ver, this.typename) ? res : null;
            };
            member.branch_func = function(buf, obj) {
               // this is special functions, used by branch in the STL container
               const ver = buf.readVersion(), sz0 = obj[this.stl_size], res = new Array(sz0);

               for (let loop0 = 0; loop0 < sz0; ++loop0) {
                  let cnt = obj[this.cntname][loop0];
                  res[loop0] = this.read_loop(buf, cnt);
               }
               obj[this.name] = buf.checkByteCount(ver, this.typename) ? res : null;
            };

            member.objs_branch_func = function(buf, obj) {
               // special function when branch read as part of complete object
               // objects already preallocated and only appropriate member must be set
               // see code in JSRoot.tree.js for reference

               const ver = buf.readVersion(),
                     arr = obj[this.name0]; // objects array where reading is done

               for (let loop0 = 0; loop0 < arr.length; ++loop0) {
                  let obj1 = this.get(arr, loop0), cnt = obj1[this.cntname];
                  obj1[this.name] = this.read_loop(buf, cnt);
               }

               buf.checkByteCount(ver, this.typename);
            };

         } else {
            console.error(`fail to provide function for ${element.fName} (${element.fTypeName})  typ = ${element.fType}`);
            member.func = function(buf, obj) {
               const ver = buf.readVersion();
               buf.checkByteCount(ver);
               obj[this.name] = null;
            };
         }

         break;

      case kStreamer: {
         member.typename = element.fTypeName;

         let stl = (element.fSTLtype || 0) % 40;

         if ((element._typename === 'TStreamerSTLstring') ||
            (member.typename == 'string') || (member.typename == 'string*')) {
            member.readelem = buf => buf.readTString();
         } else if ((stl === kSTLvector) || (stl === kSTLlist) ||
                    (stl === kSTLdeque) || (stl === kSTLset) || (stl === kSTLmultiset)) {
            let p1 = member.typename.indexOf('<'),
                p2 = member.typename.lastIndexOf('>');

            member.conttype = member.typename.slice(p1 + 1, p2).trim();

            member.typeid = getTypeId(member.conttype);
            if ((member.typeid < 0) && file.fBasicTypes[member.conttype]) {
               member.typeid = file.fBasicTypes[member.conttype];
               console.log(`!!! Reuse basic type ${member.conttype} from file streamer infos`);
            }

            // check
            if (element.fCtype && (element.fCtype < 20) && (element.fCtype !== member.typeid)) {
               console.warn(`Contained type ${member.conttype} not recognized as basic type ${element.fCtype} FORCE`);
               member.typeid = element.fCtype;
            }

            if (member.typeid > 0) {
               member.readelem = function(buf) {
                  return buf.readFastArray(buf.ntoi4(), this.typeid);
               };
            } else {
               member.isptr = false;

               if (member.conttype.lastIndexOf('*') === member.conttype.length - 1) {
                  member.isptr = true;
                  member.conttype = member.conttype.slice(0, member.conttype.length - 1);
               }

               if (element.fCtype === kObjectp) member.isptr = true;

               member.arrkind = getArrayKind(member.conttype);

               member.readelem = readVectorElement;

               if (!member.isptr && (member.arrkind < 0)) {

                  let subelem = createStreamerElement('temp', member.conttype);

                  if (subelem.fType === kStreamer) {
                     subelem.$fictional = true;
                     member.submember = createMemberStreamer(subelem, file);
                  }
               }
            }
         } else if ((stl === kSTLmap) || (stl === kSTLmultimap)) {
            const p1 = member.typename.indexOf('<'),
                  p2 = member.typename.lastIndexOf('>');

            member.pairtype = 'pair<' + member.typename.slice(p1 + 1, p2) + '>';

            // remember found streamer info from the file -
            // most probably it is the only one which should be used
            member.si = file.findStreamerInfo(member.pairtype);

            member.streamer = getPairStreamer(member.si, member.pairtype, file);

            if (!member.streamer || (member.streamer.length !== 2)) {
               console.error(`Fail to build streamer for pair ${member.pairtype}`);
               delete member.streamer;
            }

            if (member.streamer) member.readelem = readMapElement;
         } else if (stl === kSTLbitset) {
            member.readelem = (buf/*, obj*/) => buf.readFastArray(buf.ntou4(), kBool);
         }

         if (!member.readelem) {
            console.error(`failed to create streamer for element ${member.typename} ${member.name} element ${element._typename} STL type ${element.fSTLtype}`);
            member.func = function(buf, obj) {
               const ver = buf.readVersion();
               buf.checkByteCount(ver);
               obj[this.name] = null;
            };
         } else
            if (!element.$fictional) {

               member.read_version = function(buf, cnt) {
                  if (cnt === 0) return null;
                  const ver = buf.readVersion();
                  this.member_wise = ((ver.val & kStreamedMemberWise) !== 0);

                  this.stl_version = undefined;
                  if (this.member_wise) {
                     ver.val = ver.val & ~kStreamedMemberWise;
                     this.stl_version = { val: buf.ntoi2() };
                     if (this.stl_version.val <= 0) this.stl_version.checksum = buf.ntou4();
                  }
                  return ver;
               };

               member.func = function(buf, obj) {
                  const ver = this.read_version(buf);

                  let res = buf.readNdimArray(this, (buf2, member2) => member2.readelem(buf2));

                  if (!buf.checkByteCount(ver, this.typename)) res = null;
                  obj[this.name] = res;
               };

               member.branch_func = function(buf, obj) {
                  // special function to read data from STL branch
                  const cnt = obj[this.stl_size],
                        ver = this.read_version(buf, cnt);
                  let arr = new Array(cnt);

                  for (let n = 0; n < cnt; ++n)
                     arr[n] = buf.readNdimArray(this, (buf2, member2) => member2.readelem(buf2));

                  if (ver) buf.checkByteCount(ver, `branch ${this.typename}`);

                  obj[this.name] = arr;
               };
               member.split_func = function(buf, arr, n) {
                  // function to read array from member-wise streaming
                  const ver = this.read_version(buf);
                  for (let i = 0; i < n; ++i)
                     arr[i][this.name] = buf.readNdimArray(this, (buf2, member2) => member2.readelem(buf2));
                  buf.checkByteCount(ver, this.typename);
               };
               member.objs_branch_func = function(buf, obj) {
                  // special function when branch read as part of complete object
                  // objects already preallocated and only appropriate member must be set
                  // see code in JSRoot.tree.js for reference

                  let arr = obj[this.name0]; // objects array where reading is done

                  const ver = this.read_version(buf, arr.length);

                  for (let n = 0; n < arr.length; ++n) {
                     let obj1 = this.get(arr, n);
                     obj1[this.name] = buf.readNdimArray(this, (buf2, member2) => member2.readelem(buf2));
                  }

                  if (ver) buf.checkByteCount(ver, `branch ${this.typename}`);
               };
            }
         break;
      }

      default:
         console.error(`fail to provide function for ${element.fName} (${element.fTypeName})  typ = ${element.fType}`);

         member.func = function(/*buf, obj*/) { };  // do nothing, fix in the future
   }

   return member;
}


/** @summary Analyze and returns arrays kind
  * @return 0 if TString (or equivalent), positive value - some basic type, -1 - any other kind
  * @private */
function getArrayKind(type_name) {
   if ((type_name === clTString) || (type_name === 'string') ||
      (CustomStreamers[type_name] === clTString)) return 0;
   if ((type_name.length < 7) || (type_name.indexOf('TArray') !== 0)) return -1;
   if (type_name.length == 7)
      switch (type_name[6]) {
         case 'I': return kInt;
         case 'D': return kDouble;
         case 'F': return kFloat;
         case 'S': return kShort;
         case 'C': return kChar;
         case 'L': return kLong;
         default: return -1;
      }

   return type_name == 'TArrayL64' ? kLong64 : -1;
}

/** @summary Let directly assign methods when doing I/O
  * @private */
function addClassMethods(clname, streamer) {
   if (streamer === null) return streamer;

   let methods = getMethods(clname);

   if (methods)
      for (let key in methods)
         if (isFunc(methods[key]) || (key.indexOf('_') == 0))
            streamer.push({
               name: key,
               method: methods[key],
               func(buf, obj) { obj[this.name] = this.method; }
            });

   return streamer;
}


/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
 * Version: 1.0.0.1
 * LastModified: Dec 25 1999
 * original: http://www.onicos.com/staff/iz/amuse/javascript/expert/inflate.txt
 */

/* constant parameters */
const zip_WSIZE = 32768;       // Sliding Window size

/* constant tables (inflate) */
const zip_MASK_BITS = [
   0x0000,
   0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
   0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff],

// Tables for deflate from PKZIP's appnote.txt.
   zip_cplens = [ // Copy lengths for literal codes 257..285
   3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
   35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0],

/* note: see note #13 above about the 258 in this list. */
   zip_cplext = [ // Extra bits for literal codes 257..285
   0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
   3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99], // 99==invalid

   zip_cpdist = [ // Copy offsets for distance codes 0..29
   1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
   257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
   8193, 12289, 16385, 24577],

   zip_cpdext = [ // Extra bits for distance codes
   0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
   7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
   12, 12, 13, 13],

   zip_border = [  // Order of the bit length code lengths
   16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

//    zip_STORED_BLOCK = 0,
//    zip_STATIC_TREES = 1,
//    zip_DYN_TREES    = 2,

/* for inflate */
//    zip_lbits = 9,            // bits in base literal/length lookup table
//    zip_dbits = 6,            // bits in base distance lookup table
//    zip_INBUFSIZ = 32768,     // Input buffer size
//    zip_INBUF_EXTRA = 64,     // Extra buffer

function ZIP_inflate(arr, tgt) {

   /* variables (inflate) */
   let zip_slide = new Array(2 * zip_WSIZE),
       zip_wp = 0,                // current position in slide
       zip_fixed_tl = null,      // inflate static
       zip_fixed_td,             // inflate static
       zip_fixed_bl, zip_fixed_bd,   // inflate static
       zip_bit_buf = 0,            // bit buffer
       zip_bit_len = 0,           // bits in bit buffer
       zip_method = -1,
       zip_eof = false,
       zip_copy_leng = 0,
       zip_copy_dist = 0,
       zip_tl = null, zip_td,    // literal/length and distance decoder tables
       zip_bl, zip_bd,           // number of bits decoded by tl and td
       zip_inflate_data = arr,
       zip_inflate_datalen = arr.byteLength,
       zip_inflate_pos = 0;

   function zip_NEEDBITS(n) {
      while (zip_bit_len < n) {
         if (zip_inflate_pos < zip_inflate_datalen)
            zip_bit_buf |= zip_inflate_data[zip_inflate_pos++] << zip_bit_len;
         zip_bit_len += 8;
      }
   }

   function zip_GETBITS(n) {
      return zip_bit_buf & zip_MASK_BITS[n];
   }

   function zip_DUMPBITS(n) {
      zip_bit_buf >>= n;
      zip_bit_len -= n;
   }

   /* objects (inflate) */
   function zip_HuftBuild(b,     // code lengths in bits (all assumed <= BMAX)
                          n,     // number of codes (assumed <= N_MAX)
                          s,     // number of simple-valued codes (0..s-1)
                          d,     // list of base values for non-simple codes
                          e,     // list of extra bits for non-simple codes
                          mm ) { // maximum lookup bits

      this.status = 0;     // 0: success, 1: incomplete table, 2: bad input
      this.root = null;    // (zip_HuftList) starting table
      this.m = 0;          // maximum lookup bits, returns actual

   /* Given a list of code lengths and a maximum table size, make a set of
      tables to decode that set of codes. Return zero on success, one if
      the given code set is incomplete (the tables are still built in this
      case), two if the input is invalid (all zero length codes or an
      oversubscribed set of lengths), and three if not enough memory.
      The code with value 256 is special, and the tables are constructed
      so that no bits beyond that code are fetched when that code is
      decoded. */

      const BMAX = 16,      // maximum bit length of any code
            N_MAX = 288;    // maximum number of codes in any set
      let c = Array(BMAX+1).fill(0),  // bit length count table
          lx = Array(BMAX+1).fill(0), // stack of bits per table
          u = Array(BMAX).fill(null), // zip_HuftNode[BMAX][]  table stack
          v = Array(N_MAX).fill(0), // values in order of bit length
          x = Array(BMAX+1).fill(0),// bit offsets, then code stack
          r = { e: 0, b: 0, n: 0, t: null }, // new zip_HuftNode(), // table entry for structure assignment
          rr = null, // temporary variable, use in assignment
          el = (n > 256) ? b[256] : BMAX, // set length of EOB code, if any
          a,         // counter for codes of length k
          f,         // i repeats in table every f entries
          g,         // maximum code length
          h,         // table level
          j,         // counter
          k,         // number of bits in current code
          p = b,     // pointer into c[], b[], or v[]
          pidx = 0,  // index of p
          q,         // (zip_HuftNode) points to current table
          w,
          xp,        // pointer into x or c
          y,         // number of dummy codes added
          z,         // number of entries in current table
          o,
          tail = this.root = null, // (zip_HuftList)
          i = n;         // counter, current code

      // Generate counts for each bit length
      do {
         c[p[pidx++]]++; // assume all entries <= BMAX
      } while (--i > 0);

      if (c[0] == n) {   // null input--all zero length codes
         this.root = null;
         this.m = 0;
         this.status = 0;
         return this;
      }

      // Find minimum and maximum length, bound *m by those
      for (j = 1; j <= BMAX; ++j)
         if (c[j] != 0)
            break;
      k = j;         // minimum code length
      if (mm < j)
         mm = j;
      for (i = BMAX; i != 0; --i)
         if (c[i] != 0)
            break;
      g = i;         // maximum code length
      if (mm > i)
         mm = i;

      // Adjust last length count to fill out codes, if needed
      for (y = 1 << j; j < i; ++j, y <<= 1) {
         if ((y -= c[j]) < 0) {
            this.status = 2;  // bad input: more codes than bits
            this.m = mm;
            return this;
         }
      }
      if ((y -= c[i]) < 0) {
         this.status = 2;
         this.m = mm;
         return this;
      }
      c[i] += y;

      // Generate starting offsets into the value table for each length
      x[1] = j = 0;
      p = c;
      pidx = 1;
      xp = 2;
      while (--i > 0)    // note that i == g from above
         x[xp++] = (j += p[pidx++]);

      // Make a table of values in order of bit lengths
      p = b; pidx = 0;
      i = 0;
      do {
         if ((j = p[pidx++]) != 0)
            v[x[j]++] = i;
      } while (++i < n);
      n = x[g];         // set n to length of v

      // Generate the Huffman codes and for each, make the table entries
      x[0] = i = 0;     // first Huffman code is zero
      p = v; pidx = 0;     // grab values in bit order
      h = -1;        // no tables yet--level -1
      w = lx[0] = 0;    // no bits decoded yet
      q = null;         // ditto
      z = 0;         // ditto

      // go through the bit lengths (k already is bits in shortest code)
      for (; k <= g; ++k) {
         a = c[k];
         while (a-- > 0) {
            // here i is the Huffman code of length k bits for value p[pidx]
            // make tables up to required level
            while (k > w + lx[1 + h]) {
               w += lx[1 + h++]; // add bits already decoded

               // compute minimum size table less than or equal to *m bits
               z = (z = g - w) > mm ? mm : z; // upper limit
               if ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table
                  // too few codes for k-w bit table
                  f -= a + 1; // deduct codes from patterns left
                  xp = k;
                  while (++j < z) { // try smaller tables up to z bits
                     if ((f <<= 1) <= c[++xp])
                        break;   // enough codes to use up j bits
                     f -= c[xp];   // else deduct codes from patterns
                  }
               }
               if (w + j > el && w < el)
                  j = el - w; // make EOB code end at table
               z = 1 << j;   // table entries for j-bit table
               lx[1 + h] = j; // set table size in stack

               // allocate and link in new table
               q = new Array(z);
               for (o = 0; o < z; ++o)
                  q[o] = { e: 0, b: 0, n: 0, t: null }; // new zip_HuftNode

               if (tail == null)
                  tail = this.root = { next: null, list: null }; // new zip_HuftList();
               else
                  tail = tail.next = { next: null, list: null }; // new zip_HuftList();
               tail.next = null;
               tail.list = q;
               u[h] = q;  // table starts after link

               /* connect to last table, if there is one */
               if (h > 0) {
                  x[h] = i;      // save pattern for backing up
                  r.b = lx[h];   // bits to dump before this table
                  r.e = 16 + j;  // bits in this table
                  r.t = q;    // pointer to this table
                  j = (i & ((1 << w) - 1)) >> (w - lx[h]);
                  rr = u[h-1][j];
                  rr.e = r.e;
                  rr.b = r.b;
                  rr.n = r.n;
                  rr.t = r.t;
               }
            }

            // set up table entry in r
            r.b = k - w;
            if (pidx >= n)
               r.e = 99;     // out of values--invalid code
            else if (p[pidx] < s) {
               r.e = (p[pidx] < 256 ? 16 : 15); // 256 is end-of-block code
               r.n = p[pidx++]; // simple code is just the value
            } else {
               r.e = e[p[pidx] - s];  // non-simple--look up in lists
               r.n = d[p[pidx++] - s];
            }

            // fill code-like entries with r //
            f = 1 << (k - w);
            for (j = i >> w; j < z; j += f) {
               rr = q[j];
               rr.e = r.e;
               rr.b = r.b;
               rr.n = r.n;
               rr.t = r.t;
            }

            // backwards increment the k-bit code i
            for (j = 1 << (k - 1); (i & j) != 0; j >>= 1)
               i ^= j;
            i ^= j;

            // backup over finished tables
            while ((i & ((1 << w) - 1)) != x[h]) {
               w -= lx[h--];      // don't need to update q
            }
         }
      }

      /* return actual size of base table */
      this.m = lx[1];

      /* Return true (1) if we were given an incomplete table */
      this.status = ((y != 0 && g != 1) ? 1 : 0);
     /* end of constructor */

      return this;
   }

   /* routines (inflate) */

   function zip_inflate_codes(buff, off, size) {
      if (size == 0) return 0;

      /* inflate (decompress) the codes in a deflated (compressed) block.
         Return an error code or zero if it all goes ok. */

      let e,     // table entry flag/number of extra bits
          t,     // (zip_HuftNode) pointer to table entry
          n = 0;

      // inflate the coded data
      for (;;) {        // do until end of block
         zip_NEEDBITS(zip_bl);
         t = zip_tl.list[zip_GETBITS(zip_bl)];
         e = t.e;
         while (e > 16) {
            if (e == 99)
               return -1;
            zip_DUMPBITS(t.b);
            e -= 16;
            zip_NEEDBITS(e);
            t = t.t[zip_GETBITS(e)];
            e = t.e;
         }
         zip_DUMPBITS(t.b);

         if (e == 16) {     // then it's a literal
            zip_wp &= zip_WSIZE - 1;
            buff[off + n++] = zip_slide[zip_wp++] = t.n;
            if (n == size)
               return size;
            continue;
         }

         // exit if end of block
         if (e == 15)
            break;

         // it's an EOB or a length

         // get length of block to copy
         zip_NEEDBITS(e);
         zip_copy_leng = t.n + zip_GETBITS(e);
         zip_DUMPBITS(e);

         // decode distance of block to copy
         zip_NEEDBITS(zip_bd);
         t = zip_td.list[zip_GETBITS(zip_bd)];
         e = t.e;

         while (e > 16) {
            if (e == 99)
               return -1;
            zip_DUMPBITS(t.b);
            e -= 16;
            zip_NEEDBITS(e);
            t = t.t[zip_GETBITS(e)];
            e = t.e;
         }
         zip_DUMPBITS(t.b);
         zip_NEEDBITS(e);
         zip_copy_dist = zip_wp - t.n - zip_GETBITS(e);
         zip_DUMPBITS(e);

         // do the copy
         while (zip_copy_leng > 0 && n < size) {
            --zip_copy_leng;
            zip_copy_dist &= zip_WSIZE - 1;
            zip_wp &= zip_WSIZE - 1;
            buff[off + n++] = zip_slide[zip_wp++] = zip_slide[zip_copy_dist++];
         }

         if (n == size)
            return size;
      }

      zip_method = -1; // done
      return n;
   }

   function zip_inflate_stored(buff, off, size) {
      /* 'decompress' an inflated type 0 (stored) block. */

      // go to byte boundary
      let n = zip_bit_len & 7;
      zip_DUMPBITS(n);

      // get the length and its complement
      zip_NEEDBITS(16);
      n = zip_GETBITS(16);
      zip_DUMPBITS(16);
      zip_NEEDBITS(16);
      if (n != ((~zip_bit_buf) & 0xffff))
         return -1;        // error in compressed data
      zip_DUMPBITS(16);

      // read and output the compressed data
      zip_copy_leng = n;

      n = 0;
      while (zip_copy_leng > 0 && n < size) {
         --zip_copy_leng;
         zip_wp &= zip_WSIZE - 1;
         zip_NEEDBITS(8);
         buff[off + n++] = zip_slide[zip_wp++] = zip_GETBITS(8);
         zip_DUMPBITS(8);
      }

      if (zip_copy_leng == 0)
         zip_method = -1; // done
      return n;
   }

   function zip_inflate_fixed(buff, off, size) {
      /* decompress an inflated type 1 (fixed Huffman codes) block.  We should
         either replace this with a custom decoder, or at least precompute the
         Huffman tables. */

      // if first time, set up tables for fixed blocks
      if (zip_fixed_tl == null) {

         // literal table
         let l = Array(288).fill(8, 0, 144).fill(9, 144, 256).fill(7, 256, 280).fill(8, 280, 288);
         // make a complete, but wrong code set
         zip_fixed_bl = 7;

         let h = new zip_HuftBuild(l, 288, 257, zip_cplens, zip_cplext, zip_fixed_bl);
         if (h.status != 0)
            throw new Error('HufBuild error: ' + h.status);
         zip_fixed_tl = h.root;
         zip_fixed_bl = h.m;

         // distance table
         l.fill(5, 0, 30); // make an incomplete code set
         zip_fixed_bd = 5;

         h = new zip_HuftBuild(l, 30, 0, zip_cpdist, zip_cpdext, zip_fixed_bd);
         if (h.status > 1) {
            zip_fixed_tl = null;
            throw new Error('HufBuild error: '+h.status);
         }
         zip_fixed_td = h.root;
         zip_fixed_bd = h.m;
      }

      zip_tl = zip_fixed_tl;
      zip_td = zip_fixed_td;
      zip_bl = zip_fixed_bl;
      zip_bd = zip_fixed_bd;
      return zip_inflate_codes(buff, off, size);
   }

   function zip_inflate_dynamic(buff, off, size) {
      // decompress an inflated type 2 (dynamic Huffman codes) block.
      let i,j,    // temporary variables
          l,     // last length
          n,     // number of lengths to get
          t,     // (zip_HuftNode) literal/length code table
          h,     // (zip_HuftBuild)
          ll = new Array(286+30).fill(0); // literal/length and distance code lengths

      // read in table lengths
      zip_NEEDBITS(5);
      const nl = 257 + zip_GETBITS(5);   // number of literal/length codes
      zip_DUMPBITS(5);
      zip_NEEDBITS(5);
      const nd = 1 + zip_GETBITS(5);  // number of distance codes
      zip_DUMPBITS(5);
      zip_NEEDBITS(4);
      const nb = 4 + zip_GETBITS(4);  // number of bit length codes
      zip_DUMPBITS(4);
      if (nl > 286 || nd > 30)
         return -1;     // bad lengths

      // read in bit-length-code lengths
      for (j = 0; j < nb; ++j) {
         zip_NEEDBITS(3);
         ll[zip_border[j]] = zip_GETBITS(3);
         zip_DUMPBITS(3);
      }
      for (; j < 19; ++j)
         ll[zip_border[j]] = 0;

      // build decoding table for trees--single level, 7 bit lookup
      zip_bl = 7;
      h = new zip_HuftBuild(ll, 19, 19, null, null, zip_bl);
      if (h.status != 0)
         return -1;  // incomplete code set

      zip_tl = h.root;
      zip_bl = h.m;

      // read in literal and distance code lengths
      n = nl + nd;
      i = l = 0;
      while (i < n) {
         zip_NEEDBITS(zip_bl);
         t = zip_tl.list[zip_GETBITS(zip_bl)];
         j = t.b;
         zip_DUMPBITS(j);
         j = t.n;
         if (j < 16) // length of code in bits (0..15)
            ll[i++] = l = j; // save last length in l
         else if (j == 16) {   // repeat last length 3 to 6 times
            zip_NEEDBITS(2);
            j = 3 + zip_GETBITS(2);
            zip_DUMPBITS(2);
            if (i + j > n)
               return -1;
            while (j-- > 0)
               ll[i++] = l;
         } else if (j == 17) { // 3 to 10 zero length codes
            zip_NEEDBITS(3);
            j = 3 + zip_GETBITS(3);
            zip_DUMPBITS(3);
            if (i + j > n)
               return -1;
            while (j-- > 0)
               ll[i++] = 0;
            l = 0;
         } else {    // j == 18: 11 to 138 zero length codes
            zip_NEEDBITS(7);
            j = 11 + zip_GETBITS(7);
            zip_DUMPBITS(7);
            if (i + j > n)
               return -1;
            while (j-- > 0)
               ll[i++] = 0;
            l = 0;
         }
      }

      // build the decoding tables for literal/length and distance codes
      zip_bl = 9; // zip_lbits;
      h = new zip_HuftBuild(ll, nl, 257, zip_cplens, zip_cplext, zip_bl);
      if (zip_bl == 0)  // no literals or lengths
         h.status = 1;
      if (h.status != 0) {
         // if (h.status == 1); // **incomplete literal tree**
         return -1;     // incomplete code set
      }
      zip_tl = h.root;
      zip_bl = h.m;

      for (i = 0; i < nd; ++i)
         ll[i] = ll[i + nl];
      zip_bd = 6; // zip_dbits;
      h = new zip_HuftBuild(ll, nd, 0, zip_cpdist, zip_cpdext, zip_bd);
      zip_td = h.root;
      zip_bd = h.m;

      if (zip_bd == 0 && nl > 257) {   // lengths but no distances
         // **incomplete distance tree**
         return -1;
      }

      //if (h.status == 1); // **incomplete distance tree**

      if (h.status != 0)
         return -1;

      // decompress until an end-of-block code
      return zip_inflate_codes(buff, off, size);
   }

   function zip_inflate_internal(buff, off, size) {
      // decompress an inflated entry
      let n = 0, i;

      while (n < size) {
         if (zip_eof && zip_method == -1)
            return n;

         if (zip_copy_leng > 0) {
            if (zip_method != 0 /*zip_STORED_BLOCK*/) {
               // STATIC_TREES or DYN_TREES
               while (zip_copy_leng > 0 && n < size) {
                  --zip_copy_leng;
                  zip_copy_dist &= zip_WSIZE - 1;
                  zip_wp &= zip_WSIZE - 1;
                  buff[off + n++] = zip_slide[zip_wp++] =
                  zip_slide[zip_copy_dist++];
               }
            } else {
               while (zip_copy_leng > 0 && n < size) {
                  --zip_copy_leng;
                  zip_wp &= zip_WSIZE - 1;
                  zip_NEEDBITS(8);
                  buff[off + n++] = zip_slide[zip_wp++] = zip_GETBITS(8);
                  zip_DUMPBITS(8);
               }
               if (zip_copy_leng == 0)
                  zip_method = -1; // done
            }
            if (n == size)
               return n;
         }

         if (zip_method == -1) {
            if (zip_eof)
               break;

            // read in last block bit
            zip_NEEDBITS(1);
            if (zip_GETBITS(1) != 0)
               zip_eof = true;
            zip_DUMPBITS(1);

            // read in block type
            zip_NEEDBITS(2);
            zip_method = zip_GETBITS(2);
            zip_DUMPBITS(2);
            zip_tl = null;
            zip_copy_leng = 0;
         }

         switch (zip_method) {
            case 0: // zip_STORED_BLOCK
               i = zip_inflate_stored(buff, off + n, size - n);
               break;

            case 1: // zip_STATIC_TREES
               if (zip_tl != null)
                  i = zip_inflate_codes(buff, off + n, size - n);
               else
                  i = zip_inflate_fixed(buff, off + n, size - n);
               break;

            case 2: // zip_DYN_TREES
               if (zip_tl != null)
                  i = zip_inflate_codes(buff, off + n, size - n);
               else
                  i = zip_inflate_dynamic(buff, off + n, size - n);
               break;

            default: // error
               i = -1;
               break;
         }

         if (i == -1)
            return zip_eof ? 0 : -1;
         n += i;
      }
      return n;
   }

   let i, cnt = 0;
   while ((i = zip_inflate_internal(tgt, cnt, Math.min(1024, tgt.byteLength-cnt))) > 0) {
      cnt += i;
   }

   return cnt;
} // function ZIP_inflate

/**
 * https://github.com/pierrec/node-lz4/blob/master/lib/binding.js
 *
 * LZ4 based compression and decompression
 * Copyright (c) 2014 Pierre Curto
 * MIT Licensed
 */

/**
 * Decode a block. Assumptions: input contains all sequences of a
 * chunk, output is large enough to receive the decoded data.
 * If the output buffer is too small, an error will be thrown.
 * If the returned value is negative, an error occured at the returned offset.
 *
 * @param input {Buffer} input data
 * @param output {Buffer} output data
 * @return {Number} number of decoded bytes
 * @private */
function LZ4_uncompress(input, output, sIdx, eIdx) {
   sIdx = sIdx || 0;
   eIdx = eIdx || (input.length - sIdx);
   // Process each sequence in the incoming data
   for (let i = sIdx, n = eIdx, j = 0; i < n;) {
      let token = input[i++];

      // Literals
      let literals_length = (token >> 4);
      if (literals_length > 0) {
         // length of literals
         let l = literals_length + 240;
         while (l === 255) {
            l = input[i++];
            literals_length += l;
         }

         // Copy the literals
         let end = i + literals_length;
         while (i < end) output[j++] = input[i++];

         // End of buffer?
         if (i === n) return j;
      }

      // Match copy
      // 2 bytes offset (little endian)
      const offset = input[i++] | (input[i++] << 8);

      // 0 is an invalid offset value
      if (offset === 0 || offset > j) return -(i-2);

      // length of match copy
      let match_length = (token & 0xf),
          l = match_length + 240;
      while (l === 255) {
         l = input[i++];
         match_length += l;
      }

      // Copy the match
      let pos = j - offset; // position of the match copy in the current output
      const end = j + match_length + 4; // minmatch = 4;
      while (j < end) output[j++] = output[pos++];
   }

   return j;
}

/** @summary Reads header envelope, determines zipped size and unzip content
  * @return {Promise} with unzipped content
  * @private */
async function R__unzip(arr, tgtsize, noalert, src_shift) {

   const HDRSIZE = 9, totallen = arr.byteLength,
        getChar = o => String.fromCharCode(arr.getUint8(o)),
        getCode = o => arr.getUint8(o);

   let curr = src_shift || 0, fullres = 0, tgtbuf = null;

   const nextPortion = () => {

      while (fullres < tgtsize) {

         let fmt = 'unknown', off = 0, CHKSUM = 0;

         if (curr + HDRSIZE >= totallen) {
            if (!noalert) console.error('Error R__unzip: header size exceeds buffer size');
            return Promise.resolve(null);
         }

         if (getChar(curr) == 'Z' && getChar(curr + 1) == 'L' && getCode(curr + 2) == 8) { fmt = 'new'; off = 2; } else
         if (getChar(curr) == 'C' && getChar(curr + 1) == 'S' && getCode(curr + 2) == 8) { fmt = 'old'; off = 0; } else
         if (getChar(curr) == 'X' && getChar(curr + 1) == 'Z' && getCode(curr + 2) == 0) fmt = 'LZMA'; else
         if (getChar(curr) == 'Z' && getChar(curr + 1) == 'S' && getCode(curr + 2) == 1) fmt = 'ZSTD'; else
         if (getChar(curr) == 'L' && getChar(curr + 1) == '4') { fmt = 'LZ4'; off = 0; CHKSUM = 8; }

         /*   C H E C K   H E A D E R   */
         if ((fmt !== 'new') && (fmt !== 'old') && (fmt !== 'LZ4') && (fmt !== 'ZSTD')) {
            if (!noalert) console.error(`R__unzip: ${fmt} format is not supported!`);
            return Promise.resolve(null);
         }

         const srcsize = HDRSIZE + ((getCode(curr + 3) & 0xff) | ((getCode(curr + 4) & 0xff) << 8) | ((getCode(curr + 5) & 0xff) << 16));

         const uint8arr = new Uint8Array(arr.buffer, arr.byteOffset + curr + HDRSIZE + off + CHKSUM, Math.min(arr.byteLength - curr - HDRSIZE - off - CHKSUM, srcsize - HDRSIZE - CHKSUM));

         if (fmt === 'ZSTD')  {
            const handleZsdt = ZstdCodec => {

               return new Promise((resolveFunc, rejectFunc) => {

                  ZstdCodec.run(zstd => {
                     // const simple = new zstd.Simple();
                     const streaming = new zstd.Streaming();

                     // const data2 = simple.decompress(uint8arr);
                     const data2 = streaming.decompress(uint8arr);

                     // console.log(`tgtsize ${tgtsize} zstd size ${data2.length} offset ${data2.byteOffset} rawlen ${data2.buffer.byteLength}`);

                     const reslen = data2.length;

                     if (data2.byteOffset !== 0)
                        return rejectFunc(Error('ZSTD result with byteOffset != 0'));

                     // shortcut when exactly required data unpacked
                     //if ((tgtsize == reslen) && data2.buffer)
                     //   resolveFunc(new DataView(data2.buffer));

                     // need to copy data while zstd does not provide simple way of doing it
                     if (!tgtbuf) tgtbuf = new ArrayBuffer(tgtsize);
                     let tgt8arr = new Uint8Array(tgtbuf, fullres);

                     for(let i = 0; i < reslen; ++i)
                        tgt8arr[i] = data2[i];

                     fullres += reslen;
                     curr += srcsize;
                     resolveFunc(true);
                  });
               });
            };

            let promise = isNodeJs() ? Promise.resolve().then(function () { return _rollup_plugin_ignore_empty_module_placeholder$1; }).then(handle => handleZsdt(handle.ZstdCodec))
                                        : loadScript('../../zstd/zstd-codec.min.js')
                                             .catch(() => loadScript('https://root.cern/js/zstd/zstd-codec.min.js'))
                                             .then(() => handleZsdt(ZstdCodec));
            return promise.then(() => nextPortion());
         }

         //  place for unpacking
         if (!tgtbuf) tgtbuf = new ArrayBuffer(tgtsize);

         let tgt8arr = new Uint8Array(tgtbuf, fullres);

         const reslen = (fmt === 'LZ4') ? LZ4_uncompress(uint8arr, tgt8arr) : ZIP_inflate(uint8arr, tgt8arr);
         if (reslen <= 0) break;

         fullres += reslen;
         curr += srcsize;
      }

      if (fullres !== tgtsize) {
         if (!noalert) console.error(`R__unzip: fail to unzip data expects ${tgtsize}, got ${fullres}`);
         return Promise.resolve(null);
      }

      return Promise.resolve(new DataView(tgtbuf));
   };

   return nextPortion();
}


/**
  * @summary Buffer object to read data from TFile
  *
  * @private
  */

class TBuffer {
   constructor(arr, pos, file, length) {
      this._typename = 'TBuffer';
      this.arr = arr;
      this.o = pos || 0;
      this.fFile = file;
      this.length = length || (arr ? arr.byteLength : 0); // use size of array view, blob buffer can be much bigger
      this.clearObjectMap();
      this.fTagOffset = 0;
      this.last_read_version = 0;
   }

   /** @summary locate position in the buffer  */
   locate(pos) { this.o = pos; }

   /** @summary shift position in the buffer  */
   shift(cnt) { this.o += cnt; }

   /** @summary Returns remaining place in the buffer */
   remain() { return this.length - this.o; }

   /** @summary Get mapped object with provided tag */
   getMappedObject(tag) { return this.fObjectMap[tag]; }

   /** @summary Map object */
   mapObject(tag, obj) { if (obj !== null) this.fObjectMap[tag] = obj; }

   /** @summary Map class */
   mapClass(tag, classname) { this.fClassMap[tag] = classname; }

   /** @summary Get mapped class with provided tag */
   getMappedClass(tag) { return (tag in this.fClassMap) ? this.fClassMap[tag] : -1; }

   /** @summary Clear objects map */
   clearObjectMap() {
      this.fObjectMap = {};
      this.fClassMap = {};
      this.fObjectMap[0] = null;
      this.fDisplacement = 0;
   }

   /** @summary  read class version from I/O buffer */
   readVersion() {
      let ver = {}, bytecnt = this.ntou4(); // byte count

      if (bytecnt & kByteCountMask)
         ver.bytecnt = bytecnt - kByteCountMask - 2; // one can check between Read version and end of streamer
      else
         this.o -= 4; // rollback read bytes, this is old buffer without byte count

      this.last_read_version = ver.val = this.ntoi2();
      this.last_read_checksum = 0;
      ver.off = this.o;

      if ((ver.val <= 0) && ver.bytecnt && (ver.bytecnt >= 4)) {
         ver.checksum = this.ntou4();
         if (!this.fFile.findStreamerInfo(undefined, undefined, ver.checksum)) {
            // console.error(`Fail to find streamer info with check sum ${ver.checksum} version ${ver.val}`);
            this.o -= 4; // not found checksum in the list
            delete ver.checksum; // remove checksum
         } else {
            this.last_read_checksum = ver.checksum;
         }
      }
      return ver;
   }

   /** @summary Check bytecount after object streaming */
   checkByteCount(ver, where) {
      if ((ver.bytecnt !== undefined) && (ver.off + ver.bytecnt !== this.o)) {
         if (where)
            console.log(`Missmatch in ${where} bytecount expected = ${ver.bytecnt}  got = ${this.o - ver.off}`);
         this.o = ver.off + ver.bytecnt;
         return false;
      }
      return true;
   }

   /** @summary Read TString object (or equivalent)
     * @desc std::string uses similar binary format */
   readTString() {
      let len = this.ntou1();
      // large strings
      if (len == 255) len = this.ntou4();
      if (len == 0) return '';

      const pos = this.o;
      this.o += len;

      return (this.codeAt(pos) == 0) ? '' : this.substring(pos, pos + len);
   }

    /** @summary read Char_t array as string
      * @desc string either contains all symbols or until 0 symbol */
   readFastString(n) {
      let res = '', code, closed = false;
      for (let i = 0; (n < 0) || (i < n); ++i) {
         code = this.ntou1();
         if (code == 0) { closed = true; if (n < 0) break; }
         if (!closed) res += String.fromCharCode(code);
      }

      return res;
   }

   /** @summary read uint8_t */
   ntou1() { return this.arr.getUint8(this.o++); }

   /** @summary read uint16_t */
   ntou2() {
      const o = this.o; this.o += 2;
      return this.arr.getUint16(o);
   }

   /** @summary read uint32_t */
   ntou4() {
      const o = this.o; this.o += 4;
      return this.arr.getUint32(o);
   }

   /** @summary read uint64_t */
   ntou8() {
      const high = this.arr.getUint32(this.o); this.o += 4;
      const low = this.arr.getUint32(this.o); this.o += 4;
      return (high < 0x200000) ? (high * 0x100000000 + low) : (BigInt(high) * BigInt(0x100000000) + BigInt(low));
   }

   /** @summary read int8_t */
   ntoi1() { return this.arr.getInt8(this.o++); }

   /** @summary read int16_t */
   ntoi2() {
      const o = this.o; this.o += 2;
      return this.arr.getInt16(o);
   }

   /** @summary read int32_t */
   ntoi4() {
      const o = this.o; this.o += 4;
      return this.arr.getInt32(o);
   }

   /** @summary read int64_t */
   ntoi8() {
      const high = this.arr.getUint32(this.o); this.o += 4;
      const low = this.arr.getUint32(this.o); this.o += 4;
      if (high < 0x80000000)
         return (high < 0x200000) ? (high * 0x100000000 + low) : (BigInt(high) * BigInt(0x100000000) + BigInt(low));
      return (~high < 0x200000) ? (-1 - ((~high) * 0x100000000 + ~low)) : (BigInt(-1) - (BigInt(~high) * BigInt(0x100000000) + BigInt(~low)));
   }

   /** @summary read float */
   ntof() {
      const o = this.o; this.o += 4;
      return this.arr.getFloat32(o);
   }

   /** @summary read double */
   ntod() {
      const o = this.o; this.o += 8;
      return this.arr.getFloat64(o);
   }

   /** @summary Reads array of n values from the I/O buffer */
   readFastArray(n, array_type) {
      let array, i = 0, o = this.o;
      const view = this.arr;
      switch (array_type) {
         case kDouble:
            array = new Float64Array(n);
            for (; i < n; ++i, o += 8)
               array[i] = view.getFloat64(o);
            break;
         case kFloat:
            array = new Float32Array(n);
            for (; i < n; ++i, o += 4)
               array[i] = view.getFloat32(o);
            break;
         case kLong:
         case kLong64:
            array = new Array(n);
            for (; i < n; ++i)
               array[i] = this.ntoi8();
            return array; // exit here to avoid conflicts
         case kULong:
         case kULong64:
            array = new Array(n);
            for (; i < n; ++i)
               array[i] = this.ntou8();
            return array; // exit here to avoid conflicts
         case kInt:
         case kCounter:
            array = new Int32Array(n);
            for (; i < n; ++i, o += 4)
               array[i] = view.getInt32(o);
            break;
         case kShort:
            array = new Int16Array(n);
            for (; i < n; ++i, o += 2)
               array[i] = view.getInt16(o);
            break;
         case kUShort:
            array = new Uint16Array(n);
            for (; i < n; ++i, o += 2)
               array[i] = view.getUint16(o);
            break;
         case kChar:
            array = new Int8Array(n);
            for (; i < n; ++i)
               array[i] = view.getInt8(o++);
            break;
         case kBool:
         case kUChar:
            array = new Uint8Array(n);
            for (; i < n; ++i)
               array[i] = view.getUint8(o++);
            break;
         case kTString:
            array = new Array(n);
            for (; i < n; ++i)
               array[i] = this.readTString();
            return array; // exit here to avoid conflicts
         case kDouble32:
            throw new Error('kDouble32 should not be used in readFastArray');
         case kFloat16:
            throw new Error('kFloat16 should not be used in readFastArray');
         // case kBits:
         // case kUInt:
         default:
            array = new Uint32Array(n);
            for (; i < n; ++i, o += 4)
               array[i] = view.getUint32(o);
            break;
      }

      this.o = o;

      return array;
   }

   /** @summary Check if provided regions can be extracted from the buffer */
   canExtract(place) {
      for (let n = 0; n < place.length; n += 2)
         if (place[n] + place[n + 1] > this.length) return false;
      return true;
   }

   /** @summary Extract area */
   extract(place) {
      if (!this.arr || !this.arr.buffer || !this.canExtract(place)) return null;
      if (place.length === 2) return new DataView(this.arr.buffer, this.arr.byteOffset + place[0], place[1]);

      let res = new Array(place.length / 2);

      for (let n = 0; n < place.length; n += 2)
         res[n / 2] = new DataView(this.arr.buffer, this.arr.byteOffset + place[n], place[n + 1]);

      return res; // return array of buffers
   }

   /** @summary Get code at buffer position */
   codeAt(pos) {
      return this.arr.getUint8(pos);
   }

   /** @summary Get part of buffer as string */
   substring(beg, end) {
      let res = '';
      for (let n = beg; n < end; ++n)
         res += String.fromCharCode(this.arr.getUint8(n));
      return res;
   }

   /** @summary Read buffer as N-dim array */
   readNdimArray(handle, func) {
      let ndim = handle.fArrayDim, maxindx = handle.fMaxIndex, res;
      if ((ndim < 1) && (handle.fArrayLength > 0)) { ndim = 1; maxindx = [handle.fArrayLength]; }
      if (handle.minus1) --ndim;

      if (ndim < 1) return func(this, handle);

      if (ndim === 1) {
         res = new Array(maxindx[0]);
         for (let n = 0; n < maxindx[0]; ++n)
            res[n] = func(this, handle);
      } else if (ndim === 2) {
         res = new Array(maxindx[0]);
         for (let n = 0; n < maxindx[0]; ++n) {
            let res2 = new Array(maxindx[1]);
            for (let k = 0; k < maxindx[1]; ++k)
               res2[k] = func(this, handle);
            res[n] = res2;
         }
      } else {
         let indx = [], arr = [], k;
         for (k = 0; k < ndim; ++k) { indx[k] = 0; arr[k] = []; }
         res = arr[0];
         while (indx[0] < maxindx[0]) {
            k = ndim - 1;
            arr[k].push(func(this, handle));
            ++indx[k];
            while ((indx[k] === maxindx[k]) && (k > 0)) {
               indx[k] = 0;
               arr[k - 1].push(arr[k]);
               arr[k] = [];
               ++indx[--k];
            }
         }
      }

      return res;
   }

   /** @summary read TKey data */
   readTKey(key) {
      if (!key) key = {};
      this.classStreamer(key, 'TKey');
      let name = key.fName.replace(/['"]/g, '');
      if (name !== key.fName) {
         key.fRealName = key.fName;
         key.fName = name;
      }
      return key;
   }

   /** @summary reading basket data
     * @desc this is remaining part of TBasket streamer to decode fEntryOffset
     * after unzipping of the TBasket data */
   readBasketEntryOffset(basket, offset) {

      this.locate(basket.fLast - offset);

      if (this.remain() <= 0) {
         if (!basket.fEntryOffset && (basket.fNevBuf <= 1)) basket.fEntryOffset = [basket.fKeylen];
         if (!basket.fEntryOffset) console.warn(`No fEntryOffset when expected for basket with ${basket.fNevBuf} entries`);
         return;
      }

      const nentries = this.ntoi4();
      // there is error in file=reco_103.root&item=Events;2/PCaloHits_g4SimHits_EcalHitsEE_Sim.&opt=dump;num:10;first:101
      // it is workaround, but normally I/O should fail here
      if ((nentries < 0) || (nentries > this.remain() * 4)) {
         console.error(`Error when reading entries offset from basket fNevBuf ${basket.fNevBuf} remains ${this.remain()} want to read ${nentries}`);
         if (basket.fNevBuf <= 1) basket.fEntryOffset = [basket.fKeylen];
         return;
      }

      basket.fEntryOffset = this.readFastArray(nentries, kInt);
      if (!basket.fEntryOffset) basket.fEntryOffset = [basket.fKeylen];

      if (this.remain() > 0)
         basket.fDisplacement = this.readFastArray(this.ntoi4(), kInt);
      else
         basket.fDisplacement = undefined;
   }

   /** @summary read class definition from I/O buffer */
   readClass() {
      const classInfo = { name: -1 }, bcnt = this.ntou4(), startpos = this.o;
      let tag;

      if (!(bcnt & kByteCountMask) || (bcnt == kNewClassTag)) {
         tag = bcnt;
         // bcnt = 0;
      } else {
         tag = this.ntou4();
      }
      if (!(tag & kClassMask)) {
         classInfo.objtag = tag + this.fDisplacement; // indicate that we have deal with objects tag
         return classInfo;
      }
      if (tag == kNewClassTag) {
         // got a new class description followed by a new object
         classInfo.name = this.readFastString(-1);

         if (this.getMappedClass(this.fTagOffset + startpos + kMapOffset) === -1)
            this.mapClass(this.fTagOffset + startpos + kMapOffset, classInfo.name);
      } else {
         // got a tag to an already seen class
         const clTag = (tag & ~kClassMask) + this.fDisplacement;
         classInfo.name = this.getMappedClass(clTag);

         if (classInfo.name === -1)
            console.error(`Did not found class with tag ${clTag}`);
      }

      return classInfo;
   }

   /** @summary Read any object from buffer data */
   readObjectAny() {
      const objtag = this.fTagOffset + this.o + kMapOffset,
            clRef = this.readClass();

      // class identified as object and should be handled so
      if ('objtag' in clRef)
         return this.getMappedObject(clRef.objtag);

      if (clRef.name === -1) return null;

      const arrkind = getArrayKind(clRef.name);
      let obj;

      if (arrkind === 0) {
         obj = this.readTString();
      } else if (arrkind > 0) {
         // reading array, can map array only afterwards
         obj = this.readFastArray(this.ntou4(), arrkind);
         this.mapObject(objtag, obj);
      } else {
         // reading normal object, should map before to
         obj = {};
         this.mapObject(objtag, obj);
         this.classStreamer(obj, clRef.name);
      }

      return obj;
   }

   /** @summary Invoke streamer for specified class  */
   classStreamer(obj, classname) {

      if (obj._typename === undefined) obj._typename = classname;

      const direct = DirectStreamers[classname];
      if (direct) {
         direct(this, obj);
         return obj;
      }

      const ver = this.readVersion(),
            streamer = this.fFile.getStreamer(classname, ver);

      if (streamer !== null) {

         const len = streamer.length;

         for (let n = 0; n < len; ++n)
            streamer[n].func(this, obj);

      } else {
         // just skip bytes belonging to not-recognized object
         // console.warn(`skip object ${classname}`);

         addMethods(obj);
      }

      this.checkByteCount(ver, classname);

      return obj;
   }

} // class TBuffer

// ==============================================================================

/**
  * @summary A class that reads a TDirectory from a buffer.
  *
  * @private
  */

class TDirectory {

   /** @summary constructor */
   constructor(file, dirname, cycle) {
      this.fFile = file;
      this._typename = clTDirectory;
      this.dir_name = dirname;
      this.dir_cycle = cycle;
      this.fKeys = [];
   }

   /** @summary retrieve a key by its name and cycle in the list of keys */
   getKey(keyname, cycle, only_direct) {

      if (typeof cycle != 'number') cycle = -1;
      let bestkey = null;
      for (let i = 0; i < this.fKeys.length; ++i) {
         const key = this.fKeys[i];
         if (!key || (key.fName!==keyname)) continue;
         if (key.fCycle == cycle) { bestkey = key; break; }
         if ((cycle < 0) && (!bestkey || (key.fCycle > bestkey.fCycle))) bestkey = key;
      }
      if (bestkey)
         return only_direct ? bestkey : Promise.resolve(bestkey);

      let pos = keyname.lastIndexOf('/');
      // try to handle situation when object name contains slashed (bad practice anyway)
      while (pos > 0) {
         let dirname = keyname.slice(0, pos),
             subname = keyname.slice(pos+1),
             dirkey = this.getKey(dirname, undefined, true);

         if (dirkey && !only_direct && (dirkey.fClassName.indexOf(clTDirectory) == 0))
            return this.fFile.readObject(this.dir_name + '/' + dirname, 1)
                             .then(newdir => newdir.getKey(subname, cycle));

         pos = keyname.lastIndexOf('/', pos-1);
      }

      return only_direct ? null : Promise.reject(Error(`Key not found ${keyname}`));
   }

   /** @summary Read object from the directory
     * @param {string} name - object name
     * @param {number} [cycle] - cycle number
     * @return {Promise} with read object */
   readObject(obj_name, cycle) {
      return this.fFile.readObject(this.dir_name + '/' + obj_name, cycle);
   }

   /** @summary Read list of keys in directory
     * @return {Promise} with TDirectory object */
   async readKeys(objbuf) {

      objbuf.classStreamer(this, clTDirectory);

      if ((this.fSeekKeys <= 0) || (this.fNbytesKeys <= 0))
         return this;

      return this.fFile.readBuffer([this.fSeekKeys, this.fNbytesKeys]).then(blob => {
         // Read keys of the top directory

         const buf = new TBuffer(blob, 0, this.fFile);

         buf.readTKey();
         const nkeys = buf.ntoi4();

         for (let i = 0; i < nkeys; ++i)
            this.fKeys.push(buf.readTKey());

         this.fFile.fDirectories.push(this);

         return this;
      });
   }

} // class TDirectory

/**
  * @summary Interface to read objects from ROOT files
  *
  * @desc Use {@link openFile} to create instance of the class
  */

class TFile {

   constructor(url) {
      this._typename = 'TFile';
      this.fEND = 0;
      this.fFullURL = url;
      this.fURL = url;
      // when disabled ('+' at the end of file name), complete file content read with single operation
      this.fAcceptRanges = true;
      // use additional time stamp parameter for file name to avoid browser caching problem
      this.fUseStampPar = settings.UseStamp ? 'stamp=' + (new Date).getTime() : false;
      this.fFileContent = null; // this can be full or partial content of the file (if ranges are not supported or if 1K header read from file)
      // stored as TBuffer instance
      this.fMaxRanges = settings.MaxRanges || 200; // maximal number of file ranges requested at once
      this.fDirectories = [];
      this.fKeys = [];
      this.fSeekInfo = 0;
      this.fNbytesInfo = 0;
      this.fTagOffset = 0;
      this.fStreamers = 0;
      this.fStreamerInfos = null;
      this.fFileName = '';
      this.fStreamers = [];
      this.fBasicTypes = {}; // custom basic types, in most case enumerations

      if (!isStr(this.fURL)) return this;

      if (this.fURL[this.fURL.length - 1] === '+') {
         this.fURL = this.fURL.slice(0, this.fURL.length - 1);
         this.fAcceptRanges = false;
      }

      if (this.fURL[this.fURL.length - 1] === '^') {
         this.fURL = this.fURL.slice(0, this.fURL.length - 1);
         this.fSkipHeadRequest = true;
      }

      if (this.fURL[this.fURL.length - 1] === '-') {
         this.fURL = this.fURL.slice(0, this.fURL.length - 1);
         this.fUseStampPar = false;
      }

      if (this.fURL.indexOf('file://') == 0) {
         this.fUseStampPar = false;
         this.fAcceptRanges = false;
      }

      const pos = Math.max(this.fURL.lastIndexOf('/'), this.fURL.lastIndexOf('\\'));
      this.fFileName = pos >= 0 ? this.fURL.slice(pos + 1) : this.fURL;
   }

   /** @summary Assign BufferArray with file contentOpen file
     * @private */
   assignFileContent(bufArray) {
      this.fFileContent = new TBuffer(new DataView(bufArray));
      this.fAcceptRanges = false;
      this.fUseStampPar = false;
      this.fEND = this.fFileContent.length;
   }

   /** @summary Open file
     * @return {Promise} after file keys are read
     * @private */
   async _open() {
      if (!this.fAcceptRanges || this.fSkipHeadRequest)
         return this.readKeys();

      return httpRequest(this.fURL, 'head').then(res => {
         const accept_ranges = res.getResponseHeader('Accept-Ranges');
         if (!accept_ranges) this.fAcceptRanges = false;
         const len = res.getResponseHeader('Content-Length');
         if (len) this.fEND = parseInt(len);
             else this.fAcceptRanges = false;
         return this.readKeys();
      });
   }

   /** @summary read buffer(s) from the file
    * @return {Promise} with read buffers
    * @private */
   async readBuffer(place, filename, progress_callback) {

      if ((this.fFileContent !== null) && !filename && (!this.fAcceptRanges || this.fFileContent.canExtract(place)))
         return this.fFileContent.extract(place);

      let file = this, fileurl = file.fURL, resolveFunc, rejectFunc,
          promise = new Promise((resolve,reject) => { resolveFunc = resolve; rejectFunc = reject; }),
          first = 0, last = 0, blobs = [], read_callback; // array of requested segments

      if (isStr(filename) && filename) {
         const pos = fileurl.lastIndexOf('/');
         fileurl = (pos < 0) ? filename : fileurl.slice(0, pos + 1) + filename;
      }

      function send_new_request(increment) {

         if (increment) {
            first = last;
            last = Math.min(first + file.fMaxRanges * 2, place.length);
            if (first >= place.length) return resolveFunc(blobs);
         }

         let fullurl = fileurl, ranges = 'bytes', totalsz = 0;
         // try to avoid browser caching by adding stamp parameter to URL
         if (file.fUseStampPar) fullurl += ((fullurl.indexOf('?') < 0) ? '?' : '&') + file.fUseStampPar;

         for (let n = first; n < last; n += 2) {
            ranges += (n > first ? ',' : '=') + (place[n] + '-' + (place[n] + place[n + 1] - 1));
            totalsz += place[n + 1]; // accumulated total size
         }
         if (last - first > 2)
            totalsz += (last - first) * 60; // for multi-range ~100 bytes/per request

         return createHttpRequest(fullurl, 'buf', read_callback, undefined, true).then(xhr => {

            if (file.fAcceptRanges) {
               xhr.setRequestHeader('Range', ranges);
               xhr.expected_size = Math.max(Math.round(1.1 * totalsz), totalsz + 200); // 200 if offset for the potential gzip
            }

            if (progress_callback && isFunc(xhr.addEventListener)) {
               let sum1 = 0, sum2 = 0, sum_total = 0;
               for (let n = 1; n < place.length; n += 2) {
                  sum_total += place[n];
                  if (n < first) sum1 += place[n];
                  if (n < last) sum2 += place[n];
               }
               if (!sum_total) sum_total = 1;

               let progress_offest = sum1 / sum_total, progress_this = (sum2 - sum1) / sum_total;
               xhr.addEventListener('progress', function(oEvent) {
                  if (oEvent.lengthComputable)
                     progress_callback(progress_offest + progress_this * oEvent.loaded / oEvent.total);
               });
            }

            xhr.send(null);
         });
      }

      read_callback = function(res) {

         if (!res && file.fUseStampPar && (place[0] === 0) && (place.length === 2)) {
            // if fail to read file with stamp parameter, try once again without it
            file.fUseStampPar = false;
            return send_new_request();
         }

         if (res && (place[0] === 0) && (place.length === 2) && !file.fFileContent) {
            // special case - keep content of first request (could be complete file) in memory

            file.fFileContent = new TBuffer(isStr(res) ? res : new DataView(res));

            if (!file.fAcceptRanges)
               file.fEND = file.fFileContent.length;

            return resolveFunc(file.fFileContent.extract(place));
         }

         if (!res) {
            if ((first === 0) && (last > 2) && (file.fMaxRanges > 1)) {
               // server return no response with multi request - try to decrease ranges count or fail

               if (last / 2 > 200)
                  file.fMaxRanges = 200;
               else if (last / 2 > 50)
                  file.fMaxRanges = 50;
               else if (last / 2 > 20)
                  file.fMaxRanges = 20;
               else if (last / 2 > 5)
                  file.fMaxRanges = 5;
               else
                  file.fMaxRanges = 1;
               last = Math.min(last, file.fMaxRanges * 2);
               // console.log(`Change maxranges to ${file.fMaxRanges} last ${last}`);
               return send_new_request();
            }

            return rejectFunc(Error('Fail to read with several ranges'));
         }

         // if only single segment requested, return result as is
         if (last - first === 2) {
            let b = new DataView(res);
            if (place.length === 2) return resolveFunc(b);
            blobs.push(b);
            return send_new_request(true);
         }

         // object to access response data
         let hdr = this.getResponseHeader('Content-Type'),
            ismulti = isStr(hdr) && (hdr.indexOf('multipart') >= 0),
            view = new DataView(res);

         if (!ismulti) {
            // server may returns simple buffer, which combines all segments together

            let hdr_range = this.getResponseHeader('Content-Range'), segm_start = 0, segm_last = -1;

            if (hdr_range && hdr_range.indexOf('bytes') >= 0) {
               let parts = hdr_range.slice(hdr_range.indexOf('bytes') + 6).split(/[\s-\/]+/);
               if (parts.length === 3) {
                  segm_start = parseInt(parts[0]);
                  segm_last = parseInt(parts[1]);
                  if (!Number.isInteger(segm_start) || !Number.isInteger(segm_last) || (segm_start > segm_last)) {
                     segm_start = 0; segm_last = -1;
                  }
               }
            }

            let canbe_single_segment = (segm_start <= segm_last);
            for (let n = first; n < last; n += 2)
               if ((place[n] < segm_start) || (place[n] + place[n + 1] - 1 > segm_last))
                  canbe_single_segment = false;

            if (canbe_single_segment) {
               for (let n = first; n < last; n += 2)
                  blobs.push(new DataView(res, place[n] - segm_start, place[n + 1]));
               return send_new_request(true);
            }

            if ((file.fMaxRanges === 1) || (first !== 0))
               return rejectFunc(Error('Server returns normal response when multipart was requested, disable multirange support'));

            file.fMaxRanges = 1;
            last = Math.min(last, file.fMaxRanges * 2);

            return send_new_request();
         }

         // multipart messages requires special handling

         let indx = hdr.indexOf('boundary='), boundary = '', n = first, o = 0;
         if (indx > 0) {
            boundary = hdr.slice(indx + 9);
            if ((boundary[0] == '"') && (boundary[boundary.length - 1] == '"'))
               boundary = boundary.slice(1, boundary.length - 1);
            boundary = '--' + boundary;
         } else {
            console.error('Did not found boundary id in the response header');
         }

         while (n < last) {

            let code1, code2 = view.getUint8(o), nline = 0, line = '',
               finish_header = false, segm_start = 0, segm_last = -1;

            while ((o < view.byteLength - 1) && !finish_header && (nline < 5)) {
               code1 = code2;
               code2 = view.getUint8(o + 1);

               if (((code1 == 13) && (code2 == 10)) || (code1 == 10)) {

                  if ((line.length > 2) && (line.slice(0, 2) == '--') && (line !== boundary))
                     return rejectFunc(Error(`Decode multipart message, expect boundary ${boundary} got ${line}`));

                  line = line.toLowerCase();

                  if ((line.indexOf('content-range') >= 0) && (line.indexOf('bytes') > 0)) {
                     let parts = line.slice(line.indexOf('bytes') + 6).split(/[\s-\/]+/);
                     if (parts.length === 3) {
                        segm_start = parseInt(parts[0]);
                        segm_last = parseInt(parts[1]);
                        if (!Number.isInteger(segm_start) || !Number.isInteger(segm_last) || (segm_start > segm_last)) {
                           segm_start = 0; segm_last = -1;
                        }
                     } else {
                        console.error(`Fail to decode content-range ${line} ${parts}`);
                     }
                  }

                  if ((nline > 1) && (line.length === 0)) finish_header = true;

                  nline++; line = '';
                  if (code1 != 10) {
                     o++; code2 = view.getUint8(o + 1);
                  }
               } else {
                  line += String.fromCharCode(code1);
               }
               o++;
            }

            if (!finish_header)
               return rejectFunc(Error('Cannot decode header in multipart message'));

            if (segm_start > segm_last) {
               // fall-back solution, believe that segments same as requested
               blobs.push(new DataView(res, o, place[n + 1]));
               o += place[n + 1];
               n += 2;
            } else {
               while ((n < last) && (place[n] >= segm_start) && (place[n] + place[n + 1] - 1 <= segm_last)) {
                  blobs.push(new DataView(res, o + place[n] - segm_start, place[n + 1]));
                  n += 2;
               }

               o += (segm_last - segm_start + 1);
            }
         }

         send_new_request(true);
      };

      return send_new_request(true).then(() => promise);
   }

   /** @summary Returns file name */
   getFileName() { return this.fFileName; }

   /** @summary Get directory with given name and cycle
    * @desc Function only can be used for already read directories, which are preserved in the memory
    * @private */
   getDir(dirname, cycle) {

      if ((cycle === undefined) && isStr(dirname)) {
         const pos = dirname.lastIndexOf(';');
         if (pos > 0) { cycle = parseInt(dirname.slice(pos + 1)); dirname = dirname.slice(0, pos); }
      }

      for (let j = 0; j < this.fDirectories.length; ++j) {
         const dir = this.fDirectories[j];
         if (dir.dir_name != dirname) continue;
         if ((cycle !== undefined) && (dir.dir_cycle !== cycle)) continue;
         return dir;
      }
      return null;
   }

   /** @summary Retrieve a key by its name and cycle in the list of keys
    * @desc If only_direct not specified, returns Promise while key keys must be read first from the directory
    * @private */
   getKey(keyname, cycle, only_direct) {

      if (typeof cycle != 'number') cycle = -1;
      let bestkey = null;
      for (let i = 0; i < this.fKeys.length; ++i) {
         const key = this.fKeys[i];
         if (!key || (key.fName !== keyname)) continue;
         if (key.fCycle == cycle) { bestkey = key; break; }
         if ((cycle < 0) && (!bestkey || (key.fCycle > bestkey.fCycle))) bestkey = key;
      }
      if (bestkey)
         return only_direct ? bestkey : Promise.resolve(bestkey);

      let pos = keyname.lastIndexOf('/');
      // try to handle situation when object name contains slashes (bad practice anyway)
      while (pos > 0) {
         let dirname = keyname.slice(0, pos),
             subname = keyname.slice(pos + 1),
             dir = this.getDir(dirname);

         if (dir) return dir.getKey(subname, cycle, only_direct);

         let dirkey = this.getKey(dirname, undefined, true);
         if (dirkey && !only_direct && (dirkey.fClassName.indexOf(clTDirectory) == 0))
            return this.readObject(dirname).then(newdir => newdir.getKey(subname, cycle));

         pos = keyname.lastIndexOf('/', pos - 1);
      }

      return only_direct ? null : Promise.reject(Error(`Key not found ${keyname}`));
   }

   /** @summary Read and inflate object buffer described by its key
    * @private */
   async readObjBuffer(key) {

      return this.readBuffer([key.fSeekKey + key.fKeylen, key.fNbytes - key.fKeylen]).then(blob1 => {

         if (key.fObjlen <= key.fNbytes - key.fKeylen) {
            let buf = new TBuffer(blob1, 0, this);
            buf.fTagOffset = key.fKeylen;
            return buf;
         }

         return R__unzip(blob1, key.fObjlen).then(objbuf => {
            if (!objbuf) return Promise.reject(Error('Fail to UNZIP buffer'));
            let buf = new TBuffer(objbuf, 0, this);
            buf.fTagOffset = key.fKeylen;
            return buf;

         });
      });
   }

   /** @summary Read any object from a root file
     * @desc One could specify cycle number in the object name or as separate argument
     * @param {string} obj_name - name of object, may include cycle number like 'hpxpy;1'
     * @param {number} [cycle] - cycle number, also can be included in obj_name
     * @return {Promise} promise with object read
     * @example
     * let f = await openFile('https://root.cern/js/files/hsimple.root');
     * let obj = await f.readObject('hpxpy;1');
     * console.log(`Read object of type ${obj._typename}`); */
   async readObject(obj_name, cycle, only_dir) {

      let pos = obj_name.lastIndexOf(';');
      if (pos > 0) {
         cycle = parseInt(obj_name.slice(pos + 1));
         obj_name = obj_name.slice(0, pos);
      }

      if (typeof cycle != 'number') cycle = -1;
      // remove leading slashes
      while (obj_name.length && (obj_name[0] == '/')) obj_name = obj_name.slice(1);

      // one uses Promises while in some cases we need to
      // read sub-directory to get list of keys
      // in such situation calls are asynchrone
      return this.getKey(obj_name, cycle).then(key => {

         if ((obj_name == nameStreamerInfo) && (key.fClassName == clTList))
            return this.fStreamerInfos;

         let isdir = false;

         if ((key.fClassName == clTDirectory || key.fClassName == clTDirectoryFile)) {
            let dir = this.getDir(obj_name, cycle);
            if (dir) return dir;
            isdir = true;
         }

         if (!isdir && only_dir)
            return Promise.reject(Error(`Key ${obj_name} is not directory}`));

         return this.readObjBuffer(key).then(buf => {

            if (isdir) {
               let dir = new TDirectory(this, obj_name, cycle);
               dir.fTitle = key.fTitle;
               return dir.readKeys(buf);
            }

            let obj = {};
            buf.mapObject(1, obj); // tag object itself with id == 1
            buf.classStreamer(obj, key.fClassName);

            if ((key.fClassName === clTF1) || (key.fClassName === clTF2))
               return this._readFormulas(obj);

            return obj;
         });
      });
   }

   /** @summary read formulas from the file and add them to TF1/TF2 objects
     * @private */
   async _readFormulas(tf1) {

      let arr = [];

      for (let indx = 0; indx < this.fKeys.length; ++indx)
         if (this.fKeys[indx].fClassName == 'TFormula')
            arr.push(this.readObject(this.fKeys[indx].fName, this.fKeys[indx].fCycle));

      return Promise.all(arr).then(formulas => {
         formulas.forEach(obj => tf1.addFormula(obj));
         return tf1;
      });
   }

   /** @summary extract streamer infos from the buffer
     * @private */
   extractStreamerInfos(buf) {
      if (!buf) return;

      let lst = {};
      buf.mapObject(1, lst);
      buf.classStreamer(lst, clTList);

      lst._typename = clTStreamerInfoList;

      this.fStreamerInfos = lst;

      if (internals.addStreamerInfosForPainter)
         internals.addStreamerInfosForPainter(lst);

      for (let k = 0; k < lst.arr.length; ++k) {
         let si = lst.arr[k];
         if (!si.fElements) continue;
         for (let l = 0; l < si.fElements.arr.length; ++l) {
            let elem = si.fElements.arr[l];

            if (!elem.fTypeName || !elem.fType) continue;

            let typ = elem.fType, typname = elem.fTypeName;

            if (typ >= 60) {
               if ((typ === kStreamer) && (elem._typename == clTStreamerSTL) && elem.fSTLtype && elem.fCtype && (elem.fCtype < 20)) {
                  let prefix = (StlNames[elem.fSTLtype] || 'undef') + '<';
                  if ((typname.indexOf(prefix) === 0) && (typname[typname.length - 1] == '>')) {
                     typ = elem.fCtype;
                     typname = typname.slice(prefix.length, typname.length - 1).trim();

                     if ((elem.fSTLtype === kSTLmap) || (elem.fSTLtype === kSTLmultimap))
                        if (typname.indexOf(',') > 0) typname = typname.slice(0, typname.indexOf(',')).trim();
                        else continue;
                  }
               }
               if (typ >= 60) continue;
            } else {
               if ((typ > 20) && (typname[typname.length - 1] == '*')) typname = typname.slice(0, typname.length - 1);
               typ = typ % 20;
            }

            const kind = getTypeId(typname);
            if (kind === typ) continue;

            if ((typ === kBits) && (kind === kUInt)) continue;
            if ((typ === kCounter) && (kind === kInt)) continue;

            if (typname && typ && (this.fBasicTypes[typname] !== typ))
               this.fBasicTypes[typname] = typ;
         }
      }
   }

   /** @summary Read file keys
     * @private */
   async readKeys() {

      // with the first readbuffer we read bigger amount to create header cache
      return this.readBuffer([0, 1024]).then(blob => {
         let buf = new TBuffer(blob, 0, this);

         if (buf.substring(0, 4) !== 'root')
            return Promise.reject(Error(`Not a ROOT file ${this.fURL}`));

         buf.shift(4);

         this.fVersion = buf.ntou4();
         this.fBEGIN = buf.ntou4();
         if (this.fVersion < 1000000) { //small file
            this.fEND = buf.ntou4();
            this.fSeekFree = buf.ntou4();
            this.fNbytesFree = buf.ntou4();
            buf.shift(4); // const nfree = buf.ntoi4();
            this.fNbytesName = buf.ntou4();
            this.fUnits = buf.ntou1();
            this.fCompress = buf.ntou4();
            this.fSeekInfo = buf.ntou4();
            this.fNbytesInfo = buf.ntou4();
         } else { // new format to support large files
            this.fEND = buf.ntou8();
            this.fSeekFree = buf.ntou8();
            this.fNbytesFree = buf.ntou4();
            buf.shift(4); // const nfree = buf.ntou4();
            this.fNbytesName = buf.ntou4();
            this.fUnits = buf.ntou1();
            this.fCompress = buf.ntou4();
            this.fSeekInfo = buf.ntou8();
            this.fNbytesInfo = buf.ntou4();
         }

         // empty file
         if (!this.fSeekInfo || !this.fNbytesInfo)
            return Promise.reject(Error(`File ${this.fURL} does not provide streamer infos`));

         // extra check to prevent reading of corrupted data
         if (!this.fNbytesName || this.fNbytesName > 100000)
            return Promise.reject(Error(`Cannot read directory info of the file ${this.fURL}`));

         //*-*-------------Read directory info
         let nbytes = this.fNbytesName + 22;
         nbytes += 4;  // fDatimeC.Sizeof();
         nbytes += 4;  // fDatimeM.Sizeof();
         nbytes += 18; // fUUID.Sizeof();
         // assume that the file may be above 2 Gbytes if file version is > 4
         if (this.fVersion >= 40000) nbytes += 12;

         // this part typically read from the header, no need to optimize
         return this.readBuffer([this.fBEGIN, Math.max(300, nbytes)]);
      }).then(blob3 => {

         let buf3 = new TBuffer(blob3, 0, this);

         // keep only title from TKey data
         this.fTitle = buf3.readTKey().fTitle;

         buf3.locate(this.fNbytesName);

         // we read TDirectory part of TFile
         buf3.classStreamer(this, clTDirectory);

         if (!this.fSeekKeys)
            return Promise.reject(Error(`Empty keys list in ${this.fURL}`));

         // read with same request keys and streamer infos
         return this.readBuffer([this.fSeekKeys, this.fNbytesKeys, this.fSeekInfo, this.fNbytesInfo]);
      }).then(blobs => {

         const buf4 = new TBuffer(blobs[0], 0, this);

         buf4.readTKey(); //
         const nkeys = buf4.ntoi4();
         for (let i = 0; i < nkeys; ++i)
            this.fKeys.push(buf4.readTKey());

         const buf5 = new TBuffer(blobs[1], 0, this),
               si_key = buf5.readTKey();
         if (!si_key)
            return Promise.reject(Error(`Fail to read StreamerInfo data in ${this.fURL}`));

         this.fKeys.push(si_key);
         return this.readObjBuffer(si_key);
      }).then(blob6 => {
          this.extractStreamerInfos(blob6);
          return this;
      });
   }

   /** @summary Read the directory content from  a root file
     * @desc If directory was already read - return previously read object
     * Same functionality as {@link TFile#readObject}
     * @param {string} dir_name - directory name
     * @param {number} [cycle] - directory cycle
     * @return {Promise} - promise with read directory */
   async readDirectory(dir_name, cycle) {
      return this.readObject(dir_name, cycle, true);
   }

   /** @summary Search streamer info
     * @param {string} clanme - class name
     * @param {number} [clversion] - class version
     * @param {number} [checksum] - streamer info checksum, have to match when specified
     * @private */
   findStreamerInfo(clname, clversion, checksum) {
      if (!this.fStreamerInfos) return null;

      const arr = this.fStreamerInfos.arr, len = arr.length;

      if (checksum !== undefined) {
         let cache = this.fStreamerInfos.cache;
         if (!cache) cache = this.fStreamerInfos.cache = {};
         let si = cache[checksum];
         if (si !== undefined) return si;

         for (let i = 0; i < len; ++i) {
            si = arr[i];
            if (si.fCheckSum === checksum)
               return cache[checksum] = si;
         }
         cache[checksum] = null; // checksum didnot found, do not try again
      } else {
         for (let i = 0; i < len; ++i) {
            let si = arr[i];
            if ((si.fName === clname) && ((si.fClassVersion === clversion) || (clversion === undefined))) return si;
         }
      }

      return null;
   }

   /** @summary Returns streamer for the class 'clname',
     * @desc From the list of streamers or generate it from the streamer infos and add it to the list
     * @private */
   getStreamer(clname, ver, s_i) {

      // these are special cases, which are handled separately
      if (clname == clTQObject || clname == clTBasket) return null;

      let streamer, fullname = clname;

      if (ver) {
         fullname += (ver.checksum ? `$chksum${ver.checksum}` : `$ver${ver.val}`);
         streamer = this.fStreamers[fullname];
         if (streamer !== undefined) return streamer;
      }

      let custom = CustomStreamers[clname];

      // one can define in the user streamers just aliases
      if (isStr(custom))
         return this.getStreamer(custom, ver, s_i);

      // streamer is just separate function
      if (isFunc(custom)) {
         streamer = [{ typename: clname, func: custom }];
         return addClassMethods(clname, streamer);
      }

      streamer = [];

      if (isObject(custom)) {
         if (!custom.name && !custom.func) return custom;
         streamer.push(custom); // special read entry, add in the beginning of streamer
      }

      // check element in streamer infos, one can have special cases
      if (!s_i) s_i = this.findStreamerInfo(clname, ver.val, ver.checksum);

      if (!s_i) {
         delete this.fStreamers[fullname];
         if (!ver.nowarning)
            console.warn(`Not found streamer for ${clname} ver ${ver.val} checksum ${ver.checksum} full ${fullname}`);
         return null;
      }

      // special handling for TStyle which has duplicated member name fLineStyle
      if ((s_i.fName == clTStyle) && s_i.fElements)
         s_i.fElements.arr.forEach(elem => {
            if (elem.fName == 'fLineStyle') elem.fName = 'fLineStyles'; // like in ROOT JSON now
         });

      // for each entry in streamer info produce member function
      if (s_i.fElements)
         for (let j = 0; j < s_i.fElements.arr.length; ++j)
            streamer.push(createMemberStreamer(s_i.fElements.arr[j], this));

      this.fStreamers[fullname] = streamer;

      return addClassMethods(clname, streamer);
   }

   /** @summary Here we produce list of members, resolving all base classes
     * @private */
   getSplittedStreamer(streamer, tgt) {
      if (!streamer) return tgt;

      if (!tgt) tgt = [];

      for (let n = 0; n < streamer.length; ++n) {
         let elem = streamer[n];

         if (elem.base === undefined) {
            tgt.push(elem);
            continue;
         }

         if (elem.basename == clTObject) {
            tgt.push({
               func(buf, obj) {
                  buf.ntoi2(); // read version, why it here??
                  obj.fUniqueID = buf.ntou4();
                  obj.fBits = buf.ntou4();
                  if (obj.fBits & kIsReferenced) buf.ntou2(); // skip pid
               }
            });
            continue;
         }

         let ver = { val: elem.base };

         if (ver.val === 4294967295) {
            // this is -1 and indicates foreign class, need more workarounds
            ver.val = 1; // need to search version 1 - that happens when several versions of foreign class exists ???
         }

         let parent = this.getStreamer(elem.basename, ver);
         if (parent) this.getSplittedStreamer(parent, tgt);
      }

      return tgt;
   }

   /** @summary Fully clenaup TFile data
     * @private */
   delete() {
      this.fDirectories = null;
      this.fKeys = null;
      this.fStreamers = null;
      this.fSeekInfo = 0;
      this.fNbytesInfo = 0;
      this.fTagOffset = 0;
   }

} // class TFile

/** @summary Function to read vector element in the streamer
  * @private */
function readVectorElement(buf) {

   if (this.member_wise) {

      const n = buf.ntou4();
      let streamer = null, ver = this.stl_version;

      if (n === 0) return []; // for empty vector no need to search split streamers

      if (n > 1000000) {
         throw new Error(`member-wise streaming of ${this.conttype} num ${n} member ${this.name}`);
         // return [];
      }

      if ((ver.val === this.member_ver) && (ver.checksum === this.member_checksum)) {
         streamer = this.member_streamer;
      } else {
         streamer = buf.fFile.getStreamer(this.conttype, ver);

         this.member_streamer = streamer = buf.fFile.getSplittedStreamer(streamer);
         this.member_ver = ver.val;
         this.member_checksum = ver.checksum;
      }

      let res = new Array(n), i, k, member;

      for (i = 0; i < n; ++i)
         res[i] = { _typename: this.conttype }; // create objects
      if (!streamer) {
         console.error(`Fail to create split streamer for ${this.conttype} need to read ${n} objects version ${ver}`);
      } else {
         for (k = 0; k < streamer.length; ++k) {
            member = streamer[k];
            if (member.split_func) {
               member.split_func(buf, res, n);
            } else {
               for (i = 0; i < n; ++i)
                  member.func(buf, res[i]);
            }
         }
      }
      return res;
   }

   const n = buf.ntou4();
   let res = new Array(n), i = 0;

   if (n > 200000) { console.error(`vector streaming for ${this.conttype} at ${n}`); return res; }

   if (this.arrkind > 0) {
      while (i < n) res[i++] = buf.readFastArray(buf.ntou4(), this.arrkind);
   } else if (this.arrkind === 0) {
      while (i < n) res[i++] = buf.readTString();
   } else if (this.isptr) {
      while (i < n) res[i++] = buf.readObjectAny();
   } else if (this.submember) {
      while (i < n) res[i++] = this.submember.readelem(buf);
   } else {
      while (i < n) res[i++] = buf.classStreamer({}, this.conttype);
   }

   return res;
}


/** @summary Function used in streamer to read std::map object
  * @private */
function readMapElement(buf) {
   let streamer = this.streamer;

   if (this.member_wise) {
      // when member-wise streaming is used, version is written
      const ver = this.stl_version;

      if (this.si) {
         let si = buf.fFile.findStreamerInfo(this.pairtype, ver.val, ver.checksum);

         if (this.si !== si) {

            streamer = getPairStreamer(si, this.pairtype, buf.fFile);
            if (!streamer || streamer.length !== 2) {
               console.log(`Fail to produce streamer for ${this.pairtype}`);
               return null;
            }
         }
      }
   }

   const n = buf.ntoi4();
   let i, res = new Array(n);
   if (this.member_wise && (buf.remain() >= 6)) {
      if (buf.ntoi2() == kStreamedMemberWise)
         buf.shift(4);
      else
         buf.shift(-2); // rewind
   }

   for (i = 0; i < n; ++i) {
      res[i] = { _typename: this.pairtype };
      streamer[0].func(buf, res[i]);
      if (!this.member_wise) streamer[1].func(buf, res[i]);
   }

   // due-to member-wise streaming second element read after first is completed
   if (this.member_wise)
      for (i = 0; i < n; ++i)
         streamer[1].func(buf, res[i]);

   return res;
}

// =============================================================

/**
  * @summary Interface to read local file in the browser
  *
  * @hideconstructor
  * @desc Use {@link openFile} to create instance of the class
  * @private
  */

class TLocalFile extends TFile {

   constructor(file) {
      super(null);
      this.fUseStampPar = false;
      this.fLocalFile = file;
      this.fEND = file.size;
      this.fFullURL = file.name;
      this.fURL = file.name;
      this.fFileName = file.name;
   }

   /** @summary Open local file
     * @return {Promise} after file keys are read */
   async _open() { return this.readKeys(); }

   /** @summary read buffer from local file
     * @return {Promise} with read data */
   async readBuffer(place, filename /*, progress_callback */) {
      let file = this.fLocalFile;

      return new Promise((resolve, reject) => {
         if (filename)
            return reject(Error(`Cannot access other local file ${filename}`));

         let reader = new FileReader(), cnt = 0, blobs = [];

         reader.onload = function(evnt) {
            let res = new DataView(evnt.target.result);
            if (place.length === 2) return resolve(res);

            blobs.push(res);
            cnt += 2;
            if (cnt >= place.length) return resolve(blobs);
            reader.readAsArrayBuffer(file.slice(place[cnt], place[cnt] + place[cnt + 1]));
         };

         reader.readAsArrayBuffer(file.slice(place[0], place[0] + place[1]));
      });
   }

} // class TLocalFile

/**
  * @summary Interface to read file in node.js
  *
  * @hideconstructor
  * @desc Use {@link openFile} to create instance of the class
  * @private
  */

class TNodejsFile extends TFile {
   constructor(filename) {
      super(null);
      this.fUseStampPar = false;
      this.fEND = 0;
      this.fFullURL = filename;
      this.fURL = filename;
      this.fFileName = filename;
   }

   /** @summary Open file in node.js
     * @return {Promise} after file keys are read */
   async _open() {
      return Promise.resolve().then(function () { return _rollup_plugin_ignore_empty_module_placeholder$1; }).then(fs => {

         this.fs = fs;

         return new Promise((resolve,reject) =>

            this.fs.open(this.fFileName, 'r', (status, fd) => {
               if (status) {
                  console.log(status.message);
                  return reject(Error(`Not possible to open ${this.fFileName} inside node.js`));
               }
               let stats = this.fs.fstatSync(fd);

               this.fEND = stats.size;

               this.fd = fd;

               this.readKeys().then(resolve).catch(reject);
            })
         );
      });
   }

   /** @summary Read buffer from node.js file
     * @return {Promise} with requested blocks */
   async readBuffer(place, filename /*, progress_callback */) {
      return new Promise((resolve, reject) => {
         if (filename)
            return reject(Error(`Cannot access other local file ${filename}`));

         if (!this.fs || !this.fd)
            return reject(Error(`File is not opened ${this.fFileName}`));

         let cnt = 0, blobs = [];

         let readfunc = (err, bytesRead, buf) => {

            let res = new DataView(buf.buffer, buf.byteOffset, place[cnt + 1]);
            if (place.length === 2) return resolve(res);

            blobs.push(res);
            cnt += 2;
            if (cnt >= place.length) return resolve(blobs);
            this.fs.read(this.fd, Buffer.alloc(place[cnt + 1]), 0, place[cnt + 1], place[cnt], readfunc);
         };

         this.fs.read(this.fd, Buffer.alloc(place[1]), 0, place[1], place[0], readfunc);
      });
   }

} // class TNodejsFile

/**
  * @summary Proxy to read file contenxt
  *
  * @desc Should implement followinf methods
  *        openFile() - return Promise with true when file can be open normally
  *        getFileName() - returns string with file name
  *        getFileSize() - returns size of file
  *        readBuffer(pos, len) - return promise with DataView for requested position and length
  * @private
  */

class FileProxy {

   async openFile() { return false; }

   getFileName() { return ''; }

   getFileSize() { return 0; }

   async readBuffer(/*pos, sz*/) { return null; }

} // class FileProxy

/**
  * @summary File to use file context via FileProxy
  *
  * @hideconstructor
  * @desc Use {@link openFile} to create instance of the class, providing FileProxy as argument
  * @private
  */

class TProxyFile extends TFile {

   constructor(proxy) {
      super(null);
      this.fUseStampPar = false;
      this.proxy = proxy;
   }

   /** @summary Open file
     * @return {Promise} after file keys are read */
   async _open() {
      return this.proxy.openFile().then(res => {
         if (!res) return false;
         this.fEND = this.proxy.getFileSize();
         this.fFullURL = this.fURL = this.fFileName = this.proxy.getFileName();
         if (isStr(this.fFileName)) {
            let p = this.fFileName.lastIndexOf('/');
            if ((p > 0) && (p < this.fFileName.length - 4))
               this.fFileName = this.fFileName.slice(p+1);
         }
         return this.readKeys();
      });
   }

   /** @summary Read buffer from FileProxy
     * @return {Promise} with requested blocks */
   async readBuffer(place, filename /*, progress_callback */) {
      if (filename)
         return Promise.reject(Error(`Cannot access other file ${filename}`));

      if (!this.proxy)
         return Promise.reject(Error(`File is not opened ${this.fFileName}`));

      if (place.length == 2)
         return this.proxy.readBuffer(place[0], place[1]);

      let arr = [];
      for (let k = 0; k < place.length; k+=2)
         arr.push(this.proxy.readBuffer(place[k], place[k+1]));
      return Promise.all(arr);
   }

} // class TProxyFile


/** @summary Open ROOT file for reading
  * @desc Generic method to open ROOT file for reading
  * Following kind of arguments can be provided:
  *  - string with file URL (see example). In node.js environment local file like 'file://hsimple.root' can be specified
  *  - [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File} instance which let read local files from browser
  *  - [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer} instance with complete file content
  *  - [FileProxy]{@link FileProxy} let access arbitrary files via tiny proxy API
  * @param {string|object} arg - argument for file open like url, see details
  * @return {object} - Promise with {@link TFile} instance when file is opened
  * @example
  *
  * import { openFile } from '/path_to_jsroot/modules/io.mjs';
  * let f = await openFile('https://root.cern/js/files/hsimple.root');
  * console.log(`Open file ${f.getFileName()}`); */
function openFile(arg) {

   let file;

   if (isNodeJs() && isStr(arg)) {
      if (arg.indexOf('file://') == 0)
         file = new TNodejsFile(arg.slice(7));
      else if (arg.indexOf('http') !== 0)
         file = new TNodejsFile(arg);
   }

   if (!file && isObject(arg) && (arg instanceof FileProxy))
      file = new TProxyFile(arg);

   if (!file && isObject(arg) && (arg instanceof ArrayBuffer)) {
      file = new TFile('localfile.root');
      file.assignFileContent(arg);
   }

   if (!file && isObject(arg) && arg.size && arg.name)
      file = new TLocalFile(arg);

   if (!file)
      file = new TFile(arg);

   return file._open();
}

// special way to assign methods when streaming objects
addClassMethods(clTNamed, CustomStreamers[clTNamed]);
addClassMethods(clTObjString, CustomStreamers[clTObjString]);

// branch types
const kLeafNode = 0, kBaseClassNode = 1, kObjectNode = 2, kClonesNode = 3,
      kSTLNode = 4, kClonesMemberNode = 31, kSTLMemberNode = 41,
      // branch bits
      // kDoNotProcess = BIT(10), // Active bit for branches
      // kIsClone = BIT(11), // to indicate a TBranchClones
      // kBranchObject = BIT(12), // branch is a TObject*
      // kBranchAny = BIT(17), // branch is an object*
      // kAutoDelete = BIT(15),
      kDoNotUseBufferMap = BIT(22), // If set, at least one of the entry in the branch will use the buffer's map of classname and objects.
      clTBranchElement = 'TBranchElement', clTBranchFunc = 'TBranchFunc';

/**
 * @summary Class to read data from TTree
 *
 * @desc Instance of TSelector can be used to access TTree data
 */

class TSelector {

   /** @summary constructor */
   constructor() {
      this._branches = []; // list of branches to read
      this._names = []; // list of member names for each branch in tgtobj
      this._directs = []; // indication if only branch without any children should be read
      this._break = 0;
      this.tgtobj = {};
   }

   /** @summary Add branch to the selector
    * @desc Either branch name or branch itself should be specified
    * Second parameter defines member name in the tgtobj
    * If selector.addBranch('px', 'read_px') is called,
    * branch will be read into selector.tgtobj.read_px member
    * If second parameter not specified, branch name (here 'px') will be used
    * If branch object specified as first parameter and second parameter missing,
    * then member like 'br0', 'br1' and so on will be assigned
    * @param {string|Object} branch - name of branch (or branch object itself}
    * @param {string} [name] - member name in tgtobj where data will be read
    * @param {boolean} [direct] - if only branch without any children should be read */
   addBranch(branch, name, direct) {
      if (!name)
         name = isStr(branch) ? branch : `br${this._branches.length}`;
      this._branches.push(branch);
      this._names.push(name);
      this._directs.push(direct);
      return this._branches.length - 1;
   }

   /** @summary returns number of branches used in selector */
   numBranches() { return this._branches.length; }

   /** @summary returns branch by index used in selector */
   getBranch(indx) { return this._branches[indx]; }

   /** @summary returns index of branch
     * @private */
   indexOfBranch(branch) { return this._branches.indexOf(branch); }

   /** @summary returns name of branch
     * @private */
   nameOfBranch(indx) { return this._names[indx]; }

   /** @summary function called during TTree processing
    * @abstract
    * @param {number} progress - current value between 0 and 1 */
   ShowProgress(/* progress */) {}

   /** @summary call this function to abort processing */
   Abort() { this._break = -1111; }

   /** @summary function called before start processing
    * @abstract
    * @param {object} tree - tree object */
   Begin(/* tree */) {}

   /** @summary function called when next entry extracted from the tree
    * @abstract
    * @param {number} entry - read entry number */
   Process(/* entry */) {}

   /** @summary function called at the very end of processing
    * @abstract
    * @param {boolean} res - true if all data were correctly processed */
   Terminate(/* res */) {}

} // class TSelector

// =================================================================

/** @summary Checks array kind
  * @desc return 0 when not array
  * 1 - when arbitrary array
  * 2 - when plain (1-dim) array with same-type content
  * @private */
function checkArrayPrototype(arr, check_content) {
   if (!isObject(arr)) return 0;

   let arr_kind = isArrayProto(Object.prototype.toString.apply(arr));

   if (!check_content || (arr_kind != 1)) return arr_kind;

   let typ, plain = true;
   for (let k = 0; k < arr.length; ++k) {
      let sub = typeof arr[k];
      if (!typ) typ = sub;
      if (sub !== typ) { plain = false; break; }
      if (isObject(sub) && checkArrayPrototype(arr[k])) { plain = false; break; }
   }

   return plain ? 2 : 1;
}

/**
 * @summary Class to iterate over array elements
 *
 * @private
 */

class ArrayIterator {

   /** @summary constructor */
   constructor(arr, select, tgtobj) {
      this.object = arr;
      this.value = 0; // value always used in iterator
      this.arr = []; // all arrays
      this.indx = []; // all indexes
      this.cnt = -1; // current index counter
      this.tgtobj = tgtobj;

      if (isObject(select))
         this.select = select; // remember indexes for selection
      else
         this.select = []; // empty array, undefined for each dimension means iterate over all indexes
   }

   /** @summary next element */
   next() {
      let obj, typ, cnt = this.cnt;

      if (cnt >= 0) {

         if (++this.fastindx < this.fastlimit) {
            this.value = this.fastarr[this.fastindx];
            return true;
         }

         while (--cnt >= 0) {
            if ((this.select[cnt] === undefined) && (++this.indx[cnt] < this.arr[cnt].length)) break;
         }
         if (cnt < 0) return false;
      }

      while (true) {

         obj = (cnt < 0) ? this.object : (this.arr[cnt])[this.indx[cnt]];

         typ = obj ? typeof obj : 'any';

         if (typ === 'object') {
            if (obj._typename !== undefined) {
               if (isRootCollection(obj)) { obj = obj.arr; typ = 'array'; }
               else typ = 'any';
            } else if (Number.isInteger(obj.length) && (checkArrayPrototype(obj) > 0)) {
               typ = 'array';
            } else {
               typ = 'any';
            }
         }

         if (this.select[cnt + 1] == '$self$') {
            this.value = obj;
            this.fastindx = this.fastlimit = 0;
            this.cnt = cnt + 1;
            return true;
         }

         if ((typ == 'any') && isStr(this.select[cnt + 1])) {
            // this is extraction of the member from arbitrary class
            this.arr[++cnt] = obj;
            this.indx[cnt] = this.select[cnt]; // use member name as index
            continue;
         }

         if ((typ === 'array') && ((obj.length > 0) || (this.select[cnt + 1] === '$size$'))) {
            this.arr[++cnt] = obj;
            switch (this.select[cnt]) {
               case undefined: this.indx[cnt] = 0; break;
               case '$last$': this.indx[cnt] = obj.length - 1; break;
               case '$size$':
                  this.value = obj.length;
                  this.fastindx = this.fastlimit = 0;
                  this.cnt = cnt;
                  return true;
               default:
                  if (Number.isInteger(this.select[cnt])) {
                     this.indx[cnt] = this.select[cnt];
                     if (this.indx[cnt] < 0) this.indx[cnt] = obj.length - 1;
                  } else {
                     // this is compile variable as array index - can be any expression
                     this.select[cnt].produce(this.tgtobj);
                     this.indx[cnt] = Math.round(this.select[cnt].get(0));
                  }
            }
         } else {

            if (cnt < 0) return false;

            this.value = obj;
            if (this.select[cnt] === undefined) {
               this.fastarr = this.arr[cnt];
               this.fastindx = this.indx[cnt];
               this.fastlimit = this.fastarr.length;
            } else {
               this.fastindx = this.fastlimit = 0; // no any iteration on that level
            }

            this.cnt = cnt;
            return true;
         }
      }

      // unreachable code
      // return false;
   }

   /** @summary reset iterator */
   reset() {
      this.arr = [];
      this.indx = [];
      delete this.fastarr;
      this.cnt = -1;
      this.value = 0;
   }

} // class ArrayIterator


/** @summary return class name of the object, stored in the branch
  * @private */
function getBranchObjectClass(branch, tree, with_clones = false, with_leafs = false) {

   if (!branch || (branch._typename !== clTBranchElement)) return '';

   if ((branch.fType === kLeafNode) && (branch.fID === -2) && (branch.fStreamerType === -1)) {
      // object where all sub-branches will be collected
      return branch.fClassName;
   }

   if (with_clones && branch.fClonesName && ((branch.fType === kClonesNode) || (branch.fType === kSTLNode)))
      return branch.fClonesName;

   let s_elem = findBrachStreamerElement(branch, tree.$file);

   if ((branch.fType === kBaseClassNode) && s_elem && (s_elem.fTypeName === 'BASE'))
      return s_elem.fName;

   if (branch.fType === kObjectNode) {
      if (s_elem && ((s_elem.fType === kObject) || (s_elem.fType === kAny)))
         return s_elem.fTypeName;
      return clTObject;
   }

   if ((branch.fType === kLeafNode) && s_elem && with_leafs) {
      if ((s_elem.fType === kObject) || (s_elem.fType === kAny)) return s_elem.fTypeName;
      if (s_elem.fType === kObjectp) return s_elem.fTypeName.slice(0, s_elem.fTypeName.length - 1);
   }

   return '';
}


/** @summary Get branch with specified id
  * @desc All sub-branches checked as well
  * @return {Object} branch
  * @private */
function getTreeBranch(tree, id) {
   if (!Number.isInteger(id)) return;
   let res, seq = 0;
   function scan(obj) {
      if (obj && obj.fBranches)
         obj.fBranches.arr.forEach(br => {
            if (seq++ === id) res = br;
            if (!res) scan(br);
         });
   }

   scan(tree);
   return res;
}


/** @summary Special branch search
  * @desc Name can include extra part, which will be returned in the result
  * @param {string} name - name of the branch
  * @return {Object} with 'branch' and 'rest' members
  * @private */
function findBranchComplex(tree, name, lst = undefined, only_search = false) {

   let top_search = false, search = name, res = null;

   if (!lst) {
      top_search = true;
      lst = tree.fBranches;
      let pos = search.indexOf('[');
      if (pos > 0) search = search.slice(0, pos);
   }

   if (!lst || (lst.arr.length === 0)) return null;

   for (let n = 0; n < lst.arr.length; ++n) {
      let brname = lst.arr[n].fName;
      if (brname[brname.length - 1] == ']')
         brname = brname.slice(0, brname.indexOf('['));

      // special case when branch name includes STL map name
      if ((search.indexOf(brname) !== 0) && (brname.indexOf('<') > 0)) {
         let p1 = brname.indexOf('<'), p2 = brname.lastIndexOf('>');
         brname = brname.slice(0, p1) + brname.slice(p2 + 1);
      }

      if (brname === search) { res = { branch: lst.arr[n], rest: '' }; break; }

      if (search.indexOf(brname) !== 0) continue;

      // this is a case when branch name is in the begin of the search string

      // check where point is
      let pnt = brname.length;
      if (brname[pnt - 1] === '.') pnt--;
      if (search[pnt] !== '.') continue;

      res = findBranchComplex(tree, search, lst.arr[n].fBranches);
      if (!res) res = findBranchComplex(tree, search.slice(pnt + 1), lst.arr[n].fBranches);

      if (!res) res = { branch: lst.arr[n], rest: search.slice(pnt) };

      break;
   }

   if (top_search && !only_search && !res && (search.indexOf('br_') == 0)) {
      let p = 3;
      while ((p < search.length) && (search[p] >= '0') && (search[p] <= '9')) ++p;
      let br = (p > 3) ? getTreeBranch(tree, parseInt(search.slice(3,p))) : null;
      if (br) res = { branch: br, rest: search.slice(p) };
   }

   if (!top_search || !res) return res;

   if (name.length > search.length) res.rest += name.slice(search.length);

   return res;
}


/** @summary Search branch with specified name
  * @param {string} name - name of the branch
  * @return {Object} found branch
  * @private */
function findBranch(tree, name) {
   let res = findBranchComplex(tree, name, tree.fBranches, true);
   return (!res || res.rest) ? null : res.branch;
}


/**
 * @summary object with single variable in TTree::Draw expression
 *
 * @private
 */

class TDrawVariable {

   /** @summary constructor */
   constructor (globals) {
      this.globals = globals;

      this.code = '';
      this.brindex = []; // index of used branches from selector
      this.branches = []; // names of branches in target object
      this.brarray = []; // array specifier for each branch
      this.func = null; // generic function for variable calculation

      this.kind = undefined;
      this.buf = []; // buffer accumulates temporary values
   }

   /** @summary Parse variable
     * @desc when only_branch specified, its placed in the front of the expression */
   parse(tree, selector, code, only_branch, branch_mode) {

      const is_start_symbol = symb => {
         if ((symb >= 'A') && (symb <= 'Z')) return true;
         if ((symb >= 'a') && (symb <= 'z')) return true;
         return (symb === '_');
      }, is_next_symbol = symb => {
         if (is_start_symbol(symb)) return true;
         if ((symb >= '0') && (symb <= '9')) return true;
         return false;
      };

      if (!code) code = ''; // should be empty string at least

      this.code = (only_branch?.fName ?? '') + code;

      let pos = 0, pos2 = 0, br = null;
      while ((pos < code.length) || only_branch) {

         let arriter = [];

         if (only_branch) {
            br = only_branch;
            only_branch = undefined;
         } else {
            // first try to find branch
            pos2 = pos;
            while ((pos2 < code.length) && (is_next_symbol(code[pos2]) || code[pos2] === '.')) pos2++;
            if (code[pos2] == '$') {
               let repl = '';
               switch (code.slice(pos, pos2)) {
                  case 'LocalEntry':
                  case 'Entry': repl = 'arg.$globals.entry'; break;
                  case 'Entries': repl = 'arg.$globals.entries'; break;
               }
               if (repl) {
                  code = code.slice(0, pos) + repl + code.slice(pos2 + 1);
                  pos = pos + repl.length;
                  continue;
               }
            }

            br = findBranchComplex(tree, code.slice(pos, pos2));
            if (!br) { pos = pos2 + 1; continue; }

            // when full id includes branch name, replace only part of extracted expression
            if (br.branch && (br.rest !== undefined)) {
               pos2 -= br.rest.length;
               branch_mode = undefined; // maybe selection of the sub-object done
               br = br.branch;
            }

            // when code ends with the point - means object itself will be accessed
            // sometime branch name itself ends with the point
            if ((pos2 >= code.length - 1) && (code[code.length - 1] === '.')) {
               arriter.push('$self$');
               pos2 = code.length;
            }
         }

         // now extract all levels of iterators
         while (pos2 < code.length) {

            if ((code[pos2] === '@') && (code.slice(pos2, pos2 + 5) == '@size') && (arriter.length == 0)) {
               pos2 += 5;
               branch_mode = true;
               break;
            }

            if (code[pos2] === '.') {
               // this is object member
               let prev = ++pos2;

               if ((code[prev] === '@') && (code.slice(prev, prev + 5) === '@size')) {
                  arriter.push('$size$');
                  pos2 += 5;
                  break;
               }

               if (!is_start_symbol(code[prev])) {
                  arriter.push('$self$'); // last point means extraction of object itself
                  break;
               }

               while ((pos2 < code.length) && is_next_symbol(code[pos2])) pos2++;

               // this is looks like function call - do not need to extract member with
               if (code[pos2] == '(') { pos2 = prev - 1; break; }

               // this is selection of member, but probably we need to activate iterator for ROOT collection
               if ((arriter.length === 0) && br) {
                  // TODO: if selected member is simple data type - no need to make other checks - just break here
                  if ((br.fType === kClonesNode) || (br.fType === kSTLNode)) {
                     arriter.push(undefined);
                  } else {
                     let objclass = getBranchObjectClass(br, tree, false, true);
                     if (objclass && isRootCollection(null, objclass)) arriter.push(undefined);
                  }
               }
               arriter.push(code.slice(prev, pos2));
               continue;
            }

            if (code[pos2] !== '[') break;

            // simple []
            if (code[pos2 + 1] == ']') { arriter.push(undefined); pos2 += 2; continue; }

            let prev = pos2++, cnt = 0;
            while ((pos2 < code.length) && ((code[pos2] != ']') || (cnt > 0))) {
               if (code[pos2] == '[') cnt++; else if (code[pos2] == ']') cnt--;
               pos2++;
            }
            let sub = code.slice(prev + 1, pos2);
            switch (sub) {
               case '':
               case '$all$': arriter.push(undefined); break;
               case '$last$': arriter.push('$last$'); break;
               case '$size$': arriter.push('$size$'); break;
               case '$first$': arriter.push(0); break;
               default:
                  if (Number.isInteger(parseInt(sub))) {
                     arriter.push(parseInt(sub));
                  } else {
                     // try to compile code as draw variable
                     let subvar = new TDrawVariable(this.globals);
                     if (!subvar.parse(tree, selector, sub)) return false;
                     arriter.push(subvar);
                  }
            }
            pos2++;
         }

         if (arriter.length === 0) arriter = undefined; else
            if ((arriter.length === 1) && (arriter[0] === undefined)) arriter = true;

         let indx = selector.indexOfBranch(br);
         if (indx < 0) indx = selector.addBranch(br, undefined, branch_mode);

         branch_mode = undefined;

         this.brindex.push(indx);
         this.branches.push(selector.nameOfBranch(indx));
         this.brarray.push(arriter);

         // this is simple case of direct usage of the branch
         if ((pos === 0) && (pos2 === code.length) && (this.branches.length === 1)) {
            this.direct_branch = true; // remember that branch read as is
            return true;
         }

         let replace = 'arg.var' + (this.branches.length - 1);

         code = code.slice(0, pos) + replace + code.slice(pos2);

         pos = pos + replace.length;
      }

      // support usage of some standard TMath functions
      code = code.replace(/TMath::Exp\(/g, 'Math.exp(')
                 .replace(/TMath::Abs\(/g, 'Math.abs(')
                 .replace(/TMath::Prob\(/g, 'arg.$math.Prob(')
                 .replace(/TMath::Gaus\(/g, 'arg.$math.Gaus(');

      this.func = new Function('arg', `return (${code})`);

      return true;
   }

   /** @summary Check if it is dummy variable */
   is_dummy() { return (this.branches.length === 0) && !this.func; }

   /** @summary Produce variable
     * @desc after reading tree braches into the object, calculate variable value */
   produce(obj) {

      this.length = 1;
      this.isarray = false;

      if (this.is_dummy()) {
         this.value = 1.; // used as dummy weight variable
         this.kind = 'number';
         return;
      }

      let arg = { $globals: this.globals, $math: jsroot_math }, usearrlen = -1, arrs = [];
      for (let n = 0; n < this.branches.length; ++n) {
         let name = 'var' + n;
         arg[name] = obj[this.branches[n]];

         // try to check if branch is array and need to be iterated
         if (this.brarray[n] === undefined)
            this.brarray[n] = (checkArrayPrototype(arg[name]) > 0) || isRootCollection(arg[name]);

         // no array - no pain
         if (this.brarray[n] === false) continue;

         // check if array can be used as is - one dimension and normal values
         if ((this.brarray[n] === true) && (checkArrayPrototype(arg[name], true) === 2)) {
            // plain array, can be used as is
            arrs[n] = arg[name];
         } else {
            let iter = new ArrayIterator(arg[name], this.brarray[n], obj);
            arrs[n] = [];
            while (iter.next()) arrs[n].push(iter.value);
         }
         if ((usearrlen < 0) || (usearrlen < arrs[n].length)) usearrlen = arrs[n].length;
      }

      if (usearrlen < 0) {
         this.value = this.direct_branch ? arg.var0 : this.func(arg);
         if (!this.kind) this.kind = typeof this.value;
         return;
      }

      if (usearrlen == 0) {
         // empty array - no any histogram should be filled
         this.length = 0;
         this.value = 0;
         return;
      }

      this.length = usearrlen;
      this.isarray = true;

      if (this.direct_branch) {
         this.value = arrs[0]; // just use array
      } else {
         this.value = new Array(usearrlen);

         for (let k = 0; k < usearrlen; ++k) {
            for (let n = 0; n < this.branches.length; ++n) {
               if (arrs[n]) arg['var' + n] = arrs[n][k];
            }
            this.value[k] = this.func(arg);
         }
      }

      if (!this.kind) this.kind = typeof this.value[0];
   }

   /** @summary Get variable */
   get(indx) { return this.isarray ? this.value[indx] : this.value; }

   /** @summary Append array to the buffer */
   appendArray(tgtarr) { this.buf = this.buf.concat(tgtarr[this.branches[0]]); }

} // class TDrawVariable


/**
 * @summary Selector class for TTree::Draw function
 *
 * @private
 */

class TDrawSelector extends TSelector {

   /** @summary constructor */
   constructor() {
      super();

      this.ndim = 0;
      this.vars = []; // array of expression variables
      this.cut = null; // cut variable
      this.hist = null;
      this.histo_drawopt = '';
      this.hist_name = '$htemp';
      this.hist_title = 'Result of TTree::Draw';
      this.graph = false;
      this.hist_args = []; // arguments for histogram creation
      this.arr_limit = 1000;  // number of accumulated items before create histogram
      this.htype = 'F';
      this.monitoring = 0;
      this.globals = {}; // object with global parameters, which could be used in any draw expression
      this.last_progress = 0;
      this.aver_diff = 0;
   }

   /** @summary Set draw selector callbacks */
   setCallback(result_callback, progress_callback) {
      this.result_callback = result_callback;
      this.progress_callback = progress_callback;
   }

   /** @summary Parse parameters */
   parseParameters(tree, args, expr) {

      if (!expr || !isStr(expr)) return '';

      // parse parameters which defined at the end as expression;par1name:par1value;par2name:par2value
      let pos = expr.lastIndexOf(';');
      while (pos >= 0) {
         let parname = expr.slice(pos + 1), parvalue = undefined;
         expr = expr.slice(0, pos);
         pos = expr.lastIndexOf(';');

         let separ = parname.indexOf(':');
         if (separ > 0) { parvalue = parname.slice(separ + 1); parname = parname.slice(0, separ); }

         let intvalue = parseInt(parvalue);
         if (!parvalue || !Number.isInteger(intvalue)) intvalue = undefined;

         switch (parname) {
            case 'num':
            case 'entries':
            case 'numentries':
               if (parvalue === 'all')
                  args.numentries = tree.fEntries;
               else if (parvalue === 'half')
                  args.numentries = Math.round(tree.fEntries / 2);
               else if (intvalue !== undefined)
                  args.numentries = intvalue;
               break;
            case 'first':
               if (intvalue !== undefined) args.firstentry = intvalue;
               break;
            case 'mon':
            case 'monitor':
               args.monitoring = (intvalue !== undefined) ? intvalue : 5000;
               break;
            case 'player':
               args.player = true;
               break;
            case 'dump':
               args.dump = true;
               break;
            case 'maxseg':
            case 'maxrange':
               if (intvalue) tree.$file.fMaxRanges = intvalue;
               break;
            case 'accum':
               if (intvalue) this.arr_limit = intvalue;
               break;
            case 'htype':
               if (parvalue && (parvalue.length === 1)) {
                  this.htype = parvalue.toUpperCase();
                  if (['C', 'S', 'I', 'F', 'L', 'D'].indexOf(this.htype) < 0)
                     this.htype = 'F';
               }
               break;
            case 'hbins':
               this.hist_nbins = parseInt(parvalue);
               if (!Number.isInteger(this.hist_nbins) || (this.hist_nbins <= 3))
                  delete this.hist_nbins;
               else
                  this.want_hist = true;
               break;
            case 'drawopt':
               args.drawopt = parvalue;
               break;
            case 'graph':
               args.graph = intvalue || true;
               break;
         }
      }

      pos = expr.lastIndexOf('>>');
      if (pos >= 0) {
         let harg = expr.slice(pos + 2).trim();
         expr = expr.slice(0, pos).trim();
         pos = harg.indexOf('(');
         if (pos > 0) {
            this.hist_name = harg.slice(0, pos);
            harg = harg.slice(pos);
         }
         if (harg === 'dump') {
            args.dump = true;
         } else if (harg.indexOf('Graph') == 0) {
            args.graph = true;
         } else if (pos < 0) {
            this.want_hist = true;
            this.hist_name = harg;
         } else if ((harg[0] == '(') && (harg[harg.length - 1] == ')')) {
            this.want_hist = true;
            harg = harg.slice(1, harg.length - 1).split(',');
            let isok = true;
            for (let n = 0; n < harg.length; ++n) {
               harg[n] = (n % 3 === 0) ? parseInt(harg[n]) : parseFloat(harg[n]);
               if (!Number.isFinite(harg[n])) isok = false;
            }
            if (isok) this.hist_args = harg;
         }
      }

      if (args.dump) {
         this.dump_values = true;
         args.reallocate_objects = true;
         if (args.numentries === undefined) args.numentries = 10;
      }

      return expr;
   }

   /** @summary Parse draw expression */
   parseDrawExpression(tree, args) {

      // parse complete expression
      let expr = this.parseParameters(tree, args, args.expr), cut = '';

      // parse option for histogram creation
      this.hist_title = `drawing '${expr}' from ${tree.fName}`;

      let pos = 0;
      if (args.cut) {
         cut = args.cut;
      } else {
         pos = expr.replace(/TMath::/g, 'TMath__').lastIndexOf('::'); // avoid confusion due-to :: in the namespace
         if (pos > 0) {
            cut = expr.slice(pos + 2).trim();
            expr = expr.slice(0, pos).trim();
         }
      }

      args.parse_expr = expr;
      args.parse_cut = cut;

      // let names = expr.split(':'); // to allow usage of ? operator, we need to handle : as well
      let names = [], nbr1 = 0, nbr2 = 0, prev = 0;
      for (pos = 0; pos < expr.length; ++pos) {
         switch (expr[pos]) {
            case '(': nbr1++; break;
            case ')': nbr1--; break;
            case '[': nbr2++; break;
            case ']': nbr2--; break;
            case ':':
               if (expr[pos + 1] == ':') { pos++; continue; }
               if (!nbr1 && !nbr2 && (pos > prev)) names.push(expr.slice(prev, pos));
               prev = pos + 1;
               break;
         }
      }
      if (!nbr1 && !nbr2 && (pos > prev)) names.push(expr.slice(prev, pos));

      if ((names.length < 1) || (names.length > 3)) return false;

      this.ndim = names.length;

      let is_direct = !cut;

      for (let n = 0; n < this.ndim; ++n) {
         this.vars[n] = new TDrawVariable(this.globals);
         if (!this.vars[n].parse(tree, this, names[n])) return false;
         if (!this.vars[n].direct_branch) is_direct = false;
      }

      this.cut = new TDrawVariable(this.globals);
      if (cut)
         if (!this.cut.parse(tree, this, cut)) return false;

      if (!this.numBranches()) {
         console.warn('no any branch is selected');
         return false;
      }

      if (is_direct) this.ProcessArrays = this.ProcessArraysFunc;

      this.monitoring = args.monitoring;

      // force TPolyMarker3D drawing for 3D case
      if ((this.ndim == 3) && !this.want_hist && !args.dump) args.graph = true;

      this.graph = args.graph;

      if (args.drawopt !== undefined)
         this.histo_drawopt = args.drawopt;
      else
         this.histo_drawopt = (this.ndim === 2) ? 'col' : '';

      return true;
   }

   /** @summary Draw only specified branch */
   drawOnlyBranch(tree, branch, expr, args) {
      this.ndim = 1;

      if (expr.indexOf('dump') == 0) expr = ';' + expr;

      expr = this.parseParameters(tree, args, expr);

      this.monitoring = args.monitoring;

      if (args.dump) {
         this.dump_values = true;
         args.reallocate_objects = true;
      }

      if (this.dump_values) {

         this.hist = []; // array of dump objects

         this.leaf = args.leaf;

         // branch object remains, therefore we need to copy fields to see them all
         this.copy_fields = ((args.branch.fLeaves && (args.branch.fLeaves.arr.length > 1)) ||
            (args.branch.fBranches && (args.branch.fBranches.arr.length > 0))) && !args.leaf;

         this.addBranch(branch, 'br0', args.direct_branch); // add branch

         this.Process = this.ProcessDump;

         return true;
      }

      this.vars[0] = new TDrawVariable(this.globals);
      if (!this.vars[0].parse(tree, this, expr, branch, args.direct_branch)) return false;
      this.hist_title = `drawing branch ${branch.fName} ${expr?' expr:'+expr:''} from ${tree.fName}`;

      this.cut = new TDrawVariable(this.globals);

      if (this.vars[0].direct_branch) this.ProcessArrays = this.ProcessArraysFunc;

      return true;
   }

   /** @summary Begin processing */
   Begin(tree) {
      this.globals.entries = tree.fEntries;

      if (this.monitoring)
         this.lasttm = new Date().getTime();
   }

   /** @summary Show progress */
   ShowProgress(/*value*/) { }

   /** @summary Get bins for bits histogram */
   getBitsBins(nbits, res) {
      res.nbins = res.max = nbits;
      res.fLabels = create$1(clTHashList);
      for (let k = 0; k < nbits; ++k) {
         let s = create$1(clTObjString);
         s.fString = k.toString();
         s.fUniqueID = k + 1;
         res.fLabels.Add(s);
      }
      return res;
   }

   /** @summary Get min.max bins */
   getMinMaxBins(axisid, nbins) {

      let res = { min: 0, max: 0, nbins: nbins, k: 1., fLabels: null, title: '' };

      if (axisid >= this.ndim) return res;

      let arr = this.vars[axisid].buf;

      res.title = this.vars[axisid].code || '';

      if (this.vars[axisid].kind === 'object') {
         // this is any object type
         let typename, similar = true, maxbits = 8;
         for (let k = 0; k < arr.length; ++k) {
            if (!arr[k]) continue;
            if (!typename) typename = arr[k]._typename;
            if (typename !== arr[k]._typename) similar = false; // check all object types
            if (arr[k].fNbits) maxbits = Math.max(maxbits, arr[k].fNbits + 1);
         }

         if (typename && similar) {
            if ((typename === 'TBits') && (axisid === 0)) {
               this.fill1DHistogram = this.fillTBitsHistogram;
               if (maxbits % 8) maxbits = (maxbits & 0xfff0) + 8;

               if ((this.hist_name === 'bits') && (this.hist_args.length == 1) && this.hist_args[0])
                  maxbits = this.hist_args[0];

               return this.getBitsBins(maxbits, res);
            }
         }
      }

      if (this.vars[axisid].kind === 'string') {
         res.lbls = []; // all labels

         for (let k = 0; k < arr.length; ++k)
            if (res.lbls.indexOf(arr[k]) < 0)
               res.lbls.push(arr[k]);

         res.lbls.sort();
         res.max = res.nbins = res.lbls.length;

         res.fLabels = create$1(clTHashList);
         for (let k = 0; k < res.lbls.length; ++k) {
            let s = create$1(clTObjString);
            s.fString = res.lbls[k];
            s.fUniqueID = k + 1;
            if (s.fString === '') s.fString = '<empty>';
            res.fLabels.Add(s);
         }
      } else if ((axisid === 0) && (this.hist_name === 'bits') && (this.hist_args.length <= 1)) {
         this.fill1DHistogram = this.FillBitsHistogram;
         return this.getBitsBins(this.hist_args[0] || 32, res);
      } else if (axisid * 3 + 2 < this.hist_args.length) {
         res.nbins = this.hist_args[axisid * 3];
         res.min = this.hist_args[axisid * 3 + 1];
         res.max = this.hist_args[axisid * 3 + 2];
      } else {

         res.min = Math.min.apply(null, arr);
         res.max = Math.max.apply(null, arr);

         if (this.hist_nbins)
            nbins = res.nbins = this.hist_nbins;

         res.isinteger = (Math.round(res.min) === res.min) && (Math.round(res.max) === res.max);
         if (res.isinteger)
            for (let k = 0; k < arr.length; ++k)
               if (arr[k] !== Math.round(arr[k])) { res.isinteger = false; break; }

         if (res.isinteger) {
            res.min = Math.round(res.min);
            res.max = Math.round(res.max);
            if (res.max - res.min < nbins * 5) {
               res.min -= 1;
               res.max += 2;
               res.nbins = Math.round(res.max - res.min);
            } else {
               let range = (res.max - res.min + 2), step = Math.floor(range / nbins);
               while (step * nbins < range) step++;
               res.max = res.min + nbins * step;
            }
         } else if (res.min >= res.max) {
            res.max = res.min;
            if (Math.abs(res.min) < 100) { res.min -= 1; res.max += 1; } else
               if (res.min > 0) { res.min *= 0.9; res.max *= 1.1; } else { res.min *= 1.1; res.max *= 0.9; }
         } else {
            res.max += (res.max - res.min) / res.nbins;
         }
      }

      res.k = res.nbins / (res.max - res.min);

      res.GetBin = function(value) {
         const bin = this.lbls ? this.lbls.indexOf(value) : Math.floor((value - this.min) * this.k);
         return (bin < 0) ? 0 : ((bin > this.nbins) ? this.nbins + 1 : bin + 1);
      };

      return res;
   }

   /** @summary Create histogram which matches value in dimensions */
   createHistogram(nbins, set_hist = false) {
      if (!nbins) nbins = 20;

      let x = this.getMinMaxBins(0, nbins),
          y = this.getMinMaxBins(1, nbins),
          z = this.getMinMaxBins(2, nbins),
          hist = null;

      switch (this.ndim) {
         case 1: hist = createHistogram(clTH1 + this.htype, x.nbins); break;
         case 2: hist = createHistogram(clTH2 + this.htype, x.nbins, y.nbins); break;
         case 3: hist = createHistogram(clTH3 + this.htype, x.nbins, y.nbins, z.nbins); break;
      }

      hist.fXaxis.fTitle = x.title;
      hist.fXaxis.fXmin = x.min;
      hist.fXaxis.fXmax = x.max;
      hist.fXaxis.fLabels = x.fLabels;

      if (this.ndim > 1) hist.fYaxis.fTitle = y.title;
      hist.fYaxis.fXmin = y.min;
      hist.fYaxis.fXmax = y.max;
      hist.fYaxis.fLabels = y.fLabels;

      if (this.ndim > 2) hist.fZaxis.fTitle = z.title;
      hist.fZaxis.fXmin = z.min;
      hist.fZaxis.fXmax = z.max;
      hist.fZaxis.fLabels = z.fLabels;

      hist.fName = this.hist_name;
      hist.fTitle = this.hist_title;
      hist.fOption = this.histo_drawopt;
      hist.$custom_stat = (this.hist_name == '$htemp') ? 111110 : 111111;

      if (set_hist) {
         this.hist = hist;
         this.x = x;
         this.y = y;
         this.z = z;
      } else {
         let kNoStats = BIT(9);
         hist.fBits = hist.fBits | kNoStats;
      }

      return hist;
   }

   /** @summary Create output object - histogram, graph, dump array */
   createOutputObject() {
      if (this.hist || !this.vars[0].buf) return;

      if (this.dump_values) {
         // just create array where dumped valus will be collected
         this.hist = [];

         // reassign fill method
         this.fill1DHistogram = this.fill2DHistogram = this.fill3DHistogram = this.dumpValues;
      } else if (this.graph) {
         let N = this.vars[0].buf.length, res = null;

         if (this.ndim == 1) {
            // A 1-dimensional graph will just have the x axis as an index
            res = createTGraph(N, Array.from(Array(N).keys()), this.vars[0].buf);
            res.fName = 'Graph';
            res.fTitle = this.hist_title;
         } else if (this.ndim == 2) {
            res = createTGraph(N, this.vars[0].buf, this.vars[1].buf);
            res.fName = 'Graph';
            res.fTitle = this.hist_title;
            delete this.vars[1].buf;
         } else if (this.ndim == 3) {
            res = create$1(clTPolyMarker3D);
            res.fN = N;
            res.fLastPoint = N - 1;
            let arr = new Array(N*3);
            for (let k = 0; k< N; ++k) {
               arr[k*3] = this.vars[0].buf[k];
               arr[k*3+1] = this.vars[1].buf[k];
               arr[k*3+2] = this.vars[2].buf[k];
            }
            res.fP = arr;
            res.$hist = this.createHistogram(10);
            delete this.vars[1].buf;
            delete this.vars[2].buf;
            res.fName = 'Points';
         }

         this.hist = res;

      } else {
         let nbins = [ 200, 50, 20 ];
         this.createHistogram(nbins[this.ndim], true);
      }

      let var0 = this.vars[0].buf, cut = this.cut.buf, len = var0.length;

      if (!this.graph) {
         switch (this.ndim) {
            case 1: {
               for (let n = 0; n < len; ++n)
                  this.fill1DHistogram(var0[n], cut ? cut[n] : 1.);
               break;
            }
            case 2: {
               let var1 = this.vars[1].buf;
               for (let n = 0; n < len; ++n)
                  this.fill2DHistogram(var0[n], var1[n], cut ? cut[n] : 1.);
               delete this.vars[1].buf;
               break;
            }
            case 3: {
               let var1 = this.vars[1].buf, var2 = this.vars[2].buf;
               for (let n = 0; n < len; ++n)
                  this.fill3DHistogram(var0[n], var1[n], var2[n], cut ? cut[n] : 1.);
               delete this.vars[1].buf;
               delete this.vars[2].buf;
               break;
            }
         }
      }

      delete this.vars[0].buf;
      delete this.cut.buf;
   }

   /** @summary Fill TBits histogram */
   fillTBitsHistogram(xvalue, weight) {
      if (!weight || !xvalue || !xvalue.fNbits || !xvalue.fAllBits) return;

      const sz = Math.min(xvalue.fNbits + 1, xvalue.fNbytes * 8);

      for (let bit = 0, mask = 1, b = 0; bit < sz; ++bit) {
         if (xvalue.fAllBits[b] && mask) {
            if (bit <= this.x.nbins)
               this.hist.fArray[bit + 1] += weight;
            else
               this.hist.fArray[this.x.nbins + 1] += weight;
         }

         mask *= 2;
         if (mask >= 0x100) { mask = 1; ++b; }
      }
   }

   /** @summary Fill bits histogram */
   FillBitsHistogram(xvalue, weight) {
      if (!weight) return;

      for (let bit = 0, mask = 1; bit < this.x.nbins; ++bit) {
         if (xvalue & mask) this.hist.fArray[bit + 1] += weight;
         mask *= 2;
      }
   }

   /** @summary Fill 1D histogram */
   fill1DHistogram(xvalue, weight) {
      let bin = this.x.GetBin(xvalue);
      this.hist.fArray[bin] += weight;

      if (!this.x.lbls) {
         this.hist.fTsumw += weight;
         this.hist.fTsumwx += weight * xvalue;
         this.hist.fTsumwx2 += weight * xvalue * xvalue;
      }
   }

   /** @summary Fill 2D histogram */
   fill2DHistogram(xvalue, yvalue, weight) {
      let xbin = this.x.GetBin(xvalue),
         ybin = this.y.GetBin(yvalue);

      this.hist.fArray[xbin + (this.x.nbins + 2) * ybin] += weight;
      if (!this.x.lbls && !this.y.lbls) {
         this.hist.fTsumw += weight;
         this.hist.fTsumwx += weight * xvalue;
         this.hist.fTsumwy += weight * yvalue;
         this.hist.fTsumwx2 += weight * xvalue * xvalue;
         this.hist.fTsumwxy += weight * xvalue * yvalue;
         this.hist.fTsumwy2 += weight * yvalue * yvalue;
      }
   }

   /** @summary Fill 3D histogram */
   fill3DHistogram(xvalue, yvalue, zvalue, weight) {
      let xbin = this.x.GetBin(xvalue),
         ybin = this.y.GetBin(yvalue),
         zbin = this.z.GetBin(zvalue);

      this.hist.fArray[xbin + (this.x.nbins + 2) * (ybin + (this.y.nbins + 2) * zbin)] += weight;
      if (!this.x.lbls && !this.y.lbls && !this.z.lbls) {
         this.hist.fTsumw += weight;
         this.hist.fTsumwx += weight * xvalue;
         this.hist.fTsumwy += weight * yvalue;
         this.hist.fTsumwz += weight * zvalue;
         this.hist.fTsumwx2 += weight * xvalue * xvalue;
         this.hist.fTsumwy2 += weight * yvalue * yvalue;
         this.hist.fTsumwz2 += weight * zvalue * zvalue;
         this.hist.fTsumwxy += weight * xvalue * yvalue;
         this.hist.fTsumwxz += weight * xvalue * zvalue;
         this.hist.fTsumwyz += weight * yvalue * zvalue;
      }
   }

   /** @summary Dump values */
   dumpValues(v1, v2, v3, v4) {
      let obj;
      switch (this.ndim) {
         case 1: obj = { x: v1, weight: v2 }; break;
         case 2: obj = { x: v1, y: v2, weight: v3 }; break;
         case 3: obj = { x: v1, y: v2, z: v3, weight: v4 }; break;
      }

      if (this.cut.is_dummy()) {
         if (this.ndim === 1)
            obj = v1;
         else
            delete obj.weight;
      }

      this.hist.push(obj);
   }

    /** @summary function used when all branches can be read as array
      * @desc most typical usage - histogramming of single branch */
   ProcessArraysFunc(/*entry*/) {

      if (this.arr_limit || this.graph) {
         let var0 = this.vars[0],
             var1 = this.vars[1],
             var2 = this.vars[2],
             len = this.tgtarr.br0.length;
         if ((var0.buf.length === 0) && (len >= this.arr_limit) && !this.graph) {
            // special use case - first array large enough to create histogram directly base on it
            var0.buf = this.tgtarr.br0;
            if (var1) var1.buf = this.tgtarr.br1;
            if (var2) var2.buf = this.tgtarr.br2;
         } else {
            for (let k = 0; k < len; ++k) {
               var0.buf.push(this.tgtarr.br0[k]);
               if (var1) var1.buf.push(this.tgtarr.br1[k]);
               if (var2) var2.buf.push(this.tgtarr.br2[k]);
            }
         }
         var0.kind = 'number';
         if (var1) var1.kind = 'number';
         if (var2) var2.kind = 'number';
         this.cut.buf = null; // do not create buffer for cuts
         if (!this.graph && (var0.buf.length >= this.arr_limit)) {
            this.createOutputObject();
            this.arr_limit = 0;
         }
      } else {
         let br0 = this.tgtarr.br0, len = br0.length;
         switch (this.ndim) {
            case 1: {
               for (let k = 0; k < len; ++k)
                  this.fill1DHistogram(br0[k], 1.);
               break;
            }
            case 2: {
               let br1 = this.tgtarr.br1;
               for (let k = 0; k < len; ++k)
                  this.fill2DHistogram(br0[k], br1[k], 1.);
               break;
            }
            case 3: {
               let br1 = this.tgtarr.br1, br2 = this.tgtarr.br2;
               for (let k = 0; k < len; ++k)
                  this.fill3DHistogram(br0[k], br1[k], br2[k], 1.);
               break;
            }
         }
      }
   }

   /** @summary simple dump of the branch - no need to analyze something */
   ProcessDump(/* entry */) {

      let res = this.leaf ? this.tgtobj.br0[this.leaf] : this.tgtobj.br0;

      if (res && this.copy_fields) {
         if (checkArrayPrototype(res) === 0) {
            this.hist.push(Object.assign({}, res));
         } else {
            this.hist.push(res);
         }
      } else {
         this.hist.push(res);
      }
   }

   /** @summary Normal TSelector Process handler */
   Process(entry) {

      this.globals.entry = entry; // can be used in any expression

      this.cut.produce(this.tgtobj);
      if (!this.dump_values && !this.cut.value) return;

      for (let n = 0; n < this.ndim; ++n)
         this.vars[n].produce(this.tgtobj);

      let var0 = this.vars[0], var1 = this.vars[1], var2 = this.vars[2], cut = this.cut;

      if (this.graph || this.arr_limit) {
         switch (this.ndim) {
            case 1:
               for (let n0 = 0; n0 < var0.length; ++n0) {
                  var0.buf.push(var0.get(n0));
                  cut.buf.push(cut.value);
               }
               break;
            case 2:
               for (let n0 = 0; n0 < var0.length; ++n0)
                  for (let n1 = 0; n1 < var1.length; ++n1) {
                     var0.buf.push(var0.get(n0));
                     var1.buf.push(var1.get(n1));
                     cut.buf.push(cut.value);
                  }
               break;
            case 3:
               for (let n0 = 0; n0 < var0.length; ++n0)
                  for (let n1 = 0; n1 < var1.length; ++n1)
                     for (let n2 = 0; n2 < var2.length; ++n2) {
                        var0.buf.push(var0.get(n0));
                        var1.buf.push(var1.get(n1));
                        var2.buf.push(var2.get(n2));
                        cut.buf.push(cut.value);
                     }
               break;
         }
         if (!this.graph && (var0.buf.length >= this.arr_limit)) {
            this.createOutputObject();
            this.arr_limit = 0;
         }
      } else if (this.hist) {
         switch (this.ndim) {
            case 1:
               for (let n0 = 0; n0 < var0.length; ++n0)
                  this.fill1DHistogram(var0.get(n0), cut.value);
               break;
            case 2:
               for (let n0 = 0; n0 < var0.length; ++n0)
                  for (let n1 = 0; n1 < var1.length; ++n1)
                     this.fill2DHistogram(var0.get(n0), var1.get(n1), cut.value);
               break;
            case 3:
               for (let n0 = 0; n0 < var0.length; ++n0)
                  for (let n1 = 0; n1 < var1.length; ++n1)
                     for (let n2 = 0; n2 < var2.length; ++n2)
                        this.fill3DHistogram(var0.get(n0), var1.get(n1), var2.get(n2), cut.value);
               break;
         }
      }

      if (this.monitoring && this.hist && !this.dump_values) {
         let now = new Date().getTime();
         if (now - this.lasttm > this.monitoring) {
            this.lasttm = now;
            if (this.progress_callback)
               this.progress_callback(this.hist);
         }
      }
   }

   /** @summary Normal TSelector Terminate handler */
   Terminate(res) {
      if (res && !this.hist)
         this.createOutputObject();

      this.ShowProgress();

      if (isFunc(this.result_callback))
         this.result_callback(this.hist);
   }

} // class TDrawSelector


/** @summary return TStreamerElement associated with the branch - if any
  * @desc unfortunately, branch.fID is not number of element in streamer info
  * @private */
function findBrachStreamerElement(branch, file) {
   if (!branch || !file || (branch._typename !== clTBranchElement) || (branch.fID < 0) || (branch.fStreamerType < 0)) return null;

   let s_i = file.findStreamerInfo(branch.fClassName, branch.fClassVersion, branch.fCheckSum),
      arr = (s_i && s_i.fElements) ? s_i.fElements.arr : null;
   if (!arr) return null;

   let match_name = branch.fName,
      pos = match_name.indexOf('[');
   if (pos > 0) match_name = match_name.slice(0, pos);
   pos = match_name.lastIndexOf('.');
   if (pos > 0) match_name = match_name.slice(pos + 1);

   function match_elem(elem) {
      if (!elem) return false;
      if (elem.fName !== match_name) return false;
      if (elem.fType === branch.fStreamerType) return true;
      if ((elem.fType === kBool) && (branch.fStreamerType === kUChar)) return true;
      if (((branch.fStreamerType === kSTL) || (branch.fStreamerType === kSTL + kOffsetL) ||
         (branch.fStreamerType === kSTLp) || (branch.fStreamerType === kSTLp + kOffsetL))
         && (elem.fType === kStreamer)) return true;
      console.warn(`Should match element ${elem.fType} with branch ${branch.fStreamerType}`);
      return false;
   }

   // first check branch fID - in many cases gut guess
   if (match_elem(arr[branch.fID])) return arr[branch.fID];

   // console.warn(`Missmatch with branch name ${branch.fName} and extracted element ${match_name} ${s_elem?.fName}`);

   for (let k = 0; k < arr.length; ++k)
      if ((k !== branch.fID) && match_elem(arr[k])) return arr[k];

   console.error(`Did not found/match element for branch ${branch.fName} class ${branch.fClassName}`);

   return null;
}

/** @summary return type name of given member in the class
  * @private */
function defineMemberTypeName(file, parent_class, member_name) {
   let s_i = file.findStreamerInfo(parent_class),
      arr = (s_i && s_i.fElements) ? s_i.fElements.arr : null,
      elem = null;
   if (!arr) return '';

   for (let k = 0; k < arr.length; ++k) {
      if (arr[k].fTypeName === 'BASE') {
         let res = defineMemberTypeName(file, arr[k].fName, member_name);
         if (res) return res;
      } else
         if (arr[k].fName === member_name) { elem = arr[k]; break; }
   }

   if (!elem) return '';

   let clname = elem.fTypeName;
   if (clname[clname.length - 1] === '*') clname = clname.slice(0, clname.length - 1);

   return clname;
}

/** @summary create fast list to assign all methods to the object
  * @private */
function makeMethodsList(typename) {
   let methods = getMethods(typename);

   let res = {
      names: [],
      values: [],
      Create() {
         let obj = {};
         for (let n = 0; n < this.names.length; ++n)
            obj[this.names[n]] = this.values[n];
         return obj;
      }
   };

   res.names.push('_typename');
   res.values.push(typename);
   for (let key in methods) {
      res.names.push(key);
      res.values.push(methods[key]);
   }
   return res;
}

/** @summary try to define classname for the branch member, scanning list of branches
  * @private */
function detectBranchMemberClass(brlst, prefix, start) {
   let clname = '';
   for (let kk = (start || 0); kk < brlst.arr.length; ++kk)
      if ((brlst.arr[kk].fName.indexOf(prefix) === 0) && brlst.arr[kk].fClassName)
         clname = brlst.arr[kk].fClassName;
   return clname;
}

/** @summary Process selector for the tree
  * @desc function similar to the TTree::Process
  * @param {object} tree - instance of TTree class
  * @param {object} selector - instance of {@link TSelector} class
  * @param {object} [args] - different arguments
  * @param {number} [args.firstentry] - first entry to process, 0 when not specified
  * @param {number} [args.numentries] - number of entries to process, all when not specified
  * @return {Promise} with TSelector instance */
async function treeProcess(tree, selector, args) {
   if (!args) args = {};

   if (!selector || !tree.$file || !selector.numBranches()) {
      if (selector) selector.Terminate(false);
      return Promise.reject(Error('required parameter missing for TTree::Process'));
   }

   // central handle with all information required for reading
   const handle = {
      tree, // keep tree reference
      file: tree.$file, // keep file reference
      selector: selector, // reference on selector
      arr: [], // list of branches
      curr: -1,  // current entry ID
      current_entry: -1, // current processed entry
      simple_read: true, // all baskets in all used branches are in sync,
      process_arrays: true // one can process all branches as arrays
   };

   const createLeafElem = (leaf, name) => {
      // function creates TStreamerElement which corresponds to the elementary leaf
      let datakind = 0;
      switch (leaf._typename) {
         case 'TLeafF': datakind = kFloat; break;
         case 'TLeafD': datakind = kDouble; break;
         case 'TLeafO': datakind = kBool; break;
         case 'TLeafB': datakind = leaf.fIsUnsigned ? kUChar : kChar; break;
         case 'TLeafS': datakind = leaf.fIsUnsigned ? kUShort : kShort; break;
         case 'TLeafI': datakind = leaf.fIsUnsigned ? kUInt : kInt; break;
         case 'TLeafL': datakind = leaf.fIsUnsigned ? kULong64 : kLong64; break;
         case 'TLeafC': datakind = kTString; break;
         default: return null;
      }
      return createStreamerElement(name || leaf.fName, datakind);

   }, findInHandle = branch => {
      for (let k = 0; k < handle.arr.length; ++k)
         if (handle.arr[k].branch === branch)
             return handle.arr[k];
      return null;
   };

   let namecnt = 0;

   function AddBranchForReading(branch, target_object, target_name, read_mode) {
      // central method to add branch for reading
      // read_mode == true - read only this branch
      // read_mode == '$child$' is just member of object from for STL or clonesarray
      // read_mode == '<any class name>' is sub-object from STL or clonesarray, happens when such new object need to be created
      // read_mode == '.member_name' select only reading of member_name instead of complete object

      if (isStr(branch))
         branch = findBranch(handle.tree, branch);

      if (!branch) { console.error('Did not found branch'); return null; }

      let item = findInHandle(branch);

      if (item) {
         console.error(`Branch ${branch.fName} already configured for reading`);
         if (item.tgt !== target_object) console.error('Target object differs');
         return null;
      }

      if (!branch.fEntries) {
         console.warn(`Branch ${branch.fName} does not have entries`);
         return null;
      }

      // console.log(`Add branch ${branch.fName}`);

      item = {
         branch: branch,
         tgt: target_object, // used target object - can be differ for object members
         name: target_name,
         index: -1, // index in the list of read branches
         member: null, // member to read branch
         type: 0, // keep type identifier
         curr_entry: -1, // last processed entry
         raw: null, // raw buffer for reading
         basket: null, // current basket object
         curr_basket: 0,  // number of basket used for processing
         read_entry: -1,  // last entry which is already read
         staged_entry: -1, // entry which is staged for reading
         first_readentry: -1, // first entry to read
         staged_basket: 0,  // last basket staged for reading
         numentries: branch.fEntries,
         numbaskets: branch.fWriteBasket, // number of baskets which can be read from the file
         counters: null, // branch indexes used as counters
         ascounter: [], // list of other branches using that branch as counter
         baskets: [], // array for read baskets,
         staged_prev: 0, // entry limit of previous I/O request
         staged_now: 0, // entry limit of current I/O request
         progress_showtm: 0, // last time when progress was showed
         GetBasketEntry(k) {
            if (!this.branch || (k > this.branch.fMaxBaskets)) return 0;
            let res = (k < this.branch.fMaxBaskets) ? this.branch.fBasketEntry[k] : 0;
            if (res) return res;
            let bskt = (k > 0) ? this.branch.fBaskets.arr[k - 1] : null;
            return bskt ? (this.branch.fBasketEntry[k - 1] + bskt.fNevBuf) : 0;
         },
         GetTarget(tgtobj) {
            // returns target object which should be used for the branch reading
            if (!this.tgt) return tgtobj;
            for (let k = 0; k < this.tgt.length; ++k) {
               let sub = this.tgt[k];
               if (!tgtobj[sub.name]) tgtobj[sub.name] = sub.lst.Create();
               tgtobj = tgtobj[sub.name];
            }
            return tgtobj;
         },
         GetEntry(entry) {
            // This should be equivalent to TBranch::GetEntry() method
            let shift = entry - this.first_entry, off;
            if (!this.branch.TestBit(kDoNotUseBufferMap))
               this.raw.clearObjectMap();
            if (this.basket.fEntryOffset) {
               off = this.basket.fEntryOffset[shift];
               if (this.basket.fDisplacement)
                  this.raw.fDisplacement = this.basket.fDisplacement[shift];
            } else {
               off = this.basket.fKeylen + this.basket.fNevBufSize * shift;
            }
            this.raw.locate(off - this.raw.raw_shift);

            // this.member.func(this.raw, this.GetTarget(tgtobj));
         }
      };

      // last basket can be stored directly with the branch
      while (item.GetBasketEntry(item.numbaskets + 1)) item.numbaskets++;

      // check all counters if we
      let nb_leaves = branch.fLeaves ? branch.fLeaves.arr.length : 0,
         leaf = (nb_leaves > 0) ? branch.fLeaves.arr[0] : null,
         elem = null, // TStreamerElement used to create reader
         member = null, // member for actual reading of the branch
         is_brelem = (branch._typename === clTBranchElement),
         child_scan = 0, // scan child branches after main branch is appended
         item_cnt = null, item_cnt2 = null, object_class = '';

      if (branch.fBranchCount) {

         item_cnt = findInHandle(branch.fBranchCount);

         if (!item_cnt)
            item_cnt = AddBranchForReading(branch.fBranchCount, target_object, '$counter' + namecnt++, true);

         if (!item_cnt) { console.error(`Cannot add counter branch ${branch.fBranchCount.fName}`); return null; }

         let BranchCount2 = branch.fBranchCount2;

         if (!BranchCount2 && (branch.fBranchCount.fStreamerType === kSTL) &&
            ((branch.fStreamerType === kStreamLoop) || (branch.fStreamerType === kOffsetL + kStreamLoop))) {
            // special case when count member from kStreamLoop not assigned as fBranchCount2
            let elemd = findBrachStreamerElement(branch, handle.file),
               arrd = branch.fBranchCount.fBranches.arr;

            if (elemd && elemd.fCountName && arrd)
               for (let k = 0; k < arrd.length; ++k)
                  if (arrd[k].fName === branch.fBranchCount.fName + '.' + elemd.fCountName) {
                     BranchCount2 = arrd[k];
                     break;
                  }

            if (!BranchCount2) console.error('Did not found branch for second counter of kStreamLoop element');
         }

         if (BranchCount2) {
            item_cnt2 = findInHandle(BranchCount2);

            if (!item_cnt2) item_cnt2 = AddBranchForReading(BranchCount2, target_object, '$counter' + namecnt++, true);

            if (!item_cnt2) { console.error(`Cannot add counter branch2 ${BranchCount2.fName}`); return null; }
         }
      } else if (nb_leaves === 1 && leaf && leaf.fLeafCount) {
         let br_cnt = findBranch(handle.tree, leaf.fLeafCount.fName);

         if (br_cnt) {
            item_cnt = findInHandle(br_cnt);

            if (!item_cnt) item_cnt = AddBranchForReading(br_cnt, target_object, '$counter' + namecnt++, true);

            if (!item_cnt) { console.error(`Cannot add counter branch ${br_cnt.fName}`); return null; }
         }
      }

      function ScanBranches(lst, master_target, chld_kind) {
         if (!lst || !lst.arr.length) return true;

         let match_prefix = branch.fName;
         if (match_prefix[match_prefix.length - 1] === '.') match_prefix = match_prefix.slice(0, match_prefix.length - 1);
         if (isStr(read_mode) && (read_mode[0] == '.')) match_prefix += read_mode;
         match_prefix += '.';

         for (let k = 0; k < lst.arr.length; ++k) {
            let br = lst.arr[k];
            if ((chld_kind > 0) && (br.fType !== chld_kind)) continue;

            if (br.fType === kBaseClassNode) {
               if (!ScanBranches(br.fBranches, master_target, chld_kind)) return false;
               continue;
            }

            let elem = findBrachStreamerElement(br, handle.file);
            if (elem && (elem.fTypeName === 'BASE')) {
               // if branch is data of base class, map it to original target
               if (br.fTotBytes && !AddBranchForReading(br, target_object, target_name, read_mode)) return false;
               if (!ScanBranches(br.fBranches, master_target, chld_kind)) return false;
               continue;
            }

            let subname = br.fName, chld_direct = 1;

            if (br.fName.indexOf(match_prefix) === 0) {
               subname = subname.slice(match_prefix.length);
            } else {
               if (chld_kind > 0) continue; // for defined children names prefix must be present
            }

            let p = subname.indexOf('[');
            if (p > 0) subname = subname.slice(0, p);
            p = subname.indexOf('<');
            if (p > 0) subname = subname.slice(0, p);

            if (chld_kind > 0) {
               chld_direct = '$child$';
               let pp = subname.indexOf('.');
               if (pp > 0) chld_direct = detectBranchMemberClass(lst, branch.fName + '.' + subname.slice(0, pp + 1), k) || clTObject;
            }

            if (!AddBranchForReading(br, master_target, subname, chld_direct)) return false;
         }

         return true;
      }

      if (branch._typename === 'TBranchObject') {
         member = {
            name: target_name,
            typename: branch.fClassName,
            virtual: leaf.fVirtual,
            func(buf, obj) {
               let clname = this.typename;
               if (this.virtual) clname = buf.readFastString(buf.ntou1() + 1);
               obj[this.name] = buf.classStreamer({}, clname);
            }
         };

      } else if ((branch.fType === kClonesNode) || (branch.fType === kSTLNode)) {

         elem = createStreamerElement(target_name, kInt);

         if (!read_mode || (isStr(read_mode) && (read_mode[0] === '.')) || (read_mode === 1)) {
            handle.process_arrays = false;

            member = {
               name: target_name,
               conttype: branch.fClonesName || clTObject,
               reallocate: args.reallocate_objects,
               func(buf, obj) {
                  let size = buf.ntoi4(), n = 0, arr = obj[this.name];
                  if (!arr || this.reallocate) {
                     arr = obj[this.name] = new Array(size);
                  } else {
                     n = arr.length;
                     arr.length = size; // reallocate array
                  }

                  while (n < size) arr[n++] = this.methods.Create(); // create new objects
               }
            };

            if (isStr(read_mode) && (read_mode[0] === '.')) {
               member.conttype = detectBranchMemberClass(branch.fBranches, branch.fName + read_mode);
               if (!member.conttype) {
                  console.error(`Cannot select object ${read_mode} in the branch ${branch.fName}`);
                  return null;
               }
            }

            member.methods = makeMethodsList(member.conttype);

            child_scan = (branch.fType === kClonesNode) ? kClonesMemberNode : kSTLMemberNode;
         }

      } else if ((object_class = getBranchObjectClass(branch, handle.tree))) {

         if (read_mode === true) {
            console.warn(`Object branch ${object_class} can not have data to be read directly`);
            return null;
         }

         handle.process_arrays = false;

         let newtgt = new Array(target_object ? (target_object.length + 1) : 1);
         for (let l = 0; l < newtgt.length - 1; ++l)
            newtgt[l] = target_object[l];
         newtgt[newtgt.length - 1] = { name: target_name, lst: makeMethodsList(object_class) };

         if (!ScanBranches(branch.fBranches, newtgt, 0)) return null;

         return item; // this kind of branch does not have baskets and not need to be read

      } else if (is_brelem && (nb_leaves === 1) && (leaf.fName === branch.fName) && (branch.fID == -1)) {

         elem = createStreamerElement(target_name, branch.fClassName);

         if (elem.fType === kAny) {

            let streamer = handle.file.getStreamer(branch.fClassName, { val: branch.fClassVersion, checksum: branch.fCheckSum });
            if (!streamer) { elem = null; console.warn('not found streamer!'); } else
               member = {
                  name: target_name,
                  typename: branch.fClassName,
                  streamer,
                  func(buf, obj) {
                     let res = { _typename: this.typename };
                     for (let n = 0; n < this.streamer.length; ++n)
                        this.streamer[n].func(buf, res);
                     obj[this.name] = res;
                  }
               };
         }

         // elem.fType = kAnyP;

         // only STL containers here
         // if (!elem.fSTLtype) elem = null;

      } else if (is_brelem && (nb_leaves <= 1)) {

         elem = findBrachStreamerElement(branch, handle.file);

         // this is basic type - can try to solve problem differently
         if (!elem && branch.fStreamerType && (branch.fStreamerType < 20))
            elem = createStreamerElement(target_name, branch.fStreamerType);

      } else if (nb_leaves === 1) {
         // no special constrains for the leaf names

         elem = createLeafElem(leaf, target_name);

      } else if ((branch._typename === 'TBranch') && (nb_leaves > 1)) {
         // branch with many elementary leaves

         let leaves = new Array(nb_leaves), isok = true;
         for (let l = 0; l < nb_leaves; ++l) {
            leaves[l] = createMemberStreamer(createLeafElem(branch.fLeaves.arr[l]), handle.file);
            if (!leaves[l]) isok = false;
         }

         if (isok)
            member = {
               name: target_name,
               leaves,
               func(buf, obj) {
                  let tgt = obj[this.name], l = 0;
                  if (!tgt) obj[this.name] = tgt = {};
                  while (l < this.leaves.length)
                     this.leaves[l++].func(buf, tgt);
               }
            };
      }

      if (!elem && !member) {
         console.warn(`Not supported branch ${branch.fName} type ${branch._typename}`);
         return null;
      }

      if (!member) {
         member = createMemberStreamer(elem, handle.file);

         if ((member.base !== undefined) && member.basename) {
            // when element represent base class, we need handling which differ from normal IO
            member.func = function(buf, obj) {
               if (!obj[this.name]) obj[this.name] = { _typename: this.basename };
               buf.classStreamer(obj[this.name], this.basename);
            };
         }
      }

      if (item_cnt && isStr(read_mode)) {

         member.name0 = item_cnt.name;

         let snames = target_name.split('.');

         if (snames.length === 1) {
            // no point in the name - just plain array of objects
            member.get = (arr, n) => arr[n];
         } else if (read_mode === '$child$') {
            console.error(`target name ${target_name} contains point, but suppose to be direct child`);
            return null;
         } else if (snames.length === 2) {
            target_name = member.name = snames[1];
            member.name1 = snames[0];
            member.subtype1 = read_mode;
            member.methods1 = makeMethodsList(member.subtype1);
            member.get = function(arr, n) {
               let obj1 = arr[n][this.name1];
               if (!obj1) obj1 = arr[n][this.name1] = this.methods1.Create();
               return obj1;
            };
         } else {
            // very complex task - we need to reconstruct several embedded members with their types
            // try our best - but not all data types can be reconstructed correctly
            // while classname is not enough - there can be different versions

            if (!branch.fParentName) {
               console.error(`Not possible to provide more than 2 parts in the target name ${target_name}`);
               return null;
            }

            target_name = member.name = snames.pop(); // use last element
            member.snames = snames; // remember all sub-names
            member.smethods = []; // and special handles to create missing objects

            let parent_class = branch.fParentName; // unfortunately, without version

            for (let k = 0; k < snames.length; ++k) {
               let chld_class = defineMemberTypeName(handle.file, parent_class, snames[k]);
               member.smethods[k] = makeMethodsList(chld_class || 'AbstractClass');
               parent_class = chld_class;
            }
            member.get = function(arr, n) {
               let obj1 = arr[n][this.snames[0]];
               if (!obj1) obj1 = arr[n][this.snames[0]] = this.smethods[0].Create();
               for (let k = 1; k < this.snames.length; ++k) {
                  let obj2 = obj1[this.snames[k]];
                  if (!obj2) obj2 = obj1[this.snames[k]] = this.smethods[k].Create();
                  obj1 = obj2;
               }
               return obj1;
            };
         }

         // case when target is sub-object and need to be created before

         if (member.objs_branch_func) {
            // STL branch provides special function for the reading
            member.func = member.objs_branch_func;
         } else {
            member.func0 = member.func;

            member.func = function(buf, obj) {
               let arr = obj[this.name0], n = 0; // objects array where reading is done
               while (n < arr.length)
                  this.func0(buf, this.get(arr, n++)); // read all individual object with standard functions
            };
         }

      } else if (item_cnt) {

         handle.process_arrays = false;

         if ((elem.fType === kDouble32) || (elem.fType === kFloat16)) {
            // special handling for compressed floats

            member.stl_size = item_cnt.name;
            member.func = function(buf, obj) {
               obj[this.name] = this.readarr(buf, obj[this.stl_size]);
            };

         } else if (((elem.fType === kOffsetP + kDouble32) || (elem.fType === kOffsetP + kFloat16)) && branch.fBranchCount2) {
            // special handling for variable arrays of compressed floats in branch - not tested

            member.stl_size = item_cnt.name;
            member.arr_size = item_cnt2.name;
            member.func = function(buf, obj) {
               let sz0 = obj[this.stl_size], sz1 = obj[this.arr_size], arr = new Array(sz0);
               for (let n = 0; n < sz0; ++n)
                  arr[n] = (buf.ntou1() === 1) ? this.readarr(buf, sz1[n]) : [];
               obj[this.name] = arr;
            };

         } else if (((elem.fType > 0) && (elem.fType < kOffsetL)) || (elem.fType === kTString) ||
                    (((elem.fType > kOffsetP) && (elem.fType < kOffsetP + kOffsetL)) && branch.fBranchCount2)) {
            // special handling of simple arrays
            member = {
               name: target_name,
               stl_size: item_cnt.name,
               type: elem.fType,
               func(buf, obj) {
                  obj[this.name] = buf.readFastArray(obj[this.stl_size], this.type);
               }
            };

            if (branch.fBranchCount2) {
               member.type -= kOffsetP;
               member.arr_size = item_cnt2.name;
               member.func = function(buf, obj) {
                  let sz0 = obj[this.stl_size], sz1 = obj[this.arr_size], arr = new Array(sz0);
                  for (let n = 0; n < sz0; ++n)
                     arr[n] = (buf.ntou1() === 1) ? buf.readFastArray(sz1[n], this.type) : [];
                  obj[this.name] = arr;
               };
            }

         } else if ((elem.fType > kOffsetP) && (elem.fType < kOffsetP + kOffsetL) && member.cntname) {

            member.cntname = item_cnt.name;

         } else if (elem.fType == kStreamer) {
            // with streamers one need to extend existing array

            if (item_cnt2)
               throw new Error('Second branch counter not supported yet with kStreamer');

            // function provided by normal I/O
            member.func = member.branch_func;
            member.stl_size = item_cnt.name;

         } else if ((elem.fType === kStreamLoop) || (elem.fType === kOffsetL + kStreamLoop)) {
            if (item_cnt2) {
               // special solution for kStreamLoop
               member.stl_size = item_cnt.name;
               member.cntname = item_cnt2.name;
               member.func = member.branch_func; // this is special function, provided by base I/O
            } else {
               member.cntname = item_cnt.name;
            }
         } else {

            member.name = '$stl_member';

            let loop_size_name;

            if (item_cnt2) {
               if (member.cntname) {
                  loop_size_name = item_cnt2.name;
                  member.cntname = '$loop_size';
               } else {
                  throw new Error('Second branch counter not used - very BAD');
               }
            }

            let stlmember = {
               name: target_name,
               stl_size: item_cnt.name,
               loop_size: loop_size_name,
               member0: member,
               func(buf, obj) {
                  let cnt = obj[this.stl_size], arr = new Array(cnt);
                  for (let n = 0; n < cnt; ++n) {
                     if (this.loop_size) obj.$loop_size = obj[this.loop_size][n];
                     this.member0.func(buf, obj);
                     arr[n] = obj.$stl_member;
                  }
                  delete obj.$stl_member;
                  delete obj.$loop_size;
                  obj[this.name] = arr;
               }
            };

            member = stlmember;
         }
      } // if (item_cnt)

      // set name used to store result
      member.name = target_name;

      item.member = member; // member for reading
      if (elem) item.type = elem.fType;
      item.index = handle.arr.length; // index in the global list of branches

      if (item_cnt) {
         item.counters = [item_cnt.index];
         item_cnt.ascounter.push(item.index);

         if (item_cnt2) {
            item.counters.push(item_cnt2.index);
            item_cnt2.ascounter.push(item.index);
         }
      }

      handle.arr.push(item);

      // now one should add all other child branches
      if (child_scan)
         if (!ScanBranches(branch.fBranches, target_object, child_scan)) return null;

      return item;
   }

   // main loop to add all branches from selector for reading
   for (let nn = 0; nn < selector.numBranches(); ++nn) {

      let item = AddBranchForReading(selector.getBranch(nn), undefined, selector.nameOfBranch(nn), selector._directs[nn]);

      if (!item) {
         selector.Terminate(false);
         return Promise.reject(Error(`Fail to add branch ${selector.nameOfBranch(nn)}`));
      }
   }

   // check if simple reading can be performed and there are direct data in branch

   for (let h = 1; (h < handle.arr.length) && handle.simple_read; ++h) {

      let item = handle.arr[h], item0 = handle.arr[0];

      if ((item.numentries !== item0.numentries) || (item.numbaskets !== item0.numbaskets)) handle.simple_read = false;
      for (let n = 0; n < item.numbaskets; ++n)
         if (item.GetBasketEntry(n) !== item0.GetBasketEntry(n)) handle.simple_read = false;
   }

   // now calculate entries range

   handle.firstentry = handle.lastentry = 0;
   for (let nn = 0; nn < handle.arr.length; ++nn) {
      let branch = handle.arr[nn].branch, e1 = branch.fFirstEntry;
      if (e1 === undefined) e1 = (branch.fBasketBytes[0] ? branch.fBasketEntry[0] : 0);
      handle.firstentry = Math.max(handle.firstentry, e1);
      handle.lastentry = (nn === 0) ? (e1 + branch.fEntries) : Math.min(handle.lastentry, e1 + branch.fEntries);
   }

   if (handle.firstentry >= handle.lastentry) {
      selector.Terminate(false);
      return Promise.reject(Error('No any common events for selected branches'));
   }

   handle.process_min = handle.firstentry;
   handle.process_max = handle.lastentry;

   let resolveFunc, rejectFunc; // Promise methods

   if (Number.isInteger(args.firstentry) && (args.firstentry > handle.firstentry) && (args.firstentry < handle.lastentry))
      handle.process_min = args.firstentry;

   handle.current_entry = handle.staged_now = handle.process_min;

   if (Number.isInteger(args.numentries) && (args.numentries > 0)) {
      let max = handle.process_min + args.numentries;
      if (max < handle.process_max) handle.process_max = max;
   }

   if (isFunc(selector.ProcessArrays) && handle.simple_read) {
      // this is indication that selector can process arrays of values
      // only strictly-matched tree structure can be used for that

      for (let k = 0; k < handle.arr.length; ++k) {
         let elem = handle.arr[k];
         if ((elem.type <= 0) || (elem.type >= kOffsetL) || (elem.type === kCharStar)) handle.process_arrays = false;
      }

      if (handle.process_arrays) {
         // create other members for fast processing

         selector.tgtarr = {}; // object with arrays

         for (let nn = 0; nn < handle.arr.length; ++nn) {
            let item = handle.arr[nn],
               elem = createStreamerElement(item.name, item.type);

            elem.fType = item.type + kOffsetL;
            elem.fArrayLength = 10;
            elem.fArrayDim = 1;
            elem.fMaxIndex[0] = 10; // 10 if artificial number, will be replaced during reading

            item.arrmember = createMemberStreamer(elem, handle.file);
         }
      }
   } else {
      handle.process_arrays = false;
   }

   /** read basket with tree data, selecting different files */
   function ReadBaskets(bitems) {

      function ExtractPlaces() {
         // extract places to read and define file name

         let places = [], filename = '';

         for (let n = 0; n < bitems.length; ++n) {
            if (bitems[n].done) continue;

            let branch = bitems[n].branch;

            if (places.length === 0)
               filename = branch.fFileName;
            else if (filename !== branch.fFileName)
               continue;

            bitems[n].selected = true; // mark which item was selected for reading

            places.push(branch.fBasketSeek[bitems[n].basket], branch.fBasketBytes[bitems[n].basket]);
         }

         return places.length > 0 ? { places, filename } : null;
      }

      function ReadProgress(value) {

         if ((handle.staged_prev === handle.staged_now) ||
            (handle.process_max <= handle.process_min)) return;

         let tm = new Date().getTime();

         if (tm - handle.progress_showtm < 500) return; // no need to show very often

         handle.progress_showtm = tm;

         let portion = (handle.staged_prev + value * (handle.staged_now - handle.staged_prev)) /
            (handle.process_max - handle.process_min);

         handle.selector.ShowProgress(portion);
      }

      function ProcessBlobs(blobs, places) {
         if (!blobs || ((places.length > 2) && (blobs.length * 2 !== places.length)))
            return Promise.resolve(null);

         if (places.length == 2) blobs = [ blobs ];

         function DoProcessing(k) {

            for (; k < bitems.length; ++k) {
               if (!bitems[k].selected) continue;

               bitems[k].selected = false;
               bitems[k].done = true;

               let blob = blobs.shift(),
                  buf = new TBuffer(blob, 0, handle.file),
                  basket = buf.classStreamer({}, clTBasket);

               if (basket.fNbytes !== bitems[k].branch.fBasketBytes[bitems[k].basket])
                  console.error(`mismatch in read basket sizes ${basket.fNbytes} != ${bitems[k].branch.fBasketBytes[bitems[k].basket]}`);

               // items[k].obj = basket; // keep basket object itself if necessary

               bitems[k].bskt_obj = basket; // only number of entries in the basket are relevant for the moment

               if (basket.fKeylen + basket.fObjlen === basket.fNbytes) {
                  // use data from original blob
                  buf.raw_shift = 0;

                  bitems[k].raw = buf; // here already unpacked buffer

                 if (bitems[k].branch.fEntryOffsetLen > 0)
                     buf.readBasketEntryOffset(basket, buf.raw_shift);

                 continue;
               }

               // unpack data and create new blob
               return R__unzip(blob, basket.fObjlen, false, buf.o).then(objblob => {

                  if (objblob) {
                     buf = new TBuffer(objblob, 0, handle.file);
                     buf.raw_shift = basket.fKeylen;
                     buf.fTagOffset = basket.fKeylen;
                  } else {
                     throw new Error('FAIL TO UNPACK');
                  }

                  bitems[k].raw = buf; // here already unpacked buffer

                  if (bitems[k].branch.fEntryOffsetLen > 0)
                     buf.readBasketEntryOffset(basket, buf.raw_shift);

                  return DoProcessing(k+1);  // continue processing
               });
            }

            let req = ExtractPlaces();

            if (req)
               return handle.file.readBuffer(req.places, req.filename, ReadProgress).then(blobs => ProcessBlobs(blobs)).catch(() => { return null; });

            return Promise.resolve(bitems);
          }

          return DoProcessing(0);
      }

      let req = ExtractPlaces();

      // extract places where to read
      if (req)
         return handle.file.readBuffer(req.places, req.filename, ReadProgress).then(blobs => ProcessBlobs(blobs, req.places)).catch(() => { return null; });

      return Promise.resolve(null);
   }

   function ReadNextBaskets() {

      let totalsz = 0, bitems = [], isany = true, is_direct = false, min_staged = handle.process_max;

      while ((totalsz < 1e6) && isany) {
         isany = false;
         // very important, loop over branches in reverse order
         // let check counter branch after reading of normal branch is prepared
         for (let n = handle.arr.length - 1; n >= 0; --n) {
            let elem = handle.arr[n];

            while (elem.staged_basket < elem.numbaskets) {

               let k = elem.staged_basket++;

               // no need to read more baskets, process_max is not included
               if (elem.GetBasketEntry(k) >= handle.process_max) break;

               // check which baskets need to be read
               if (elem.first_readentry < 0) {
                  let lmt = elem.GetBasketEntry(k + 1),
                     not_needed = (lmt <= handle.process_min);

                  //for (let d=0;d<elem.ascounter.length;++d) {
                  //   let dep = handle.arr[elem.ascounter[d]]; // dependent element
                  //   if (dep.first_readentry < lmt) not_needed = false; // check that counter provide required data
                  //}

                  if (not_needed) continue; // if that basket not required, check next

                  elem.curr_basket = k; // basket where reading will start

                  elem.first_readentry = elem.GetBasketEntry(k); // remember which entry will be read first
               }

               // check if basket already loaded in the branch

               let bitem = {
                  id: n, // to find which element we are reading
                  branch: elem.branch,
                  basket: k,
                  raw: null // here should be result
               };

               let bskt = elem.branch.fBaskets.arr[k];
               if (bskt) {
                  bitem.raw = bskt.fBufferRef;
                  if (bitem.raw)
                     bitem.raw.locate(0); // reset pointer - same branch may be read several times
                  else
                     bitem.raw = new TBuffer(null, 0, handle.file); // create dummy buffer - basket has no data
                  bitem.raw.raw_shift = bskt.fKeylen;

                  if (bskt.fBufferRef && (elem.branch.fEntryOffsetLen > 0))
                     bitem.raw.readBasketEntryOffset(bskt, bitem.raw.raw_shift);

                  bitem.bskt_obj = bskt;
                  is_direct = true;
                  elem.baskets[k] = bitem;
               } else {
                  bitems.push(bitem);
                  totalsz += elem.branch.fBasketBytes[k];
                  isany = true;
               }

               elem.staged_entry = elem.GetBasketEntry(k + 1);

               min_staged = Math.min(min_staged, elem.staged_entry);

               break;
            }
         }
      }

      if ((totalsz === 0) && !is_direct) {
         handle.selector.Terminate(true);
         return resolveFunc(handle.selector);
      }

      handle.staged_prev = handle.staged_now;
      handle.staged_now = min_staged;

      let portion = 0;
      if (handle.process_max > handle.process_min)
         portion = (handle.staged_prev - handle.process_min) / (handle.process_max - handle.process_min);

      handle.selector.ShowProgress(portion);

      handle.progress_showtm = new Date().getTime();

      if (totalsz > 0)
         return ReadBaskets(bitems).then(ProcessBaskets);

      if (is_direct) return ProcessBaskets([]); // directly process baskets

      throw new Error('No any data is requested - never come here');
   }

   function ProcessBaskets(bitems) {
      // this is call-back when next baskets are read

      if ((handle.selector._break !== 0) || (bitems === null)) {
         handle.selector.Terminate(false);
         return resolveFunc(handle.selector);
      }

      // redistribute read baskets over branches
      for (let n = 0; n < bitems.length; ++n)
         handle.arr[bitems[n].id].baskets[bitems[n].basket] = bitems[n];

      // now process baskets

      let isanyprocessed = false;

      while (true) {

         let loopentries = 100000000, n, elem;

         // first loop used to check if all required data exists
         for (n = 0; n < handle.arr.length; ++n) {

            elem = handle.arr[n];

            if (!elem.raw || !elem.basket || (elem.first_entry + elem.basket.fNevBuf <= handle.current_entry)) {
               delete elem.raw;
               delete elem.basket;

               if ((elem.curr_basket >= elem.numbaskets)) {
                  if (n == 0) {
                     handle.selector.Terminate(true);
                     return resolveFunc(handle.selector);
                  }
                  continue; // ignore non-master branch
               }

               // this is single response from the tree, includes branch, bakset number, raw data
               let bitem = elem.baskets[elem.curr_basket];

               // basket not read
               if (!bitem) {
                  // no data, but no any event processed - problem
                  if (!isanyprocessed) {
                     handle.selector.Terminate(false);
                     return rejectFunc(Error(`no data for ${elem.branch.fName} basket ${elem.curr_basket}`));
                  }

                  // try to read next portion of tree data
                  return ReadNextBaskets();
               }

               elem.raw = bitem.raw;
               elem.basket = bitem.bskt_obj;
               // elem.nev = bitem.fNevBuf; // number of entries in raw buffer
               elem.first_entry = elem.GetBasketEntry(bitem.basket);

               bitem.raw = null; // remove reference on raw buffer
               bitem.branch = null; // remove reference on the branch
               bitem.bskt_obj = null; // remove reference on the branch
               elem.baskets[elem.curr_basket++] = undefined; // remove from array
            }

            // define how much entries can be processed before next raw buffer will be finished
            loopentries = Math.min(loopentries, elem.first_entry + elem.basket.fNevBuf - handle.current_entry);
         }

         // second loop extracts all required data

         // do not read too much
         if (handle.current_entry + loopentries > handle.process_max)
            loopentries = handle.process_max - handle.current_entry;

         if (handle.process_arrays && (loopentries > 1)) {
            // special case - read all data from baskets as arrays

            for (n = 0; n < handle.arr.length; ++n) {
               elem = handle.arr[n];

               elem.GetEntry(handle.current_entry);

               elem.arrmember.arrlength = loopentries;
               elem.arrmember.func(elem.raw, handle.selector.tgtarr);

               elem.raw = null;
            }

            handle.selector.ProcessArrays(handle.current_entry);

            handle.current_entry += loopentries;

            isanyprocessed = true;
         } else

            // main processing loop
            while (loopentries--) {

               for (n = 0; n < handle.arr.length; ++n) {
                  elem = handle.arr[n];

                  // locate buffer offset at proper place
                  elem.GetEntry(handle.current_entry);

                  elem.member.func(elem.raw, elem.GetTarget(handle.selector.tgtobj));
               }

               handle.selector.Process(handle.current_entry);

               handle.current_entry++;

               isanyprocessed = true;
            }

         if (handle.current_entry >= handle.process_max) {
            handle.selector.Terminate(true);
            return resolveFunc(handle.selector);
         }
      }
   }

   return new Promise((resolve, reject) => {

      resolveFunc = resolve;
      rejectFunc = reject;

      // call begin before first entry is read
      handle.selector.Begin(tree);

      ReadNextBaskets();

   });

}

/** @summary implementation of TTree::Draw
  * @param {object|string} args - different setting or simply draw expression
  * @param {string} args.expr - draw expression
  * @param {string} [args.cut=undefined]   - cut expression (also can be part of 'expr' after '::')
  * @param {string} [args.drawopt=undefined] - draw options for result histogram
  * @param {number} [args.firstentry=0] - first entry to process
  * @param {number} [args.numentries=undefined] - number of entries to process, all by default
  * @param {object} [args.branch=undefined] - TBranch object from TTree itself for the direct drawing
  * @param {function} [args.progress=undefined] - function called during histogram accumulation with argument { obj: draw_object, opt: draw_options }
  * @return {Promise} with object like { obj: draw_object, opt: draw_options } */
async function treeDraw(tree, args) {

   if (isStr(args)) args = { expr: args };

   if (!args.expr) args.expr = '';

   let selector = new TDrawSelector();

   if (args.branch) {
      if (!selector.drawOnlyBranch(tree, args.branch, args.expr, args)) selector = null;
   } else {
      if (!selector.parseDrawExpression(tree, args)) selector = null;
   }

   if (!selector)
      return Promise.reject(Error('Fail to create selector for specified expression'));

   return new Promise(resolve => {
      selector.setCallback(resolve, args.progress);
      treeProcess(tree, selector, args);
   });
}

/** @summary Performs generic I/O test for all branches in the TTree
  * @desc Used when 'testio' draw option for TTree is specified
  * @private */
function treeIOTest(tree, args) {
   let branches = [], names = [], nchilds = [];

   function collectBranches(obj, prntname = '') {
      if (!obj?.fBranches) return 0;

      let cnt = 0;

      for (let n = 0; n < obj.fBranches.arr.length; ++n) {
         let br = obj.fBranches.arr[n],
             name = (prntname ? prntname + '/' : '') + br.fName;
         branches.push(br);
         names.push(name);
         nchilds.push(0);
         let pos = nchilds.length - 1;
         cnt += br.fLeaves ? br.fLeaves.arr.length : 0;
         let nchld = collectBranches(br, name);

         cnt += nchld;
         nchilds[pos] = nchld;

      }
      return cnt;
   }

   let numleaves = collectBranches(tree);

   names.push(`Total are ${branches.length} branches with ${numleaves} leaves`);

   function testBranch(nbr) {

      if (nbr >= branches.length)
         return Promise.resolve(true);

      let selector = new TSelector;

      selector.addBranch(branches[nbr], 'br0');

      selector.Process = function() {
         if (this.tgtobj.br0 === undefined)
            this.fail = true;
      };

      selector.Terminate = function(res) {
         if (!isStr(res))
            res = (!res || this.fails) ? 'FAIL' : 'ok';

         names[nbr] = res + ' ' + names[nbr];
      };

      let br = branches[nbr],
          object_class = getBranchObjectClass(br, tree),
          num = br.fEntries,
          skip_branch = (!br.fLeaves || (br.fLeaves.arr.length === 0));

      if (object_class) skip_branch = (nchilds[nbr] > 100);

      if (skip_branch || (num <= 0))
         return testBranch(nbr+1);

      let drawargs = { numentries: 10 },
          first = br.fFirstEntry || 0,
          last = br.fEntryNumber || (first + num);

      if (num < drawargs.numentries) {
         drawargs.numentries = num;
      } else {
         // select randomly first entry to test I/O
         drawargs.firstentry = first + Math.round((last - first - drawargs.numentries) * Math.random());
      }

      // keep console output for debug purposes
      console.log(`test branch ${br.fName} first ${drawargs.firstentry || 0} num ${drawargs.numentries}`);

      if (args.showProgress)
         args.showProgress(`br ${nbr}/${branches.length} ${br.fName}`);

      return treeProcess(tree, selector, drawargs).then(() => testBranch(nbr+1));
   }

   return testBranch(0).then(() => {
      if (args.showProgress) args.showProgress();

      return names;
   });
}


/** @summary Create hierarchy of TTree object
  * @private */
function treeHierarchy(node, obj) {

   function createBranchItem(node, branch, tree, parent_branch) {
      if (!node || !branch) return false;

      let nb_branches = branch.fBranches ? branch.fBranches.arr.length : 0,
          nb_leaves = branch.fLeaves ? branch.fLeaves.arr.length : 0;

      function ClearName(arg) {
         let pos = arg.indexOf('[');
         if (pos > 0) arg = arg.slice(0, pos);
         if (parent_branch && arg.indexOf(parent_branch.fName) == 0) {
            arg = arg.slice(parent_branch.fName.length);
            if (arg[0] === '.') arg = arg.slice(1);
         }
         return arg;
      }

      branch.$tree = tree; // keep tree pointer, later do it more smart

      let subitem = {
            _name: ClearName(branch.fName),
            _kind: 'ROOT.' + branch._typename,
            _title: branch.fTitle,
            _obj: branch
      };

      if (!node._childs) node._childs = [];

      node._childs.push(subitem);

      if (branch._typename === clTBranchElement)
         subitem._title += ` from ${branch.fClassName};${branch.fClassVersion}`;

      if (nb_branches > 0) {
         subitem._more = true;
         subitem._expand = function(bnode,bobj) {
            // really create all sub-branch items
            if (!bobj) return false;

            if (!bnode._childs) bnode._childs = [];

            if (bobj.fLeaves && (bobj.fLeaves.arr.length === 1) &&
                ((bobj.fType === kClonesNode) || (bobj.fType === kSTLNode))) {
                 bobj.fLeaves.arr[0].$branch = bobj;
                 bnode._childs.push({
                    _name: '@size',
                    _title: 'container size',
                    _kind: 'ROOT.TLeafElement',
                    _icon: 'img_leaf',
                    _obj: bobj.fLeaves.arr[0],
                    _more: false
                 });
              }

            for (let i = 0; i < bobj.fBranches.arr.length; ++i)
               createBranchItem(bnode, bobj.fBranches.arr[i], bobj.$tree, bobj);

            let object_class = getBranchObjectClass(bobj, bobj.$tree, true),
                methods = object_class ? getMethods(object_class) : null;

            if (methods && (bobj.fBranches.arr.length > 0))
               for (let key in methods) {
                  if (!isFunc(methods[key])) continue;
                  let s = methods[key].toString();
                  if ((s.indexOf('return') > 0) && (s.indexOf('function ()') == 0))
                     bnode._childs.push({
                        _name: key+'()',
                        _title: `function ${key} of class ${object_class}`,
                        _kind: 'ROOT.' + clTBranchFunc, // fictional class, only for drawing
                        _obj: { _typename: clTBranchFunc, branch: bobj, func: key },
                        _more: false
                     });

               }

            return true;
         };
         return true;
      } else if (nb_leaves === 1) {
         subitem._icon = 'img_leaf';
         subitem._more = false;
      } else if (nb_leaves > 1) {
         subitem._childs = [];
         for (let j = 0; j < nb_leaves; ++j) {
            branch.fLeaves.arr[j].$branch = branch; // keep branch pointer for drawing
            let leafitem = {
               _name : ClearName(branch.fLeaves.arr[j].fName),
               _kind : 'ROOT.' + branch.fLeaves.arr[j]._typename,
               _obj: branch.fLeaves.arr[j]
            };
            subitem._childs.push(leafitem);
         }
      }

      return true;
   }

   node._childs = [];
   node._tree = obj;  // set reference, will be used later by TTree::Draw

   for (let i = 0; i < obj.fBranches.arr.length; ++i)
      createBranchItem(node, obj.fBranches.arr[i], obj);

   return true;
}

var tree = /*#__PURE__*/Object.freeze({
__proto__: null,
kClonesNode: kClonesNode,
kSTLNode: kSTLNode,
clTBranchFunc: clTBranchFunc,
TSelector: TSelector,
TDrawVariable: TDrawVariable,
TDrawSelector: TDrawSelector,
treeHierarchy: treeHierarchy,
treeProcess: treeProcess,
treeDraw: treeDraw,
treeIOTest: treeIOTest
});

// v7 namespace prefix
const _v7 = 'ROOT::Experimental::';

async function import_more() { return Promise.resolve().then(function () { return more; }); }

async function import_geo() {
   return Promise.resolve().then(function () { return TGeoPainter$1; }).then(geo => {
      let handle = getDrawHandle('ROOT.TGeoVolumeAssembly');
      if (handle) handle.icon = 'img_geoassembly';
      return geo;
   });
}

const clTGraph2D = 'TGraph2D', clTH2Poly = 'TH2Poly', clTEllipse = 'TEllipse',
      clTSpline3 = 'TSpline3', clTTree = 'TTree', clTCanvasWebSnapshot = 'TCanvasWebSnapshot';

// list of registered draw functions
const drawFuncs = { lst: [
   { name: clTCanvas, icon: 'img_canvas', class: () => Promise.resolve().then(function () { return TCanvasPainter$1; }).then(h => h.TCanvasPainter), opt: ';grid;gridx;gridy;tick;tickx;ticky;log;logx;logy;logz', expand_item: 'fPrimitives' },
   { name: clTPad, icon: 'img_canvas', class: () => Promise.resolve().then(function () { return TPadPainter$1; }).then(h => h.TPadPainter), opt: ';grid;gridx;gridy;tick;tickx;ticky;log;logx;logy;logz', expand_item: 'fPrimitives' },
   { name: 'TSlider', icon: 'img_canvas', class: () => Promise.resolve().then(function () { return TPadPainter$1; }).then(h => h.TPadPainter) },
   { name: clTButton, icon: 'img_canvas', class: () => Promise.resolve().then(function () { return TPadPainter$1; }).then(h => h.TPadPainter) },
   { name: 'TFrame', icon: 'img_frame', draw: () => Promise.resolve().then(function () { return TCanvasPainter$1; }).then(h => h.drawTFrame) },
   { name: clTPave, icon: 'img_pavetext', class: () => Promise.resolve().then(function () { return TPavePainter$1; }).then(h => h.TPavePainter) },
   { name: clTPaveText, sameas: clTPave },
   { name: 'TPavesText', sameas: clTPave },
   { name: clTPaveStats, sameas: clTPave },
   { name: 'TPaveLabel', sameas: clTPave },
   { name: 'TDiamond', sameas: clTPave },
   { name: clTLegend, icon: 'img_pavelabel', sameas: clTPave },
   { name: clTPaletteAxis, icon: 'img_colz', sameas: clTPave },
   { name: clTLatex, icon: 'img_text', draw: () => import_more().then(h => h.drawText), direct: true },
   { name: clTMathText, sameas: clTLatex },
   { name: clTText, sameas: clTLatex },
   { name: /^TH1/, icon: 'img_histo1d', class: () => Promise.resolve().then(function () { return TH1Painter$1; }).then(h => h.TH1Painter), opt: ';hist;P;P0;E;E1;E2;E3;E4;E1X0;L;LF2;B;B1;A;TEXT;LEGO;same', ctrl: 'l' },
   { name: clTProfile, icon: 'img_profile', class: () => Promise.resolve().then(function () { return TH1Painter$1; }).then(h => h.TH1Painter), opt: ';E0;E1;E2;p;AH;hist' },
   { name: clTH2Poly, icon: 'img_histo2d', class: () => Promise.resolve().then(function () { return TH2Painter$1; }).then(h => h.TH2Painter), opt: ';COL;COL0;COLZ;LCOL;LCOL0;LCOLZ;LEGO;TEXT;same', expand_item: 'fBins', theonly: true },
   { name: 'TProfile2Poly', sameas: clTH2Poly },
   { name: 'TH2PolyBin', icon: 'img_histo2d', draw_field: 'fPoly', draw_field_opt: 'L' },
   { name: /^TH2/, icon: 'img_histo2d', class: () => Promise.resolve().then(function () { return TH2Painter$1; }).then(h => h.TH2Painter), dflt: 'col', opt: ';COL;COLZ;COL0;COL1;COL0Z;COL1Z;COLA;BOX;BOX1;PROJ;PROJX1;PROJX2;PROJX3;PROJY1;PROJY2;PROJY3;SCAT;TEXT;TEXTE;TEXTE0;CANDLE;CANDLE1;CANDLE2;CANDLE3;CANDLE4;CANDLE5;CANDLE6;CANDLEY1;CANDLEY2;CANDLEY3;CANDLEY4;CANDLEY5;CANDLEY6;VIOLIN;VIOLIN1;VIOLIN2;VIOLINY1;VIOLINY2;CONT;CONT1;CONT2;CONT3;CONT4;ARR;SURF;SURF1;SURF2;SURF4;SURF6;E;A;LEGO;LEGO0;LEGO1;LEGO2;LEGO3;LEGO4;same', ctrl: 'lego' },
   { name: clTProfile2D, sameas: clTH2 },
   { name: /^TH3/, icon: 'img_histo3d', class: () => Promise.resolve().then(function () { return TH3Painter$1; }).then(h => h.TH3Painter), opt: ';SCAT;BOX;BOX2;BOX3;GLBOX1;GLBOX2;GLCOL' },
   { name: 'THStack', icon: 'img_histo1d', class: () => Promise.resolve().then(function () { return THStackPainter$1; }).then(h => h.THStackPainter), expand_item: 'fHists', opt: 'NOSTACK;HIST;E;PFC;PLC' },
   { name: clTPolyMarker3D, icon: 'img_histo3d', draw: () => Promise.resolve().then(function () { return draw3d; }).then(h => h.drawPolyMarker3D), direct: true, frame: '3d' },
   { name: clTPolyLine3D, icon: 'img_graph', draw: () => Promise.resolve().then(function () { return draw3d; }).then(h => h.drawPolyLine3D), direct: true, frame: '3d' },
   { name: 'TGraphStruct' },
   { name: 'TGraphNode' },
   { name: 'TGraphEdge' },
   { name: clTGraphTime, icon: 'img_graph', class: () => Promise.resolve().then(function () { return TGraphTimePainter$1; }).then(h => h.TGraphTimePainter), opt: 'once;repeat;first', theonly: true },
   { name: clTGraph2D, icon: 'img_graph', class: () => Promise.resolve().then(function () { return TGraph2DPainter$1; }).then(h => h.TGraph2DPainter), opt: ';P;PCOL', theonly: true },
   { name: 'TGraph2DErrors', sameas: clTGraph2D, opt: ';P;PCOL;ERR', theonly: true },
   { name: 'TGraph2DAsymmErrors', sameas: clTGraph2D, opt: ';P;PCOL;ERR', theonly: true },
   { name: clTGraphPolargram, icon: 'img_graph', class: () => Promise.resolve().then(function () { return TGraphPolarPainter$1; }).then(h => h.TGraphPolargramPainter), theonly: true },
   { name: 'TGraphPolar', icon: 'img_graph', class: () => Promise.resolve().then(function () { return TGraphPolarPainter$1; }).then(h => h.TGraphPolarPainter), opt: ';F;L;P;PE', theonly: true },
   { name: /^TGraph/, icon: 'img_graph', class: () => Promise.resolve().then(function () { return TGraphPainter$2; }).then(h => h.TGraphPainter), opt: ';L;P' },
   { name: 'TEfficiency', icon: 'img_graph', class: () => Promise.resolve().then(function () { return TEfficiencyPainter$1; }).then(h => h.TEfficiencyPainter), opt: ';AP' },
   { name: clTCutG, sameas: clTGraph },
   { name: /^RooHist/, sameas: clTGraph },
   { name: /^RooCurve/, sameas: clTGraph },
   { name: 'RooPlot', icon: 'img_canvas', func: drawRooPlot },
   { name: 'TRatioPlot', icon: 'img_mgraph', class: () => Promise.resolve().then(function () { return TRatioPlotPainter$1; }).then(h => h.TRatioPlotPainter), opt: '' },
   { name: clTMultiGraph, icon: 'img_mgraph', class: () => Promise.resolve().then(function () { return TMultiGraphPainter$1; }).then(h => h.TMultiGraphPainter), opt: ';l;p;3d', expand_item: 'fGraphs' },
   { name: clTStreamerInfoList, icon: 'img_question', draw: () => Promise.resolve().then(function () { return HierarchyPainter$1; }).then(h => h.drawStreamerInfo) },
   { name: 'TWebPainting', icon: 'img_graph', class: () => Promise.resolve().then(function () { return TWebPaintingPainter$1; }).then(h => h.TWebPaintingPainter) },
   { name: clTCanvasWebSnapshot, icon: 'img_canvas', draw: () => Promise.resolve().then(function () { return TCanvasPainter$1; }).then(h => h.drawTPadSnapshot) },
   { name: 'TPadWebSnapshot', sameas: clTCanvasWebSnapshot },
   { name: 'kind:Text', icon: 'img_text', func: drawRawText },
   { name: clTObjString, icon: 'img_text', func: drawRawText },
   { name: clTF1, icon: 'img_tf1', class: () => Promise.resolve().then(function () { return TF1Painter$1; }).then(h => h.TF1Painter) },
   { name: clTF2, icon: 'img_tf2', draw: () => Promise.resolve().then(function () { return TF2; }).then(h => h.drawTF2) },
   { name: clTSpline3, icon: 'img_tf1', class: () => Promise.resolve().then(function () { return TSplinePainter$1; }).then(h => h.TSplinePainter) },
   { name: 'TSpline5', sameas: clTSpline3 },
   { name: clTEllipse, icon: 'img_graph', draw: () => import_more().then(h => h.drawEllipse), direct: true },
   { name: 'TArc', sameas: clTEllipse },
   { name: 'TCrown', sameas: clTEllipse },
   { name: 'TPie', icon: 'img_graph', draw: () => import_more().then(h => h.drawPie), direct: true },
   { name: 'TPieSlice', icon: 'img_graph', dummy: true },
   { name: 'TExec', icon: 'img_graph', dummy: true },
   { name: clTLine, icon: 'img_graph', draw: () => import_more().then(h => h.drawTLine) },
   { name: 'TArrow', icon: 'img_graph', class: () => Promise.resolve().then(function () { return TArrowPainter$1; }).then(h => h.TArrowPainter) },
   { name: clTPolyLine, icon: 'img_graph', draw: () => import_more().then(h => h.drawPolyLine), direct: true },
   { name: 'TCurlyLine', sameas: clTPolyLine },
   { name: 'TCurlyArc', sameas: clTPolyLine },
   { name: 'TParallelCoord', icon: 'img_graph', dummy: true },
   { name: clTGaxis, icon: 'img_graph', draw: () => Promise.resolve().then(function () { return TCanvasPainter$1; }).then(h => h.drawTGaxis) },
   { name: clTBox, icon: 'img_graph', draw: () => import_more().then(h => h.drawBox), direct: true },
   { name: 'TWbox', sameas: clTBox },
   { name: 'TSliderBox', sameas: clTBox },
   { name: 'TMarker', icon: 'img_graph', draw: () => import_more().then(h => h.drawMarker), direct: true },
   { name: 'TPolyMarker', icon: 'img_graph', draw: () => import_more().then(h => h.drawPolyMarker), direct: true },
   { name: 'TASImage', icon: 'img_mgraph', class: () => Promise.resolve().then(function () { return TASImagePainter$1; }).then(h => h.TASImagePainter), opt: ';z' },
   { name: 'TJSImage', icon: 'img_mgraph', draw: () => import_more().then(h => h.drawJSImage), opt: ';scale;center' },
   { name: clTGeoVolume, icon: 'img_histo3d', class: () => import_geo().then(h => h.TGeoPainter), get_expand: () => import_geo().then(h => h.expandGeoObject), opt: ';more;all;count;projx;projz;wire;no_screen;dflt', ctrl: 'dflt' },
   { name: 'TEveGeoShapeExtract', sameas: clTGeoVolume, opt: ';more;all;count;projx;projz;wire;dflt' },
   { name: _v7+'REveGeoShapeExtract', sameas: clTGeoVolume, opt: ';more;all;count;projx;projz;wire;dflt' },
   { name: 'TGeoOverlap', sameas: clTGeoVolume, opt: ';more;all;count;projx;projz;wire;dflt', dflt: 'dflt', ctrl: 'expand' },
   { name: 'TGeoManager', sameas: clTGeoVolume, opt: ';more;all;count;projx;projz;wire;tracks;no_screen;dflt', dflt: 'expand', ctrl: 'dflt' },
   { name: 'TGeoVolumeAssembly', sameas: clTGeoVolume, /* icon: 'img_geoassembly', */ opt: ';more;all;count' },
   { name: /^TGeo/, class: () => import_geo().then(h => h.TGeoPainter), get_expand: () => import_geo().then(h => h.expandGeoObject), opt: ';more;all;axis;compa;count;projx;projz;wire;no_screen;dflt', dflt: 'dflt', ctrl: 'expand' },
   { name: 'TAxis3D', icon: 'img_graph', draw: () => import_geo().then(h => h.drawAxis3D), direct: true },
   // these are not draw functions, but provide extra info about correspondent classes
   { name: 'kind:Command', icon: 'img_execute', execute: true },
   { name: 'TFolder', icon: 'img_folder', icon2: 'img_folderopen', noinspect: true, get_expand: () => Promise.resolve().then(function () { return HierarchyPainter$1; }).then(h => h.folderHierarchy) },
   { name: 'TTask', icon: 'img_task', get_expand: () => Promise.resolve().then(function () { return HierarchyPainter$1; }).then(h => h.taskHierarchy), for_derived: true },
   { name: clTTree, icon: 'img_tree', get_expand: () => Promise.resolve().then(function () { return tree; }).then(h => h.treeHierarchy), draw: () => Promise.resolve().then(function () { return TTree; }).then(h => h.drawTree), dflt: 'expand', opt: 'player;testio', shift: 'inspect' },
   { name: 'TNtuple', sameas: clTTree },
   { name: 'TNtupleD', sameas: clTTree },
   { name: clTBranchFunc, icon: 'img_leaf_method', draw: () => Promise.resolve().then(function () { return TTree; }).then(h => h.drawTree), opt: ';dump', noinspect: true },
   { name: /^TBranch/, icon: 'img_branch', draw: () => Promise.resolve().then(function () { return TTree; }).then(h => h.drawTree), dflt: 'expand', opt: ';dump', ctrl: 'dump', shift: 'inspect', ignore_online: true, always_draw: true },
   { name: /^TLeaf/, icon: 'img_leaf', noexpand: true, draw: () => Promise.resolve().then(function () { return TTree; }).then(h => h.drawTree), opt: ';dump', ctrl: 'dump', ignore_online: true, always_draw: true },
   { name: clTList, icon: 'img_list', draw: () => Promise.resolve().then(function () { return HierarchyPainter$1; }).then(h => h.drawList), get_expand: () => Promise.resolve().then(function () { return HierarchyPainter$1; }).then(h => h.listHierarchy), dflt: 'expand' },
   { name: clTHashList, sameas: clTList },
   { name: clTObjArray, sameas: clTList },
   { name: clTClonesArray, sameas: clTList },
   { name: clTMap, sameas: clTList },
   { name: clTColor, icon: 'img_color' },
   { name: 'TFile', icon: 'img_file', noinspect: true },
   { name: 'TMemFile', icon: 'img_file', noinspect: true },
   { name: clTStyle, icon: 'img_question', noexpand: true },
   { name: 'Session', icon: 'img_globe' },
   { name: 'kind:TopFolder', icon: 'img_base' },
   { name: 'kind:Folder', icon: 'img_folder', icon2: 'img_folderopen', noinspect: true },
   { name: _v7+'RCanvas', icon: 'img_canvas', class: () => init_v7().then(h => h.RCanvasPainter), opt: '', expand_item: 'fPrimitives' },
   { name: _v7+'RCanvasDisplayItem', icon: 'img_canvas', draw: () => init_v7().then(h => h.drawRPadSnapshot), opt: '', expand_item: 'fPrimitives' },
   { name: _v7+'RHist1Drawable', icon: 'img_histo1d', class: () => init_v7('rh1').then(h => h.RH1Painter), opt: '' },
   { name: _v7+'RHist2Drawable', icon: 'img_histo2d', class: () => init_v7('rh2').then(h => h.RH2Painter), opt: '' },
   { name: _v7+'RHist3Drawable', icon: 'img_histo3d', class: () => init_v7('rh3').then(h => h.RH3Painter), opt: '' },
   { name: _v7+'RHistDisplayItem', icon: 'img_histo1d', draw: () => init_v7('rh3').then(h => h.drawHistDisplayItem), opt: '' },
   { name: _v7+'RText', icon: 'img_text', draw: () => init_v7('more').then(h => h.drawText), opt: '', direct: 'v7', csstype: 'text' },
   { name: _v7+'RFrameTitle', icon: 'img_text', draw: () => init_v7().then(h => h.drawRFrameTitle), opt: '', direct: 'v7', csstype: 'title' },
   { name: _v7+'RPaletteDrawable', icon: 'img_text', class: () => init_v7('more').then(h => h.RPalettePainter), opt: '' },
   { name: _v7+'RDisplayHistStat', icon: 'img_pavetext', class: () => init_v7('pave').then(h => h.RHistStatsPainter), opt: '' },
   { name: _v7+'RLine', icon: 'img_graph', draw: () => init_v7('more').then(h => h.drawLine), opt: '', direct: 'v7', csstype: 'line' },
   { name: _v7+'RBox', icon: 'img_graph', draw: () => init_v7('more').then(h => h.drawBox), opt: '', direct: 'v7', csstype: 'box' },
   { name: _v7+'RMarker', icon: 'img_graph', draw: () => init_v7('more').then(h => h.drawMarker), opt: '', direct: 'v7', csstype: 'marker' },
   { name: _v7+'RPave', icon: 'img_pavetext', class: () => init_v7('pave').then(h => h.RPavePainter), opt: '' },
   { name: _v7+'RLegend', icon: 'img_graph', class: () => init_v7('pave').then(h => h.RLegendPainter), opt: '' },
   { name: _v7+'RPaveText', icon: 'img_pavetext', class: () => init_v7('pave').then(h => h.RPaveTextPainter), opt: '' },
   { name: _v7+'RFrame', icon: 'img_frame', draw: () => init_v7().then(h => h.drawRFrame), opt: '' },
   { name: _v7+'RFont', icon: 'img_text', draw: () => init_v7().then(h => h.drawRFont), opt: '', direct: 'v7', csstype: 'font' },
   { name: _v7+'RAxisDrawable', icon: 'img_frame', draw: () => init_v7().then(h => h.drawRAxis), opt: '' }
], cache: {} };


/** @summary Register draw function for the class
  * @desc List of supported draw options could be provided, separated  with ';'
  * @param {object} args - arguments
  * @param {string|regexp} args.name - class name or regexp pattern
  * @param {function} [args.func] - draw function
  * @param {function} [args.draw] - async function to load draw function
  * @param {function} [args.class] - async function to load painter class with static draw function
  * @param {boolean} [args.direct] - if true, function is just Redraw() method of ObjectPainter
  * @param {string} [args.opt] - list of supported draw options (separated with semicolon) like 'col;scat;'
  * @param {string} [args.icon] - icon name shown for the class in hierarchy browser
  * @param {string} [args.draw_field] - draw only data member from object, like fHistogram
  * @protected */
function addDrawFunc(args) {
   drawFuncs.lst.push(args);
   return args;
}

/** @summary return draw handle for specified item kind
  * @desc kind could be ROOT.TH1I for ROOT classes or just
  * kind string like 'Command' or 'Text'
  * selector can be used to search for draw handle with specified option (string)
  * or just sequence id
  * @private */
function getDrawHandle(kind, selector) {

   if (!isStr(kind)) return null;
   if (selector === '') selector = null;

   let first = null;

   if ((selector === null) && (kind in drawFuncs.cache))
      return drawFuncs.cache[kind];

   let search = (kind.indexOf('ROOT.') == 0) ? kind.slice(5) : 'kind:' + kind, counter = 0;
   for (let i = 0; i < drawFuncs.lst.length; ++i) {
      let h = drawFuncs.lst[i];
      if (isStr(h.name)) {
         if (h.name != search) continue;
      } else {
         if (!search.match(h.name)) continue;
      }

      if (h.sameas) {
         let hs = getDrawHandle('ROOT.' + h.sameas, selector);
         if (hs) {
            for (let key in hs)
               if (h[key] === undefined)
                  h[key] = hs[key];
            delete h.sameas;
         }
         return h;
      }

      if ((selector === null) || (selector === undefined)) {
         // store found handle in cache, can reuse later
         if (!(kind in drawFuncs.cache)) drawFuncs.cache[kind] = h;
         return h;
      } else if (isStr(selector)) {
         if (!first) first = h;
         // if drawoption specified, check it present in the list

         if (selector == '::expand') {
            if (('expand' in h) || ('expand_item' in h)) return h;
         } else if ('opt' in h) {
            let opts = h.opt.split(';');
            for (let j = 0; j < opts.length; ++j)
               opts[j] = opts[j].toLowerCase();
            if (opts.indexOf(selector.toLowerCase()) >= 0) return h;
         }
      } else if (selector === counter) {
         return h;
      }
      ++counter;
   }

   return first;
}

/** @summary Returns true if handle can be potentially drawn
  * @private */
function canDrawHandle(h) {
   if (isStr(h))
      h = getDrawHandle(h);
   if (!isObject(h)) return false;
   return h.func || h.class || h.draw || h.draw_field ? true : false;
}

/** @summary Provide draw settings for specified class or kind
  * @private */
function getDrawSettings(kind, selector) {
   let res = { opts: null, inspect: false, expand: false, draw: false, handle: null };
   if (!isStr(kind)) return res;
   let isany = false, noinspect = false, canexpand = false;
   if (!isStr(selector)) selector = '';

   for (let cnt = 0; cnt < 1000; ++cnt) {
      let h = getDrawHandle(kind, cnt);
      if (!h) break;
      if (!res.handle) res.handle = h;
      if (h.noinspect) noinspect = true;
      if (h.expand || h.get_expand || h.expand_item || h.can_expand) canexpand = true;
      if (!h.func && !h.class && !h.draw) break;
      isany = true;
      if (!('opt' in h)) continue;
      let opts = h.opt.split(';');
      for (let i = 0; i < opts.length; ++i) {
         opts[i] = opts[i].toLowerCase();
         if ((selector.indexOf('nosame') >= 0) && (opts[i].indexOf('same') == 0)) continue;

         if (res.opts === null) res.opts = [];
         if (res.opts.indexOf(opts[i]) < 0) res.opts.push(opts[i]);
      }
      if (h.theonly) break;
   }

   if (selector.indexOf('noinspect') >= 0) noinspect = true;

   if (isany && (res.opts === null)) res.opts = [''];

   // if no any handle found, let inspect ROOT-based objects
   if (!isany && (kind.indexOf('ROOT.') == 0) && !noinspect) res.opts = [];

   if (!noinspect && res.opts)
      res.opts.push('inspect');

   res.inspect = !noinspect;
   res.expand = canexpand;
   res.draw = !!res.opts;

   return res;
}

/** @summary Set default draw option for provided class */
function setDefaultDrawOpt(classname, opt) {
   let handle = getDrawHandle('ROOT.' + classname, 0);
   if (handle)
      handle.dflt = opt;
}

/** @summary Draw object in specified HTML element with given draw options.
  * @param {string|object} dom - id of div element to draw or directly DOMElement
  * @param {object} obj - object to draw, object type should be registered before with {@link addDrawFunc}
  * @param {string} opt - draw options separated by space, comma or semicolon
  * @return {Promise} with painter object
  * @public
  * @desc An extensive list of support draw options can be found on [examples page]{@link https://root.cern/js/latest/examples.htm}
  * @example
  * let file = await openFile('https://root.cern/js/files/hsimple.root');
  * let obj = await file.readObject('hpxpy;1');
  * await draw('drawing', obj, 'colz;logx;gridx;gridy'); */
async function draw(dom, obj, opt) {

   if (!isObject(obj))
      return Promise.reject(Error('not an object in draw call'));

   if (opt == 'inspect')
      return Promise.resolve().then(function () { return HierarchyPainter$1; }).then(h => h.drawInspector(dom, obj));

   let handle, type_info;
   if ('_typename' in obj) {
      type_info = 'type ' + obj._typename;
      handle = getDrawHandle('ROOT.' + obj._typename, opt);
   } else if ('_kind' in obj) {
      type_info = 'kind ' + obj._kind;
      handle = getDrawHandle(obj._kind, opt);
   } else
      return Promise.resolve().then(function () { return HierarchyPainter$1; }).then(h => h.drawInspector(dom, obj));

   // this is case of unsupported class, close it normally
   if (!handle)
      return Promise.reject(Error(`Object of ${type_info} cannot be shown with draw`));

   if (handle.dummy)
      return null;

   if (handle.draw_field && obj[handle.draw_field])
      return draw(dom, obj[handle.draw_field], opt || handle.draw_field_opt);

   if (!canDrawHandle(handle)) {
      if (opt && (opt.indexOf('same') >= 0)) {

         let main_painter = getElementMainPainter(dom);

         if (isFunc(main_painter?.performDrop))
            return main_painter.performDrop(obj, '', null, opt);
      }

      return Promise.reject(Error(`Function not specified to draw object ${type_info}`));
   }

    function performDraw() {
      let promise, painter;
      if (handle.direct == 'v7') {
         promise = Promise.resolve().then(function () { return RCanvasPainter$1; }).then(v7h => {
            painter = new v7h.RObjectPainter(dom, obj, opt, handle.csstype);
            painter.redraw = handle.func;
            return v7h.ensureRCanvas(painter, handle.frame || false);
         }).then(() => painter.redraw());
      } else if (handle.direct) {
         painter = new ObjectPainter(dom, obj, opt);
         painter.redraw = handle.func;
         promise = Promise.resolve().then(function () { return TCanvasPainter$1; })
                           .then(v6h => v6h.ensureTCanvas(painter, handle.frame || false))
                           .then(() => painter.redraw());
      } else {
         promise = getPromise(handle.func(dom, obj, opt));
      }

      return promise.then(p => {
         if (!painter) painter = p;
         if (!painter)
             throw Error(`Fail to draw object ${type_info}`);
         if (isObject(painter) && !painter.options)
            painter.options = { original: opt || '' }; // keep original draw options
         return painter;
      });
   }

   if (isFunc(handle.func))
      return performDraw();

   let promise;

   if (isFunc(handle.class)) {
      // class coded as async function which returns class handle
      // simple extract class and access class.draw method
      promise = handle.class().then(cl => { handle.func = cl.draw; });
   } else if (isFunc(handle.draw)) {
      // draw function without special class
      promise = handle.draw().then(h => { handle.func = h; });
   } else if (!handle.func || !isStr(handle.func)) {
      return Promise.reject(Error(`Draw function or class not specified to draw ${type_info}`));
   } else if (!handle.prereq && !handle.script) {
      return Promise.reject(Error(`Prerequicities to load ${handle.func} are not specified`));
   } else {

      let init_promise = internals.ignore_v6 ? Promise.resolve(true) : _ensureJSROOT().then(v6 => {
         let pr = handle.prereq ? v6.require(handle.prereq) : Promise.resolve(true);
         return pr.then(() => {
            if (handle.script)
               return loadScript(handle.script);
         }).then(() => v6._complete_loading());
      });

      promise = init_promise.then(() => {
         let func = findFunction(handle.func);

         if (!isFunc(func))
            return Promise.reject(Error(`Fail to find function ${handle.func} after loading ${handle.prereq || handle.script}`));

         handle.func = func;
      });
   }

   return promise.then(() => performDraw());
}

/** @summary Redraw object in specified HTML element with given draw options.
  * @param {string|object} dom - id of div element to draw or directly DOMElement
  * @param {object} obj - object to draw, object type should be registered before with {@link addDrawFunc}
  * @param {string} opt - draw options
  * @return {Promise} with painter object
  * @desc If drawing was not done before, it will be performed with {@link draw}.
  * Otherwise drawing content will be updated
  * @public */
async function redraw(dom, obj, opt) {

   if (!isObject(obj))
      return Promise.reject(Error('not an object in redraw'));

   let can_painter = getElementCanvPainter(dom), handle, res_painter = null, redraw_res;
   if (obj._typename)
      handle = getDrawHandle('ROOT.' + obj._typename);
   if (handle?.draw_field && obj[handle.draw_field])
      obj = obj[handle.draw_field];

   if (can_painter) {
      if (can_painter.matchObjectType(obj._typename)) {
         redraw_res = can_painter.redrawObject(obj, opt);
         if (redraw_res) res_painter = can_painter;
      } else {
         for (let i = 0; i < can_painter.painters.length; ++i) {
            let painter = can_painter.painters[i];
            if (painter.matchObjectType(obj._typename)) {
               redraw_res = painter.redrawObject(obj, opt);
               if (redraw_res) {
                  res_painter = painter;
                  break;
               }
            }
         }
      }
   } else {
      let top = new BasePainter(dom).getTopPainter();
      // base painter do not have this method, if it there use it
      // it can be object painter here or can be specially introduce method to handling redraw!
      if (isFunc(top?.redrawObject)) {
         redraw_res = top.redrawObject(obj, opt);
         if (redraw_res) res_painter = top;
      }
   }

   if (res_painter)
      return getPromise(redraw_res).then(() => res_painter);

   cleanup(dom);

   return draw(dom, obj, opt);
}

/** @summary Scan streamer infos for derived classes
  * @desc Assign draw functions for such derived classes
  * @private */
function addStreamerInfosForPainter(lst) {
   if (!lst) return;

   function checkBaseClasses(si, lvl) {
      if (!si.fElements || (lvl > 10))
         return null;

      for (let j = 0; j < si.fElements.arr.length; ++j) {
         // extract streamer info for each class member
         let element = si.fElements.arr[j];
         if (element.fTypeName !== 'BASE') continue;

         let handle = getDrawHandle('ROOT.' + element.fName);
         if (handle && !handle.for_derived)
            handle = null;

         // now try find that base class of base in the list
         if (handle === null)
            for (let k = 0; k < lst.arr.length; ++k)
               if (lst.arr[k].fName === element.fName) {
                  handle = checkBaseClasses(lst.arr[k], lvl + 1);
                  break;
               }

         if (handle?.for_derived)
            return handle;
      }
      return null;
   }

   lst.arr.forEach(si => {
      if (getDrawHandle('ROOT.' + si.fName) !== null) return;

      let handle = checkBaseClasses(si, 0);
      if (handle) {
         let newhandle = Object.assign({}, handle);
         // delete newhandle.for_derived; // should we disable?
         newhandle.name = si.fName;
         addDrawFunc(newhandle);
      }
   });
}


/** @summary Create SVG image for provided object.
  * @desc Function especially useful in Node.js environment to generate images for
  * supported ROOT classes
  * @param {object} args - contains different settings
  * @param {object} args.object - object for the drawing
  * @param {string} [args.option] - draw options
  * @param {number} [args.width = 1200] - image width
  * @param {number} [args.height = 800] - image height
  * @return {Promise} with svg code */
async function makeSVG(args) {

   if (!args) args = {};
   if (!args.object) return Promise.reject(Error('No object specified to generate SVG'));
   if (!args.width) args.width = 1200;
   if (!args.height) args.height = 800;

   async function build(main) {

      main.attr('width', args.width).attr('height', args.height)
          .style('width', args.width + 'px').style('height', args.height + 'px');

      internals.svg_3ds = undefined;

      return draw(main.node(), args.object, args.option || '').then(() => {

         let has_workarounds = internals.svg_3ds && internals.processSvgWorkarounds;

         main.select('svg')
             .attr('xmlns', 'http://www.w3.org/2000/svg')
             .attr('xmlns:xlink', 'http://www.w3.org/1999/xlink')
             .attr('width', args.width)
             .attr('height', args.height)
             .attr('style', null).attr('class', null).attr('x', null).attr('y', null);

         function clear_element() {
            const elem = select(this);
            if (elem.style('display') == 'none') elem.remove();
         }
         // remove containers with display: none
         if (has_workarounds)
            main.selectAll('g.root_frame').each(clear_element);

         main.selectAll('svg').each(clear_element);

         let svg = main.html();

         if (has_workarounds)
            svg = internals.processSvgWorkarounds(svg);

         svg = compressSVG(svg);

         cleanup(main.node());

         main.remove();

         return svg;
      });
   }

   if (!isNodeJs())
      return build(select('body').append('div').style('visible', 'hidden'));

   return _loadJSDOM().then(handle => build(handle.body.append('div')));
}

internals.addDrawFunc = addDrawFunc;

function assignPadPainterDraw(PadPainterClass) {
   PadPainterClass.prototype.drawObject = draw;
   PadPainterClass.prototype.getObjectDrawSettings = getDrawSettings;
}

// only now one can draw primitives in the canvas
assignPadPainterDraw(TPadPainter);

// load v7 only by demand
async function init_v7(arg) {
   return Promise.resolve().then(function () { return RCanvasPainter$1; }).then(h => {
      // only now one can draw primitives in the canvas
      assignPadPainterDraw(h.RPadPainter);
      switch(arg) {
         case 'more': return Promise.resolve().then(function () { return v7more; });
         case 'pave': return Promise.resolve().then(function () { return RPavePainter$1; });
         case 'rh1': return Promise.resolve().then(function () { return RH1Painter$1; });
         case 'rh2': return Promise.resolve().then(function () { return RH2Painter$1; });
         case 'rh3': return Promise.resolve().then(function () { return RH3Painter$1; });
      }
      return h;
   });
}


// to avoid cross-dependnecy between io.mjs and draw.mjs
internals.addStreamerInfosForPainter = addStreamerInfosForPainter;

/** @summary Draw TRooPlot
  * @private */
async function drawRooPlot(dom, plot) {

   return draw(dom, plot._hist, 'hist').then(hp => {
      let arr = [];

      for (let i = 0; i < plot._items.arr.length; ++i)
         arr.push(draw(dom, plot._items.arr[i], plot._items.opt[i]));

      return Promise.all(arr).then(() => hp);
   });
}

function injectHStyle(node) {

   function img(name,sz,fmt,code) {
      return `.jsroot .img_${name} { display: inline-block; height: ${sz}px; width: ${sz}px; background-image: url("data:image/${fmt};base64,${code}"); }`;
   }

   let bkgr_color = settings.DarkMode ? 'black' : '#E6E6FA',
       border_color = settings.DarkMode ? 'green' : 'black',
       shadow_color = settings.DarkMode ? '#555' : '#aaa';

   injectStyle(`
.jsroot .h_tree { display: block; white-space: nowrap; }
.jsroot .h_tree * { padding: 0; margin: 0; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; box-sizing: content-box; line-height: 14px }
.jsroot .h_tree img { border: 0px; vertical-align: middle; }
.jsroot .h_tree a { text-decoration: none; vertical-align: top; white-space: nowrap; padding: 1px 2px 0px 2px; display: inline-block; margin: 0; }
.jsroot .h_tree p { font-weight: bold; white-space: nowrap; text-decoration: none; vertical-align: top; white-space: nowrap; padding: 1px 2px 0px 2px; display: inline-block; margin: 0; }
.jsroot .h_value_str { color: green; }
.jsroot .h_value_num { color: blue; }
.jsroot .h_line { height: 18px; display: block; }
.jsroot .h_button { cursor: pointer; color: blue; text-decoration: underline; }
.jsroot .h_item { cursor: pointer; }
.jsroot .h_item:hover { text-decoration: underline; }
.jsroot .h_childs { overflow: hidden; display: block; }
.jsroot_fastcmd_btn { height: 32px; width: 32px; display: inline-block; margin: 2px; padding: 2px; background-position: left 2px top 2px;
                      background-repeat: no-repeat; background-size: 24px 24px; border-color: inherit; }
.jsroot_inspector { border: 1px solid ${border_color}; box-shadow: 1px 1px 2px 2px ${shadow_color}; opacity: 0.95; background-color: ${bkgr_color}; }
.jsroot_drag_area { background-color: #007fff; }
${img('minus',18,'gif','R0lGODlhEgASAJEDAIKCgoCAgAAAAP///yH5BAEAAAMALAAAAAASABIAAAInnD+By+2rnpyhWvsizE0zf4CIIpRlgiqaiDosa7zZdU22A9y6u98FADs=')}
${img('minusbottom',18,'gif','R0lGODlhEgASAJECAICAgAAAAP///wAAACH5BAEAAAIALAAAAAASABIAAAImlC+Ay+2rnpygWvsizE0zf4CIEpRlgiqaiDosa7zZdU32jed6XgAAOw==')}
${img('plus',18,'gif','R0lGODlhEgASAJECAICAgAAAAP///wAAACH5BAEAAAIALAAAAAASABIAAAIqlC+Ay+2rnpygWvsizCcczWieAW7BeSaqookfZ4yqU5LZdU06vfe8rysAADs=')}
${img('plusbottom',18,'gif','R0lGODlhEgASAJECAICAgAAAAP///wAAACH5BAEAAAIALAAAAAASABIAAAIplC+Ay+2rnpygWvsizCcczWieAW7BeSaqookfZ4yqU5LZdU36zvd+XwAAOw==')}
${img('empty',18,'gif','R0lGODlhEgASAJEAAAAAAP///4CAgP///yH5BAEAAAMALAAAAAASABIAAAIPnI+py+0Po5y02ouz3pwXADs=')}
${img('line',18,'gif','R0lGODlhEgASAIABAICAgP///yH5BAEAAAEALAAAAAASABIAAAIZjB+Ay+2rnpwo0uss3kfz7X1XKE5k+ZxoAQA7')}
${img('join',18,'gif','R0lGODlhEgASAIABAICAgP///yH5BAEAAAEALAAAAAASABIAAAIcjB+Ay+2rnpwo0uss3kf5BGocNJZiSZ2opK5BAQA7')}
${img('joinbottom',18,'gif','R0lGODlhEgASAIABAICAgP///yH5BAEAAAEALAAAAAASABIAAAIZjB+Ay+2rnpwo0uss3kf5BGrcSJbmiaZGAQA7')}
${img('base',18,'gif','R0lGODlhEwASAPcAAPv6/Pn4+mnN/4zf/764x2vO//Dv84HZ/5jl/0ZGmfTz9vLy8lHB/+zr70u+/7S03IODtd7d6c/P0ndqiq/w/4Pb/5SKo/Py9fPy9tTU121kjd/f4MzM062tx5+zy5rO67GwxNDM14d8mJzn/7awwry713zX/9bW27u71lFRmW5uoZ+fxjOy/zm1/9HQ2o3g/2xfgZeMplav7sn9/6Cgv37X/6Dp/3jU/2uJ2M7J1JC63vn5+v38/d7e38PD0Z7o/9LR4LS01cPDzPb1+Nzb5IJ2lHCEv5bk/53C3MrJ3X56t+np6YF7o3JsndTU5Wtgh5GHoKaesuLi4mrO/19RdnnV/4WBqF5QdWPK/4+PvW5uu4+PuuHh4q7w/97e68C9z63w/9PT0+zs7FtbmWVXerS0yaqitpuSqWVlpcL6/8jD0H/C9mVajqWu3nFwpYqHtFfE/42DnaWl0bTz/5OPt+7u7tra5Y+Yz+Tk56fM6Gek5pG50LGpvOHh72LJ/9XU5lbD/6GnwHpujfDu8mxpntzb45qav7PH41+n6JeXyUZGopyYsWeGyDu2/6LQ44re/1yV41TD/8LC1zix/sS/zdTU4Y+gsd/c5L7z+a6uzE+3+XG89L6+087O1sTD3K2twoGBtWVbgomo4P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAKMALAAAAAATABIAAAjtAEcJFLgDTyE7SVCsAAJgoMNRYTII8fEpkAckOpiEaPhwlARLexxhmpEGzJEmBAJ0HMXhw6MfXeZQsDHADZ8hK13kMTEAwQgEL2oYiaJgJZFDU24cqHCgSgFGFgysBJAJkB8BBQRggQNJxKCVo0rIcMAgEgMHmnBMaADWEyIWLRptEqWETRG2K//ombSmjRZFoaCo4djRyZ0HchIlSECIRNGVXur0WcAlCJoUoOhcAltpyQIxPSRtGQPhjRkMKyN0krLhBCcaKrJoOCO1I48vi0CU6WDIyhNBKcEGyBEDBpUrZOJQugC2ufPnDwMCADs=')}
${img('folder',18,'gif','R0lGODlhEgASANUAAPv7++/v79u3UsyZNOTk5MHBwaNxC8KPKre3t55sBrqHIpxqBMmWMb2KJbOBG5lnAdu3cbWCHaBuCMuYM///urB+GMWSLad1D8eUL6ampqVzDbeEH6t5E8iVMMCNKMbGxq58FppoAqh2EKx6FP/Ub//4k+vr6///nP/bdf/kf//viba2tv//////mQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAC4ALAAAAAASABIAAAaRQJdwSCwaj8ik0jUYTBidAEA5YFkplANhehxABGAwpKHYRByVwHBibbvbo8+Q0TrZ7/jWBTHEtP6AgX8GK0MWLSWJiostEoVCBy0qk5SVLQmPLh4tKZ2eny0LmQ0tKKanqC0hmQotJK+wsS0PfEIBZxUgHCIaBhIJCw8ZBUMABAUrycrLBQREAAEm0tPUUktKQQA7')}
${img('folderopen',18,'gif','R0lGODlhEgASANUAAO/v76VzDfv7+8yZNMHBweTk5JpoAqBuCMuYM8mWMZ5sBpxqBPr7/Le3t///pcaaGvDker2KJc+iJqd1D7B+GOKzQ8KPKqJwCrOBG7WCHbeEH9e4QNq/bP/rhJlnAffwiaampuLBUMmgIf3VcKRyDP/XhLqHIqNxC8iVMMbGxqx6FP/kf//bdf/vievr67a2tv/4k8aaGf//nP//mf///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAADUALAAAAAASABIAAAaVwJpwSCwaj8ikUjgYIBIogEA5oFkZDEtheqzKvl9axKTJYCiAIYIGblutqtQwQYPZ73jZpCGM+f+AfiEdJy99M21tMxwxJQeGNTGIeHcyHzEjCpAAki2en54OIhULkAKSMiuqqysOGxIGkDWcMyy2t7YQDx58QqcBwMAkFwcKCwYgBEQFBC/Oz9AEBUUALtbX2FJLSUEAOw==')}
${img('page',18,'gif','R0lGODlhEgASAOYAAPv7++/v7/j7/+32/8HBweTk5P39/djr/8Df//7///P5/8Ph//T09fn5+YGVw2t0pc7n/15hkFWn7ZOq0nqDsMDA/9nh7YSbyoqo2eTx/5G46pK873N+sPX6//f395Cjy83m/7rd/9jl9m13qGVqmoeh0n+OvI+z5Yyu387T//b6/2dtnvz9/32JtpS/8sbGxv7+/tvn92lwom96rHJ8rnSAsoep3NHp/8nk/7e3t+vr67a2tun1/3V4o+Hw/9vt/////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAEEALAAAAAASABIAAAejgEGCg4SFhoeILjaLjDY1AQCHG0AGAA0eDBY1E5CGGjBAoQkCMTUSHwGGJwaiAh0iNbEvhiihAgIDPDwpFRw5hhgsuLk8Pz8HNL+FJSoKuT4+xzczyoQXzjzQxjcgI9WDDrraPzc4OA/fgibZ0eTmCzLpQS0Z7TflCwgr8hT2EOYIQpCQ16OgwYMRCBgqQGCHw4cOCRQwBCCAjosYL3ZCxNFQIAA7')}
${img('question',18,'gif','R0lGODlhEgASAPelAOP0//7//9bs//n///j//9Ls/8Pn//r//6rB1t3f5crO2N7g5k1livT4+7PW9dXt/+v4/+Xl5LHW9Ov6/+j1/6CyxrfCz9rd5Nzj6un1/Z6ouwcvj8HBzO7+/+3//+Ln7BUuXNHv/6K4y+/9/wEBZvX08snn/19qhufs8fP7/87n/+/t7czr/5q1yk55q97v/3Cfztnu//z//+X6/ypIdMHY7rPc/7fX9cbl/9/h52WHr2yKrd/0/9fw/4KTs9rm75Svzb2+ya690pu92mWJrcT3//H//+Dv/Xym35S216Ouwsvt/3N/mMnZ5gEBcMnq/wEBXs/o/wEBetzw/zdYpTdZpsvP2ClGml2N3b3H0Nzu/2Z2lF1ricrl/93w/97h6JqluktojM/u/+/z9g8pVff4+ebu9q+1xa6/zzdFaIiXr5Wyz0xslrTK4uL//2uIp11rh8Xj/NXn+Oz2/9bf6bG2xAEBePP//1xwkK/K5Nbr/8fp/2OBtG53kai3ykVCYwEBde/6/7O4xabI+fD//+by/x8+jDhZpM/q/6jK58nO19ny/7jV7ZO42NHr/9H4/2ZwimSV6VBxwMDX7Nvf5hYwX5m20sfb6Ieqyk9Yjr/k/cPM2NDp/+/098Tl9yQ9jLfW+Mne8sjU30JklP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAKUALAAAAAASABIAAAjxAEsJHEiwoMEyGMaQWthg0xeDAlGUWKjoz5mFAegY/LBiIalMUK54JCWEoJkIpA6kSDmoAykKgRaqGSiq04A5A5r4AKOEAAAtE2S0USAwSwYIhUb8METiUwAvemLMCMVEoIUjAF5MIYXAThUCDzgVWDQJjkA0cngIEHAHCCAqRqJ0QeQoDxeBFS71KKDCwxonhwiZwPEkzo4+AimJqBFCjBs+UjZ4WmLgxhAQVgb6acGIBShJkbAgMSAhCQ1IBTW8sZRI055HDhoRqXQCYo4tDMJgsqGDTJo6EAlyYFNkVJDgBgXBcJEAucEFeC44n04wIAA7')}
${img('histo1d',16,'gif','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAADAFBMVEW9vb2np6empqanpqenpqivr6//AAD3+fn09vb19vf3+Pv8+v//+//29/v3+fr19vbZ3Nza3d7X0+Lb3t7b3N3AwMP2+PimpqXe4+Th6uvQ0dTi6uzg5ebFx8nt6vb////r5/T2+fnl4e3a3uDN0NT7/P6lpqX3+vvn9vhcVVHu+//W1uH48//29P///f+mpqelpqb4/v/t/f9oY2H6///59v/x8fXw9fny9/78/v+lpqf7//9iXl12dHPW2t/R1tdtaGbT2dpoZmT6/v9ycnKCgoJpZGJ6dnT3///2///0//95entpa2t+gIKLjI55d3aDgYBvcXL1+/z9/v6lpaWGiIt7fH6Ji42SlJeEhIZubGyMjI17fYD+//+kpKSmpaaRk5WIioyRk5aYmp2OkJJ+f4KTlZilpKWcnqGVl5qcnqCfoaOYmp6PkZOdn6GsrrGoqq6qrK+rrbGpq66lp6uqrbCoqq20tLSsrKzc3NzMzMzPz88AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB6enrU4/9iYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmLU4/9KSkoAAAAAAAAAAAB6enrU4//m5uZiYmLm5uZiYmLm5uZiYmLm5uZiYmLm5ubU4/9KSkoAAAAAAAAAAAB6enrU4/9KSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkrU4/9KSkoAAAAAAAAAAABubm7U4//U4//U4//U4//U4//U4//U4//U4//U4//U4//U4/9KSkoAAAAAAAAAAABubm5KSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABt6dBwBYjWHVG2AAAAB3RSTlP///////8AGksDRgAAAAlwSFlzAAALEgAACxIB0t1+/AAAAOxJREFUeNpjYGBkggBmFmYmRlY2BkZ2DhDg5OLm4eblY2RjYOIXEBQSFhEFkgKCYkxsDOKcEpJS0jKycvJS8gpcIAFFJWUVGFIFCqipa8hrymtpy+sI6crr6bMxGBgayRvLm8iamkmZW1gCBayslWxs7ewd7OwdlZStrYC2ODm7uLrJu3t4usl7mRiwMeh7+/j6+VsHBMr7+wQFhwAFQsPCIyKjomOiIsOiYuPYGOITEpOSU1LTElNTElPlgQLpGZlZ2Tm5eZm5OZm5IAGm/ILCouKS0rKS4oISeaDDypniEICpgo2hsgoZVLMBAHIaNxuoIXy2AAAAAElFTkSuQmCC')}
${img('histo2d',16,'gif','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAACXBIWXMAAAsSAAALEgHS3X78AAABUUlEQVR42o1R0U7CQBDkU/w/v8qk1/OhCS+88miMiQYMBMNRTqiisQiRhF6h13adsuVKDEYvm81kdmdv9q7V7XallP65I30UrpErLGW73SaiFtDF5dXWmNNITJrubJ4RWUI2qU33GTorAdSJMeMwhOxpEE20noRTYISaajBcMrsdOlkgME+/vILtPw6j+BPg5vZuFRuUgZGX71tc2AjALuYrpWcP/WE1+ADAADMAY/OyFghfpJnlSTCAvLb1YDbJmArC5izwQa0K4g5EdgSbTQKTX8keOC8bgXSWAEbqmbs5BmPF3iyR8I+vdNrhIj3ewzdnlaBeWroCDHBZxWtm9DzaEyU2L8pSCNEI+N76+fVs8rE8fbeRUiWR53kHgWgs6cXbD2OOIScQnji7g7OE2UVZNILflnbrulx/XKfTAfL+OugJgqAShGF4/7/T6/Ug+AYZrx7y3UV8agAAAABJRU5ErkJggg==')}
${img('histo3d',16,'gif','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAADAFBMVEX////48OjIgTrHfjjKgTr78+yixH9HiQBHiACiw37jvJXfpVP6wzT7zTn7yj3lp1qOhyJzvgCa3wCa3gB2ugBinQ6Pt2D4+vfOjEr96p3986z83mT99rD99a3WhEvC0kaU3gCV3ADG71zo/KORzw1gowBonS3Z5snHfTb6uyD6tzD+/Nb7z0/70D3KdTXI1l3h+qTi+KXD7luU3ACY3gCc4QCi3g1QjwXHfjr710T6xi/+9sn70UH73E/MdDqhvQCi1BKkug2XxACU1wCS2ADD51rr9aJXkw/MpYDgpkb71U7+9MP7007hnEO3niOj0hGq3SCZtQCbtQCjtwj//+7F4Vui0wBDhgDk5eTMxcGxfi3TfTq+fyPPz4ak3xux5TG87kmZuwCZvACWtgDf8a+c0gCy3yNLiwD7/Ps1iwCiyAPF3F7j7bG67EW77kmq5yWYzwCZwwCTugDc8KTE51ve9YZCigCgwgCVuQDa5p7U9YSq4yWT2gCV2wCT2wCp2h/y+9HC6lW87DlChQBGigCixgCYvgDK3nyXvgC72UjG7mSj3xXL7XDK7W7b9J+36TrG9lBDhQBHigClywCbxQDJ33SXvwCYvQCcwADq+8S77Ei460Hd+KDD9VHU/2VEhgBdlR1rowCXwwDK4W6bxgCaxQCVvQDp/L+/8k7F91fn/6zC9V18tiNbkx/U1dSyv6RglihnoQCYwwChyQDs/7/P/2fE92F5tCBdkib19vXW1taoupVLiwNooQCWwADo/7h5tSBFhgaouZXx8vHOz86ftYVJiQBNjQKetIXt7u3Nzs0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBfAAAAAAAAAA2tmA2tmAAACQAAAAAAAAAAAAAAAAAAAAAATgAABNBfMAAAAAAAAA2tpQ2tpQAACQAAAAAAAAAAAAAAAAAAAAAAdQAABNBfMAAAAAAAAA2tsg2tsgAACQAAAAAAAAAAAAAAAAAAAAAAggAABNBfMCaVmCSAAAAAXRSTlMAQObYZgAAAAlwSFlzAAALEgAACxIB0t1+/AAAAQVJREFUeNpjYGBkYmZhZWBj5+BkAAMubh5ePn4BQSFhEVExcaCAhKSUtIysnLyCopKyiqqaOoOGppa2jq6evoGhkbGJqZk5g4WllbWNrZ29g6OTs4urmzuDh6eXt4+vn39AYFBwSGhYOENEZFR0TGxcfEJiUnJKalo6A0NGZlZ2Tm5efkFhUXFJqTnQnrLyisqq6prauvqGxqZmoEBLa1t7R2dXd09vX/+EiUCBSZOnTJ02fcbMWbPnzJ03HyiwYOGixUuWLlu+YuWq1WvWAgXWrd+wcdPmTVu2btu+Y/06kHd27tq9Z+++/QcOHtq1E+JBhsNHjh47fuLIYQYEOHnq1EkwAwCuO1brXBOTOwAAAABJRU5ErkJggg==')}
${img('graph',16,'png','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AEFCgohaz8VogAAAT9JREFUOMulkz1LQlEYx39XmrIhcLa5i4mD4JBQrtHieDbb+gx3dbl9hca7tLi4VOsRMkKQVO7LLAQNNdSQgyJPg903tDT8w4HzPDznd56Xc1BKCVsokzTGjhPBXDcQAAEZDgPZCHDQaESH5/PYXyqZxp8A349vGHkjOXo3uXtp035sy79KABi8DQCwshb7x3U6gIYU6KNej+1kEwUEjbQeWtIb9mTsOCIgN1eXgiYd96OdcKNBOoCuQc47pFgoGmHw7skZTK9X16CUku5zV9BIkhz4vgSuG/nsWzvKIhmXAah+VpfJsxnGZMKkUln05NwykqOORq6UWkn+TRokXFEG/Vx/45c3fbrnFKjpRVkZgHKxbAC8NptrAfm9PAD2l42VtdJjDDwv2CSLpSaGMgsFc91hpdRFKtNtf6OxLeAbVYSb7ipFh3AAAAAASUVORK5CYII=')}
${img('mgraph',16,'gif','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAADAFBMVEW9vb2np6empqanpqenpqivr68AAAD3+fn09vb19vf3+Pv8+v//+//29/v3+fr19vbZ3Nza3d6/wcLb3t7b3N3AwMPi4et2oz0yfwDh3+n2+PimpqXe4+Th6uvD0NHi6uzg5ebFx8nt6vY2ggDs/881gQDr5/T2+fnFz9DDZVrAIhDEZVvJ0tTN0NTX0+IvZAA4hAAuYgDT0N77/P6lpqX3+vvn9vi/JRL81cHBJhTu+//W1uEkXgD48//29P8fWwD//f+mpqelpqb4/v/t/f+yCwDBKBi3CgD6//8kYAD59v/x8fXQ0dTw9fny9/78/v+lpqf7//+wAADV5ezZ5e7g6PQjZQDf4+/W2t/R1tfT2drT3+OvAAD9///6/v/////k4vIiXwC1AAD3///2///X6Oz0//9+rUgzfwAwdADa6u6xCwDAJxb5///1+/z9/v6lpaUwfADo/8vl4e3a3uDb6eu+IxL808C+IhDZ5+nW2tr+//+kpKSmpaaArUgvewB1oj39/v/e5ebVd227HgvJa2H8///6/PylpKXn4+ze4eLg5+j9/v20tLSsrKzc3NzMzMzPz88AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAPAAAAAAEAAAEAAABzL1z/CSMAAAAAAAAAAAAAAAMAAAAmCTsAAAAAAAAAAAAAAAAAAAQAAQEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7op0gAAAAB3RSTlP///////8AGksDRgAAAAlwSFlzAAALEgAACxIB0t1+/AAAAOhJREFUeNpjYGBkggBmFmYmRlY2BkZ2DhDg5OLm4eblY2RjYOIXEBQSFhEVE5cQl5RiYmOQ5pSRlZNXUFRSVlFV4wIJqGtoamnr6OrpGxgaGQMFTEzNzC0sraxtbPXs7B0c2RicnF1c3dw9PL28fXz9/IECAYFBwSGhYeERkVHRMYEBQFti4+ITEuOTklNSg9I8nNgYHOPTMzLjA7Oyc7Jz8/ILQAKFRRnFJaVl5RWVVdU1bAy18XX1DfGNTc0trW3t8UCBjvj4+M746q74+O7qHpAAUzwyADqsl6kGAZj62Bj6JyCDiWwAyPNF46u5fYIAAAAASUVORK5CYII=')}
${img('tree',16,'gif','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAAAQAAAAEABcxq3DAAACjklEQVQ4y4WTy49LcRzFP+2tzmVUr9dIDJOWGGVBicgEyTQTCzIetUFssDKJSFhY2SARCYvBbGrj8QcIkYglk8xCmEQ9xqNexbQVY2Zub3un9/W7PwstHZH4Jie/7+Kc8/suzgnwr+kjBqSBbm2lkm6bHyH3XM9SZQ8Z8s3UQJPo0IJVof5EZ7v2faxMrKONlhmQWN5GSFEwLbhybjBPhDwVsmQ4AaA09Mou+k8d702EAzXiS6KEgzahoIthGOi6DtKlN71GS+/cEPs0WewaX2R9ZphssP776UhESY0WSpQNg7Jh4Anx+zgJVKpV3uZyvHjzir27NwGs/XVBH8c7N2nnjx7eSqlYxPM8JCCkxBU+rhA4dVhCYJgmyc4Ej96/7rLi8nNAPc/k2ZNp7cnTpziuiy8lvpSI+tvYhS/xpY8vJXMiEbZv3MzFq3cJqaqiPX72jnKt9kfQRPZ9f5qZ70sMawyAas1GseIy1rNtVXK8Mkm1VsP2PBzhYQuB5Qns+t6AJQSqqlIcrTAy+ONGENBWLF3MN71MxXGo1mE6DqbrYLou8z/a7L3uMKvgUnU8xk2T3u71ADGFDdgvCx/3TwkLEfKxhWDHbY+eYZ+Obz6tJcmRApRsuJ8Ex4Po7Jl8/TDBl7flm4Gm5F1vSZKaFQUh4cB9OLgaDB3UVrjwA+6tBnKAis4El8lwujmJSVQeoKAxFzqDcG0KWhZC6R30tUJRQD3Odxqy4G+DDFks4pisY5RLgRx5pZ5T4cKy95yhSrxZDBCaVqIMOpAd2EIeSEW7wLQh3Ar7RtCHbk0v0vQy1WdgCymgf147Sa0dhAOVMZgoALDu2BDZ/xloQAzQgIOhMCnPYQ+gHRvi4d/8n00kYDRVLifLAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDEwLTAyLTExVDE0OjUxOjE3LTA2OjAwHh/NoQAAACV0RVh0ZGF0ZTptb2RpZnkAMjAwNC0wOS0yMFQxNzoxMDoyNi0wNTowMCcJijsAAAAASUVORK5CYII=')}
${img('branch',16,'gif','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAADAFBMVEX///99plFAfADL27hpmyfP8YxyoilSiRiv0XGGygK02VtRiBmVwjh8xQCcziFZkhLz9+9BfQB2rwaCyACRygFQigXw9Ox0mkpXkQCJzwBblgBmkzP8/fxEgQBCfwBEgQejwITe3t5hkC1CfgBfjynZ2tmSq3eArDu72oNvoDJajyTY2dhFgQDCzLqhvn9EgAazx55XkwCVzC2824GMs1J0oUTY48xajiK72YR9qj2Tq3dhkix+th99xAB3uADA3oQ+fABEgABIgwW82oOUyi5VkgCf0CaEygB+wwCbzjN1mkrA3YZ1tAB7wAB+uB1vl0JdmgCJwwCKzwBoqAB4nVBikiuayzZ8wQCFywCg0Sjd3t1lkjFBfABLgwhKgwlmpgCK0QCJxQBclwDMzMzPz89GggCDpFxDfgCIpmPl5eUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABhAABQEABuZQBjYQBvcgAIZABiYQBlZAAABQDU/wCx/wCO/wBr/wBI/wAl/wAA/wAA3AAAuQAAlgAAcwAAUADU/wCx/wCO/wBr/wBI/wAl/wAA/gAA3AAAuQAAlgAAcwAAUADj/wDH/wCr/wCP/wBz/wBX/wBV/wBJ3AA9uQAxlgAlcwAZUADw/wDi/wDU/wDG/wC4/wCq/wCq/wCS3AB6uQBilgBKcwAyUAD//wD//wD//wD//wD//wD//wD+/gDc3AC5uQCWlgBzcwBQUAD/8AD/4gD/1AD/xgD/uAD/qgD/qgDckgC5egCWYgBzSgBQMgD/4wD/xwD/qwD/jwD/cwD/VwD/VQDcSQC5PQCWMQBzJQBQGQD/1AD/sQD/jgD/awD/SAD/JQD+AADcAAC5AACWAABzAABQAAD/1AD/sQD/jgD/awD/SAD/JQD/AADcAACwULzWAAAAAXRSTlMAQObYZgAAAAlwSFlzAAALEgAACxIB0t1+/AAAALZJREFUeNpjYAADRiZGBmTAzMLKxowswM7BycWNLMDEw8vHL4AkICgkLCIqhiQgLiEpJS0D5cjKySsoKimrqMJk1dQ1NLW0dXQZ9PTlZEECBoZGxiamOmbmmhaWViABaxtbO3sHRycTZxdXA7ANbu4enkxeDt4+vn7WIAH/gMCg4JBQprDwiEhBkEBUtGBMrI5OXHxCYpI/2BrV5OSU5NS09BjB6CiE01JTM5KTVZHcmpycCWEAANfrHJleKislAAAAAElFTkSuQmCC')}
${img('leaf',16,'gif','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAADAFBMVEX////M27mQs2tilDA9eQA7egBbkhVTjAxJgwWBqVdGgQBrnySdxViu0WrE4oaYv2PC35NtoCqxvaSevX5FgAB7qje73nDK6neu109vpyVupCGo2kJ9xwBQhBtilC9pnx7G63PM6olgnAB/vQBDigCVv0yb1CaDzAB8uBJwmkNnnBnB52ui2Ca94WZopAE/hgCtz2ue2CmDywCByACKujtdjyqdvHpdlhLV9YdkowCFxwCw1lFXmAJvpC5jng1coABlpwBprAB8sitAfABDfgKx31Gr3TuCsi5sqABtqgBUkxTV85zL7I213mef0j+OxyKk00k/ewCp3TCSyhCw0mRRjQC23HmU0h55wQB5vQB4uQB1tgCIwBeJxgCBvQDC3ndCjACYx1204Fx6wwB7vQB1tABzsQBBfQBpkzdtpQB9tQA/iQCMu1SMukNUlQBYmQBsqAd4rh11rwZyrQBvqgBDfwCqvZVWkQBUnACp0Hq/43K733C+4X+w12eZyT2IvSN5sgpZkwBxmUSDqFlbnACJzQy742p/wwB2ugBysgBwrwBvqwBwqQBhmgBCfwDV2NN8pk1foACO1QBZmABRkABpqwB3uQB0sgB0rgBnogBUjgC7w7NymkFdnQBUhxmis41okjdCfgBGgQWHpWPMzMzb3NtumD5NhQzT09Pv8O/a2trOz87l5eXc3NzPz88AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABtHAA4HXQAAEgAAB9CTigAAABCfCQ4HTxy6Kw4HXRy+8xy+8wAAMwAAAAAAAAAAAAAAAAAAAAAAAgAAAgAABgYAAG7AAAAACgAAAgAAAgYAAEAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4Hnw4HnwAAFRpRiYmO2V0aWRtSSY7ZWdsZVNpdGNBO251amRGO3R0bCYmO3J3ZWlvVCY7c2xuaVc7d28ABCwBG8q3AAAAAXRSTlMAQObYZgAAAAlwSFlzAAALEgAACxIB0t1+/AAAAOtJREFUeNpjYIACRiZmFlY2dg4ol5OLm4eXj19AUAjMFRYRFROXkJSSlpEF8+XkFRSVlFVU1dQ1NMF8LW0dXT19A0MjYxNTIN/M3MLSytrG1s7ewdHJGSjg4urm7uHp5e3j6+cfABIIDAoOCVUJC4+IjIqOAQk4x8bFJyQmJadEpaalpQMFMjKzsnNy8/ILCouKS0qBAmXlFZVV1TW1dfUNJY1NQIHmlta29o7ozq7unt6+fgaGCRMnTZ4ydVrU9BkzZ5XOBiqYM3HuvPkL0tPTFy5avATkzqXLlq9YuWoJEKxeA/Ho2nUMyAAA9OtDOfv2TiUAAAAASUVORK5CYII=')}
${img('leaf_method',16,'png','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAKlBMVEUAAAAAgADzExMAgIAAAADAwMCAgADxGRnuFxLnHhHuIyPKJQ/rLi7////aW8ZOAAAAAXRSTlMAQObYZgAAAAFiS0dEDfa0YfUAAAAHdElNRQfgCxIPFR/msbP7AAAAaUlEQVQI12NggANBBiYFMMNQxAjCYA4UUoZIBRpBGMyiQorGIIaxWRCEwSYo3igiCNJlaLkwGSwkJn1QGMhgNDQ0TDU2dACqERYTDksGG5SkmGoApBnFhBRTBUAiaYJpDIJgs10cGBgdACxbDamu76Z5AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE3LTAxLTE3VDA5OjMwOjM1KzAxOjAwyGHxKQAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNi0xMS0xOFQxNToyMTozMSswMTowMJgvuUkAAAAASUVORK5CYII=')}
${img('globe',18,'gif','R0lGODlhEwASAPcAAPr7/AFyAQFCpwGD6jy3/wE9on7N0AE+pAFjyMLI0AE2mwF94wGP9QFpzgU3nISSopWgrmJsfTNLfgFHqAFuBilNiTp4sLnGzwWb/0xYb/P09mRygGl0hRlnMgR12V2Pr6e4xF9peS2Cyh5FpBdSfgF84YmisdPa30hjvw+foQFYvlWj4HWIlkWb5gk5n/b4+gw+kgFMscXb6ylmieDj5ju2pylTsniElgqd/u/x8wGW/O7v8SVMsUq+JSSJXQFiwfv+/AFqvB9ntobZeKbc/9vt+B+YmW2rvKruzQGPkm3PPrjmxQFIklrFLVbD4QGMYaXkoIPD13LC+nGw5AGFQHG66gF2eBaJxket9sLf84HI+wF7axBdbg2c0CR+1QFsEIfJ7yqoUIbH41tldgF+KzVTjn3QfitZgTJZkaDR8gKDsXeWrE+zogE3nCeKzQFtJ0tknjdnbQGB6EJgxQFqAcLJ0WC//yKm/wE+o7vI0ARozEOz/4/g/4KToyaX4/D09pCpuNHV24HA6gw7oAF/AXWKnEVSb5TI6VzDTrPprxBQts7e6FNdcBA9oySd9RRjPAhnD2NvgIydrF+6wdLo9v7//2K+twKSdDmKyeD56wGCyHq12VnF+ZXXsARdTjZWthShoo7gtilDlAFw1RCXvF+z6p/R8kqZzAF0Oj5jjFuJqgFoAkRgxtzr9YmcrJKsugFlylfBgxJGhjJIeFnFuhmi/+bo65ipt8Hn+UhVco7B5SZowAGBKoaZqAGGAVHBUwF8Qq7Y819qe4DEoVyYwrnb8QGN9GCy6QFTuHB9jgGY/gFRtuTu9ZOhr150iwFbwTFiwFus4h9mYt/y+kWZ35vM7hGfccz43Xy/6m3BuS1GiYveqDRfwnbUV4rdu////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAN8ALAAAAAATABIAAAj/AL8JHEiwVTVspar8ITiwiJhswyaBibJJUq9Trxh+S2OAVihvSzqRcoTpmy5ADIPFqrHtGpBETbrIuXJEBgiGbHoogTItExJOoAbw8rHmAkFTC8KYwTWkGx8COp4AozAjD8Epo4wQQfTLCQEcxqigoiONBUFqerRYspYCgzIGmgi98cRlA8EVLaR4UJPk0oASVgKs6kAiBMFDdrzAarDFF5kgCJA9ilNBGMFjWAQse/YjwBcVMfCcgTMr2UBKe0QIaHNgAiQmBRS4+CSKEYSBWe44E6JoEAxZDhrxmDPCEAcaA4vVinTCwi5uKFhBs6EtQ4QEOQYy8+NGUDRiqdCUJJGQa8yNQDsADHyxSNUHE4Vc3erzoFkdWxoAVNLIv7///98EBAA7')}
${img('canvas',16,'gif','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAADAFBMVEX/AAC1t7etsLCsrq6rrq6rrq2tr6+0tratsK/////p6enIysrl5OTn5uXo5+ajpaXo5+dhhKdliKlmialgg6elp6f6+/vIycnr7Ozw7u7x7u7x7u3t6+vLzMvp7vbs7/bz8PD17+3z7u2rrq/6xS76xy13zv9+z/+EwLF4zP/38/NfgqWAoL36uCj6vCmR2f+TxamSrBmNvoj++fz8+Pf69/WZ3f+g4P+n4/+Cnw2Dox16nQ3//f9hg6eBob6x5/+46f+77P+p2NKSZhOi1s////7//fusrq98sB6CsyWDtSmFuC9+dBl/tilfgqasr6+sr7DbAADcAABcgqWAoLyusLC4urqssLCssLGrsLCrr7Ctr67c3NzMzMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABoAAAKAgJldmV0dU8GB3JvTnZDBWVyb2xsYwdjYWxhUBB0bmVrY2F1b3IICGRPYmFyZWQAAAXj1P/Hsf+rjv+Pa/9zSP9XJf9VAP9JANw9ALkxAJYlAHMZAFDU1P+xsf+Ojv9ra/9ISP8lJf8AAP4AANwAALkAAJYAAHMAAFDU4/+xx/+Oq/9rj/9Ic/8lV/8AVf8ASdwAPbkAMZYAJXMAGVDU8P+x4v+O1P9rxv9IuP8lqv8Aqv8AktwAerkAYpYASnMAMlDU//+x//+O//9r//9I//8l//8A/v4A3NwAubkAlpYAc3MAUFDU//Cx/+KO/9Rr/8ZI/7gl/6oA/6oA3JIAuXoAlmIAc0oAUDLU/+Ox/8eO/6tr/49I/3Ml/1cA/1UA3EkAuT0AljEAcyUAUBnU/9Sx/7GO/45r/2tI/0gl/yUA/gAA3AAAuQAAlgAAcwAAUADj/9TH/7Gr/46P/2tz/0hX/yVV/wBJ3AAQ+AFLAAAAAXRSTlMAQObYZgAAAAlwSFlzAAALEgAACxIB0t1+/AAAALpJREFUeNpjYGBkYmZhYWFlYWNngAAOTijg4oYIMHPy8PLx8nDycwpwQwUEhYSFRDhFxTi5xCECEpJS0jKcsqL8nGwgARZOOXkFRSWwMcwgAWVOFVU1dQ1NLW0dmICunr6BoZGxiSlEgJnTzNzC0sraxtYOJmDv4Ojk7MLp6gYRcOf08PTy9vHl9IOa4c+JAGCBAM7AoEDOwEDO4BCIABOSilCQQBhTeERkVGS4f3R0aBhIICYWAWIYGAClIBsa7hXG7gAAAABJRU5ErkJggg==')}
${img('profile',16,'gif','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAACXBIWXMAAAsSAAALEgHS3X78AAABZElEQVR42o1R22rCQBD1U/p//apCNtsHwRdfBaFIKbRoUVKMMTWBWIxVCq2b+07POrn4UKjDMpw9O2fm7G5vNBpJKe2/Qto4uEc2WMrBYEBEPaAky36UulwnlSRpUeZEBSGrpEiyHJVGAPVJqZvbO3ftv83Dle+vvPV4/LD0PGYAcKrSFJUsEOgHKoj3s9dFGH9uou3k8ekQKxyDQcYpBnYC7Hm9zBZmlL8BiIJDC0AWpa4FwhZJXoDCBgYAjgU5ToBt+k1tL14ssFNNvIEBAFwVljJlSDBfpwyg1ISnYoEsiHju5XLcd+T50q0tEQm7eaWKKNfUWgKApUsbPFY0lzY6DraEZm585Do/CLMzqLQWQnSC9k34lVa7PTsBs/zYOa4LB5ZlnQXCbif40Ra50jUwE6JtCcMlUiMQlugEQYisG8CWtGlRdQL+jmui/rjhcAhk/Reo6ff7RuB53vN1MZ1OIfgFQC1cuR3Y6lIAAAAASUVORK5CYII=')}
${img('execute',16,'png','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAABlBMVEXAwMAAxwCvbOAvAAAAAXRSTlMAQObYZgAAAAlwSFlzAAALEgAACxIB0t1+/AAAACBJREFUCFtjYIABHgYGfiA6wMD/gYH/B5g8ABLhYUAGAHniBNrUPuoHAAAAAElFTkSuQmCC')}
${img('file',16,'png','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAAAQAAAAEABcxq3DAAAA2klEQVRIx61VURbDIAgTX+9ljg4n2z5sNouj1ml+LE9rQkSU5PA6kTZBToTznj5aqKqq+py4lFJKScnMzCwlAAB6IbnNuyXycd1g3oHrf32CmR9mZqpVOdDHs2DmI+c+AiJixu1RAN9xFUcdWCjVIr8xCX8Jubc8Ao9CJF8nRFgNJBxZSCEkjmrIxxSS0yIAoBU4OkpfU8sCPEbEvqaOXcR31zWORbYJ8EI8rsK+DWm7gMVb8F/GK7eg6818jNjJZjMn0agY7x6oxqL5sWbIbhLHoQN78PQ5F3kDgX8u9tphBfoAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMDItMDZUMTA6Mjc6MzErMDE6MDChLu/mAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE0LTExLTEyVDA4OjM5OjIwKzAxOjAwIGvf8wAAAABJRU5ErkJggg==')}
${img('text',16,'gif','R0lGODlhEgASALMAAP/////MzP+Zmf9mZv8zM/8AAMzM/8zMzJmZ/5mZmWZm/2ZmZjMz/zMzMwAA/////yH5BAUUAA8ALAAAAAASABIAAARo8MlJq73SKGSwdSDjUQoIjhNYOujDnGAnFXRBZKoBIpMw1ICHaaigBAq/AUK1CVEIhcfPNFlRbAEBEvWr0VDYQLYgkCQWh8XiAfgRymPyoTFRa2uPO009maP8ZmsjAHxnBygLDQ1zihEAOw==')}
${img('task',18,'png','iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAAAAACMfPpKAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJiS0dEAP+Hj8y/AAAACXBIWXMAAABIAAAASABGyWs+AAAATklEQVQY05XQUQoAIAgD0N3JY3fIChWttKR9xYvBCj0J0FsI3VVKQflwV22J0oyo3LOCc6pHW4dqi56v2CebbpMLtcmr+uTizz6UYpBnADSS8gvhaL5WAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE2LTA0LTA3VDA5OjQyOjQ4KzAyOjAwMgzRmQAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNC0xMS0xMlQwODozOToxOCswMTowMJ0LlncAAAAASUVORK5CYII=')}
${img('pavetext',18,'png','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAAAsSURBVBjTY2CgCuBAAt1gASS5KKgARBpJACSEooIsARRbkABYoDsKCRDhEQBA2Am/6OrPewAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNi0wMS0wNFQxMDoxODoyNyswMTowMHsz6UQAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTQtMTEtMTJUMDg6Mzk6MjArMDE6MDAga9/zAAAAAElFTkSuQmCC')}
${img('pavelabel',18,'png','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJ0Uk5TAAB2k804AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAAApSURBVBjTY2CgCuBAAt1gASS5KJgABzUEgABFANUWJAAWYIhCAkR4BAAHoAkEyi2U3wAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNi0wMS0wNFQxMDoxODoyNyswMTowMHsz6UQAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTQtMTEtMTJUMDg6Mzk6MjArMDE6MDAga9/zAAAAAElFTkSuQmCC')}
${img('list',16,'png','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AEECTc01vBgywAAAE9JREFUOMu1k8ERwDAMwqRc9l/Z/eeRpKZlABkOLFD0JQGgAAah5kp8Y30F2HEwDhGTCG6tX5yqtAV/acEdwHQHl0Y8RbA7pLIxRPziGyM9xLEOKSpp/5AAAAAASUVORK5CYII=')}
${img('color',16,'png','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAM1BMVEUAAAAA4xcavGZGS1xZT79lW+9wdvFz/3N6fo3RISTZwXbyniXz80v/AAD/zAD/66v//6vGWiYeAAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAADswAAA7MAbGhBn4AAAAHdElNRQfgAQQLLBhOmhPcAAAAIklEQVQY02NgRgEMDAzMnLzcfDwC7IxMbKwsQ10A3XMEAQA3JQVNowlkTAAAAABJRU5ErkJggg==')}
${img('colz',16,'png','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAMFBMVEV6fo0A4xcavGZGS1xZT79lW+9wdvFz/3PRISTZwXbyniXz80v/AAD/zAD/66v//6t1AkcGAAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAADswAAA7MAbGhBn4AAAAHdElNRQfgAQQLNwdqpNWzAAAAT0lEQVQI12NgYGAwNjZmAAOLjmY0hs2ZwxCG1arFEIbt3csQhvXuzRCG/f/PEIZ5eTGEYSgoDGEYKSlDGGZpyRCGaWgwhGHi4gxhwG0HAwCr3BFWzqCkcAAAAABJRU5ErkJggg==')}
${img('frame',16,'png','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfgAQQLOwq4oOYCAAAAcUlEQVQoz7WQMQqAMAxFX0Uk4OLgIbp4oZ7BA/cOXR0KDnGpRbGayT+EQF74nw+GHIBo+5hdWdqAaFDoLIsegCSeWE0VcMxXYM6xvmiZSYDTooSR4WlxzzBZwGYBuwWs4mWUpVHJe1H9F1J7yC4ov+kAkTYXFCNzDrEAAAAASUVORK5CYII=')}
${img('class',16,'png','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QAvQC9AL1pQtWoAAAAjUlEQVR42p2T2wnAIAxFM0g/O6jDdBBHcAyHKKQYjfiI0UY4P8I9BG4CID8smB4+8SUsohpO3CFzKqmBFrhCO4kqQnCR6MJF4BEJTVQFhBAmASNIZkH6a0OMc8oUDAu8z7RhTTBVyIIEhxeCdYWjQApvK2TBrgGpwpP1livsBXC0ROMO/LqDKjKEzaf8AZWbJP6pTT9BAAAATHpUWHRTb2Z0d2FyZQAAeNpz0FDW9MxNTE/1TUzPTM5WMNEz0jNQsLTUNzDWNzBUSC7KLC6pdMitLC7JTNZLLdZLKS3IzyvRS87PBQDzvxJ8u4pLSgAAADN6VFh0U2lnbmF0dXJlAAB42ktKs0hLMkk2MzJKNEuzMLKwtEizSElMMbNITUw0NUtNAQCc7Qma0Goe1QAAAABJRU5ErkJggg==')}
${img('member',16,'png','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QAvQC9AL1pQtWoAAAAX0lEQVR42mNgAAIVBob/+DADPgBS8GCPBV6M1xCKDcDnBRcoZhgW4D8DBV75v2bLATAmxyC4ZmRMrCFYNfeU9BBvwJwpS8AYWTNZBoAwTDPFBpAciDCDyNFMtXSAFwAAUyq0GRPbbz4AAABMelRYdFNvZnR3YXJlAAB42nPQUNb0zE1MT/VNTM9MzlYw0TPSM1CwtNQ3MNY3MFRILsosLql0yK0sLslM1kst1kspLcjPK9FLzs8FAPO/Eny7iktKAAAAM3pUWHRTaWduYXR1cmUAAHjaS01JNrE0S00zSbU0NEsxMbMwM0xOSjYwNzY3NLRIMjUCAJcdCJ2BHe6SAAAAAElFTkSuQmCC')}
${img('tf1',16,'png','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAgMAAABinRfyAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAADFBMVEX/////AP8/SMz///+Cf5VqAAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAAHdElNRQfgCw4QHgSCla+2AAAAL0lEQVQI12MQYAACrAQXiFBoABINCgwMQgwcDAwSDEwMDKmhodMYJjAwaKDrAAEAoRAEjHDJ/uQAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTYtMTEtMTRUMTc6Mjk6MjErMDE6MDDxcSccAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE2LTExLTE0VDE3OjI5OjA1KzAxOjAwNka8zgAAAABJRU5ErkJggg==')}
${img('tf2',16,'png','iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAgMAAABinRfyAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAADFBMVEX/////AP8A/wD////pL6WoAAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAAHdElNRQfgCw4PNgzGaW1jAAAARUlEQVQI12NgEGDQZAASKkBigQKQ6GhgYBDiYgASIiAigIGBS8iBgUFhEpCnoAEkUkNDQxkagUIMrUDMMAVETAARQI0MAD5GCJ7tAr1aAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE2LTExLTE0VDE2OjUxOjUzKzAxOjAwi1Gz3gAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNi0xMS0xNFQxNjo1MTozNiswMTowMG5bLUIAAAAASUVORK5CYII=')}
`, node);
}

/** @summary draw list content
  * @desc used to draw all items from TList or TObjArray inserted into the TCanvas list of primitives
  * @private */
async function drawList(dom, lst, opt) {
   if (!lst || !lst.arr)
      return null;

   let handle = { dom, lst, opt, indx: -1, painter: null,
     draw_next() {
        while (++this.indx < this.lst.arr.length) {
           let item = this.lst.arr[this.indx],
               opt = (this.lst.opt && this.lst.opt[this.indx]) ? this.lst.opt[this.indx] : this.opt;
           if (!item) continue;
           return draw(this.dom, item, opt).then(p => {
              if (p && !this.painter) this.painter = p;
              return this.draw_next(); // reenter loop
           });
        }
        return this.painter;
     }
   };

   return handle.draw_next();
}

// ===================== hierarchy scanning functions ==================================

/** @summary Create hierarchy elements for TFolder object
  * @private */
function folderHierarchy(item, obj) {

   if (!obj?.fFolders) return false;

   if (obj.fFolders.arr.length === 0) { item._more = false; return true; }

   item._childs = [];

   for (let i = 0; i < obj.fFolders.arr.length; ++i) {
      let chld = obj.fFolders.arr[i];
      item._childs.push( {
         _name: chld.fName,
         _kind: 'ROOT.' + chld._typename,
         _obj: chld
      });
   }
   return true;
}

/** @summary Create hierarchy elements for TTask object
  * @private */
function taskHierarchy(item, obj) {
   // function can be used for different derived classes
   // we show not only child tasks, but all complex data members

   if (!obj?.fTasks) return false;

   objectHierarchy(item, obj, { exclude: ['fTasks', 'fName'] });

   if ((obj.fTasks.arr.length === 0) && (item._childs.length == 0)) {
      item._more = false;
      return true;
   }

   // item._childs = [];

   for (let i = 0; i < obj.fTasks.arr.length; ++i) {
      let chld = obj.fTasks.arr[i];
      item._childs.push({
         _name: chld.fName,
         _kind: 'ROOT.' + chld._typename,
         _obj: chld
      });
   }
   return true;
}

/** @summary Create hierarchy elements for TList object
  * @private */
function listHierarchy(folder, lst) {
   if (!isRootCollection(lst)) return false;

   if ((lst.arr === undefined) || (lst.arr.length === 0)) {
      folder._more = false;
      return true;
   }

   let do_context = false, prnt = folder;
   while (prnt) {
      if (prnt._do_context) do_context = true;
      prnt = prnt._parent;
   }

   // if list has objects with similar names, create cycle number for them
   let ismap = (lst._typename == clTMap), names = [], cnt = [], cycle = [];

   for (let i = 0; i < lst.arr.length; ++i) {
      let obj = ismap ? lst.arr[i].first : lst.arr[i];
      if (!obj) continue; // for such objects index will be used as name
      let objname = obj.fName || obj.name;
      if (!objname) continue;
      let indx = names.indexOf(objname);
      if (indx >= 0) {
         cnt[indx]++;
      } else {
         cnt[names.length] = cycle[names.length] = 1;
         names.push(objname);
      }
   }

   folder._childs = [];
   for (let i = 0; i < lst.arr.length; ++i) {
      let obj = ismap ? lst.arr[i].first : lst.arr[i],
          item = !obj?._typename ? {
            _name: i.toString(),
            _kind: 'ROOT.NULL',
            _title: 'NULL',
            _value: 'null',
            _obj: null
          } : {
            _name: obj.fName || obj.name,
            _kind: 'ROOT.' + obj._typename,
            _title: (obj.fTitle || '') + ' type:'  +  obj._typename,
            _obj: obj
          };

        switch(obj._typename) {
           case clTColor: item._value = getRGBfromTColor(obj); break;
           case clTText:
           case clTLatex: item._value = obj.fTitle; break;
           case clTObjString: item._value = obj.fString; break;
           default: if (lst.opt && lst.opt[i] && lst.opt[i].length) item._value = lst.opt[i];
        }

        if (do_context && canDrawHandle(obj._typename)) item._direct_context = true;

        // if name is integer value, it should match array index
        if (!item._name || (Number.isInteger(parseInt(item._name)) && (parseInt(item._name) !== i))
            || (lst.arr.indexOf(obj) < i)) {
           item._name = i.toString();
        } else {
           // if there are several such names, add cycle number to the item name
           let indx = names.indexOf(obj.fName);
           if ((indx >= 0) && (cnt[indx] > 1)) {
              item._cycle = cycle[indx]++;
              item._keyname = item._name;
              item._name = item._keyname + ';' + item._cycle;
           }
        }

      folder._childs.push(item);
   }
   return true;
}

/** @summary Create hierarchy of TKey lists in file or sub-directory
  * @private */
function keysHierarchy(folder, keys, file, dirname) {

   if (keys === undefined) return false;

   folder._childs = [];

   for (let i = 0; i < keys.length; ++i) {
      let key = keys[i];

      if (settings.OnlyLastCycle && (i > 0) && (key.fName == keys[i-1].fName) && (key.fCycle < keys[i-1].fCycle)) continue;

      let item = {
         _name: key.fName + ';' + key.fCycle,
         _cycle: key.fCycle,
         _kind: 'ROOT.' + key.fClassName,
         _title: key.fTitle,
         _keyname: key.fName,
         _readobj: null,
         _parent: folder
      };

      if (key.fObjlen > 1e5)
         item._title += ' (size: ' + (key.fObjlen/1e6).toFixed(1) + 'MB)';

      if (key.fRealName)
         item._realname = key.fRealName + ';' + key.fCycle;

      if (key.fClassName == clTDirectory || key.fClassName == clTDirectoryFile) {
         let dir = (dirname && file) ? file.getDir(dirname + key.fName) : null;
         if (dir) {
            // remove cycle number - we have already directory
            item._name = key.fName;
            keysHierarchy(item, dir.fKeys, file, dirname + key.fName + '/');
         } else  {
            item._more = true;
            item._expand = function(node, obj) {
               // one can get expand call from child objects - ignore them
               return keysHierarchy(node, obj.fKeys);
            };
         }
      } else if ((key.fClassName == clTList) && (key.fName == nameStreamerInfo)) {
         if (settings.SkipStreamerInfos) continue;
         item._name = nameStreamerInfo;
         item._kind = 'ROOT.' + clTStreamerInfoList;
         item._title = 'List of streamer infos for binary I/O';
         item._readobj = file.fStreamerInfos;
      }

      folder._childs.push(item);
   }

   return true;
}

/** @summary Create hierarchy for arbitrary object
  * @private */
function objectHierarchy(top, obj, args = undefined) {
   if (!top || (obj === null)) return false;

   top._childs = [];

   let proto = Object.prototype.toString.apply(obj);

   if (proto === '[object DataView]') {

      let item = {
          _parent: top,
          _name: 'size',
          _value: obj.byteLength.toString(),
          _vclass: 'h_value_num'
      };

      top._childs.push(item);
      let namelen = (obj.byteLength < 10) ? 1 : Math.log10(obj.byteLength);

      for (let k = 0; k < obj.byteLength; ++k) {
         if (k % 16 === 0) {
            item = {
              _parent: top,
              _name: k.toString(),
              _value: '',
              _vclass: 'h_value_num'
            };
            while (item._name.length < namelen)
               item._name = '0' + item._name;
            top._childs.push(item);
         }

         let val = obj.getUint8(k).toString(16);
         while (val.length < 2) val = '0'+val;
         if (item._value)
            item._value += (k%4 === 0) ? ' | ' : ' ';

         item._value += val;
      }
      return true;
   }

   // check nosimple property in all parents
   let nosimple = true, do_context = false, prnt = top;
   while (prnt) {
      if (prnt._do_context) do_context = true;
      if ('_nosimple' in prnt) { nosimple = prnt._nosimple; break; }
      prnt = prnt._parent;
   }

   let isarray = (isArrayProto(proto) > 0) && obj.length,
       compress = isarray && (obj.length > settings.HierarchyLimit),  arrcompress = false;

   if (isarray && (top._name === 'Object') && !top._parent) top._name = 'Array';

   if (compress) {
      arrcompress = true;
      for (let k = 0; k < obj.length; ++k) {
         let typ = typeof obj[k];
         if ((typ === 'number') || (typ === 'boolean') || (typ == 'string' && (obj[k].length < 16))) continue;
         arrcompress = false; break;
      }
   }

   if (!('_obj' in top))
      top._obj = obj;
   else if (top._obj !== obj)
      alert('object missmatch');

   if (!top._title) {
      if (obj._typename)
         top._title = 'ROOT.' + obj._typename;
      else if (isarray)
         top._title = 'Array len: ' + obj.length;
   }

   if (arrcompress) {
      for (let k = 0; k < obj.length;) {

         let nextk = Math.min(k+10,obj.length), allsame = true, prevk = k;

         while (allsame) {
            allsame = true;
            for (let d=prevk;d<nextk;++d)
               if (obj[k]!==obj[d]) allsame = false;

            if (allsame) {
               if (nextk===obj.length) break;
               prevk = nextk;
               nextk = Math.min(nextk+10,obj.length);
            } else if (prevk !== k) {
               // last block with similar
               nextk = prevk;
               allsame = true;
               break;
            }
         }

         let item = { _parent: top, _name: k+'..'+(nextk-1), _vclass: 'h_value_num' };

         if (allsame) {
            item._value = obj[k].toString();
         } else {
            item._value = '';
            for (let d = k; d < nextk; ++d)
               item._value += ((d===k) ? '[ ' : ', ') + obj[d].toString();
            item._value += ' ]';
         }

         top._childs.push(item);

         k = nextk;
      }
      return true;
   }

   let lastitem, lastkey, lastfield, cnt;

   for (let key in obj) {
      if ((key == '_typename') || (key[0] == '$')) continue;
      let fld = obj[key];
      if (isFunc(fld)) continue;
      if (args?.exclude && (args.exclude.indexOf(key) >= 0)) continue;

      if (compress && lastitem) {
         if (lastfield===fld) { ++cnt; lastkey = key; continue; }
         if (cnt > 0) lastitem._name += '..' + lastkey;
      }

      let item = { _parent: top, _name: key };

      if (compress) { lastitem = item;  lastkey = key; lastfield = fld; cnt = 0; }

      if (fld === null) {
         item._value = item._title = 'null';
         if (!nosimple) top._childs.push(item);
         continue;
      }

      let simple = false;

      if (isObject(fld)) {

         proto = Object.prototype.toString.apply(fld);

         if (isArrayProto(proto) > 0) {
            item._title = 'array len=' + fld.length;
            simple = (proto != '[object Array]');
            if (fld.length === 0) {
               item._value = '[ ]';
               item._more = false; // hpainter will not try to expand again
            } else {
               item._value = '[...]';
               item._more = true;
               item._expand = objectHierarchy;
               item._obj = fld;
            }
         } else if (proto === '[object DataView]') {
            item._title = 'DataView len=' + fld.byteLength;
            item._value = '[...]';
            item._more = true;
            item._expand = objectHierarchy;
            item._obj = fld;
         } else if (proto === '[object Date]') {
            item._more = false;
            item._title = 'Date';
            item._value = fld.toString();
            item._vclass = 'h_value_num';
         } else {

            if (fld.$kind || fld._typename)
               item._kind = item._title = 'ROOT.' + (fld.$kind || fld._typename);

            if (fld._typename) {
               item._title = fld._typename;
               if (do_context && canDrawHandle(fld._typename)) item._direct_context = true;
            }

            // check if object already shown in hierarchy (circular dependency)
            let curr = top, inparent = false;
            while (curr && !inparent) {
               inparent = (curr._obj === fld);
               curr = curr._parent;
            }

            if (inparent) {
               item._value = '{ prnt }';
               item._vclass = 'h_value_num';
               item._more = false;
               simple = true;
            } else {
               item._obj = fld;
               item._more = false;

               switch(fld._typename) {
                  case clTColor: item._value = getRGBfromTColor(fld); break;
                  case clTText:
                  case clTLatex: item._value = fld.fTitle; break;
                  case clTObjString: item._value = fld.fString; break;
                  default:
                     if (isRootCollection(fld) && isObject(fld.arr)) {
                        item._value = fld.arr.length ? '[...]' : '[]';
                        item._title += ', size:'  + fld.arr.length;
                        if (fld.arr.length > 0) item._more = true;
                     } else {
                        item._more = true;
                        item._value = '{ }';
                     }
               }
            }
         }
      } else if ((typeof fld === 'number') || (typeof fld === 'boolean')) {
         simple = true;
         if (key == 'fBits')
            item._value = '0x' + fld.toString(16);
         else
            item._value = fld.toString();
         item._vclass = 'h_value_num';
      } else if (isStr(fld)) {
         simple = true;
         item._value = '&quot;' + fld.replace(/\&/g, '&amp;').replace(/\"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;') + '&quot;';
         item._vclass = 'h_value_str';
      } else if (typeof fld === 'undefined') {
         simple = true;
         item._value = 'undefined';
         item._vclass = 'h_value_num';
      } else {
         simple = true;
         alert(`miss ${key} type ${typeof fld}`);
      }

      if (!simple || !nosimple)
         top._childs.push(item);
   }

   if (compress && lastitem && (cnt > 0))
      lastitem._name += '..' + lastkey;

   return true;
}

/** @summary Create hierarchy for streamer info object
  * @private */
function createStreamerInfoContent(lst) {
   let h = { _name: nameStreamerInfo, _childs: [] };

   for (let i = 0; i < lst.arr.length; ++i) {
      let entry = lst.arr[i];

      if (entry._typename == clTList) continue;

      if (typeof entry.fName == 'undefined') {
         console.warn(`strange element in StreamerInfo with type ${entry._typename}`);
         continue;
      }

      let item = {
         _name : `${entry.fName};${entry.fClassVersion}`,
         _kind : `class ${entry.fName}`,
         _title : `class:${entry.fName} version:${entry.fClassVersion} checksum:${entry.fCheckSum}`,
         _icon: 'img_class',
         _childs : []
      };

      if (entry.fTitle) item._title += '  ' + entry.fTitle;

      h._childs.push(item);

      if (typeof entry.fElements == 'undefined') continue;
      for (let l = 0; l < entry.fElements.arr.length; ++l) {
         let elem = entry.fElements.arr[l];
         if (!elem || !elem.fName) continue;
         let info = elem.fTypeName + ' ' + elem.fName,
             title = elem.fTypeName + ' type:' + elem.fType;
         if (elem.fArrayDim === 1)
            info += '[' + elem.fArrayLength + ']';
         else
            for (let dim = 0; dim < elem.fArrayDim; ++dim)
               info += '[' + elem.fMaxIndex[dim] + ']';
         if (elem.fBaseVersion === 4294967295)
            info += ':-1';
         else if (elem.fBaseVersion !== undefined)
            info += ':' + elem.fBaseVersion;
         info += ';';
         if (elem.fTitle)
            info += ' // ' + elem.fTitle;

         item._childs.push({ _name: info, _title: title, _kind: elem.fTypeName, _icon: (elem.fTypeName == 'BASE') ? 'img_class' : 'img_member' });
      }
      if (!item._childs.length) delete item._childs;
   }

   return h;
}

/** @summary tag item in hierarchy painter as streamer info
  * @desc this function used on THttpServer to mark streamer infos list
  * as fictional TStreamerInfoList class, which has special draw function
  * @private */
function markAsStreamerInfo(h, item, obj) {
   if (obj?._typename == clTList)
      obj._typename = clTStreamerInfoList;
}


/** @summary Create hierarchy for object inspector
  * @private */
function createInspectorContent(obj) {
   let h = { _name: 'Object', _title: '', _click_action: 'expand', _nosimple: false, _do_context: true };

   if (isStr(obj.fName) && obj.fName)
      h._name = obj.fName;

   if (isStr(obj.fTitle) && obj.fTitle)
      h._title = obj.fTitle;

   if (obj._typename)
      h._title += '  type:' + obj._typename;

   if (isRootCollection(obj)) {
      h._name = obj.name || obj._typename;
      listHierarchy(h, obj);
   } else {
      objectHierarchy(h, obj);
   }

   return h;
}


/** @summary Parse string value as array.
  * @desc It could be just simple string:  'value' or
  * array with or without string quotes:  [element], ['elem1',elem2]
  * @private */
function parseAsArray(val) {

   let res = [];

   if (!isStr(val)) return res;

   val = val.trim();
   if (!val) return res;

   // return as array with single element
   if ((val.length < 2) || (val[0] != '[') || (val[val.length-1] != ']')) {
      res.push(val);
      return res;
   }

   // try to split ourself, checking quotes and brackets
   let nbr = 0, nquotes = 0, ndouble = 0, last = 1;

   for (let indx = 1; indx < val.length; ++indx) {
      if (nquotes > 0) {
         if (val[indx] === "'") nquotes--;
         continue;
      }
      if (ndouble > 0) {
         if (val[indx] === '"') ndouble--;
         continue;
      }
      switch (val[indx]) {
         case "'": nquotes++; break;
         case '"': ndouble++; break;
         case '[': nbr++; break;
         case ']': if (indx < val.length - 1) { nbr--; break; }
         case ',':
            if (nbr === 0) {
               let sub = val.substring(last, indx).trim();
               if ((sub.length > 1) && (sub[0] == sub[sub.length-1]) && ((sub[0] == '"') || (sub[0] == "'")))
                  sub = sub.slice(1, sub.length-1);
               res.push(sub);
               last = indx+1;
            }
            break;
      }
   }

   if (res.length === 0)
      res.push(val.slice(1, val.length-1).trim());

   return res;
}


/** @summary central function for expand of all online items
  * @private */
function onlineHierarchy(node, obj) {
   if (obj && node && ('_childs' in obj)) {

      for (let n = 0; n < obj._childs.length; ++n)
         if (obj._childs[n]._more || obj._childs[n]._childs)
            obj._childs[n]._expand = onlineHierarchy;

      node._childs = obj._childs;
      obj._childs = null;
      return true;
   }

   return false;
}

function canExpandHandle(handle) {
   return handle?.expand || handle?.get_expand || handle?.expand_item;
}

const kindTFile = 'ROOT.TFile';

/**
  * @summary Painter of hierarchical structures
  *
  * @example
  * // create hierarchy painter in 'myTreeDiv'
  * let h = new HierarchyPainter('example', 'myTreeDiv');
  * // configure 'simple' layout in 'myMainDiv'
  * // one also can specify 'grid2x2' or 'flex' or 'tabs'
  * h.setDisplay('simple', 'myMainDiv');
  * // open file and display element
  * h.openRootFile('https://root.cern/js/files/hsimple.root').then(() => h.display('hpxpy;1','colz')); */

class HierarchyPainter extends BasePainter {

   /** @summary Create painter
     * @param {string} name - symbolic name
     * @param {string} frameid - element id where hierarchy is drawn
     * @param {string} [backgr] - background color */
   constructor(name, frameid, backgr) {
      super(frameid);
      this.name = name;
      this.h = null; // hierarchy
      this.with_icons = true;

      if (backgr == '__as_dark_mode__') {
         this.background = settings.DarkMode ? 'black' : 'white';
         this.textcolor = settings.DarkMode ? '#eee' : '#111';
      } else {
         this.background = backgr;
      }
      this.files_monitoring = !frameid; // by default files monitored when nobrowser option specified
      this.nobrowser = (frameid === null);

      // remember only very first instance
      if (!getHPainter())
         setHPainter(this);
   }

   /** @summary Cleanup hierarchy painter
     * @desc clear drawing and browser */
   cleanup() {
      this.clearHierarchy(true);

      super.cleanup();

      if (getHPainter() === this)
         setHPainter(null);
   }

   /** @summary Create file hierarchy
     * @private */
   fileHierarchy(file) {
      let painter = this;

      let folder = {
         _name: file.fFileName,
         _title: (file.fTitle ? file.fTitle + ', path ' : '')  + file.fFullURL,
         _kind: kindTFile,
         _file: file,
         _fullurl: file.fFullURL,
         _localfile: file.fLocalFile,
         _had_direct_read: false,
         // this is central get method, item or itemname can be used, returns promise
         _get(item, itemname) {

            if (item && item._readobj)
               return Promise.resolve(item._readobj);

            if (item) itemname = painter.itemFullName(item, this);

            const readFileObject = file => {
               if (!this._file) this._file = file;

               if (!file) return Promise.resolve(null);

               return file.readObject(itemname).then(obj => {

                  // if object was read even when item did not exist try to reconstruct new hierarchy
                  if (!item && obj) {
                     // first try to found last read directory
                     let d = painter.findItem({name: itemname, top: this, last_exists: true, check_keys: true});
                     if ((d?.last !== undefined) && (d.last !== this)) {
                        // reconstruct only subdir hierarchy
                        let dir = file.getDir(painter.itemFullName(d.last, this));
                        if (dir) {
                           d.last._name = d.last._keyname;
                           let dirname = painter.itemFullName(d.last, this);
                           keysHierarchy(d.last, dir.fKeys, file, dirname + '/');
                        }
                     } else {
                        // reconstruct full file hierarchy
                        keysHierarchy(this, file.fKeys, file, '');
                     }
                     item = painter.findItem({ name: itemname, top: this });
                  }

                  if (item) {
                     item._readobj = obj;
                     // remove cycle number for objects supporting expand
                     if ('_expand' in item) item._name = item._keyname;
                  }

                  return obj;
               });
            };

            if (this._file) return readFileObject(this._file);
            if (this._localfile) return openFile(this._localfile).then(f => readFileObject(f));
            if (this._fullurl) return openFile(this._fullurl).then(f => readFileObject(f));
            return Promise.resolve(null);
         }
      };

      keysHierarchy(folder, file.fKeys, file, '');

      return folder;
   }

   /** @summary Iterate over all items in hierarchy
     * @param {function} func - function called for every item
     * @param {object} [top] - top item to start from
     * @private */
   forEachItem(func, top) {
      function each_item(item, prnt) {
         if (!item) return;
         if (prnt) item._parent = prnt;
         func(item);
         if ('_childs' in item)
            for (let n = 0; n < item._childs.length; ++n)
               each_item(item._childs[n], item);
      }

      if (isFunc(func))
         each_item(top || this.h);
   }

   /** @summary Search item in the hierarchy
     * @param {object|string} arg - item name or object with arguments
     * @param {string} arg.name -  item to search
     * @param {boolean} [arg.force] - specified elements will be created when not exists
     * @param {boolean} [arg.last_exists] -  when specified last parent element will be returned
     * @param {boolean} [arg.check_keys] - check TFile keys with cycle suffix
     * @param {boolean} [arg.allow_index] - let use sub-item indexes instead of name
     * @param {object} [arg.top] - element to start search from
     * @private */
   findItem(arg) {

      function find_in_hierarchy(top, fullname) {

         if (!fullname || !top) return top;

         let pos = fullname.length;

         if (!top._parent && (top._kind !== 'TopFolder') && (fullname.indexOf(top._name) === 0)) {
            // it is allowed to provide item name, which includes top-parent like file.root/folder/item
            // but one could skip top-item name, if there are no other items
            if (fullname === top._name) return top;

            let len = top._name.length;
            if (fullname[len] == '/') {
               fullname = fullname.slice(len+1);
               pos = fullname.length;
            }
         }

         function process_child(child, ignore_prnt) {
            // set parent pointer when searching child
            if (!ignore_prnt) child._parent = top;

            if ((pos >= fullname.length-1) || (pos < 0)) return child;

            return find_in_hierarchy(child, fullname.slice(pos + 1));
         }

         while (pos > 0) {
            // we try to find element with slashes inside - start from full name
            let localname = (pos >= fullname.length) ? fullname : fullname.slice(0, pos);

            if (top._childs) {
               // first try to find direct matched item
               for (let i = 0; i < top._childs.length; ++i)
                  if (top._childs[i]._name == localname)
                     return process_child(top._childs[i]);

               // if first child online, check its elements
               if ((top._kind === 'TopFolder') && (top._childs[0]._online !== undefined))
                  for (let i = 0; i < top._childs[0]._childs.length; ++i)
                     if (top._childs[0]._childs[i]._name == localname)
                        return process_child(top._childs[0]._childs[i], true);

               // if allowed, try to found item with key
               if (arg.check_keys) {
                  let newest = null;
                  for (let i = 0; i < top._childs.length; ++i) {
                    if (top._childs[i]._keyname === localname) {
                       if (!newest || (newest._cycle < top._childs[i]._cycle))
                          newest = top._childs[i];
                    }
                  }
                  if (newest) return process_child(newest);
               }

               let allow_index = arg.allow_index;
               if ((localname[0] === '[') && (localname[localname.length-1] === ']') &&
                    /^\d+$/.test(localname.slice(1,localname.length-1))) {
                  allow_index = true;
                  localname = localname.slice(1,localname.length-1);
               }

               // when search for the elements it could be allowed to check index
               if (allow_index && /^\d+$/.test(localname)) {
                  let indx = parseInt(localname);
                  if (Number.isInteger(indx) && (indx >= 0) && (indx < top._childs.length))
                     return process_child(top._childs[indx]);
               }
            }

            pos = fullname.lastIndexOf('/', pos - 1);
         }

         if (arg.force) {
             // if did not found element with given name we just generate it
             if (top._childs === undefined) top._childs = [];
             pos = fullname.indexOf('/');
             let child = { _name: ((pos < 0) ? fullname : fullname.slice(0, pos)) };
             top._childs.push(child);
             return process_child(child);
         }

         return (arg.last_exists && top) ? { last: top, rest: fullname } : null;
      }

      let top = this.h, itemname = '';

      if (isStr(arg)) {
         itemname = arg; arg = {};
      } else if (isObject(arg)) {
         itemname = arg.name; if ('top' in arg) top = arg.top;
      } else
         return null;

      if (itemname === '__top_folder__') return top;

      if (isStr(itemname) && (itemname.indexOf('img:') == 0)) return null;

      return find_in_hierarchy(top, itemname);
   }

   /** @summary Produce full string name for item
     * @param {Object} node - item element
     * @param {Object} [uptoparent] - up to which parent to continue
     * @param {boolean} [compact] - if specified, top parent is not included
     * @return {string} produced name
     * @private */
   itemFullName(node, uptoparent, compact) {

      if (node && node._kind === 'TopFolder') return '__top_folder__';

      let res = '';

      while (node) {
         // online items never includes top-level folder
         if ((node._online !== undefined) && !uptoparent) return res;

         if ((node === uptoparent) || (node._kind === 'TopFolder')) break;
         if (compact && !node._parent) break; // in compact form top-parent is not included
         if (res) res = '/' + res;
         res = node._name + res;
         node = node._parent;
      }

      return res;
   }

    /** @summary Executes item marked as 'Command'
      * @desc If command requires additional arguments, they could be specified as extra arguments arg1, arg2, ...
      * @param {String} itemname - name of command item
      * @param {Object} [elem] - HTML element for command execution
      * @param [arg1] - first optional argument
      * @param [arg2] - second optional argument and so on
      * @return {Promise} with command result */
   async executeCommand(itemname, elem) {

      let hitem = this.findItem(itemname),
          url = this.getOnlineItemUrl(hitem) + '/cmd.json',
          d3node = select(elem),
          cmdargs = [];

      if ('_numargs' in hitem)
         for (let n = 0; n < hitem._numargs; ++n)
            cmdargs.push((n+2 < arguments.length) ? arguments[n+2] : '');

      let promise = (cmdargs.length == 0) || !elem ? Promise.resolve(cmdargs) :
                     createMenu$1().then(menu => menu.showCommandArgsDialog(hitem._name, cmdargs));

      return promise.then(args => {
         if (args === null) return false;

         let urlargs = '';
         for (let k = 0; k < args.length; ++k)
            urlargs += `${k>0?'&':'?'}arg${k+1}=${args[k]}`;

        if (!d3node.empty()) {
            d3node.style('background','yellow');
            if (hitem._title)
               d3node.attr('title', 'Executing ' + hitem._title);
         }

         return httpRequest(url + urlargs, 'text').then(res => {
            if (d3node.empty()) return res;
            let col = (res && (res != 'false')) ? 'green' : 'red';
            d3node.style('background', col);
            if (hitem._title)
               d3node.attr('title', hitem._title + ' lastres=' + res);
            setTimeout(() => {
               d3node.style('background', null);
               if (hitem._icon && d3node.classed('jsroot_fastcmd_btn'))
                  d3node.style('background-image', `url('${hitem._icon}')`);
            }, 2000);
            if ((col == 'green') && ('_hreload' in hitem))
               this.reload();
            if ((col == 'green') && ('_update_item' in hitem))
               this.updateItems(hitem._update_item.split(';'));
            return res;
         });
      });
   }

   /** @summary Get object item with specified name
     * @desc depending from provided option, same item can generate different object types
     * @param {Object} arg - item name or config object
     * @param {string} arg.name - item name
     * @param {Object} arg.item - or item itself
     * @param {string} options - supposed draw options
     * @return {Promise} with object like { item, obj, itemname }
     * @private */
   async getObject(arg, options) {

      let itemname, item, result = { item: null, obj: null };

      if (arg === null)
         return result;

      if (isStr(arg)) {
         itemname = arg;
      } else if (isObject(arg)) {
         if ((arg._parent !== undefined) && (arg._name !== undefined) && (arg._kind !== undefined)) item = arg; else
         if (arg.name !== undefined) itemname = arg.name; else
         if (arg.arg !== undefined) itemname = arg.arg; else
         if (arg.item !== undefined) item = arg.item;
      }

      if (isStr(itemname) && (itemname.indexOf('img:') == 0)) {
         // artificial class, can be created by users
         result.obj = { _typename: 'TJSImage', fName: itemname.slice(4) };
         return result;
      }

      if (item) itemname = this.itemFullName(item);
           else item = this.findItem({ name: itemname, allow_index: true, check_keys: true });

      // if item not found, try to find nearest parent which could allow us to get inside

      let d = item ? null : this.findItem({ name: itemname, last_exists: true, check_keys: true, allow_index: true });

      // if item not found, try to expand hierarchy central function
      // implements not process get in central method of hierarchy item (if exists)
      // if last_parent found, try to expand it
      if ((d !== null) && ('last' in d) && (d.last !== null)) {
         let parentname = this.itemFullName(d.last);

         // this is indication that expand does not give us better path to searched item
         if (isObject(arg) && ('rest' in arg))
            if ((arg.rest == d.rest) || (arg.rest.length <= d.rest.length))
               return result;

         return this.expandItem(parentname, undefined, options != 'hierarchy_expand_verbose').then(res => {
            if (!res) return result;
            let newparentname = this.itemFullName(d.last);
            if (newparentname) newparentname += '/';
            return this.getObject( { name: newparentname + d.rest, rest: d.rest }, options);
         });
      }

      result.item = item;

      if ((item !== null) && isObject(item._obj)) {
         result.obj = item._obj;
         return result;
      }

      // normally search _get method in the parent items
      let curr = item;
      while (curr) {
         if (isFunc(curr._get))
            return curr._get(item, null, options).then(obj => { result.obj = obj; return result; });
         curr = ('_parent' in curr) ? curr._parent : null;
      }

      return result;
   }

   /** @summary returns true if item is last in parent childs list
     * @private */
   isLastSibling(hitem) {
      if (!hitem || !hitem._parent || !hitem._parent._childs) return false;
      let chlds = hitem._parent._childs, indx = chlds.indexOf(hitem);
      if (indx < 0) return false;
      while (++indx < chlds.length)
         if (!('_hidden' in chlds[indx])) return false;
      return true;
   }

   /** @summary Create item html code
     * @private */
   addItemHtml(hitem, d3prnt, arg) {
      if (!hitem || ('_hidden' in hitem)) return true;

      let isroot = (hitem === this.h),
          has_childs = ('_childs' in hitem),
          handle = getDrawHandle(hitem._kind),
          img1 = '', img2 = '', can_click = false, break_list = false,
          d3cont, itemname = this.itemFullName(hitem);

      if (handle) {
         if ('icon' in handle) img1 = handle.icon;
         if ('icon2' in handle) img2 = handle.icon2;
         if (!img1 && isFunc(handle.icon_get))
            img1 = handle.icon_get(hitem, this);
         if (canDrawHandle(handle) || ('execute' in handle) || ('aslink' in handle) ||
             (canExpandHandle(handle) && (hitem._more !== false))) can_click = true;
      }

      if ('_icon' in hitem) img1 = hitem._icon;
      if ('_icon2' in hitem) img2 = hitem._icon2;
      if (!img1 && ('_online' in hitem))
         hitem._icon = img1 = 'img_globe';
      if (!img1 && isroot)
         hitem._icon = img1 = 'img_base';

      if (hitem._more || hitem._expand || hitem._player || hitem._can_draw)
         can_click = true;

      let can_menu = can_click;
      if (!can_menu && isStr(hitem._kind) && (hitem._kind.indexOf('ROOT.') == 0))
         can_menu = can_click = true;

      if (!img2) img2 = img1;
      if (!img1) img1 = (has_childs || hitem._more) ? 'img_folder' : 'img_page';
      if (!img2) img2 = (has_childs || hitem._more) ? 'img_folderopen' : 'img_page';

      if (arg === 'update') {
         d3prnt.selectAll('*').remove();
         d3cont = d3prnt;
      } else {
         d3cont = d3prnt.append('div');
         if (arg && (arg >= (hitem._parent._show_limit || settings.HierarchyLimit))) break_list = true;
      }

      hitem._d3cont = d3cont.node(); // set for direct referencing
      d3cont.attr('item', itemname);

      // line with all html elements for this item (excluding childs)
      let d3line = d3cont.append('div').attr('class','h_line');

      // build indent
      let prnt = isroot ? null : hitem._parent;
      while (prnt && (prnt !== this.h)) {
         d3line.insert('div',':first-child')
               .attr('class', this.isLastSibling(prnt) ? 'img_empty' : 'img_line');
         prnt = prnt._parent;
      }

      let icon_class = '', plusminus = false;

      if (isroot) ; else if (has_childs && !break_list) {
         icon_class = hitem._isopen ? 'img_minus' : 'img_plus';
         plusminus = true;
      } else /*if (hitem._more) {
         icon_class = 'img_plus'; // should be special plus ???
         plusminus = true;
      } else */ {
         icon_class = 'img_join';
      }

      let h = this;

      if (icon_class) {
         if (break_list || this.isLastSibling(hitem)) icon_class += 'bottom';
         let d3icon = d3line.append('div').attr('class', icon_class);
         if (plusminus) d3icon.style('cursor','pointer')
                              .on('click', function(evnt) { h.tree_click(evnt, this, 'plusminus'); });
      }

      // make node icons

      if (this.with_icons && !break_list) {
         let icon_name = hitem._isopen ? img2 : img1, d3img;

         if (icon_name.indexOf('img_') == 0)
            d3img = d3line.append('div')
                          .attr('class', icon_name)
                          .attr('title', hitem._kind);
         else
            d3img = d3line.append('img')
                          .attr('src', icon_name)
                          .attr('alt', '')
                          .attr('title', hitem._kind)
                          .style('vertical-align','top').style('width','18px').style('height','18px');

         if (('_icon_click' in hitem) || (handle && ('icon_click' in handle)))
            d3img.on('click', function(evnt) { h.tree_click(evnt, this, 'icon'); });
      }

      let d3a = d3line.append('a');
      if (can_click || has_childs || break_list)
         d3a.attr('class', 'h_item')
            .on('click', function(evnt) { h.tree_click(evnt, this); });

      if (break_list) {
         hitem._break_point = true; // indicate that list was broken here
         d3a.attr('title', 'there are ' + (hitem._parent._childs.length-arg) + ' more items')
            .text('...more...');
         return false;
      }

      if ('disp_kind' in h) {
         if (settings.DragAndDrop && can_click)
           this.enableDrag(d3a, itemname);

         if (settings.ContextMenu && can_menu)
            d3a.on('contextmenu', function(evnt) { h.tree_contextmenu(evnt, this); });

         d3a.on('mouseover', function() { h.tree_mouseover(true, this); })
            .on('mouseleave', function() { h.tree_mouseover(false, this); });
      } else if (hitem._direct_context && settings.ContextMenu)
         d3a.on('contextmenu', function(evnt) { h.direct_contextmenu(evnt, this); });

      let element_name = hitem._name, element_title = '';

      if ('_realname' in hitem)
         element_name = hitem._realname;

      if ('_title' in hitem)
         element_title = hitem._title;

      if ('_fullname' in hitem)
         element_title += '  fullname: ' + hitem._fullname;

      if (!element_title)
         element_title = element_name;

      d3a.attr('title', element_title)
         .text(element_name + ('_value' in hitem ? ':' : ''))
         .style('background', hitem._background ? hitem._background : null);

      if ('_value' in hitem) {
         let d3p = d3line.append('p');
         if ('_vclass' in hitem) d3p.attr('class', hitem._vclass);
         if (!hitem._isopen) d3p.html(hitem._value);
      }

      if (has_childs && (isroot || hitem._isopen)) {
         let d3chlds = d3cont.append('div').attr('class', 'h_childs');
         if (this.show_overflow) d3chlds.style('overflow', 'initial');
         for (let i = 0; i < hitem._childs.length; ++i) {
            let chld = hitem._childs[i];
            chld._parent = hitem;
            if (!this.addItemHtml(chld, d3chlds, i)) break; // if too many items, skip rest
         }
      }

      return true;
   }

   /** @summary Toggle open state of the item
     * @desc Used with 'open all' / 'close all' buttons in normal GUI
     * @param {boolean} isopen - if items should be expand or closed
     * @return {boolean} true when any item was changed */
   toggleOpenState(isopen, h) {
      let hitem = h || this.h;

      if (hitem._childs === undefined) {
         if (!isopen) return false;

         if (this.with_icons) {
            // in normal hierarchy check precisely if item can be expand
            if (!hitem._more && !hitem._expand && !this.canExpandItem(hitem)) return false;
         }

         this.expandItem(this.itemFullName(hitem));
         if (hitem._childs !== undefined) hitem._isopen = true;
         return hitem._isopen;
      }

      if ((hitem !== this.h) && isopen && !hitem._isopen) {
         // when there are childs and they are not see, simply show them
         hitem._isopen = true;
         return true;
      }

      let change_child = false;
      for (let i = 0; i < hitem._childs.length; ++i)
         if (this.toggleOpenState(isopen, hitem._childs[i]))
            change_child = true;

      if ((hitem !== this.h) && !isopen && hitem._isopen && !change_child) {
         // if none of the childs can be closed, than just close that item
         delete hitem._isopen;
         return true;
       }

      if (!h) this.refreshHtml();
      return false;
   }

   /** @summary Refresh HTML code of hierarchy painter
     * @return {Promise} when done */
   async refreshHtml() {

      let d3elem = this.selectDom();
      if (d3elem.empty())
         return this;

      d3elem.html('')   // clear html - most simple way
            .style('overflow',this.show_overflow ? 'auto' : 'hidden')
            .style('display','flex')
            .style('flex-direction','column');

      injectHStyle(d3elem.node());

      let h = this, factcmds = [], status_item = null;
      this.forEachItem(item => {
         delete item._d3cont; // remove html container
         if (('_fastcmd' in item) && (item._kind == 'Command')) factcmds.push(item);
         if (('_status' in item) && !status_item) status_item = item;
      });

      if (!this.h || d3elem.empty())
         return this;

      if (factcmds.length) {
         let fastbtns = d3elem.append('div').attr('style', 'display: inline; vertical-align: middle; white-space: nowrap;');
         for (let n = 0; n < factcmds.length; ++n) {
            let btn = fastbtns.append('button')
                       .text('')
                       .attr('class','jsroot_fastcmd_btn')
                       .attr('item', this.itemFullName(factcmds[n]))
                       .attr('title', factcmds[n]._title)
                       .on('click', function() { h.executeCommand(select(this).attr('item'), this); });

            if (factcmds[n]._icon)
               btn.style('background-image', `url('${factcmds[n]._icon}')`);
         }
      }

      let d3btns = d3elem.append('p').attr('class', 'jsroot').style('margin-bottom','3px').style('margin-top',0);
      d3btns.append('a').attr('class', 'h_button').text('open all')
            .attr('title','open all items in the browser').on('click', () => this.toggleOpenState(true));
      d3btns.append('text').text(' | ');
      d3btns.append('a').attr('class', 'h_button').text('close all')
            .attr('title','close all items in the browser').on('click', () => this.toggleOpenState(false));

      if (isFunc(this.removeInspector)) {
         d3btns.append('text').text(' | ');
         d3btns.append('a').attr('class', 'h_button').text('remove')
               .attr('title','remove inspector').on('click', () => this.removeInspector());
      }

      if ('_online' in this.h) {
         d3btns.append('text').text(' | ');
         d3btns.append('a').attr('class', 'h_button').text('reload')
               .attr('title','reload object list from the server').on('click', () => this.reload());
      }

      if ('disp_kind' in this) {
         d3btns.append('text').text(' | ');
         d3btns.append('a').attr('class', 'h_button').text('clear')
               .attr('title','clear all drawn objects').on('click', () => this.clearHierarchy(false));
      }

      let maindiv =
         d3elem.append('div')
               .attr('class', 'jsroot')
               .style('font-size', this.with_icons ? '12px' : '15px')
               .style('flex','1');

      if (!this.show_overflow)
         maindiv.style('overflow','auto');

      if (this.background) // case of object inspector and streamer infos display
         maindiv.style('background-color', this.background)
                .style('margin', '2px').style('padding', '2px');
      if (this.textcolor)
         maindiv.style('color', this.textcolor);

      this.addItemHtml(this.h, maindiv.append('div').attr('class','h_tree'));

      this.setTopPainter(); //assign hpainter as top painter

      if (status_item && !this.status_disabled && !decodeUrl().has('nostatus')) {
         let func = findFunction(status_item._status);
         if (isFunc(func))
            return this.createStatusLine().then(sdiv => {
               if (sdiv) func(sdiv, this.itemFullName(status_item));
            });
      }

      return this;
   }

   /** @summary Update item node
     * @private */
   updateTreeNode(hitem, d3cont) {
      if ((d3cont === undefined) || d3cont.empty())  {
         d3cont = select(hitem._d3cont ? hitem._d3cont : null);
         let name = this.itemFullName(hitem);
         if (d3cont.empty())
            d3cont = this.selectDom().select(`[item='${name}']`);
         if (d3cont.empty() && ('_cycle' in hitem))
            d3cont = this.selectDom().select(`[item='${name};${hitem._cycle}']`);
         if (d3cont.empty()) return;
      }

      this.addItemHtml(hitem, d3cont, 'update');

      this.brlayout?.adjustBrowserSize(true);
   }

   /** @summary Update item background
     * @private */
   updateBackground(hitem, scroll_into_view) {
      if (!hitem || !hitem._d3cont) return;

      let d3cont = select(hitem._d3cont);

      if (d3cont.empty()) return;

      let d3a = d3cont.select('.h_item');

      d3a.style('background', hitem._background ? hitem._background : null);

      if (scroll_into_view && hitem._background)
         d3a.node().scrollIntoView(false);
   }

   /** @summary Focus on hierarchy item
     * @param {Object|string} hitem - item to open or its name
     * @desc all parents to the otem will be opened first
     * @return {Promise} when done
     * @private */
   async focusOnItem(hitem) {
      if (isStr(hitem))
         hitem = this.findItem(hitem);

      let name = hitem ? this.itemFullName(hitem) : '';
      if (!name) return false;

      let itm = hitem, need_refresh = false;

      while (itm) {
         if ((itm._childs !== undefined) && !itm._isopen) {
            itm._isopen = true;
            need_refresh = true;
         }
         itm = itm._parent;
      }

      let promise = need_refresh ? this.refreshHtml() : Promise.resolve(true);

      return promise.then(() => {
         let d3cont = this.selectDom().select(`[item='${name}']`);
         if (d3cont.empty()) return false;
         d3cont.node().scrollIntoView();
         return true;
      });
   }

   /** @summary Handler for click event of item in the hierarchy
     * @private */
   tree_click(evnt, node, place) {
      if (!node) return;

      let d3cont = select(node.parentNode.parentNode),
          itemname = d3cont.attr('item'),
          hitem = itemname ? this.findItem(itemname) : null;

      if (!hitem) return;

      if (hitem._break_point) {
         // special case of more item

         delete hitem._break_point;

         // update item itself
         this.addItemHtml(hitem, d3cont, 'update');

         let prnt = hitem._parent, indx = prnt._childs.indexOf(hitem),
             d3chlds = select(d3cont.node().parentNode);

         if (indx < 0) return console.error('internal error');

         prnt._show_limit = (prnt._show_limit || settings.HierarchyLimit) * 2;

         for (let n = indx+1; n < prnt._childs.length; ++n) {
            let chld = prnt._childs[n];
            chld._parent = prnt;
            if (!this.addItemHtml(chld, d3chlds, n)) break; // if too many items, skip rest
         }

         return;
      }

      let prnt = hitem, dflt = undefined;
      while (prnt) {
         if ((dflt = prnt._click_action) !== undefined) break;
         prnt = prnt._parent;
      }

      if (!place) place = 'item';
      let selector = (hitem._kind == 'ROOT.TKey' && hitem._more) ? 'noinspect' : '',
          sett = getDrawSettings(hitem._kind, selector), handle = sett.handle;

      if (place == 'icon') {
         let func = null;
         if (isFunc(hitem._icon_click))
            func = hitem._icon_click;
         else if (isFunc(handle?.icon_click))
            func = handle.icon_click;
         if (func && func(hitem,this))
            this.updateTreeNode(hitem, d3cont);
         return;
      }

      // special feature - all items with '_expand' function are not drawn by click
      if ((place == 'item') && ('_expand' in hitem) && !evnt.ctrlKey && !evnt.shiftKey) place = 'plusminus';

      // special case - one should expand item
      if (((place == 'plusminus') && !('_childs' in hitem) && hitem._more) ||
          ((place == 'item') && (dflt === 'expand'))) {
         return this.expandItem(itemname, d3cont);
      }

      if (place == 'item') {

         if (hitem._player)
            return this.player(itemname);

         if (handle?.aslink)
            return window.open(itemname + '/');

         if (handle?.execute)
            return this.executeCommand(itemname, node.parentNode);

         if (handle?.ignore_online && this.isOnlineItem(hitem)) return;

         let can_draw = hitem._can_draw,
             can_expand = hitem._more,
             dflt_expand = (this.default_by_click === 'expand'),
             drawopt = '';

         if (evnt.shiftKey) {
            drawopt = handle?.shift || 'inspect';
            if ((drawopt == 'inspect') && handle?.noinspect) drawopt = '';
         }
         if (evnt.ctrlKey && handle?.ctrl)
            drawopt = handle.ctrl;

         if (!drawopt && !handle?.always_draw) {
            for (let pitem = hitem._parent; !!pitem; pitem = pitem._parent) {
               if (pitem._painter) { can_draw = false; if (can_expand === undefined) can_expand = false; break; }
            }
         }

         if (hitem._childs) can_expand = false;

         if (can_draw === undefined) can_draw = sett.draw;
         if (can_expand === undefined) can_expand = sett.expand || sett.get_expand;

         if (can_draw && can_expand && !drawopt) {
            // if default action specified as expand, disable drawing
            // if already displayed, try to expand
            if (dflt_expand || (handle?.dflt === 'expand') || this.isItemDisplayed(itemname)) can_draw = false;
         }

         if (can_draw && !drawopt)
            drawopt = '__default_draw_option__';

         if (can_draw)
            return this.display(itemname, drawopt, true);

         if (can_expand || dflt_expand)
            return this.expandItem(itemname, d3cont);

         // cannot draw, but can inspect ROOT objects
         if (isStr(hitem._kind) && (hitem._kind.indexOf('ROOT.') === 0) && sett.inspect && (can_draw !== false))
            return this.display(itemname, 'inspect', true);

         if (!hitem._childs || (hitem === this.h)) return;
      }

      if (hitem._isopen)
         delete hitem._isopen;
      else
         hitem._isopen = true;

      this.updateTreeNode(hitem, d3cont);
   }

   /** @summary Handler for mouse-over event
     * @private */
   tree_mouseover(on, elem) {
      let itemname = select(elem.parentNode.parentNode).attr('item'),
           hitem = this.findItem(itemname);

      if (!hitem) return;

      let painter, prnt = hitem;
      while (prnt && !painter) {
         painter = prnt._painter;
         prnt = prnt._parent;
      }

      if (isFunc(painter?.mouseOverHierarchy))
         painter.mouseOverHierarchy(on, itemname, hitem);
   }

   /** @summary alternative context menu, used in the object inspector
     * @private */
   direct_contextmenu(evnt, elem) {
      evnt.preventDefault();
      let itemname = select(elem.parentNode.parentNode).attr('item'),
           hitem = this.findItem(itemname);
      if (!hitem) return;

      if (isFunc(this.fill_context))
         createMenu$1(evnt, this).then(menu => {
            this.fill_context(menu, hitem);
            if (menu.size() > 0) {
               menu.tree_node = elem.parentNode;
               menu.show();
            }
         });
   }

   /** @summary Fills settings menu items
     * @private */
   fillSettingsMenu(menu, alone) {
      menu.addSettingsMenu(true, alone, arg => {
         if (arg == 'refresh') {
            this.forEachRootFile(folder => keysHierarchy(folder, folder._file.fKeys, folder._file, ''));
            this.refreshHtml();
         } else if (arg == 'dark') {
            this.brlayout?.createStyle();
            if (this.disp)
               this.disp.forEachFrame(frame => {
                  let canvp = getElementCanvPainter(frame);
                  if (isFunc(canvp?.changeDarkMode))
                     canvp.changeDarkMode();
               });
         }
      });
   }

   /** @summary Toggle dark mode
     * @private */
   toggleDarkMode() {
      settings.DarkMode = !settings.DarkMode;
   }

   /** @summary Handle context menu in the hieararchy
     * @private */
   tree_contextmenu(evnt, elem) {
      evnt.preventDefault();
      let itemname = select(elem.parentNode.parentNode).attr('item'),
           hitem = this.findItem(itemname);
      if (!hitem) return;

      let onlineprop = this.getOnlineProp(itemname),
          fileprop = this.getFileProp(itemname);

      function qualifyURL(url) {
         const escapeHTML = s => s.split('&').join('&amp;').split('<').join('&lt;').split('"').join('&quot;'),
               el = document.createElement('div');
         el.innerHTML = `<a href="${escapeHTML(url)}">x</a>`;
         return el.firstChild.href;
      }

      createMenu$1(evnt, this).then(menu => {

         if ((!itemname || !hitem._parent) && !('_jsonfile' in hitem)) {
            let files = [], addr = '', cnt = 0,
                separ = () => (cnt++ > 0) ? '&' : '?';

            this.forEachRootFile(item => files.push(item._file.fFullURL));

            if (!this.getTopOnlineItem())
               addr = exports.source_dir + 'index.htm';

            if (this.isMonitoring())
               addr += separ() + 'monitoring=' + this.getMonitoringInterval();

            if (files.length == 1)
               addr += separ() + 'file=' + files[0];
            else if (files.length > 1)
               addr += separ() + 'files=' + JSON.stringify(files);

            if (this.disp_kind)
               addr += separ() + 'layout=' + this.disp_kind.replace(/ /g, '');

            let items = [], opts = [];

            if (this.disp)
               this.disp.forEachFrame(frame => {
                  let dummy = new ObjectPainter(frame),
                      top = dummy.getTopPainter(),
                      item = top ? top.getItemName() : null, opt;

                  if (item) {
                     opt  = top.getDrawOpt() || top.getItemDrawOpt();
                  } else {
                     top = null;
                     dummy.forEachPainter(p => {
                        let _item = p.getItemName();
                        if (!_item) return;
                        let _opt = p.getDrawOpt() || p.getItemDrawOpt() || '';
                        if (!top) {
                           top = p;
                           item = _item;
                           opt = _opt;
                        } else if (top.getPadPainter() === p.getPadPainter()) {
                           if (_opt.indexOf('same ') == 0) _opt = _opt.slice(5);
                           item += '+' + _item;
                           opt += '+' + _opt;
                        }
                     });
                  }

                  if (item) {
                     items.push(item);
                     opts.push(opt || '');
                  }
               });

            if (items.length == 1) {
               addr += separ() + 'item=' + items[0] + separ() + 'opt=' + opts[0];
            } else if (items.length > 1) {
               addr += separ() + 'items=' + JSON.stringify(items) + separ() + 'opts=' + JSON.stringify(opts);
            }

            menu.add('Direct link', () => window.open(addr));
            menu.add('Only items', () => window.open(addr + '&nobrowser'));
            this.fillSettingsMenu(menu);
         } else if (onlineprop) {
            this.fillOnlineMenu(menu, onlineprop, itemname);
         } else {
            let sett = getDrawSettings(hitem._kind, 'nosame');

            // allow to draw item even if draw function is not defined
            if (hitem._can_draw) {
               if (!sett.opts) sett.opts = [''];
               if (sett.opts.indexOf('') < 0)
                  sett.opts.unshift('');
            }

            if (sett.opts)
               menu.addDrawMenu('Draw', sett.opts, arg => this.display(itemname, arg));

            if (fileprop && sett.opts && !fileprop.localfile) {
               let filepath = qualifyURL(fileprop.fileurl);
               if (filepath.indexOf(exports.source_dir) == 0)
                  filepath = filepath.slice(exports.source_dir.length);
               filepath = fileprop.kind + '=' + filepath;
               if (fileprop.itemname) {
                  let name = fileprop.itemname;
                  if (name.search(/\+| |\,/) >= 0) name = `'${name}'`;
                  filepath += '&item=' + name;
               }

               menu.addDrawMenu('Draw in new tab', sett.opts,
                                arg => window.open(`${exports.source_dir}index.htm?nobrowser&${filepath}&opt=${arg}`));
            }

            if ((sett.expand || sett.get_expand) && !('_childs' in hitem) && (hitem._more || !('_more' in hitem)))
               menu.add('Expand', () => this.expandItem(itemname));

            if (hitem._kind === 'ROOT.' + clTStyle)
               menu.add('Apply', () => this.applyStyle(itemname));
         }

         if (isFunc(hitem._menu))
            hitem._menu(menu, hitem, this);

         if (menu.size() > 0) {
            menu.tree_node = elem.parentNode;
            if (menu.separ) menu.add('separator'); // add separator at the end
            menu.add('Close');
            menu.show();
         }

      }); // end menu creation

      return false;
   }

   /** @summary Starts player for specified item
     * @desc Same as 'Player' context menu
     * @param {string} itemname - item name for which player should be started
     * @param {string} [option] - extra options for the player
     * @return {Promise} when ready*/
   async player(itemname, option) {
      let item = this.findItem(itemname);

      if (!item || !item._player || !isStr(item._player))
         return null;

      let player_func = null;

      if (item._module) {
         let hh = await this.importModule(item._module);
         player_func = hh ? hh[item._player] : null;
      } else {
         if (item._prereq || (item._player.indexOf('JSROOT.') >= 0))
            await this.loadScripts('', item._prereq);
         player_func = findFunction(item._player);
      }

      if (!isFunc(player_func))
         return null;

      await this.createDisplay();
      return player_func(this, itemname, option);
   }

   /** @summary Checks if item can be displayed with given draw option
     * @private */
   canDisplay(item, drawopt) {
      if (!item) return false;
      if (item._player) return true;
      if (item._can_draw !== undefined) return item._can_draw;
      if (drawopt == 'inspect') return true;
      const handle = getDrawHandle(item._kind, drawopt);
      return canDrawHandle(handle);
   }

   /** @summary Returns true if given item displayed
     * @param {string} itemname - item name */
   isItemDisplayed(itemname) {
      let mdi = this.getDisplay();
      return mdi ? mdi.findFrame(itemname) !== null : false;
   }

   /** @summary Display specified item
     * @param {string} itemname - item name
     * @param {string} [drawopt] - draw option for the item
     * @param {boolean} [interactive] - if display was called in interactive mode, will activate selected drawing
     * @return {Promise} with created painter object */
   async display(itemname, drawopt, interactive) {
      let painter = null,
          updating = false,
          item = null,
          display_itemname = itemname,
          frame_name = itemname,
          marker = '::_display_on_frame_::',
          p = drawopt ? drawopt.indexOf(marker) : -1;

      if (p >= 0) {
         frame_name = drawopt.slice(p + marker.length);
         drawopt = drawopt.slice(0, p);
      }

      const complete = (respainter, err) => {
         if (err) console.log('When display ', itemname, 'got', err);

         if (updating && item) delete item._doing_update;
         if (!updating) showProgress();
         if (isFunc(respainter?.setItemName)) {
            respainter.setItemName(display_itemname, updating ? null : drawopt, this); // mark painter as created from hierarchy
            if (item && !item._painter) item._painter = respainter;
         }

         return respainter || painter;
      };

      return this.createDisplay().then(mdi => {

         if (!mdi) return complete();

         item = this.findItem(display_itemname);

         if (item && ('_player' in item))
            return this.player(display_itemname, drawopt).then(res => complete(res));

         updating = isStr(drawopt) && (drawopt.indexOf('update:') == 0);

         if (updating) {
            drawopt = drawopt.slice(7);
            if (!item || item._doing_update) return complete();
            item._doing_update = true;
         }

         if (item && !this.canDisplay(item, drawopt)) return complete();

         let divid = '', use_dflt_opt = false;
         if (isStr(drawopt) && (drawopt.indexOf('divid:') >= 0)) {
            let pos = drawopt.indexOf('divid:');
            divid = drawopt.slice(pos+6);
            drawopt = drawopt.slice(0, pos);
         }

         if (drawopt == '__default_draw_option__') {
            use_dflt_opt = true;
            drawopt = '';
         }

         if (!updating) showProgress('Loading ' + display_itemname);

         return this.getObject(display_itemname, drawopt).then(result => {

            if (!updating) showProgress();

            if (!item) item = result.item;
            let obj = result.obj;

            if (!obj) return complete();

            if (!updating) showProgress('Drawing ' + display_itemname);

            let handle = obj._typename ? getDrawHandle('ROOT.' + obj._typename) : null;

            if (handle?.draw_field && obj[handle.draw_field]) {
               obj = obj[handle.draw_field];
               if (!drawopt) drawopt = handle.draw_field_opt || '';
               handle = obj._typename ? getDrawHandle('ROOT.' + obj._typename) : null;
            }

            if (use_dflt_opt && !drawopt && handle?.dflt && (handle.dflt != 'expand'))
               drawopt = handle.dflt;

            if (divid) {
               let func = updating ? redraw : draw;
               return func(divid, obj, drawopt).then(p => complete(p)).catch(err => complete(null, err));
            }

            let did_actiavte = false;

            mdi.forEachPainter((p, frame) => {
               if (p.getItemName() != display_itemname) return;

               let itemopt = p.getItemDrawOpt();
               if (use_dflt_opt && interactive) drawopt = itemopt;

               // verify that object was drawn with same option as specified now (if any)
               if (!updating && drawopt && (itemopt != drawopt)) return;

               if (interactive && !did_actiavte) {
                  did_actiavte = true;
                  mdi.activateFrame(frame);

               }

               if (isFunc(p.redrawObject) && p.redrawObject(obj, drawopt)) painter = p;
            });

            if (painter) return complete();

            if (updating) {
               console.warn(`something went wrong - did not found painter when doing update of ${display_itemname}`);
               return complete();
            }

            let frame = mdi.findFrame(frame_name, true);
            cleanup(frame);
            mdi.activateFrame(frame);

            return draw(frame, obj, drawopt)
                         .then(p => complete(p))
                         .catch(err => complete(null, err));

         });
      });
   }

   /** @summary Enable drag of the element
     * @private  */
   enableDrag(d3elem /*, itemname*/) {
      d3elem.attr('draggable', 'true').on('dragstart', function(ev) {
         let itemname = this.parentNode.parentNode.getAttribute('item');
         ev.dataTransfer.setData('item', itemname);
      });
   }

   /** @summary Enable drop on the frame
     * @private  */
   enableDrop(frame) {
      let h = this;
      select(frame).on('dragover', function(ev) {
         let itemname = ev.dataTransfer.getData('item'),
              ditem = h.findItem(itemname);
         if (isStr(ditem?._kind) && (ditem._kind.indexOf('ROOT.') == 0))
            ev.preventDefault(); // let accept drop, otherwise it will be refuced
      }).on('dragenter', function() {
         select(this).classed('jsroot_drag_area', true);
      }).on('dragleave', function() {
         select(this).classed('jsroot_drag_area', false);
      }).on('drop', function(ev) {
         select(this).classed('jsroot_drag_area', false);
         let itemname = ev.dataTransfer.getData('item');
         if (itemname) h.dropItem(itemname, this.getAttribute('id'));
      });
   }

   /** @summary Remove all drop handlers on the frame
     * @private  */
   clearDrop(frame) {
      select(frame).on('dragover', null).on('dragenter', null).on('dragleave', null).on('drop', null);
   }

  /** @summary Drop item on specified element for drawing
    * @return {Promise} when completed
    * @private */
   async dropItem(itemname, divid, opt) {

      if (!opt || !isStr(opt)) opt = '';

      let drop_complete = (drop_painter, is_main_painter) => {
         if (!is_main_painter && isFunc(drop_painter?.setItemName))
            drop_painter.setItemName(itemname, null, this);
         return drop_painter;
      };

      if (itemname == '$legend')
         return produceLegend(divid, opt).then(legend_painter => drop_complete(legend_painter));

      return this.getObject(itemname).then(res => {

         if (!res.obj) return null;

         let main_painter = getElementMainPainter(divid);

         if (isFunc(main_painter?.performDrop))
            return main_painter.performDrop(res.obj, itemname, res.item, opt).then(p => drop_complete(p, main_painter === p));

         if (main_painter?.accept_drops)
            return draw(divid, res.obj, 'same ' + opt).then(p => drop_complete(p, main_painter === p));

         this.cleanupFrame(divid);
         return draw(divid, res.obj, opt).then(p => drop_complete(p));
      });
   }

   /** @summary Update specified items
     * @desc Method can be used to fetch new objects and update all existing drawings
     * @param {string|array|boolean} arg - either item name or array of items names to update or true if only automatic items will be updated
     * @return {Promise} when ready */
   async updateItems(arg) {

      if (!this.disp)
         return false;

      let allitems = [], options = [], only_auto_items = false, want_update_all = false;

      if (isStr(arg))
         arg = [ arg ];
      else if (!isObject(arg)) {
         if (arg === undefined)
           arg = !this.isMonitoring();
         want_update_all = true;
         only_auto_items = !!arg;
      }

      // first collect items
      this.disp.forEachPainter(p => {
         let itemname = p.getItemName();

         if (!isStr(itemname) || (allitems.indexOf(itemname) >= 0)) return;

         if (want_update_all) {
            let item = this.findItem(itemname);
            if (!item || ('_not_monitor' in item) || ('_player' in item)) return;
            if (!('_always_monitor' in item)) {
               let forced = false, handle = getDrawHandle(item._kind);
               if (handle?.monitor !== undefined) {
                  if ((handle.monitor === false) || (handle.monitor == 'never')) return;
                  if (handle.monitor == 'always') forced = true;
               }
               if (!forced && only_auto_items) return;
            }
         } else {
            if (arg.indexOf(itemname) < 0) return;
         }

         allitems.push(itemname);
         options.push('update:' + p.getItemDrawOpt());
      }, true); // only visible panels are considered

      // force all files to read again (normally in non-browser mode)
      if (this.files_monitoring && !only_auto_items && want_update_all)
         this.forEachRootFile(item => {
            this.forEachItem(fitem => { delete fitem._readobj; }, item);
            delete item._file;
         });

      return this.displayItems(allitems, options);
   }

   /** @summary Display all provided elements
     * @return {Promise} when drawing finished
     * @private */
   async displayItems(items, options) {

      if (!items || (items.length == 0))
         return true;

      let h = this;

      if (!options) options = [];
      while (options.length < items.length)
         options.push('__default_draw_option__');

      if ((options.length == 1) && (options[0] == 'iotest')) {
         this.clearHierarchy();
         select('#' + this.disp_frameid).html('<h2>Start I/O test</h2>');

         let tm0 = new Date();
         return this.getObject(items[0]).then(() => {
            let tm1 = new Date();
            select('#' + this.disp_frameid).append('h2').html('Item ' + items[0] + ' reading time = ' + (tm1.getTime() - tm0.getTime()) + 'ms');
            return true;
         });
      }

      let dropitems = new Array(items.length),
          dropopts = new Array(items.length),
          images = new Array(items.length);

      // First of all check that items are exists, look for cycle extension and plus sign
      for (let i = 0; i < items.length; ++i) {
         dropitems[i] = dropopts[i] = null;

         let item = items[i], can_split = true;

         if (item && item.indexOf('img:') == 0) { images[i] = true; continue; }

         if (item && (item.length > 1) && (item[0] == "'") && (item[item.length - 1] == "'")) {
            items[i] = item.slice(1, item.length-1);
            can_split = false;
         }

         let elem = h.findItem({ name: items[i], check_keys: true });
         if (elem) { items[i] = h.itemFullName(elem); continue; }

         if (can_split && (items[i][0] == '[') && (items[i][items[i].length - 1] == ']')) {
            dropitems[i] = parseAsArray(items[i]);
            items[i] = dropitems[i].shift();
         } else if (can_split && (items[i].indexOf('+') > 0)) {
            dropitems[i] = items[i].split('+');
            items[i] = dropitems[i].shift();
         }

         if (dropitems[i] && dropitems[i].length > 0) {
            // allow to specify _same_ item in different file
            for (let j = 0; j < dropitems[i].length; ++j) {
               let pos = dropitems[i][j].indexOf('_same_');
               if ((pos > 0) && (h.findItem(dropitems[i][j]) === null))
                  dropitems[i][j] = dropitems[i][j].slice(0,pos) + items[i].slice(pos);

               elem = h.findItem({ name: dropitems[i][j], check_keys: true });
               if (elem) dropitems[i][j] = h.itemFullName(elem);
            }

            if ((options[i][0] == '[') && (options[i][options[i].length-1] == ']')) {
               dropopts[i] = parseAsArray(options[i]);
               options[i] = dropopts[i].shift();
            } else if (options[i].indexOf('+') > 0) {
               dropopts[i] = options[i].split('+');
               options[i] = dropopts[i].shift();
            } else {
               dropopts[i] = [];
            }

            while (dropopts[i].length < dropitems[i].length)
               dropopts[i].push('');
         }

         // also check if subsequent items has _same_, than use name from first item
         let pos = items[i].indexOf('_same_');
         if ((pos > 0) && !h.findItem(items[i]) && (i > 0))
            items[i] = items[i].slice(0,pos) + items[0].slice(pos);

         elem = h.findItem({ name: items[i], check_keys: true });
         if (elem) items[i] = h.itemFullName(elem);
      }

      // now check that items can be displayed
      for (let n = items.length - 1; n >= 0; --n) {
         if (images[n]) continue;
         let hitem = h.findItem(items[n]);
         if (!hitem || h.canDisplay(hitem, options[n])) continue;
         // try to expand specified item
         h.expandItem(items[n], null, true);
         items.splice(n, 1);
         options.splice(n, 1);
         dropitems.splice(n, 1);
      }

      if (items.length == 0)
         return true;

      let frame_names = new Array(items.length), items_wait = new Array(items.length);
      for (let n = 0; n < items.length; ++n) {
         items_wait[n] = 0;
         let fname = items[n], k = 0;
         if (items.indexOf(fname) < n) items_wait[n] = true; // if same item specified, one should wait first drawing before start next
         let p = options[n].indexOf('frameid:');
         if (p >= 0) {
            fname = options[n].slice(p+8);
            options[n] = options[n].slice(0,p);
         } else {
            while (frame_names.indexOf(fname) >= 0)
               fname = items[n] + '_' + k++;
         }
         frame_names[n] = fname;
      }

      // now check if several same items present - select only one for the drawing
      // if draw option includes 'main', such item will be drawn first
      for (let n = 0; n < items.length; ++n) {
         if (items_wait[n] !== 0) continue;
         let found_main = n;
         for (let k = 0; k < items.length; ++k)
            if ((items[n]===items[k]) && (options[k].indexOf('main') >= 0))
               found_main = k;
         for (let k = 0; k < items.length; ++k)
            if (items[n]===items[k])
               items_wait[k] = (found_main != k);
      }

      return this.createDisplay().then(mdi => {
         if (!mdi) return false;

         // Than create empty frames for each item
         for (let i = 0; i < items.length; ++i)
            if (options[i].indexOf('update:') !== 0) {
               mdi.createFrame(frame_names[i]);
               options[i] += '::_display_on_frame_::'+frame_names[i];
            }

         function DropNextItem(indx, painter) {
            if (painter && dropitems[indx] && (dropitems[indx].length > 0))
               return h.dropItem(dropitems[indx].shift(), painter.getDom(), dropopts[indx].shift()).then(() => DropNextItem(indx, painter));

            dropitems[indx] = null; // mark that all drop items are processed
            items[indx] = null; // mark item as ready

            for (let cnt = 0; cnt < items.length; ++cnt) {
               if (items[cnt] === null) continue; // ignore completed item
               if (items_wait[cnt] && items.indexOf(items[cnt]) === cnt) {
                  items_wait[cnt] = false;
                  return h.display(items[cnt], options[cnt]).then(painter => DropNextItem(cnt, painter));
               }
            }
         }

         let promises = [];

         // We start display of all items parallel, but only if they are not the same
         for (let i = 0; i < items.length; ++i)
            if (!items_wait[i])
               promises.push(h.display(items[i], options[i]).then(painter => DropNextItem(i, painter)));

         return Promise.all(promises);
      });
   }

   /** @summary Reload hierarchy and refresh html code
     * @return {Promise} when completed */
   async reload() {
      if ('_online' in this.h)
         return this.openOnline(this.h._online).then(() => this.refreshHtml());
      return false;
   }

   /** @summary activate (select) specified item
     * @param {Array} items - array of items names
     * @param {boolean} [force] - if specified, all required sub-levels will be opened
     * @private */
   activateItems(items, force) {

      if (isStr(items)) items = [ items ];

      let active = [], // array of elements to activate
          update = []; // array of elements to update
      this.forEachItem(item => { if (item._background) { active.push(item); delete item._background; } });

      let mark_active = () => {

         for (let n = update.length-1; n >= 0; --n)
            this.updateTreeNode(update[n]);

         for (let n = 0; n < active.length; ++n)
            this.updateBackground(active[n], force);
      };

      let find_next = (itemname, prev_found) => {
         if (itemname === undefined) {
            // extract next element
            if (items.length == 0) return mark_active();
            itemname = items.shift();
         }

         let hitem = this.findItem(itemname);

         if (!hitem) {
            let d = this.findItem({ name: itemname, last_exists: true, check_keys: true, allow_index: true });
            if (!d || !d.last) return find_next();
            d.now_found = this.itemFullName(d.last);

            if (force) {

               // if after last expand no better solution found - skip it
               if ((prev_found !== undefined) && (d.now_found === prev_found)) return find_next();

               return this.expandItem(d.now_found).then(res => {
                  if (!res) return find_next();
                  let newname = this.itemFullName(d.last);
                  if (newname) newname += '/';
                  find_next(newname + d.rest, d.now_found);
               });
            }
            hitem = d.last;
         }

         if (hitem) {
            // check that item is visible (opened), otherwise should enable parent

            let prnt = hitem._parent;
            while (prnt) {
               if (!prnt._isopen) {
                  if (force) {
                     prnt._isopen = true;
                     if (update.indexOf(prnt) < 0) update.push(prnt);
                  } else {
                     hitem = prnt; break;
                  }
               }
               prnt = prnt._parent;
            }

            hitem._background = 'LightSteelBlue';
            if (active.indexOf(hitem) < 0) active.push(hitem);
         }

         find_next();
      };

      if (force && this.brlayout) {
         if (!this.brlayout.browser_kind)
           return this.createBrowser('float', true).then(() => find_next());
         if (!this.brlayout.browser_visible)
            this.brlayout.toggleBrowserVisisbility();
      }

      // use recursion
      find_next();
   }

   /** @summary Check if item can be (potentially) expand
     * @private */
   canExpandItem(item) {
      if (!item) return false;
      if (item._expand) return true;
      let handle = getDrawHandle(item._kind, '::expand');
      return handle && canExpandHandle(handle);
   }

   /** @summary expand specified item
     * @param {String} itemname - item name
     * @return {Promise} when ready */
   async expandItem(itemname, d3cont, silent) {
      let hitem = this.findItem(itemname), hpainter = this;

      if (!hitem && d3cont)
         return;

      async function doExpandItem(_item, _obj){

         if (isStr(_item._expand))
            _item._expand = findFunction(item._expand);

         if (!isFunc(_item._expand)) {
            let handle = getDrawHandle(_item._kind, '::expand');

            if (handle?.expand_item) {
               _obj = _obj[handle.expand_item];
              handle = (_obj && _obj._typename) ? getDrawHandle('ROOT.'+_obj._typename, '::expand') : null;
            }

            if (handle?.expand || handle?.get_expand) {
               if (isFunc(handle.expand))
                  _item._expand = handle.expand;
               else if (isStr(handle.expand)) {
                  if (!internals.ignore_v6) {
                     let v6 = await _ensureJSROOT();
                     await v6.require(handle.prereq);
                     await v6._complete_loading();
                  }
                  _item._expand = handle.expand = findFunction(handle.expand);
               } else if (isFunc(handle.get_expand)) {
                  _item._expand = handle.expand = await handle.get_expand();
               }
            }
         }

         // try to use expand function
         if (_obj && isFunc(_item?._expand)) {
            if (_item._expand(_item, _obj)) {
               _item._isopen = true;
               if (_item._parent && !_item._parent._isopen) {
                  _item._parent._isopen = true; // also show parent
                  if (!silent) hpainter.updateTreeNode(_item._parent);
               } else {
                  if (!silent) hpainter.updateTreeNode(_item, d3cont);
               }
               return _item;
            }
         }

         if (_obj && objectHierarchy(_item, _obj)) {
            _item._isopen = true;
            if (_item._parent && !_item._parent._isopen) {
               _item._parent._isopen = true; // also show parent
               if (!silent) hpainter.updateTreeNode(_item._parent);
            } else {
               if (!silent) hpainter.updateTreeNode(_item, d3cont);
            }
            return _item;
         }

         return -1;
      }
      let promise = Promise.resolve(-1);

      if (hitem) {
         // item marked as it cannot be expanded, also top item cannot be changed
         if ((hitem._more === false) || (!hitem._parent && hitem._childs))
            return;

         if (hitem._childs && hitem._isopen) {
            hitem._isopen = false;
            if (!silent) this.updateTreeNode(hitem, d3cont);
            return;
         }

         if (hitem._obj) promise = doExpandItem(hitem, hitem._obj);
      }

      return promise.then(res => {
         if (res !== -1) return res; // done

         showProgress('Loading ' + itemname);

         return this.getObject(itemname, silent ? 'hierarchy_expand' : 'hierarchy_expand_verbose').then(res => {

            showProgress();

            if (res.obj) return doExpandItem(res.item, res.obj).then(res => { return (res !== -1) ? res : undefined; });
         });
      });

   }

   /** @summary Return main online item
     * @private */
   getTopOnlineItem(item) {
      if (item) {
         while (item && (!('_online' in item))) item = item._parent;
         return item;
      }

      if (!this.h) return null;
      if ('_online' in this.h) return this.h;
      if (this.h._childs && ('_online' in this.h._childs[0])) return this.h._childs[0];
      return null;
   }

   /** @summary Call function for each item which corresponds to JSON file
     * @private */
   forEachJsonFile(func) {
      if (!this.h) return;
      if ('_jsonfile' in this.h)
         return func(this.h);

      if (this.h._childs)
         for (let n = 0; n < this.h._childs.length; ++n) {
            let item = this.h._childs[n];
            if ('_jsonfile' in item) func(item);
         }
   }

   /** @summary Open JSON file
     * @param {string} filepath - URL to JSON file
     * @return {Promise} when object ready */
   async openJsonFile(filepath) {
      let isfileopened = false;
      this.forEachJsonFile(item => { if (item._jsonfile==filepath) isfileopened = true; });
      if (isfileopened) return;

      return httpRequest(filepath, 'object').then(res => {
         let h1 = { _jsonfile: filepath, _kind: 'ROOT.' + res._typename, _jsontmp: res, _name: filepath.split('/').pop() };
         if (res.fTitle) h1._title = res.fTitle;
         h1._get = function(item /* ,itemname */) {
            if (item._jsontmp)
               return Promise.resolve(item._jsontmp);
            return httpRequest(item._jsonfile, 'object')
                         .then(res => {
                             item._jsontmp = res;
                             return res;
                          });
         };
         if (!this.h) this.h = h1; else
         if (this.h._kind == 'TopFolder') this.h._childs.push(h1); else {
            let h0 = this.h, topname = ('_jsonfile' in h0) ? 'Files' : 'Items';
            this.h = { _name: topname, _kind: 'TopFolder', _childs : [h0, h1] };
         }

         return this.refreshHtml();
      });
   }

   /** @summary Call function for each item which corresponds to ROOT file
     * @private */
   forEachRootFile(func) {
      if (!this.h) return;
      if ((this.h._kind == kindTFile) && this.h._file)
         return func(this.h);

      if (this.h._childs)
         for (let n = 0; n < this.h._childs.length; ++n) {
            let item = this.h._childs[n];
            if ((item._kind == kindTFile) && ('_fullurl' in item))
               func(item);
         }
   }

   /** @summary Open ROOT file
     * @param {string} filepath - URL to ROOT file, argument for openFile
     * @return {Promise} when file is opened */
   async openRootFile(filepath) {

      let isfileopened = false;
      this.forEachRootFile(item => { if (item._fullurl === filepath) isfileopened = true; });
      if (isfileopened) return;

      let msg = isStr(filepath) ? filepath : 'file';

      showProgress(`Opening ${msg} ...`);

      return openFile(filepath).then(file => {

         let h1 = this.fileHierarchy(file);
         h1._isopen = true;
         if (!this.h) {
            this.h = h1;
            if (this._topname) h1._name = this._topname;
         } else if (this.h._kind == 'TopFolder') {
            this.h._childs.push(h1);
         }  else {
            let h0 = this.h, topname = (h0._kind == kindTFile) ? 'Files' : 'Items';
            this.h = { _name: topname, _kind: 'TopFolder', _childs : [h0, h1], _isopen: true };
         }

         return this.refreshHtml();
      }).catch(() => {
         // make CORS warning
         if (isBatchMode())
            console.error(`Fail to open ${msg} - check CORS headers`);
         else if (!select('#gui_fileCORS').style('background','red').empty())
            setTimeout(() => select('#gui_fileCORS').style('background',''), 5000);
         return false;
      }).finally(() => showProgress());
   }

   /** @summary Apply loaded TStyle object
     * @desc One also can specify item name of JSON file name where style is loaded
     * @param {object|string} style - either TStyle object of item name where object can be load */
   async applyStyle(style) {
      if (!style)
         return true;

      let pr = Promise.resolve(style);

      if (isStr(style)) {
         let item = this.findItem({ name: style, allow_index: true, check_keys: true });
         if (item !== null)
            pr = this.getObject(item).then(res => res.obj);
         else if (style.indexOf('.json') > 0)
            pr = httpRequest(style, 'object');
      }

      return pr.then(st => {
         if (st?._typename === clTStyle)
            Object.assign(gStyle, st);
      });
   }

   /** @summary Provides information abouf file item
     * @private */
   getFileProp(itemname) {
      let item = this.findItem(itemname);
      if (!item) return null;

      let subname = item._name;
      while (item._parent) {
         item = item._parent;
         if ('_file' in item)
            return { kind: 'file', fileurl: item._file.fURL, itemname: subname, localfile: !!item._file.fLocalFile };

         if ('_jsonfile' in item)
            return { kind: 'json', fileurl: item._jsonfile, itemname: subname };

         subname = item._name + '/' + subname;
      }

      return null;
   }

   /** @summary Provides URL for online item
     * @desc Such URL can be used  to request data from the server
     * @return string or null if item is not online
     * @private */
   getOnlineItemUrl(item) {
      if (isStr(item)) item = this.findItem(item);
      let prnt = item;
      while (prnt && (prnt._online === undefined)) prnt = prnt._parent;
      return prnt ? (prnt._online + this.itemFullName(item, prnt)) : null;
   }

   /** @summary Returns true if item is online
     * @private */
   isOnlineItem(item) {
      return this.getOnlineItemUrl(item) !== null;
   }

   /** @summary Dynamic module import, supports special shorcuts from core or draw_tree
     * @return {Promise} with module
     * @private */
   async importModule(module) {
      switch(module) {
         case 'core': return Promise.resolve().then(function () { return core; });
         case 'draw_tree': return Promise.resolve().then(function () { return TTree; });
         case 'hierarchy': return { HierarchyPainter, markAsStreamerInfo };
      }
      return import(/* webpackIgnore: true */ module);
   }

   /** @summary method used to request object from the http server
     * @return {Promise} with requested object
     * @private */
   async getOnlineItem(item, itemname, option) {

      let url = itemname, h_get = false, req = '', req_kind = 'object', draw_handle = null;

      if (isStr(option) && (option.indexOf('hierarchy_expand') == 0)) {
         h_get = true;
         option = undefined;
      }

      if (item) {
         url = this.getOnlineItemUrl(item);
         let func = null;
         if ('_kind' in item) draw_handle = getDrawHandle(item._kind);

         if (h_get) {
            req = 'h.json?compact=3';
            item._expand = onlineHierarchy; // use proper expand function
         } else if (item._make_request) {
            if (item._module) {
               let h = await this.importModule(item._module);
               func = h[item._make_request];
            } else {
               func = findFunction(item._make_request);
            }
         } else if (draw_handle?.make_request) {
            func = draw_handle.make_request;
         }

         if (isFunc(func)) {
            // ask to make request
            let dreq = func(this, item, url, option);
            // result can be simple string or object with req and kind fields
            if (dreq) {
               if (isStr(dreq)) {
                  req = dreq;
               } else {
                  if ('req' in dreq) req = dreq.req;
                  if ('kind' in dreq) req_kind = dreq.kind;
               }
            }
         }

         if (!req && (item._kind.indexOf('ROOT.') != 0))
           req = 'item.json.gz?compact=3';
      }

      if (!itemname && item && ('_cached_draw_object' in this) && !req) {
         // special handling for online draw when cashed
         let obj = this._cached_draw_object;
         delete this._cached_draw_object;
         return obj;
      }

      if (!req)
         req = 'root.json.gz?compact=23';

      if (url) url += '/';
      url += req;

      return new Promise(resolveFunc => {

         let itemreq = null;

         createHttpRequest(url, req_kind, obj => {

            let handleAfterRequest = func => {
               if (isFunc(func)) {
                  let res = func(this, item, obj, option, itemreq);
                  if (isObject(res)) obj = res;
               }
               resolveFunc(obj);
            };

            if (!h_get && item?._after_request) {
               if (item._module)
                  this.importModule(item._module).then(h => handleAfterRequest(h[item._after_request]));
               else
                  handleAfterRequest(findFunction(item._after_request)); // v6 support
            } else {
               handleAfterRequest(draw_handle?.after_request);
            }
         }, undefined, true).then(xhr => { itemreq = xhr; xhr.send(null); });
      });
   }

   /** @summary Access THttpServer with provided address
     * @param {string} server_address - URL to server like 'http://localhost:8090/'
     * @return {Promise} when ready */
   async openOnline(server_address) {
      let AdoptHierarchy = result => {
         this.h = result;
         if (!result) return Promise.resolve(null);

         if (('_title' in this.h) && (this.h._title!='')) document.title = this.h._title;

         result._isopen = true;

         // mark top hierarchy as online data and
         this.h._online = server_address;

         this.h._get = (item, itemname, option) => {
            return this.getOnlineItem(item, itemname, option);
         };

         this.h._expand = onlineHierarchy;

         let styles = [], scripts = [], v6_modules = [], v7_imports = [];
         this.forEachItem(item => {
            if (item._childs !== undefined)
               item._expand = onlineHierarchy;

            if (item._autoload) {
               let arr = item._autoload.split(';');
               arr.forEach(name => {
                  if ((name.length > 4) && (name.lastIndexOf('.mjs') == name.length-4)) {
                     v7_imports.push(this.importModule(name));
                  } else if ((name.length > 3) && (name.lastIndexOf('.js') == name.length-3)) {
                     if (!scripts.find(elem => elem == name)) scripts.push(name);
                  } else if ((name.length > 4) && (name.lastIndexOf('.css') == name.length-4)) {
                     if (!styles.find(elem => elem == name)) styles.push(name);
                  } else if (name && !v6_modules.find(elem => elem == name)) {
                     v6_modules.push(name);
                  }
               });
            }
         });

         return this.loadScripts(scripts, v6_modules)
               .then(() => loadScript(styles))
               .then(() => Promise.all(v7_imports))
               .then(() => {
                  this.forEachItem(item => {
                     if (!('_drawfunc' in item) || !('_kind' in item)) return;
                     let typename = 'kind:' + item._kind;
                     if (item._kind.indexOf('ROOT.') == 0) typename = item._kind.slice(5);
                     let drawopt = item._drawopt;
                     if (!canDrawHandle(typename) || drawopt)
                        addDrawFunc({ name: typename, func: item._drawfunc, script: item._drawscript, opt: drawopt });
                  });

                  return this;
               });
      };

      if (!server_address) server_address = '';

      if (isObject(server_address)) {
         let h = server_address;
         server_address = '';
         return AdoptHierarchy(h);
      }

      return httpRequest(server_address + 'h.json?compact=3', 'object').then(hh => AdoptHierarchy(hh));
   }

   /** @summary Get properties for online item  - server name and relative name
     * @private */
   getOnlineProp(itemname) {
      let item = this.findItem(itemname);
      if (!item) return null;

      let subname = item._name;
      while (item._parent) {
         item = item._parent;

         if ('_online' in item) {
            return {
               server: item._online,
               itemname: subname
            };
         }
         subname = item._name + '/' + subname;
      }

      return null;
   }

   /** @summary Fill context menu for online item
     * @private */
   fillOnlineMenu(menu, onlineprop, itemname) {

      let node = this.findItem(itemname),
          sett = getDrawSettings(node._kind, 'nosame;noinspect'),
          handle = getDrawHandle(node._kind),
          root_type = isStr(node._kind) ? node._kind.indexOf('ROOT.') == 0 : false;

      if (sett.opts && (node._can_draw !== false)) {
         sett.opts.push('inspect');
         menu.addDrawMenu('Draw', sett.opts, arg => this.display(itemname, arg));
      }

      if (!node._childs && (node._more !== false) && (node._more || root_type || sett.expand || sett.get_expand))
         menu.add('Expand', () => this.expandItem(itemname));

      if (handle?.execute)
         menu.add('Execute', () => this.executeCommand(itemname, menu.tree_node));

      if (sett.opts && (node._can_draw !== false))
         menu.addDrawMenu('Draw in new window', sett.opts,
                           arg => window.open(onlineprop.server + '?nobrowser&item=' + onlineprop.itemname +
                                              (this.isMonitoring() ? '&monitoring=' + this.getMonitoringInterval() : '') +
                                              (arg ? '&opt=' + arg : '')));

      if (sett.opts && (sett.opts.length > 0) && root_type && (node._can_draw !== false))
         menu.addDrawMenu('Draw as png', sett.opts,
                           arg => window.open(onlineprop.server + onlineprop.itemname + '/root.png?w=600&h=400' + (arg ? '&opt=' + arg : '')));

      if ('_player' in node)
         menu.add('Player', () => this.player(itemname));
   }

   /** @summary Assign existing hierarchy to the painter and refresh HTML code
     * @private */
   setHierarchy(h) {
      this.h = h;
      this.refreshHtml();
   }

   /** @summary Configures monitoring interval
     * @param {number} interval - repetition interval in ms
     * @param {boolean} flag - initial monitoring state */
   setMonitoring(interval, monitor_on) {

      this._runMonitoring('cleanup');

      if (interval) {
         interval = parseInt(interval);
         if (Number.isInteger(interval) && (interval > 0)) {
            this._monitoring_interval = Math.max(100,interval);
            monitor_on = true;
         } else {
            this._monitoring_interval = 3000;
         }
      }

      this._monitoring_on = monitor_on;

      if (this.isMonitoring())
         this._runMonitoring();
   }

   /** @summary Runs monitoring event loop
     * @private */
   _runMonitoring(arg) {
      if ((arg == 'cleanup') || !this.isMonitoring()) {
         if (this._monitoring_handle) {
            clearTimeout(this._monitoring_handle);
            delete this._monitoring_handle;
         }

         if (this._monitoring_frame) {
            cancelAnimationFrame(this._monitoring_frame);
            delete this._monitoring_frame;
         }
         return;
      }

      if (arg == 'frame') {
         // process of timeout, request animation frame
         delete this._monitoring_handle;
         this._monitoring_frame = requestAnimationFrame(this._runMonitoring.bind(this,'draw'));
         return;
      }

      if (arg == 'draw') {
         delete this._monitoring_frame;
         this.updateItems();
      }

      this._monitoring_handle = setTimeout(this._runMonitoring.bind(this,'frame'), this.getMonitoringInterval());
   }

   /** @summary Returns configured monitoring interval in ms */
   getMonitoringInterval() {
      return this._monitoring_interval || 3000;
   }

   /** @summary Returns true when monitoring is enabled */
   isMonitoring() {
      return this._monitoring_on;
   }

   /** @summary Assign default layout and place where drawing will be performed
     * @param {string} layout - layout like 'simple' or 'grid2x2'
     * @param {string} frameid - DOM element id where object drawing will be performed */
   setDisplay(layout, frameid) {
      if (!frameid && isObject(layout)) {
         this.disp = layout;
         this.disp_kind = 'custom';
         this.disp_frameid = null;
      } else {
         this.disp_kind = layout;
         this.disp_frameid = frameid;
      }

      if (!this.register_resize && (this.disp_kind != 'batch')) {
         this.register_resize = true;
         registerForResize(this);
      }
   }

   /** @summary Returns configured layout */
   getLayout() {
      return this.disp_kind;
   }

   /** @summary Remove painter reference from hierarhcy
     * @private */
   removePainter(obj_painter) {
      this.forEachItem(item => {
         if (item._painter === obj_painter) {
            // delete painter reference
            delete item._painter;
            // also clear data which could be associated with item
            if (isFunc(item.clear)) item.clear();
         }
      });
   }

   /** @summary Cleanup all items in hierarchy
     * @private */
   clearHierarchy(withbrowser) {
      if (this.disp) {
         this.disp.cleanup();
         delete this.disp;
      }

      let plainarr = [];

      this.forEachItem(item => {
         delete item._painter; // remove reference on the painter
         // when only display cleared, try to clear all browser items
         if (!withbrowser && isFunc(item.clear)) item.clear();
         if (withbrowser) plainarr.push(item);
      });

      if (withbrowser) {
         // cleanup all monitoring loops
         this.enableMonitoring(false);
         // simplify work for javascript and delete all (ok, most of) cross-references
         this.selectDom().html('');
         plainarr.forEach(d => { delete d._parent; delete d._childs; delete d._obj; delete d._d3cont; });
         delete this.h;
      }
   }

   /** @summary Returns actual MDI display object
     * @desc It should an instance of {@link MDIDsiplay} class */
   getDisplay() {
      return this.disp;
   }

   /** @summary method called when MDI element is cleaned up
     * @desc hook to perform extra actions when frame is cleaned
     * @private */
   cleanupFrame(frame) {

      select(frame).attr('frame_title', null);

      this.clearDrop(frame);

      let lst = cleanup(frame);

      // we remove all painters references from items
      if (lst.length > 0)
         this.forEachItem(item => {
            if (item._painter && lst.indexOf(item._painter) >= 0)
               delete item._painter;
         });
   }

   /** @summary Creates configured MDIDisplay object
     * @return {Promise} when ready
     * @private */
   async createDisplay() {

      if ('disp' in this) {
         if ((this.disp.numDraw() > 0) || (this.disp_kind == 'custom'))
            return this.disp;
         this.disp.cleanup();
         delete this.disp;
      }

      if (this.disp_kind == 'batch') {
         let pr = isNodeJs() ? _loadJSDOM() : Promise.resolve(null);
         return pr.then(handle => {
            this.disp = new BatchDisplay(1200, 800, handle?.body);
            return this.disp;
         });
      }

      // check that we can found frame where drawing should be done
      if (!document.getElementById(this.disp_frameid))
         return null;

      if ((this.disp_kind.indexOf('flex') == 0) || (this.disp_kind.indexOf('coll') == 0))
         this.disp = new FlexibleDisplay(this.disp_frameid);
      else if (this.disp_kind == 'tabs')
         this.disp = new TabsDisplay(this.disp_frameid);
      else
         this.disp = new GridDisplay(this.disp_frameid, this.disp_kind);

      this.disp.cleanupFrame = this.cleanupFrame.bind(this);
      if (settings.DragAndDrop)
          this.disp.setInitFrame(this.enableDrop.bind(this));

      return this.disp;
   }

   /** @summary If possible, creates custom MDIDisplay for given item
     * @param itemname - name of item, for which drawing is created
     * @param custom_kind - display kind
     * @return {Promise} with mdi object created
     * @private */
   async createCustomDisplay(itemname, custom_kind) {

      if (this.disp_kind != 'simple')
         return this.createDisplay();

      this.disp_kind = custom_kind;

      // check if display can be erased
      if (this.disp) {
         let num = this.disp.numDraw();
         if ((num > 1) || ((num == 1) && !this.disp.findFrame(itemname)))
            return this.createDisplay();
         this.disp.cleanup();
         delete this.disp;
      }

      return this.createDisplay();
   }

   /** @summary function updates object drawings for other painters
     * @private */
   updateOnOtherFrames(painter, obj) {
      let mdi = this.disp, isany = false;
      if (!mdi) return false;

      let handle = obj._typename ? getDrawHandle('ROOT.' + obj._typename) : null;
      if (handle?.draw_field && obj[handle?.draw_field])
         obj = obj[handle?.draw_field];

      mdi.forEachPainter((p /*, frame*/) => {
         if ((p === painter) || (p.getItemName() != painter.getItemName())) return;

         // do not actiavte frame when doing update
         // mdi.activateFrame(frame);
         if (isFunc(p.redrawObject) && p.redrawObject(obj)) isany = true;
      });
      return isany;
   }

   /** @summary Process resize event
     * @private */
   checkResize(size) {
      if (this.disp) this.disp.checkMDIResize(null, size);
   }

   /** @summary Load and execute scripts, kept to support v6 applications
     * @private */
   async loadScripts(scripts, modules) {
      if (!scripts?.length && !modules?.length)
         return true;

      if (internals.ignore_v6)
         return loadScript(scripts);

      return _ensureJSROOT().then(v6 => {
         return v6.require(modules)
                  .then(() => loadScript(scripts))
                  .then(() => v6._complete_loading());
      });
   }

   /** @summary Start GUI
     * @return {Promise} when ready
     * @private */
   async startGUI(gui_div, url) {

      let d = decodeUrl(url);

      let GetOption = opt => {
         let res = d.get(opt, null);
         if ((res === null) && gui_div && !gui_div.empty() && gui_div.node().hasAttribute(opt))
            res = gui_div.attr(opt);
         return res;
      };

      let GetUrlOptionAsArray = opt => {

         let res = [];

         while (opt) {
            let separ = opt.indexOf(';'),
                part = (separ > 0) ? opt.slice(0, separ) : opt;

            opt = (separ > 0) ? opt.slice(separ+1) : '';

            let canarray = true;
            if (part[0] == '#') { part = part.slice(1); canarray = false; }

            let val = d.get(part,null);

            if (canarray)
               res = res.concat(parseAsArray(val));
            else if (val !== null)
               res.push(val);
         }
         return res;
      };

      let GetOptionAsArray = opt => {
         let res = GetUrlOptionAsArray(opt);
         if (res.length > 0 || !gui_div || gui_div.empty()) return res;
         while (opt) {
            let separ = opt.indexOf(';');
            let part = separ > 0 ? opt.slice(0, separ) : opt;
            if (separ > 0) opt = opt.slice(separ+1); else opt = '';

            let canarray = true;
            if (part[0] == '#') { part = part.slice(1); canarray = false; }
            if (part === 'files') continue; // special case for normal UI

            if (!gui_div.node().hasAttribute(part)) continue;

            let val = gui_div.attr(part);

            if (canarray)
               res = res.concat(parseAsArray(val));
            else if (val !== null)
               res.push(val);
         }
         return res;
      };

      let prereq = GetOption('prereq') || '',
          filesdir = d.get('path') || '', // path used in normal gui
          filesarr = GetOptionAsArray('#file;files'),
          jsonarr = GetOptionAsArray('#json;jsons'),
          expanditems = GetOptionAsArray('expand'),
          focusitem = GetOption('focus'),
          itemsarr = GetOptionAsArray('#item;items'),
          optionsarr = GetOptionAsArray('#opt;opts'),
          monitor = GetOption('monitoring'),
          layout = GetOption('layout'),
          style = GetOptionAsArray('#style'),
          statush = 0, status = GetOption('status'),
          browser_kind = GetOption('browser'),
          browser_configured = !!browser_kind,
          title = GetOption('title');

      if (monitor === null)
         monitor = 0;
      else if (monitor === '')
         monitor = 3000;
      else
         monitor = parseInt(monitor);

      if (GetOption('float') !== null) { browser_kind = 'float'; browser_configured = true; } else
      if (GetOption('fix') !== null) { browser_kind = 'fix'; browser_configured = true; }

      this.no_select = GetOption('noselect');

      if (GetOption('files_monitoring') !== null) this.files_monitoring = true;

      if (title) document.title = title;

      let load = GetOption('load');

      if (expanditems.length == 0 && (GetOption('expand') === '')) expanditems.push('');

      if (filesdir) {
         for (let i = 0; i < filesarr.length; ++i) filesarr[i] = filesdir + filesarr[i];
         for (let i = 0; i < jsonarr.length; ++i) jsonarr[i] = filesdir + jsonarr[i];
      }

      if ((itemsarr.length == 0) && GetOption('item') === '') itemsarr.push('');

      if ((jsonarr.length == 1) && (itemsarr.length == 0) && (expanditems.length == 0)) itemsarr.push('');

      if (!this.disp_kind) {
         if (isStr(layout) && layout)
            this.disp_kind = layout;
         else
         switch (itemsarr.length) {
           case 0:
           case 1: this.disp_kind = 'simple'; break;
           case 2: this.disp_kind = 'vert2'; break;
           case 3: this.disp_kind = 'vert21'; break;
           case 4: this.disp_kind = 'vert22'; break;
           case 5: this.disp_kind = 'vert32'; break;
           case 6: this.disp_kind = 'vert222'; break;
           case 7: this.disp_kind = 'vert322'; break;
           case 8: this.disp_kind = 'vert332'; break;
           case 9: this.disp_kind = 'vert333'; break;
           default: this.disp_kind = 'flex';
         }
      }

      if (status === 'no')
         status = null;
      else if (status === 'off') {
         this.status_disabled = true;
         status = null;
      } else if (status === 'on')
         status = true;
      else if (status !== null) {
         statush = parseInt(status);
         if (!Number.isInteger(statush) || (statush < 5)) statush = 0;
         status = true;
      }
      if (this.no_select === '') this.no_select = true;

      if (!browser_kind)
         browser_kind = 'fix';
      else if (browser_kind === 'no')
         browser_kind = '';
      else if (browser_kind === 'off') {
         browser_kind = '';
         status = null;
         this.exclude_browser = true;
      }
      if (GetOption('nofloat') !== null)
         this.float_browser_disabled = true;

      if (this.start_without_browser) browser_kind = '';

      this._topname = GetOption('topname');

      let openAllFiles = () => {
         let promise;

         if (load || prereq) {
            promise = this.loadScripts(load, prereq); load = ''; prereq = '';
         } else if (browser_kind) {
            promise = this.createBrowser(browser_kind); browser_kind = '';
         } else if (status !== null) {
            promise = this.createStatusLine(statush, status); status = null;
         } else if (jsonarr.length > 0)
            promise = this.openJsonFile(jsonarr.shift());
         else if (filesarr.length > 0)
            promise = this.openRootFile(filesarr.shift());
         else if (expanditems.length > 0)
            promise = this.expandItem(expanditems.shift());
         else if (style.length > 0)
            promise = this.applyStyle(style.shift());
         else
            return this.refreshHtml()
                   .then(() => this.displayItems(itemsarr, optionsarr))
                   .then(() => focusitem ? this.focusOnItem(focusitem) : this)
                   .then(() => {
                      this.setMonitoring(monitor);
                      return itemsarr ? this.refreshHtml() : this; // this is final return
                   });

         return promise.then(openAllFiles);
      };

      let h0 = null;
      if (this.is_online) {
         let func = internals.getCachedHierarchy || findFunction('GetCachedHierarchy');
         if (isFunc(func))
            h0 = func();
         if (!isObject(h0))
            h0 = '';

         if ((this.is_online == 'draw') && !itemsarr.length)
            itemsarr.push('');
      }

      if (h0 !== null)
         return this.openOnline(h0).then(() => {
            // check if server enables monitoring
            if (!this.exclude_browser && !browser_configured && ('_browser' in this.h)) {
               browser_kind = this.h._browser;
               if (browser_kind === 'no') browser_kind = ''; else
               if (browser_kind === 'off') { browser_kind = ''; status = null; this.exclude_browser = true; }
            }

            if (('_monitoring' in this.h) && !monitor)
               monitor = this.h._monitoring;

            if (('_loadfile' in this.h) && (filesarr.length == 0))
               filesarr = parseAsArray(this.h._loadfile);

            if (('_drawitem' in this.h) && (itemsarr.length == 0)) {
               itemsarr = parseAsArray(this.h._drawitem);
               optionsarr = parseAsArray(this.h._drawopt);
            }

            if (('_layout' in this.h) && !layout && ((this.is_online != 'draw') || (itemsarr.length > 1)))
               this.disp_kind = this.h._layout;

            if (('_toptitle' in this.h) && this.exclude_browser && document)
               document.title = this.h._toptitle;

            if (gui_div)
               this.prepareGuiDiv(gui_div.attr('id'), this.disp_kind);

            return openAllFiles();
         });

      if (gui_div)
         this.prepareGuiDiv(gui_div.attr('id'), this.disp_kind);

      return openAllFiles();
   }

   /** @summary Prepare div element - create layout and buttons
     * @private */
   prepareGuiDiv(myDiv, layout) {

      this.gui_div = isStr(myDiv) ? myDiv : myDiv.attr('id');

      this.brlayout = new BrowserLayout(this.gui_div, this);

      this.brlayout.create(!this.exclude_browser);

      if (!this.exclude_browser) {
         let btns = this.brlayout.createBrowserBtns();

         ToolbarIcons.createSVG(btns, ToolbarIcons.diamand, 15, 'toggle fix-pos browser')
                     .style('margin','3px').on('click', () => this.createBrowser('fix', true));

         if (!this.float_browser_disabled)
            ToolbarIcons.createSVG(btns, ToolbarIcons.circle, 15, 'toggle float browser')
                        .style('margin','3px').on('click', () => this.createBrowser('float', true));

         if (!this.status_disabled)
            ToolbarIcons.createSVG(btns, ToolbarIcons.three_circles, 15, 'toggle status line')
                        .style('margin','3px').on('click', () => this.createStatusLine(0, 'toggle'));
      }

      this.setDisplay(layout, this.brlayout.drawing_divid());
   }

   /** @summary Returns trus if status is exists */
   hasStatusLine() {
      if (this.status_disabled || !this.gui_div || !this.brlayout)
         return false;
      return this.brlayout.hasStatus();
   }

   /** @summary Create status line
     * @param {number} [height] - size of the status line
     * @param [mode] - false / true / 'toggle'
     * @return {Promise} when ready */
   async createStatusLine(height, mode) {
      if (this.status_disabled || !this.gui_div || !this.brlayout)
         return '';
      return this.brlayout.createStatusLine(height, mode);
   }

   /** @summary Redraw hierarchy
     * @desc works only when inspector or streamer info is displayed
     * @private */
   redrawObject(obj) {
      if (!this._inspector && !this._streamer_info) return false;
      if (this._streamer_info)
         this.h = createStreamerInfoContent(obj);
      else
         this.h = createInspectorContent(obj);
      return this.refreshHtml().then(() => { this.setTopPainter(); });
   }

   /** @summary Create browser elements
     * @return {Promise} when completed */
   async createBrowser(browser_kind, update_html) {

      if (!this.gui_div || this.exclude_browser || !this.brlayout)
         return false;

      let main = select(`#${this.gui_div} .jsroot_browser`);

      // one requires top-level container
      if (main.empty())
         return false;

      if ((browser_kind == 'float') && this.float_browser_disabled) browser_kind = 'fix';

      if (!main.select('.jsroot_browser_area').empty()) {
         // this is case when browser created,
         // if update_html specified, hidden state will be toggled

         if (update_html) this.brlayout.toggleKind(browser_kind);

         return true;
      }

      let guiCode = `<p class="jsroot_browser_version"><a href="https://root.cern/js/">JSROOT</a> version <span style="color:green"><b>${version}</b></span></p>`;

      if (this.is_online) {
         guiCode += '<p> Hierarchy in <a href="h.json">json</a> and <a href="h.xml">xml</a> format</p>' +
                    '<div style="display:inline; vertical-align:middle; white-space: nowrap;">' +
                    '<label style="margin-right:5px"><input type="checkbox" name="monitoring" class="gui_monitoring"/>Monitoring</label>';
      } else if (!this.no_select) {
         let myDiv = select('#'+this.gui_div),
             files = myDiv.attr('files') || '../files/hsimple.root',
             path = decodeUrl().get('path') || myDiv.attr('path') || '',
             arrFiles = files.split(';');

         guiCode += '<input type="text" value="" style="width:95%; margin:5px;border:2px;" class="gui_urlToLoad" title="input file name"/>' +
                    '<div style="display:flex;flex-direction:row;padding-top:5px">' +
                    '<select class="gui_selectFileName" style="flex:1;padding:2px;" title="select file name"' +
                    '<option value="" selected="selected"></option>';
         arrFiles.forEach(fname => { guiCode += `<option value="${path + fname}">${fname}</option>`; });
         guiCode += '</select>' +
                    '<input type="file" class="gui_localFile" accept=".root" style="display:none"/><output id="list" style="display:none"></output>' +
                    '<input type="button" value="..." class="gui_fileBtn" style="min-width:3em;padding:3px;margin-left:5px;margin-right:5px;" title="select local file for reading"/><br/>' +
                    '</div>' +
                    '<p id="gui_fileCORS"><small><a href="https://github.com/root-project/jsroot/blob/master/docs/JSROOT.md#reading-root-files-from-other-servers">Read docu</a>' +
                    ' how to open files from other servers.</small></p>' +
                    '<div style="display:flex;flex-direction:row">' +
                    '<input style="padding:3px;margin-right:5px" class="gui_ReadFileBtn" type="button" title="Read the Selected File" value="Load"/>' +
                    '<input style="padding:3px;margin-right:5px" class="gui_ResetUIBtn" type="button" title="Close all opened files and clear drawings" value="Reset"/>';
      } else if (this.no_select == "file") {
         guiCode += '<div style="display:flex;flex-direction:row">';
      }

      if (this.is_online || !this.no_select || this.no_select == "file")
         guiCode += '<select style="padding:2px;margin-right:5px;" title="layout kind" class="gui_layout"></select>' +
                    '</div>';

      guiCode += `<div id="${this.gui_div}_browser_hierarchy" class="jsroot_browser_hierarchy"></div>`;

      this.brlayout.setBrowserContent(guiCode);

      let title_elem = this.brlayout.setBrowserTitle(this.is_online ? 'ROOT online server' : 'Read a ROOT file');
      if (title_elem) title_elem.on('contextmenu', evnt => {
         evnt.preventDefault();
         createMenu$1(evnt).then(menu => {
            this.fillSettingsMenu(menu, true);
            menu.show();
         });
      });

      if (!this.is_online && !this.no_select) {

         this.readSelectedFile = function() {
            let filename = main.select('.gui_urlToLoad').property('value').trim();
            if (!filename) return;

            if (filename.toLowerCase().lastIndexOf('.json') == filename.length-5)
               this.openJsonFile(filename);
            else
               this.openRootFile(filename);
         };

         main.select('.gui_selectFileName').property('value', '')
              .on('change', evnt => main.select('.gui_urlToLoad').property('value', evnt.target.value));
         main.select('.gui_fileBtn').on('click', () => main.select('.gui_localFile').node().click());

         main.select('.gui_ReadFileBtn').on('click', () => this.readSelectedFile());

         main.select('.gui_ResetUIBtn').on('click', () => this.clearHierarchy(true));

         main.select('.gui_urlToLoad').on('keyup', evnt => {
            if (evnt.code == 'Enter') this.readSelectedFile();
         });

         main.select('.gui_localFile').on('change', evnt => {
            let files = evnt.target.files;

            for (let n = 0; n < files.length; ++n) {
               let f = files[n];
               main.select('.gui_urlToLoad').property('value', f.name);
               this.openRootFile(f);
            }
         });
      }

      let layout = main.select('.gui_layout');
      if (!layout.empty()) {
         ['simple', 'vert2', 'vert3', 'vert231', 'horiz2', 'horiz32', 'flex', 'tabs',
          'grid 2x2', 'grid 1x3', 'grid 2x3', 'grid 3x3', 'grid 4x4'].forEach(kind => layout.append('option').attr('value', kind).html(kind));

         layout.on('change', ev => this.setDisplay(ev.target.value || 'flex', this.gui_div + '_drawing'));
      }

      this.setDom(this.gui_div + '_browser_hierarchy');

      if (update_html) {
         this.refreshHtml();
         this.initializeBrowser();
      }

      return this.brlayout.toggleBrowserKind(browser_kind || 'fix');
   }

   /** @summary Initialize browser elements */
   initializeBrowser() {

      let main = select(`#${this.gui_div} .jsroot_browser`);
      if (main.empty() || !this.brlayout) return;

      this.brlayout.adjustBrowserSize();

      let selects = main.select('.gui_layout').node();

      if (selects) {
         let found = false;
         for (let i in selects.options) {
            let s = selects.options[i].text;
            if (!isStr(s)) continue;
            if ((s == this.getLayout()) || (s.replace(/ /g, '') == this.getLayout())) {
               selects.selectedIndex = i; found = true;
               break;
            }
         }
         if (!found) {
            let opt = document.createElement('option');
            opt.innerHTML = opt.value = this.getLayout();
            selects.appendChild(opt);
            selects.selectedIndex = selects.options.length-1;
         }
      }

      if (this.is_online) {
         if (this.h?._toptitle)
            this.brlayout.setBrowserTitle(this.h._toptitle);
         main.select('.gui_monitoring')
           .property('checked', this.isMonitoring())
           .on('click', evnt => {
               this.enableMonitoring(evnt.target.checked);
               this.updateItems();
            });
      } else if (!this.no_select) {
         let fname = '';
         this.forEachRootFile(item => { if (!fname) fname = item._fullurl; });
         main.select('.gui_urlToLoad').property('value', fname);
      }
   }

   /** @summary Enable monitoring mode */
   enableMonitoring(on) {
      this.setMonitoring(undefined, on);

      let chkbox = select(`#${this.gui_div} .jsroot_browser .gui_monitoring`);
      if (!chkbox.empty() && (chkbox.property('checked') !== on))
         chkbox.property('checked', on);
   }

} // class HierarchyPainter



/** @summary Show object in inspector for provided object
  * @protected */
ObjectPainter.prototype.showInspector = function(obj) {
   if (obj === 'check')
      return true;

   let main = this.selectDom(),
      rect = getElementRect(main),
      w = Math.round(rect.width * 0.05) + 'px',
      h = Math.round(rect.height * 0.05) + 'px',
      id = 'root_inspector_' + internals.id_counter++;

   main.append('div')
      .attr('id', id)
      .attr('class', 'jsroot_inspector')
      .style('position', 'absolute')
      .style('top', h)
      .style('bottom', h)
      .style('left', w)
      .style('right', w);

   if (!obj?._typename)
      obj = this.getObject();

   return drawInspector(id, obj);
};


/** @summary Display streamer info
  * @private */
async function drawStreamerInfo(dom, lst) {
   let painter = new HierarchyPainter('sinfo', dom, '__as_dark_mode__');

   // in batch mode HTML drawing is not possible, just keep object reference for a minute
   if (isBatchMode()) {
      painter.selectDom().property('_json_object_', lst);
      return painter;
   }

   painter._streamer_info = true;
   painter.h = createStreamerInfoContent(lst);

   // painter.selectDom().style('overflow','auto');

   return painter.refreshHtml().then(() => {
      painter.setTopPainter();
      return painter;
   });
}

// ======================================================================================

/** @summary Display inspector
  * @private */
async function drawInspector(dom, obj) {

   cleanup(dom);
   let painter = new HierarchyPainter('inspector', dom, '__as_dark_mode__');

   // in batch mode HTML drawing is not possible, just keep object reference for a minute
   if (isBatchMode()) {
      painter.selectDom().property('_json_object_', obj);
      return painter;
   }

   painter.default_by_click = 'expand'; // default action
   painter.with_icons = false;
   painter._inspector = true; // keep

   if (painter.selectDom().classed('jsroot_inspector'))
      painter.removeInspector = function() {
         this.selectDom().remove();
      };

   painter.fill_context = function(menu, hitem) {
      let sett = getDrawSettings(hitem._kind, 'nosame');
      if (sett.opts)
         menu.addDrawMenu('nosub:Draw', sett.opts, function(arg) {
            if (!hitem || !hitem._obj) return;
            let obj = hitem._obj, ddom = this.selectDom().node();
            if (this.removeInspector) {
               ddom = ddom.parentNode;
               this.removeInspector();
               if (arg == 'inspect')
                  return this.showInspector(obj);
            }
            cleanup(ddom);
            draw(ddom, obj, arg);
         });
   };

   painter.h = createInspectorContent(obj);

   return painter.refreshHtml().then(() => {
      painter.setTopPainter();
      return painter;
   });
}

internals.drawInspector = drawInspector;

var HierarchyPainter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
getHPainter: getHPainter,
HierarchyPainter: HierarchyPainter,
drawInspector: drawInspector,
drawStreamerInfo: drawStreamerInfo,
drawList: drawList,
markAsStreamerInfo: markAsStreamerInfo,
folderHierarchy: folderHierarchy,
taskHierarchy: taskHierarchy,
listHierarchy: listHierarchy,
objectHierarchy: objectHierarchy,
keysHierarchy: keysHierarchy
});

/** @summary Read style and settings from URL
  * @private */
function readStyleFromURL(url) {

   // first try to read settings from coockies
   readSettings();
   readStyle();

   let d = decodeUrl(url);

   function get_bool(name, field) {
      if (d.has(name)) {
         let val = d.get(name);
         settings[field] = (val != '0') && (val != 'false') && (val != 'off');
      }
   }

   if (d.has('optimize')) {
      settings.OptimizeDraw = 2;
      let optimize = d.get('optimize');
      if (optimize) {
         optimize = parseInt(optimize);
         if (Number.isInteger(optimize)) settings.OptimizeDraw = optimize;
      }
   }

   get_bool('lastcycle', 'OnlyLastCycle');
   get_bool('usestamp', 'UseStamp');
   get_bool('dark', 'DarkMode');

   let mr = d.get('maxranges');
   if (mr) {
      mr = parseInt(mr);
      if (Number.isInteger(mr)) settings.MaxRanges = mr;
   }

   if (d.has('wrong_http_response'))
      settings.HandleWrongHttpResponse = true;

   if (d.has('prefer_saved_points'))
      settings.PreferSavedPoints = true;

   let inter = d.get('interactive');
   if (inter === 'nomenu')
      settings.ContextMenu = false;
   else if (inter !== undefined) {
      if (!inter || (inter == '1'))
         inter = '111111';
      else if (inter == '0')
         inter = '000000';
      if (inter.length === 6) {
         switch(inter[0]) {
            case '0': settings.ToolBar = false; break;
            case '1': settings.ToolBar = 'popup'; break;
            case '2': settings.ToolBar = true; break;
         }
         inter = inter.slice(1);
      }
      if (inter.length == 5) {
         settings.Tooltip = parseInt(inter[0]);
         settings.ContextMenu = (inter[1] != '0');
         settings.Zooming = (inter[2] != '0');
         settings.MoveResize = (inter[3] != '0');
         settings.DragAndDrop = (inter[4] != '0');
      }
   }

   get_bool('tooltip', 'Tooltip');

   if (d.has('bootstrap') || d.has('bs'))
      settings.Bootstrap = true;

   let mathjax = d.get('mathjax', null), latex = d.get('latex', null);

   if ((mathjax !== null) && (mathjax != '0') && (latex === null)) latex = 'math';
   if (latex !== null)
      settings.Latex = constants$1.Latex.fromString(latex);

   if (d.has('nomenu')) settings.ContextMenu = false;
   if (d.has('noprogress')) settings.ProgressBox = false;
   if (d.has('notouch')) browser.touches = false;
   if (d.has('adjframe')) settings.CanAdjustFrame = true;

   if (d.has('toolbar')) {
      let toolbar = d.get('toolbar', ''), val = null;
      if (toolbar.indexOf('popup') >= 0) val = 'popup';
      if (toolbar.indexOf('left') >= 0) { settings.ToolBarSide = 'left'; val = 'popup'; }
      if (toolbar.indexOf('right') >= 0) { settings.ToolBarSide = 'right'; val = 'popup'; }
      if (toolbar.indexOf('vert') >= 0) { settings.ToolBarVert = true; val = 'popup'; }
      if (toolbar.indexOf('show') >= 0) val = true;
      settings.ToolBar = val || ((toolbar.indexOf('0') < 0) && (toolbar.indexOf('false') < 0) && (toolbar.indexOf('off') < 0));
   }

   get_bool('skipsi', 'SkipStreamerInfos');
   get_bool('skipstreamerinfos', 'SkipStreamerInfos');

   if (d.has('nodraggraphs'))
      settings.DragGraphs = false;

   if (d.has('palette')) {
      let palette = parseInt(d.get('palette'));
      if (Number.isInteger(palette) && (palette > 0) && (palette < 113)) settings.Palette = palette;
   }

   let render3d = d.get('render3d'), embed3d = d.get('embed3d'), geosegm = d.get('geosegm');
   if (render3d) settings.Render3D = constants$1.Render3D.fromString(render3d);
   if (embed3d) settings.Embed3D = constants$1.Embed3D.fromString(embed3d);
   if (geosegm) settings.GeoGradPerSegm = Math.max(2, parseInt(geosegm));
   get_bool('geocomp', 'GeoCompressComp');

   if (d.has('hlimit')) settings.HierarchyLimit = parseInt(d.get('hlimit'));

   function get_int_style(name, field, dflt) {
      if (!d.has(name)) return;
      let val = d.get(name);
      if (!val || (val == 'true') || (val == 'on'))
         gStyle[field] = dflt;
      else if ((val == 'false') || (val == 'off'))
         gStyle[field] = 0;
      else
         gStyle[field] = parseInt(val);
   }

   if (d.has('histzero')) gStyle.fHistMinimumZero = true;
   if (d.has('histmargin')) gStyle.fHistTopMargin = parseFloat(d.get('histmargin'));
   get_int_style('optstat', 'fOptStat', 1111);
   get_int_style('optfit', 'fOptFit', 0);
   get_int_style('optdate', 'fOptDate', 1);
   get_int_style('optfile', 'fOptFile', 1);
   get_int_style('opttitle', 'fOptTitle', 1);
   gStyle.fStatFormat = d.get('statfmt', gStyle.fStatFormat);
   gStyle.fFitFormat = d.get('fitfmt', gStyle.fFitFormat);
}


/** @summary Build main GUI
  * @desc Used in many HTML files to create JSROOT GUI elements
  * @param {String} gui_element - id of the `<div>` element
  * @param {String} gui_kind - either 'online', 'nobrowser', 'draw'
  * @return {Promise} with {@link HierarchyPainter} instance
  * @example
  * import { buildGUI } from '/path_to_jsroot/modules/gui.mjs';
  * buildGUI('guiDiv'); */
async function buildGUI(gui_element, gui_kind = '') {
   let myDiv = isStr(gui_element) ? select('#' + gui_element) : select(gui_element);
   if (myDiv.empty())
      return Promise.reject(Error('no div for gui found'));

   myDiv.html(''); // clear element

   let d = decodeUrl(), online = (gui_kind == 'online'), nobrowser = false, drawing = false;

   if (gui_kind == 'draw') {
      online = drawing = nobrowser = true;
   } else if ((gui_kind == 'nobrowser') || d.has('nobrowser') || (myDiv.attr('nobrowser') && myDiv.attr('nobrowser') !== 'false')) {
      nobrowser = true;
   }

   if (myDiv.attr('ignoreurl') === 'true')
      settings.IgnoreUrlOptions = true;

   readStyleFromURL();

   if (nobrowser) {
      let guisize = d.get('divsize');
      if (guisize) {
         guisize = guisize.split('x');
         if (guisize.length != 2) guisize = null;
      }

      if (guisize) {
         myDiv.style('position','relative').style('width', guisize[0] + 'px').style('height', guisize[1] + 'px');
      } else {
         select('html').style('height','100%');
         select('body').style('min-height','100%').style('margin',0).style('overflow','hidden');
         myDiv.style('position','absolute').style('left',0).style('top',0).style('bottom',0).style('right',0).style('padding',1);
      }
   }

   let hpainter = new HierarchyPainter('root', null);

   if (online) hpainter.is_online = drawing ? 'draw' : 'online';
   if (drawing) hpainter.exclude_browser = true;
   hpainter.start_without_browser = nobrowser;

   return hpainter.startGUI(myDiv).then(() => {
      if (!nobrowser)
         return hpainter.initializeBrowser();
      if (!drawing)
         return;
      let obj = null, func = internals.getCachedObject || findFunction('GetCachedObject');
      if (isFunc(func))
         obj = parse(func());
      if (obj) hpainter._cached_draw_object = obj;
      let opt = d.get('opt', '');
      if (d.has('websocket')) opt+=';websocket';
      return hpainter.display('', opt);
   }).then(() => hpainter);
}

var _rollup_plugin_ignore_empty_module_placeholder = {};

var _rollup_plugin_ignore_empty_module_placeholder$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
'default': _rollup_plugin_ignore_empty_module_placeholder
});

/**
 * dat-gui JavaScript Controller Library
 * https://github.com/dataarts/dat.gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

function ___$insertStyle(css) {
  if (!css) {
    return;
  }
  if (typeof window === 'undefined') {
    return;
  }

  var style = document.createElement('style');

  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  document.head.appendChild(style);

  return css;
}

function colorToString (color, forceCSSHex) {
  var colorFormat = color.__state.conversionName.toString();
  var r = Math.round(color.r);
  var g = Math.round(color.g);
  var b = Math.round(color.b);
  var a = color.a;
  var h = Math.round(color.h);
  var s = color.s.toFixed(1);
  var v = color.v.toFixed(1);
  if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {
    var str = color.hex.toString(16);
    while (str.length < 6) {
      str = '0' + str;
    }
    return '#' + str;
  } else if (colorFormat === 'CSS_RGB') {
    return 'rgb(' + r + ',' + g + ',' + b + ')';
  } else if (colorFormat === 'CSS_RGBA') {
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  } else if (colorFormat === 'HEX') {
    return '0x' + color.hex.toString(16);
  } else if (colorFormat === 'RGB_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ']';
  } else if (colorFormat === 'RGBA_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ',' + a + ']';
  } else if (colorFormat === 'RGB_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + '}';
  } else if (colorFormat === 'RGBA_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';
  } else if (colorFormat === 'HSV_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + '}';
  } else if (colorFormat === 'HSVA_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';
  }
  return 'unknown format';
}

var ARR_EACH = Array.prototype.forEach;
var ARR_SLICE = Array.prototype.slice;
var Common = {
  BREAK: {},
  extend: function extend(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (!this.isUndefined(obj[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  defaults: function defaults(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (this.isUndefined(target[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  compose: function compose() {
    var toCall = ARR_SLICE.call(arguments);
    return function () {
      var args = ARR_SLICE.call(arguments);
      for (var i = toCall.length - 1; i >= 0; i--) {
        args = [toCall[i].apply(this, args)];
      }
      return args[0];
    };
  },
  each: function each(obj, itr, scope) {
    if (!obj) {
      return;
    }
    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
      obj.forEach(itr, scope);
    } else if (obj.length === obj.length + 0) {
      var key = void 0;
      var l = void 0;
      for (key = 0, l = obj.length; key < l; key++) {
        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
          return;
        }
      }
    } else {
      for (var _key in obj) {
        if (itr.call(scope, obj[_key], _key) === this.BREAK) {
          return;
        }
      }
    }
  },
  defer: function defer(fnc) {
    setTimeout(fnc, 0);
  },
  debounce: function debounce(func, threshold, callImmediately) {
    var timeout = void 0;
    return function () {
      var obj = this;
      var args = arguments;
      function delayed() {
        timeout = null;
        if (!callImmediately) func.apply(obj, args);
      }
      var callNow = callImmediately || !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(delayed, threshold);
      if (callNow) {
        func.apply(obj, args);
      }
    };
  },
  toArray: function toArray(obj) {
    if (obj.toArray) return obj.toArray();
    return ARR_SLICE.call(obj);
  },
  isUndefined: function isUndefined(obj) {
    return obj === undefined;
  },
  isNull: function isNull(obj) {
    return obj === null;
  },
  isNaN: function (_isNaN) {
    function isNaN(_x) {
      return _isNaN.apply(this, arguments);
    }
    isNaN.toString = function () {
      return _isNaN.toString();
    };
    return isNaN;
  }(function (obj) {
    return isNaN(obj);
  }),
  isArray: Array.isArray || function (obj) {
    return obj.constructor === Array;
  },
  isObject: function isObject(obj) {
    return obj === Object(obj);
  },
  isNumber: function isNumber(obj) {
    return obj === obj + 0;
  },
  isString: function isString(obj) {
    return obj === obj + '';
  },
  isBoolean: function isBoolean(obj) {
    return obj === false || obj === true;
  },
  isFunction: function isFunction(obj) {
    return obj instanceof Function;
  }
};

var INTERPRETATIONS = [
{
  litmus: Common.isString,
  conversions: {
    THREE_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
        };
      },
      write: colorToString
    },
    SIX_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9]{6})$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString(), 0)
        };
      },
      write: colorToString
    },
    CSS_RGB: {
      read: function read(original) {
        var test = original.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3])
        };
      },
      write: colorToString
    },
    CSS_RGBA: {
      read: function read(original) {
        var test = original.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3]),
          a: parseFloat(test[4])
        };
      },
      write: colorToString
    }
  }
},
{
  litmus: Common.isNumber,
  conversions: {
    HEX: {
      read: function read(original) {
        return {
          space: 'HEX',
          hex: original,
          conversionName: 'HEX'
        };
      },
      write: function write(color) {
        return color.hex;
      }
    }
  }
},
{
  litmus: Common.isArray,
  conversions: {
    RGB_ARRAY: {
      read: function read(original) {
        if (original.length !== 3) {
          return false;
        }
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b];
      }
    },
    RGBA_ARRAY: {
      read: function read(original) {
        if (original.length !== 4) return false;
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2],
          a: original[3]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b, color.a];
      }
    }
  }
},
{
  litmus: Common.isObject,
  conversions: {
    RGBA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b,
          a: color.a
        };
      }
    },
    RGB_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b
        };
      }
    },
    HSVA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v,
          a: color.a
        };
      }
    },
    HSV_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v
        };
      }
    }
  }
}];
var result = void 0;
var toReturn = void 0;
var interpret = function interpret() {
  toReturn = false;
  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
  Common.each(INTERPRETATIONS, function (family) {
    if (family.litmus(original)) {
      Common.each(family.conversions, function (conversion, conversionName) {
        result = conversion.read(original);
        if (toReturn === false && result !== false) {
          toReturn = result;
          result.conversionName = conversionName;
          result.conversion = conversion;
          return Common.BREAK;
        }
      });
      return Common.BREAK;
    }
  });
  return toReturn;
};

var tmpComponent = void 0;
var ColorMath = {
  hsv_to_rgb: function hsv_to_rgb(h, s, v) {
    var hi = Math.floor(h / 60) % 6;
    var f = h / 60 - Math.floor(h / 60);
    var p = v * (1.0 - s);
    var q = v * (1.0 - f * s);
    var t = v * (1.0 - (1.0 - f) * s);
    var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];
    return {
      r: c[0] * 255,
      g: c[1] * 255,
      b: c[2] * 255
    };
  },
  rgb_to_hsv: function rgb_to_hsv(r, g, b) {
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h = void 0;
    var s = void 0;
    if (max !== 0) {
      s = delta / max;
    } else {
      return {
        h: NaN,
        s: 0,
        v: 0
      };
    }
    if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else {
      h = 4 + (r - g) / delta;
    }
    h /= 6;
    if (h < 0) {
      h += 1;
    }
    return {
      h: h * 360,
      s: s,
      v: max / 255
    };
  },
  rgb_to_hex: function rgb_to_hex(r, g, b) {
    var hex = this.hex_with_component(0, 2, r);
    hex = this.hex_with_component(hex, 1, g);
    hex = this.hex_with_component(hex, 0, b);
    return hex;
  },
  component_from_hex: function component_from_hex(hex, componentIndex) {
    return hex >> componentIndex * 8 & 0xFF;
  },
  hex_with_component: function hex_with_component(hex, componentIndex, value) {
    return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);
  }
};

var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== 'function' && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
};

var Color = function () {
  function Color() {
    classCallCheck(this, Color);
    this.__state = interpret.apply(this, arguments);
    if (this.__state === false) {
      throw new Error('Failed to interpret color arguments');
    }
    this.__state.a = this.__state.a || 1;
  }
  createClass(Color, [{
    key: 'toString',
    value: function toString() {
      return colorToString(this);
    }
  }, {
    key: 'toHexString',
    value: function toHexString() {
      return colorToString(this, true);
    }
  }, {
    key: 'toOriginal',
    value: function toOriginal() {
      return this.__state.conversion.write(this);
    }
  }]);
  return Color;
}();
function defineRGBComponent(target, component, componentHexIndex) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'RGB') {
        return this.__state[component];
      }
      Color.recalculateRGB(this, component, componentHexIndex);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'RGB') {
        Color.recalculateRGB(this, component, componentHexIndex);
        this.__state.space = 'RGB';
      }
      this.__state[component] = v;
    }
  });
}
function defineHSVComponent(target, component) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'HSV') {
        return this.__state[component];
      }
      Color.recalculateHSV(this);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'HSV') {
        Color.recalculateHSV(this);
        this.__state.space = 'HSV';
      }
      this.__state[component] = v;
    }
  });
}
Color.recalculateRGB = function (color, component, componentHexIndex) {
  if (color.__state.space === 'HEX') {
    color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);
  } else if (color.__state.space === 'HSV') {
    Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
  } else {
    throw new Error('Corrupted color state');
  }
};
Color.recalculateHSV = function (color) {
  var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);
  Common.extend(color.__state, {
    s: result.s,
    v: result.v
  });
  if (!Common.isNaN(result.h)) {
    color.__state.h = result.h;
  } else if (Common.isUndefined(color.__state.h)) {
    color.__state.h = 0;
  }
};
Color.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];
defineRGBComponent(Color.prototype, 'r', 2);
defineRGBComponent(Color.prototype, 'g', 1);
defineRGBComponent(Color.prototype, 'b', 0);
defineHSVComponent(Color.prototype, 'h');
defineHSVComponent(Color.prototype, 's');
defineHSVComponent(Color.prototype, 'v');
Object.defineProperty(Color.prototype, 'a', {
  get: function get$$1() {
    return this.__state.a;
  },
  set: function set$$1(v) {
    this.__state.a = v;
  }
});
Object.defineProperty(Color.prototype, 'hex', {
  get: function get$$1() {
    if (this.__state.space !== 'HEX') {
      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
      this.__state.space = 'HEX';
    }
    return this.__state.hex;
  },
  set: function set$$1(v) {
    this.__state.space = 'HEX';
    this.__state.hex = v;
  }
});

var Controller = function () {
  function Controller(object, property) {
    classCallCheck(this, Controller);
    this.initialValue = object[property];
    this.domElement = document.createElement('div');
    this.object = object;
    this.property = property;
    this.__onChange = undefined;
    this.__onFinishChange = undefined;
  }
  createClass(Controller, [{
    key: 'onChange',
    value: function onChange(fnc) {
      this.__onChange = fnc;
      return this;
    }
  }, {
    key: 'onFinishChange',
    value: function onFinishChange(fnc) {
      this.__onFinishChange = fnc;
      return this;
    }
  }, {
    key: 'setValue',
    value: function setValue(newValue) {
      this.object[this.property] = newValue;
      if (this.__onChange) {
        this.__onChange.call(this, newValue);
      }
      this.updateDisplay();
      return this;
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.object[this.property];
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      return this;
    }
  }, {
    key: 'isModified',
    value: function isModified() {
      return this.initialValue !== this.getValue();
    }
  }]);
  return Controller;
}();

var EVENT_MAP = {
  HTMLEvents: ['change'],
  MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],
  KeyboardEvents: ['keydown']
};
var EVENT_MAP_INV = {};
Common.each(EVENT_MAP, function (v, k) {
  Common.each(v, function (e) {
    EVENT_MAP_INV[e] = k;
  });
});
var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;
function cssValueToPixels(val) {
  if (val === '0' || Common.isUndefined(val)) {
    return 0;
  }
  var match = val.match(CSS_VALUE_PIXELS);
  if (!Common.isNull(match)) {
    return parseFloat(match[1]);
  }
  return 0;
}
var dom = {
  makeSelectable: function makeSelectable(elem, selectable) {
    if (elem === undefined || elem.style === undefined) return;
    elem.onselectstart = selectable ? function () {
      return false;
    } : function () {};
    elem.style.MozUserSelect = selectable ? 'auto' : 'none';
    elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
    elem.unselectable = selectable ? 'on' : 'off';
  },
  makeFullscreen: function makeFullscreen(elem, hor, vert) {
    var vertical = vert;
    var horizontal = hor;
    if (Common.isUndefined(horizontal)) {
      horizontal = true;
    }
    if (Common.isUndefined(vertical)) {
      vertical = true;
    }
    elem.style.position = 'absolute';
    if (horizontal) {
      elem.style.left = 0;
      elem.style.right = 0;
    }
    if (vertical) {
      elem.style.top = 0;
      elem.style.bottom = 0;
    }
  },
  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
    var params = pars || {};
    var className = EVENT_MAP_INV[eventType];
    if (!className) {
      throw new Error('Event type ' + eventType + ' not supported.');
    }
    var evt = document.createEvent(className);
    switch (className) {
      case 'MouseEvents':
        {
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0,
          0,
          clientX,
          clientY,
          false, false, false, false, 0, null);
          break;
        }
      case 'KeyboardEvents':
        {
          var init = evt.initKeyboardEvent || evt.initKeyEvent;
          Common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
          break;
        }
      default:
        {
          evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
          break;
        }
    }
    Common.defaults(evt, aux);
    elem.dispatchEvent(evt);
  },
  bind: function bind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.addEventListener) {
      elem.addEventListener(event, func, bool);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + event, func);
    }
    return dom;
  },
  unbind: function unbind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.removeEventListener) {
      elem.removeEventListener(event, func, bool);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + event, func);
    }
    return dom;
  },
  addClass: function addClass(elem, className) {
    if (elem.className === undefined) {
      elem.className = className;
    } else if (elem.className !== className) {
      var classes = elem.className.split(/ +/);
      if (classes.indexOf(className) === -1) {
        classes.push(className);
        elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
      }
    }
    return dom;
  },
  removeClass: function removeClass(elem, className) {
    if (className) {
      if (elem.className === className) {
        elem.removeAttribute('class');
      } else {
        var classes = elem.className.split(/ +/);
        var index = classes.indexOf(className);
        if (index !== -1) {
          classes.splice(index, 1);
          elem.className = classes.join(' ');
        }
      }
    } else {
      elem.className = undefined;
    }
    return dom;
  },
  hasClass: function hasClass(elem, className) {
    return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
  },
  getWidth: function getWidth(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);
  },
  getHeight: function getHeight(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);
  },
  getOffset: function getOffset(el) {
    var elem = el;
    var offset = { left: 0, top: 0 };
    if (elem.offsetParent) {
      do {
        offset.left += elem.offsetLeft;
        offset.top += elem.offsetTop;
        elem = elem.offsetParent;
      } while (elem);
    }
    return offset;
  },
  isActive: function isActive(elem) {
    return elem === document.activeElement && (elem.type || elem.href);
  }
};

var BooleanController = function (_Controller) {
  inherits(BooleanController, _Controller);
  function BooleanController(object, property) {
    classCallCheck(this, BooleanController);
    var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));
    var _this = _this2;
    _this2.__prev = _this2.getValue();
    _this2.__checkbox = document.createElement('input');
    _this2.__checkbox.setAttribute('type', 'checkbox');
    function onChange() {
      _this.setValue(!_this.__prev);
    }
    dom.bind(_this2.__checkbox, 'change', onChange, false);
    _this2.domElement.appendChild(_this2.__checkbox);
    _this2.updateDisplay();
    return _this2;
  }
  createClass(BooleanController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      this.__prev = this.getValue();
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (this.getValue() === true) {
        this.__checkbox.setAttribute('checked', 'checked');
        this.__checkbox.checked = true;
        this.__prev = true;
      } else {
        this.__checkbox.checked = false;
        this.__prev = false;
      }
      return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return BooleanController;
}(Controller);

var OptionController = function (_Controller) {
  inherits(OptionController, _Controller);
  function OptionController(object, property, opts) {
    classCallCheck(this, OptionController);
    var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));
    var options = opts;
    var _this = _this2;
    _this2.__select = document.createElement('select');
    if (Common.isArray(options)) {
      var map = {};
      Common.each(options, function (element) {
        map[element] = element;
      });
      options = map;
    }
    Common.each(options, function (value, key) {
      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);
    });
    _this2.updateDisplay();
    dom.bind(_this2.__select, 'change', function () {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });
    _this2.domElement.appendChild(_this2.__select);
    return _this2;
  }
  createClass(OptionController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (dom.isActive(this.__select)) return this;
      this.__select.value = this.getValue();
      return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return OptionController;
}(Controller);

var StringController = function (_Controller) {
  inherits(StringController, _Controller);
  function StringController(object, property) {
    classCallCheck(this, StringController);
    var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));
    var _this = _this2;
    function onChange() {
      _this.setValue(_this.__input.value);
    }
    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'keyup', onChange);
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(StringController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (!dom.isActive(this.__input)) {
        this.__input.value = this.getValue();
      }
      return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return StringController;
}(Controller);

function numDecimals(x) {
  var _x = x.toString();
  if (_x.indexOf('.') > -1) {
    return _x.length - _x.indexOf('.') - 1;
  }
  return 0;
}
var NumberController = function (_Controller) {
  inherits(NumberController, _Controller);
  function NumberController(object, property, params) {
    classCallCheck(this, NumberController);
    var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));
    var _params = params || {};
    _this.__min = _params.min;
    _this.__max = _params.max;
    _this.__step = _params.step;
    if (Common.isUndefined(_this.__step)) {
      if (_this.initialValue === 0) {
        _this.__impliedStep = 1;
      } else {
        _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
      }
    } else {
      _this.__impliedStep = _this.__step;
    }
    _this.__precision = numDecimals(_this.__impliedStep);
    return _this;
  }
  createClass(NumberController, [{
    key: 'setValue',
    value: function setValue(v) {
      var _v = v;
      if (this.__min !== undefined && _v < this.__min) {
        _v = this.__min;
      } else if (this.__max !== undefined && _v > this.__max) {
        _v = this.__max;
      }
      if (this.__step !== undefined && _v % this.__step !== 0) {
        _v = Math.round(_v / this.__step) * this.__step;
      }
      return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);
    }
  }, {
    key: 'min',
    value: function min(minValue) {
      this.__min = minValue;
      return this;
    }
  }, {
    key: 'max',
    value: function max(maxValue) {
      this.__max = maxValue;
      return this;
    }
  }, {
    key: 'step',
    value: function step(stepValue) {
      this.__step = stepValue;
      this.__impliedStep = stepValue;
      this.__precision = numDecimals(stepValue);
      return this;
    }
  }]);
  return NumberController;
}(Controller);

function roundToDecimal(value, decimals) {
  var tenTo = Math.pow(10, decimals);
  return Math.round(value * tenTo) / tenTo;
}
var NumberControllerBox = function (_NumberController) {
  inherits(NumberControllerBox, _NumberController);
  function NumberControllerBox(object, property, params) {
    classCallCheck(this, NumberControllerBox);
    var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));
    _this2.__truncationSuspended = false;
    var _this = _this2;
    var prevY = void 0;
    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!Common.isNaN(attempted)) {
        _this.setValue(attempted);
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onBlur() {
      onFinish();
    }
    function onMouseDrag(e) {
      var diff = prevY - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);
      prevY = e.clientY;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      onFinish();
    }
    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prevY = e.clientY;
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'mousedown', onMouseDown);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
        onFinish();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(NumberControllerBox, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
      return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerBox;
}(NumberController);

function map(v, i1, i2, o1, o2) {
  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
}
var NumberControllerSlider = function (_NumberController) {
  inherits(NumberControllerSlider, _NumberController);
  function NumberControllerSlider(object, property, min, max, step) {
    classCallCheck(this, NumberControllerSlider);
    var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, { min: min, max: max, step: step }));
    var _this = _this2;
    _this2.__background = document.createElement('div');
    _this2.__foreground = document.createElement('div');
    dom.bind(_this2.__background, 'mousedown', onMouseDown);
    dom.bind(_this2.__background, 'touchstart', onTouchStart);
    dom.addClass(_this2.__background, 'slider');
    dom.addClass(_this2.__foreground, 'slider-fg');
    function onMouseDown(e) {
      document.activeElement.blur();
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      onMouseDrag(e);
    }
    function onMouseDrag(e) {
      e.preventDefault();
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
      return false;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onTouchStart(e) {
      if (e.touches.length !== 1) {
        return;
      }
      dom.bind(window, 'touchmove', onTouchMove);
      dom.bind(window, 'touchend', onTouchEnd);
      onTouchMove(e);
    }
    function onTouchMove(e) {
      var clientX = e.touches[0].clientX;
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
    }
    function onTouchEnd() {
      dom.unbind(window, 'touchmove', onTouchMove);
      dom.unbind(window, 'touchend', onTouchEnd);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.updateDisplay();
    _this2.__background.appendChild(_this2.__foreground);
    _this2.domElement.appendChild(_this2.__background);
    return _this2;
  }
  createClass(NumberControllerSlider, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var pct = (this.getValue() - this.__min) / (this.__max - this.__min);
      this.__foreground.style.width = pct * 100 + '%';
      return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerSlider;
}(NumberController);

var FunctionController = function (_Controller) {
  inherits(FunctionController, _Controller);
  function FunctionController(object, property, text) {
    classCallCheck(this, FunctionController);
    var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));
    var _this = _this2;
    _this2.__button = document.createElement('div');
    _this2.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(_this2.__button, 'click', function (e) {
      e.preventDefault();
      _this.fire();
      return false;
    });
    dom.addClass(_this2.__button, 'button');
    _this2.domElement.appendChild(_this2.__button);
    return _this2;
  }
  createClass(FunctionController, [{
    key: 'fire',
    value: function fire() {
      if (this.__onChange) {
        this.__onChange.call(this);
      }
      this.getValue().call(this.object);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
    }
  }]);
  return FunctionController;
}(Controller);

var ColorController = function (_Controller) {
  inherits(ColorController, _Controller);
  function ColorController(object, property) {
    classCallCheck(this, ColorController);
    var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));
    _this2.__color = new Color(_this2.getValue());
    _this2.__temp = new Color(0);
    var _this = _this2;
    _this2.domElement = document.createElement('div');
    dom.makeSelectable(_this2.domElement, false);
    _this2.__selector = document.createElement('div');
    _this2.__selector.className = 'selector';
    _this2.__saturation_field = document.createElement('div');
    _this2.__saturation_field.className = 'saturation-field';
    _this2.__field_knob = document.createElement('div');
    _this2.__field_knob.className = 'field-knob';
    _this2.__field_knob_border = '2px solid ';
    _this2.__hue_knob = document.createElement('div');
    _this2.__hue_knob.className = 'hue-knob';
    _this2.__hue_field = document.createElement('div');
    _this2.__hue_field.className = 'hue-field';
    _this2.__input = document.createElement('input');
    _this2.__input.type = 'text';
    _this2.__input_textShadow = '0 1px 1px ';
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        onBlur.call(this);
      }
    });
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__selector, 'mousedown', function () {
      dom.addClass(this, 'drag').bind(window, 'mouseup', function () {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    dom.bind(_this2.__selector, 'touchstart', function () {
      dom.addClass(this, 'drag').bind(window, 'touchend', function () {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    var valueField = document.createElement('div');
    Common.extend(_this2.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });
    Common.extend(_this2.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    Common.extend(_this2.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });
    Common.extend(_this2.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });
    Common.extend(valueField.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');
    Common.extend(_this2.__hue_field.style, {
      width: '15px',
      height: '100px',
      border: '1px solid #555',
      cursor: 'ns-resize',
      position: 'absolute',
      top: '3px',
      right: '3px'
    });
    hueGradient(_this2.__hue_field);
    Common.extend(_this2.__input.style, {
      outline: 'none',
      textAlign: 'center',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'
    });
    dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);
    dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);
    dom.bind(_this2.__field_knob, 'mousedown', fieldDown);
    dom.bind(_this2.__field_knob, 'touchstart', fieldDown);
    dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);
    dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);
    function fieldDown(e) {
      setSV(e);
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'touchmove', setSV);
      dom.bind(window, 'mouseup', fieldUpSV);
      dom.bind(window, 'touchend', fieldUpSV);
    }
    function fieldDownH(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'touchmove', setH);
      dom.bind(window, 'mouseup', fieldUpH);
      dom.bind(window, 'touchend', fieldUpH);
    }
    function fieldUpSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'touchmove', setSV);
      dom.unbind(window, 'mouseup', fieldUpSV);
      dom.unbind(window, 'touchend', fieldUpSV);
      onFinish();
    }
    function fieldUpH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'touchmove', setH);
      dom.unbind(window, 'mouseup', fieldUpH);
      dom.unbind(window, 'touchend', fieldUpH);
      onFinish();
    }
    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.__color.toOriginal());
      }
    }
    _this2.__saturation_field.appendChild(valueField);
    _this2.__selector.appendChild(_this2.__field_knob);
    _this2.__selector.appendChild(_this2.__saturation_field);
    _this2.__selector.appendChild(_this2.__hue_field);
    _this2.__hue_field.appendChild(_this2.__hue_knob);
    _this2.domElement.appendChild(_this2.__input);
    _this2.domElement.appendChild(_this2.__selector);
    _this2.updateDisplay();
    function setSV(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__saturation_field.getBoundingClientRect();
      var _ref = e.touches && e.touches[0] || e,
          clientX = _ref.clientX,
          clientY = _ref.clientY;
      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (v > 1) {
        v = 1;
      } else if (v < 0) {
        v = 0;
      }
      if (s > 1) {
        s = 1;
      } else if (s < 0) {
        s = 0;
      }
      _this.__color.v = v;
      _this.__color.s = s;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    function setH(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__hue_field.getBoundingClientRect();
      var _ref2 = e.touches && e.touches[0] || e,
          clientY = _ref2.clientY;
      var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (h > 1) {
        h = 1;
      } else if (h < 0) {
        h = 0;
      }
      _this.__color.h = h * 360;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    return _this2;
  }
  createClass(ColorController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var i = interpret(this.getValue());
      if (i !== false) {
        var mismatch = false;
        Common.each(Color.COMPONENTS, function (component) {
          if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
            mismatch = true;
            return {};
          }
        }, this);
        if (mismatch) {
          Common.extend(this.__color.__state, i);
        }
      }
      Common.extend(this.__temp.__state, this.__color.__state);
      this.__temp.a = 1;
      var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;
      var _flip = 255 - flip;
      Common.extend(this.__field_knob.style, {
        marginLeft: 100 * this.__color.s - 7 + 'px',
        marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
        backgroundColor: this.__temp.toHexString(),
        border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'
      });
      this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';
      this.__temp.s = 1;
      this.__temp.v = 1;
      linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());
      this.__input.value = this.__color.toString();
      Common.extend(this.__input.style, {
        backgroundColor: this.__color.toHexString(),
        color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
        textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'
      });
    }
  }]);
  return ColorController;
}(Controller);
var vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];
function linearGradient(elem, x, a, b) {
  elem.style.background = '';
  Common.each(vendors, function (vendor) {
    elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';
  });
}
function hueGradient(elem) {
  elem.style.background = '';
  elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';
  elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
}

var css = {
  load: function load(url, indoc) {
    var doc = indoc || document;
    var link = doc.createElement('link');
    link.type = 'text/css';
    link.rel = 'stylesheet';
    link.href = url;
    doc.getElementsByTagName('head')[0].appendChild(link);
  },
  inject: function inject(cssContent, indoc) {
    var doc = indoc || document;
    var injected = document.createElement('style');
    injected.type = 'text/css';
    injected.innerHTML = cssContent;
    var head = doc.getElementsByTagName('head')[0];
    try {
      head.appendChild(injected);
    } catch (e) {
    }
  }
};

var saveDialogContents = "<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>";

var ControllerFactory = function ControllerFactory(object, property) {
  var initialValue = object[property];
  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
    return new OptionController(object, property, arguments[2]);
  }
  if (Common.isNumber(initialValue)) {
    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
      if (Common.isNumber(arguments[4])) {
        return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
      }
      return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
    }
    if (Common.isNumber(arguments[4])) {
      return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });
    }
    return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });
  }
  if (Common.isString(initialValue)) {
    return new StringController(object, property);
  }
  if (Common.isFunction(initialValue)) {
    return new FunctionController(object, property, '');
  }
  if (Common.isBoolean(initialValue)) {
    return new BooleanController(object, property);
  }
  return null;
};

function requestAnimationFrame$1(callback) {
  setTimeout(callback, 1000 / 60);
}
var requestAnimationFrame$1$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame$1;

var CenteredDiv = function () {
  function CenteredDiv() {
    classCallCheck(this, CenteredDiv);
    this.backgroundElement = document.createElement('div');
    Common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear',
      transition: 'opacity 0.2s linear'
    });
    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';
    this.domElement = document.createElement('div');
    Common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
      transition: 'transform 0.2s ease-out, opacity 0.2s linear'
    });
    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);
    var _this = this;
    dom.bind(this.backgroundElement, 'click', function () {
      _this.hide();
    });
  }
  createClass(CenteredDiv, [{
    key: 'show',
    value: function show() {
      var _this = this;
      this.backgroundElement.style.display = 'block';
      this.domElement.style.display = 'block';
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
      this.layout();
      Common.defer(function () {
        _this.backgroundElement.style.opacity = 1;
        _this.domElement.style.opacity = 1;
        _this.domElement.style.webkitTransform = 'scale(1)';
      });
    }
  }, {
    key: 'hide',
    value: function hide() {
      var _this = this;
      var hide = function hide() {
        _this.domElement.style.display = 'none';
        _this.backgroundElement.style.display = 'none';
        dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
        dom.unbind(_this.domElement, 'transitionend', hide);
        dom.unbind(_this.domElement, 'oTransitionEnd', hide);
      };
      dom.bind(this.domElement, 'webkitTransitionEnd', hide);
      dom.bind(this.domElement, 'transitionend', hide);
      dom.bind(this.domElement, 'oTransitionEnd', hide);
      this.backgroundElement.style.opacity = 0;
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
    }
  }, {
    key: 'layout',
    value: function layout() {
      this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';
      this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';
    }
  }]);
  return CenteredDiv;
}();

var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");

css.inject(styleSheet);
var CSS_NAMESPACE = 'dg';
var HIDE_KEY_CODE = 72;
var CLOSE_BUTTON_HEIGHT = 20;
var DEFAULT_DEFAULT_PRESET_NAME = 'Default';
var SUPPORTS_LOCAL_STORAGE = function () {
  try {
    return !!window.localStorage;
  } catch (e) {
    return false;
  }
}();
var SAVE_DIALOGUE = void 0;
var autoPlaceVirgin = true;
var autoPlaceContainer = void 0;
var hide = false;
var hideableGuis = [];
var GUI = function GUI(pars) {
  var _this = this;
  var params = pars || {};
  this.domElement = document.createElement('div');
  this.__ul = document.createElement('ul');
  this.domElement.appendChild(this.__ul);
  dom.addClass(this.domElement, CSS_NAMESPACE);
  this.__folders = {};
  this.__controllers = [];
  this.__rememberedObjects = [];
  this.__rememberedObjectIndecesToControllers = [];
  this.__listening = [];
  params = Common.defaults(params, {
    closeOnTop: false,
    autoPlace: true,
    width: GUI.DEFAULT_WIDTH
  });
  params = Common.defaults(params, {
    resizable: params.autoPlace,
    hideable: params.autoPlace
  });
  if (!Common.isUndefined(params.load)) {
    if (params.preset) {
      params.load.preset = params.preset;
    }
  } else {
    params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };
  }
  if (Common.isUndefined(params.parent) && params.hideable) {
    hideableGuis.push(this);
  }
  params.resizable = Common.isUndefined(params.parent) && params.resizable;
  if (params.autoPlace && Common.isUndefined(params.scrollable)) {
    params.scrollable = true;
  }
  var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';
  var saveToLocalStorage = void 0;
  var titleRow = void 0;
  Object.defineProperties(this,
  {
    parent: {
      get: function get$$1() {
        return params.parent;
      }
    },
    scrollable: {
      get: function get$$1() {
        return params.scrollable;
      }
    },
    autoPlace: {
      get: function get$$1() {
        return params.autoPlace;
      }
    },
    closeOnTop: {
      get: function get$$1() {
        return params.closeOnTop;
      }
    },
    preset: {
      get: function get$$1() {
        if (_this.parent) {
          return _this.getRoot().preset;
        }
        return params.load.preset;
      },
      set: function set$$1(v) {
        if (_this.parent) {
          _this.getRoot().preset = v;
        } else {
          params.load.preset = v;
        }
        setPresetSelectIndex(this);
        _this.revert();
      }
    },
    width: {
      get: function get$$1() {
        return params.width;
      },
      set: function set$$1(v) {
        params.width = v;
        setWidth(_this, v);
      }
    },
    name: {
      get: function get$$1() {
        return params.name;
      },
      set: function set$$1(v) {
        params.name = v;
        if (titleRow) {
          titleRow.innerHTML = params.name;
        }
      }
    },
    closed: {
      get: function get$$1() {
        return params.closed;
      },
      set: function set$$1(v) {
        params.closed = v;
        if (params.closed) {
          dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
        } else {
          dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
        }
        this.onResize();
        if (_this.__closeButton) {
          _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
        }
      }
    },
    load: {
      get: function get$$1() {
        return params.load;
      }
    },
    useLocalStorage: {
      get: function get$$1() {
        return useLocalStorage;
      },
      set: function set$$1(bool) {
        if (SUPPORTS_LOCAL_STORAGE) {
          useLocalStorage = bool;
          if (bool) {
            dom.bind(window, 'unload', saveToLocalStorage);
          } else {
            dom.unbind(window, 'unload', saveToLocalStorage);
          }
          localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
        }
      }
    }
  });
  if (Common.isUndefined(params.parent)) {
    this.closed = params.closed || false;
    dom.addClass(this.domElement, GUI.CLASS_MAIN);
    dom.makeSelectable(this.domElement, false);
    if (SUPPORTS_LOCAL_STORAGE) {
      if (useLocalStorage) {
        _this.useLocalStorage = true;
        var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));
        if (savedGui) {
          params.load = JSON.parse(savedGui);
        }
      }
    }
    this.__closeButton = document.createElement('div');
    this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
    dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
    if (params.closeOnTop) {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);
      this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
    } else {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);
      this.domElement.appendChild(this.__closeButton);
    }
    dom.bind(this.__closeButton, 'click', function () {
      _this.closed = !_this.closed;
    });
  } else {
    if (params.closed === undefined) {
      params.closed = true;
    }
    var titleRowName = document.createTextNode(params.name);
    dom.addClass(titleRowName, 'controller-name');
    titleRow = addRow(_this, titleRowName);
    var onClickTitle = function onClickTitle(e) {
      e.preventDefault();
      _this.closed = !_this.closed;
      return false;
    };
    dom.addClass(this.__ul, GUI.CLASS_CLOSED);
    dom.addClass(titleRow, 'title');
    dom.bind(titleRow, 'click', onClickTitle);
    if (!params.closed) {
      this.closed = false;
    }
  }
  if (params.autoPlace) {
    if (Common.isUndefined(params.parent)) {
      if (autoPlaceVirgin) {
        autoPlaceContainer = document.createElement('div');
        dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
        dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);
        document.body.appendChild(autoPlaceContainer);
        autoPlaceVirgin = false;
      }
      autoPlaceContainer.appendChild(this.domElement);
      dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);
    }
    if (!this.parent) {
      setWidth(_this, params.width);
    }
  }
  this.__resizeHandler = function () {
    _this.onResizeDebounced();
  };
  dom.bind(window, 'resize', this.__resizeHandler);
  dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);
  dom.bind(this.__ul, 'transitionend', this.__resizeHandler);
  dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);
  this.onResize();
  if (params.resizable) {
    addResizeHandle(this);
  }
  saveToLocalStorage = function saveToLocalStorage() {
    if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }
  };
  this.saveToLocalStorageIfPossible = saveToLocalStorage;
  function resetWidth() {
    var root = _this.getRoot();
    root.width += 1;
    Common.defer(function () {
      root.width -= 1;
    });
  }
  if (!params.parent) {
    resetWidth();
  }
};
GUI.toggleHide = function () {
  hide = !hide;
  Common.each(hideableGuis, function (gui) {
    gui.domElement.style.display = hide ? 'none' : '';
  });
};
GUI.CLASS_AUTO_PLACE = 'a';
GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
GUI.CLASS_MAIN = 'main';
GUI.CLASS_CONTROLLER_ROW = 'cr';
GUI.CLASS_TOO_TALL = 'taller-than-window';
GUI.CLASS_CLOSED = 'closed';
GUI.CLASS_CLOSE_BUTTON = 'close-button';
GUI.CLASS_CLOSE_TOP = 'close-top';
GUI.CLASS_CLOSE_BOTTOM = 'close-bottom';
GUI.CLASS_DRAG = 'drag';
GUI.DEFAULT_WIDTH = 245;
GUI.TEXT_CLOSED = 'Close Controls';
GUI.TEXT_OPEN = 'Open Controls';
GUI._keydownHandler = function (e) {
  if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
    GUI.toggleHide();
  }
};
dom.bind(window, 'keydown', GUI._keydownHandler, false);
Common.extend(GUI.prototype,
{
  add: function add(object, property) {
    return _add(this, object, property, {
      factoryArgs: Array.prototype.slice.call(arguments, 2)
    });
  },
  addColor: function addColor(object, property) {
    return _add(this, object, property, {
      color: true
    });
  },
  remove: function remove(controller) {
    this.__ul.removeChild(controller.__li);
    this.__controllers.splice(this.__controllers.indexOf(controller), 1);
    var _this = this;
    Common.defer(function () {
      _this.onResize();
    });
  },
  destroy: function destroy() {
    if (this.parent) {
      throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');
    }
    if (this.autoPlace) {
      autoPlaceContainer.removeChild(this.domElement);
    }
    var _this = this;
    Common.each(this.__folders, function (subfolder) {
      _this.removeFolder(subfolder);
    });
    dom.unbind(window, 'keydown', GUI._keydownHandler, false);
    removeListeners(this);
  },
  addFolder: function addFolder(name) {
    if (this.__folders[name] !== undefined) {
      throw new Error('You already have a folder in this GUI by the' + ' name "' + name + '"');
    }
    var newGuiParams = { name: name, parent: this };
    newGuiParams.autoPlace = this.autoPlace;
    if (this.load &&
    this.load.folders &&
    this.load.folders[name]) {
      newGuiParams.closed = this.load.folders[name].closed;
      newGuiParams.load = this.load.folders[name];
    }
    var gui = new GUI(newGuiParams);
    this.__folders[name] = gui;
    var li = addRow(this, gui.domElement);
    dom.addClass(li, 'folder');
    return gui;
  },
  removeFolder: function removeFolder(folder) {
    this.__ul.removeChild(folder.domElement.parentElement);
    delete this.__folders[folder.name];
    if (this.load &&
    this.load.folders &&
    this.load.folders[folder.name]) {
      delete this.load.folders[folder.name];
    }
    removeListeners(folder);
    var _this = this;
    Common.each(folder.__folders, function (subfolder) {
      folder.removeFolder(subfolder);
    });
    Common.defer(function () {
      _this.onResize();
    });
  },
  open: function open() {
    this.closed = false;
  },
  close: function close() {
    this.closed = true;
  },
  hide: function hide() {
    this.domElement.style.display = 'none';
  },
  show: function show() {
    this.domElement.style.display = '';
  },
  onResize: function onResize() {
    var root = this.getRoot();
    if (root.scrollable) {
      var top = dom.getOffset(root.__ul).top;
      var h = 0;
      Common.each(root.__ul.childNodes, function (node) {
        if (!(root.autoPlace && node === root.__save_row)) {
          h += dom.getHeight(node);
        }
      });
      if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
        dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
      } else {
        dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = 'auto';
      }
    }
    if (root.__resize_handle) {
      Common.defer(function () {
        root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
      });
    }
    if (root.__closeButton) {
      root.__closeButton.style.width = root.width + 'px';
    }
  },
  onResizeDebounced: Common.debounce(function () {
    this.onResize();
  }, 50),
  remember: function remember() {
    if (Common.isUndefined(SAVE_DIALOGUE)) {
      SAVE_DIALOGUE = new CenteredDiv();
      SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
    }
    if (this.parent) {
      throw new Error('You can only call remember on a top level GUI.');
    }
    var _this = this;
    Common.each(Array.prototype.slice.call(arguments), function (object) {
      if (_this.__rememberedObjects.length === 0) {
        addSaveMenu(_this);
      }
      if (_this.__rememberedObjects.indexOf(object) === -1) {
        _this.__rememberedObjects.push(object);
      }
    });
    if (this.autoPlace) {
      setWidth(this, this.width);
    }
  },
  getRoot: function getRoot() {
    var gui = this;
    while (gui.parent) {
      gui = gui.parent;
    }
    return gui;
  },
  getSaveObject: function getSaveObject() {
    var toReturn = this.load;
    toReturn.closed = this.closed;
    if (this.__rememberedObjects.length > 0) {
      toReturn.preset = this.preset;
      if (!toReturn.remembered) {
        toReturn.remembered = {};
      }
      toReturn.remembered[this.preset] = getCurrentPreset(this);
    }
    toReturn.folders = {};
    Common.each(this.__folders, function (element, key) {
      toReturn.folders[key] = element.getSaveObject();
    });
    return toReturn;
  },
  save: function save() {
    if (!this.load.remembered) {
      this.load.remembered = {};
    }
    this.load.remembered[this.preset] = getCurrentPreset(this);
    markPresetModified(this, false);
    this.saveToLocalStorageIfPossible();
  },
  saveAs: function saveAs(presetName) {
    if (!this.load.remembered) {
      this.load.remembered = {};
      this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
    }
    this.load.remembered[presetName] = getCurrentPreset(this);
    this.preset = presetName;
    addPresetOption(this, presetName, true);
    this.saveToLocalStorageIfPossible();
  },
  revert: function revert(gui) {
    Common.each(this.__controllers, function (controller) {
      if (!this.getRoot().load.remembered) {
        controller.setValue(controller.initialValue);
      } else {
        recallSavedValue(gui || this.getRoot(), controller);
      }
      if (controller.__onFinishChange) {
        controller.__onFinishChange.call(controller, controller.getValue());
      }
    }, this);
    Common.each(this.__folders, function (folder) {
      folder.revert(folder);
    });
    if (!gui) {
      markPresetModified(this.getRoot(), false);
    }
  },
  listen: function listen(controller) {
    var init = this.__listening.length === 0;
    this.__listening.push(controller);
    if (init) {
      updateDisplays(this.__listening);
    }
  },
  updateDisplay: function updateDisplay() {
    Common.each(this.__controllers, function (controller) {
      controller.updateDisplay();
    });
    Common.each(this.__folders, function (folder) {
      folder.updateDisplay();
    });
  }
});
function addRow(gui, newDom, liBefore) {
  var li = document.createElement('li');
  if (newDom) {
    li.appendChild(newDom);
  }
  if (liBefore) {
    gui.__ul.insertBefore(li, liBefore);
  } else {
    gui.__ul.appendChild(li);
  }
  gui.onResize();
  return li;
}
function removeListeners(gui) {
  dom.unbind(window, 'resize', gui.__resizeHandler);
  if (gui.saveToLocalStorageIfPossible) {
    dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);
  }
}
function markPresetModified(gui, modified) {
  var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
  if (modified) {
    opt.innerHTML = opt.value + '*';
  } else {
    opt.innerHTML = opt.value;
  }
}
function augmentController(gui, li, controller) {
  controller.__li = li;
  controller.__gui = gui;
  Common.extend(controller, {
    options: function options(_options) {
      if (arguments.length > 1) {
        var nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: nextSibling,
          factoryArgs: [Common.toArray(arguments)]
        });
      }
      if (Common.isArray(_options) || Common.isObject(_options)) {
        var _nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: _nextSibling,
          factoryArgs: [_options]
        });
      }
    },
    name: function name(_name) {
      controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
      return controller;
    },
    listen: function listen() {
      controller.__gui.listen(controller);
      return controller;
    },
    remove: function remove() {
      controller.__gui.remove(controller);
      return controller;
    }
  });
  if (controller instanceof NumberControllerSlider) {
    var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });
    Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (method) {
      var pc = controller[method];
      var pb = box[method];
      controller[method] = box[method] = function () {
        var args = Array.prototype.slice.call(arguments);
        pb.apply(box, args);
        return pc.apply(controller, args);
      };
    });
    dom.addClass(li, 'has-slider');
    controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
  } else if (controller instanceof NumberControllerBox) {
    var r = function r(returned) {
      if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
        var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
        var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
        controller.remove();
        var newController = _add(gui, controller.object, controller.property, {
          before: controller.__li.nextElementSibling,
          factoryArgs: [controller.__min, controller.__max, controller.__step]
        });
        newController.name(oldName);
        if (wasListening) newController.listen();
        return newController;
      }
      return returned;
    };
    controller.min = Common.compose(r, controller.min);
    controller.max = Common.compose(r, controller.max);
  } else if (controller instanceof BooleanController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__checkbox, 'click');
    });
    dom.bind(controller.__checkbox, 'click', function (e) {
      e.stopPropagation();
    });
  } else if (controller instanceof FunctionController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__button, 'click');
    });
    dom.bind(li, 'mouseover', function () {
      dom.addClass(controller.__button, 'hover');
    });
    dom.bind(li, 'mouseout', function () {
      dom.removeClass(controller.__button, 'hover');
    });
  } else if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
    controller.updateDisplay = Common.compose(function (val) {
      li.style.borderLeftColor = controller.__color.toString();
      return val;
    }, controller.updateDisplay);
    controller.updateDisplay();
  }
  controller.setValue = Common.compose(function (val) {
    if (gui.getRoot().__preset_select && controller.isModified()) {
      markPresetModified(gui.getRoot(), true);
    }
    return val;
  }, controller.setValue);
}
function recallSavedValue(gui, controller) {
  var root = gui.getRoot();
  var matchedIndex = root.__rememberedObjects.indexOf(controller.object);
  if (matchedIndex !== -1) {
    var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];
    if (controllerMap === undefined) {
      controllerMap = {};
      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
    }
    controllerMap[controller.property] = controller;
    if (root.load && root.load.remembered) {
      var presetMap = root.load.remembered;
      var preset = void 0;
      if (presetMap[gui.preset]) {
        preset = presetMap[gui.preset];
      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
      } else {
        return;
      }
      if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {
        var value = preset[matchedIndex][controller.property];
        controller.initialValue = value;
        controller.setValue(value);
      }
    }
  }
}
function _add(gui, object, property, params) {
  if (object[property] === undefined) {
    throw new Error('Object "' + object + '" has no property "' + property + '"');
  }
  var controller = void 0;
  if (params.color) {
    controller = new ColorController(object, property);
  } else {
    var factoryArgs = [object, property].concat(params.factoryArgs);
    controller = ControllerFactory.apply(gui, factoryArgs);
  }
  if (params.before instanceof Controller) {
    params.before = params.before.__li;
  }
  recallSavedValue(gui, controller);
  dom.addClass(controller.domElement, 'c');
  var name = document.createElement('span');
  dom.addClass(name, 'property-name');
  name.innerHTML = controller.property;
  var container = document.createElement('div');
  container.appendChild(name);
  container.appendChild(controller.domElement);
  var li = addRow(gui, container, params.before);
  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
  if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
  } else {
    dom.addClass(li, _typeof(controller.getValue()));
  }
  augmentController(gui, li, controller);
  gui.__controllers.push(controller);
  return controller;
}
function getLocalStorageHash(gui, key) {
  return document.location.href + '.' + key;
}
function addPresetOption(gui, name, setSelected) {
  var opt = document.createElement('option');
  opt.innerHTML = name;
  opt.value = name;
  gui.__preset_select.appendChild(opt);
  if (setSelected) {
    gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
  }
}
function showHideExplain(gui, explain) {
  explain.style.display = gui.useLocalStorage ? 'block' : 'none';
}
function addSaveMenu(gui) {
  var div = gui.__save_row = document.createElement('li');
  dom.addClass(gui.domElement, 'has-save');
  gui.__ul.insertBefore(div, gui.__ul.firstChild);
  dom.addClass(div, 'save-row');
  var gears = document.createElement('span');
  gears.innerHTML = '&nbsp;';
  dom.addClass(gears, 'button gears');
  var button = document.createElement('span');
  button.innerHTML = 'Save';
  dom.addClass(button, 'button');
  dom.addClass(button, 'save');
  var button2 = document.createElement('span');
  button2.innerHTML = 'New';
  dom.addClass(button2, 'button');
  dom.addClass(button2, 'save-as');
  var button3 = document.createElement('span');
  button3.innerHTML = 'Revert';
  dom.addClass(button3, 'button');
  dom.addClass(button3, 'revert');
  var select = gui.__preset_select = document.createElement('select');
  if (gui.load && gui.load.remembered) {
    Common.each(gui.load.remembered, function (value, key) {
      addPresetOption(gui, key, key === gui.preset);
    });
  } else {
    addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
  }
  dom.bind(select, 'change', function () {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
    }
    gui.preset = this.value;
  });
  div.appendChild(select);
  div.appendChild(gears);
  div.appendChild(button);
  div.appendChild(button2);
  div.appendChild(button3);
  if (SUPPORTS_LOCAL_STORAGE) {
    var explain = document.getElementById('dg-local-explain');
    var localStorageCheckBox = document.getElementById('dg-local-storage');
    var saveLocally = document.getElementById('dg-save-locally');
    saveLocally.style.display = 'block';
    if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
      localStorageCheckBox.setAttribute('checked', 'checked');
    }
    showHideExplain(gui, explain);
    dom.bind(localStorageCheckBox, 'change', function () {
      gui.useLocalStorage = !gui.useLocalStorage;
      showHideExplain(gui, explain);
    });
  }
  var newConstructorTextArea = document.getElementById('dg-new-constructor');
  dom.bind(newConstructorTextArea, 'keydown', function (e) {
    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
      SAVE_DIALOGUE.hide();
    }
  });
  dom.bind(gears, 'click', function () {
    newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
    SAVE_DIALOGUE.show();
    newConstructorTextArea.focus();
    newConstructorTextArea.select();
  });
  dom.bind(button, 'click', function () {
    gui.save();
  });
  dom.bind(button2, 'click', function () {
    var presetName = prompt('Enter a new preset name.');
    if (presetName) {
      gui.saveAs(presetName);
    }
  });
  dom.bind(button3, 'click', function () {
    gui.revert();
  });
}
function addResizeHandle(gui) {
  var pmouseX = void 0;
  gui.__resize_handle = document.createElement('div');
  Common.extend(gui.__resize_handle.style, {
    width: '6px',
    marginLeft: '-3px',
    height: '200px',
    cursor: 'ew-resize',
    position: 'absolute'
  });
  function drag(e) {
    e.preventDefault();
    gui.width += pmouseX - e.clientX;
    gui.onResize();
    pmouseX = e.clientX;
    return false;
  }
  function dragStop() {
    dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.unbind(window, 'mousemove', drag);
    dom.unbind(window, 'mouseup', dragStop);
  }
  function dragStart(e) {
    e.preventDefault();
    pmouseX = e.clientX;
    dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.bind(window, 'mousemove', drag);
    dom.bind(window, 'mouseup', dragStop);
    return false;
  }
  dom.bind(gui.__resize_handle, 'mousedown', dragStart);
  dom.bind(gui.__closeButton, 'mousedown', dragStart);
  gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);
}
function setWidth(gui, w) {
  gui.domElement.style.width = w + 'px';
  if (gui.__save_row && gui.autoPlace) {
    gui.__save_row.style.width = w + 'px';
  }
  if (gui.__closeButton) {
    gui.__closeButton.style.width = w + 'px';
  }
}
function getCurrentPreset(gui, useInitialValues) {
  var toReturn = {};
  Common.each(gui.__rememberedObjects, function (val, index) {
    var savedValues = {};
    var controllerMap = gui.__rememberedObjectIndecesToControllers[index];
    Common.each(controllerMap, function (controller, property) {
      savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
    });
    toReturn[index] = savedValues;
  });
  return toReturn;
}
function setPresetSelectIndex(gui) {
  for (var index = 0; index < gui.__preset_select.length; index++) {
    if (gui.__preset_select[index].value === gui.preset) {
      gui.__preset_select.selectedIndex = index;
    }
  }
}
function updateDisplays(controllerArray) {
  if (controllerArray.length !== 0) {
    requestAnimationFrame$1$1.call(window, function () {
      updateDisplays(controllerArray);
    });
  }
  Common.each(controllerArray, function (c) {
    c.updateDisplay();
  });
}

var color = {
  Color: Color,
  math: ColorMath,
  interpret: interpret
};
var controllers = {
  Controller: Controller,
  BooleanController: BooleanController,
  OptionController: OptionController,
  StringController: StringController,
  NumberController: NumberController,
  NumberControllerBox: NumberControllerBox,
  NumberControllerSlider: NumberControllerSlider,
  FunctionController: FunctionController,
  ColorController: ColorController
};
var dom$1 = { dom: dom };
var gui = { GUI: GUI };
var GUI$1 = GUI;
var index = {
  color: color,
  controllers: controllers,
  dom: dom$1,
  gui: gui,
  GUI: GUI$1
};

var dat_gui = /*#__PURE__*/Object.freeze({
__proto__: null,
color: color,
controllers: controllers,
dom: dom$1,
gui: gui,
GUI: GUI$1,
'default': index
});

/** @summary Draw TText
  * @private */
async function drawText$1() {
   let text = this.getObject(),
       pp = this.getPadPainter(),
       w = pp.getPadWidth(),
       h = pp.getPadHeight(),
       pos_x = text.fX, pos_y = text.fY,
       tcolor = this.getColor(text.fTextColor),
       use_frame = false,
       fact = 1., textsize = text.fTextSize || 0.05,
       main = this.getFramePainter();

   if (text.TestBit(BIT(14))) {
      // NDC coordinates
      this.isndc = true;
   } else if (main && !main.mode3d) {
      // frame coordiantes
      w = main.getFrameWidth();
      h = main.getFrameHeight();
      use_frame = 'upper_layer';
   } else if (pp.getRootPad(true)) ; else {
      // place in the middle
      this.isndc = true;
      pos_x = pos_y = 0.5;
      text.fTextAlign = 22;
      if (!tcolor) tcolor = 'black';
   }

   this.createG(use_frame);

   this.draw_g.attr('transform', null); // remove transofrm from interactive changes

   this.pos_x = this.axisToSvg('x', pos_x, this.isndc);
   this.pos_y = this.axisToSvg('y', pos_y, this.isndc);

   let arg = { align: text.fTextAlign, x: this.pos_x, y: this.pos_y, text: text.fTitle, color: tcolor, latex: 0 };

   if (text.fTextAngle) arg.rotate = -text.fTextAngle;

   if (text._typename == clTLatex) {
      arg.latex = 1;
      fact = 0.9;
   } else if (text._typename == clTMathText) {
      arg.latex = 2;
      fact = 0.8;
   }

   this.startTextDrawing(text.fTextFont, Math.round((textsize > 1) ? textsize : textsize*Math.min(w,h)*fact));

   this.drawText(arg);

   return this.finishTextDrawing().then(() => {
      if (isBatchMode()) return this;

      this.pos_dx = this.pos_dy = 0;

      if (!this.moveDrag)
         this.moveDrag = function(dx,dy) {
            this.pos_dx += dx;
            this.pos_dy += dy;
            this.draw_g.attr('transform', `translate(${this.pos_dx},${this.pos_dy})`);
        };

      if (!this.moveEnd)
         this.moveEnd = function(not_changed) {
            if (not_changed) return;
            let text = this.getObject();
            text.fX = this.svgToAxis('x', this.pos_x + this.pos_dx, this.isndc),
            text.fY = this.svgToAxis('y', this.pos_y + this.pos_dy, this.isndc);
            this.submitCanvExec(`SetX(${text.fX});;SetY(${text.fY});;`);
         };

      addMoveHandler(this);

      return this;
   });
}

/** @summary Draw TLine
  * @private */
async function drawTLine(dom, obj) {
   let painter = new ObjectPainter(dom, obj);

   painter.redraw = function() {
      const kLineNDC = BIT(14),
            line = this.getObject(),
            lineatt = new TAttLineHandler(line),
            isndc = line.TestBit(kLineNDC);

      this.createG();

      this.draw_g
          .append('svg:path')
          .attr('d', `M${this.axisToSvg('x',line.fX1,isndc)},${this.axisToSvg('y',line.fY1,isndc)}L${this.axisToSvg('x',line.fX2,isndc)},${this.axisToSvg('y',line.fY2,isndc)}`)
          .call(lineatt.func);

      return this;
   };

   return ensureTCanvas(painter, false).then(() => painter.redraw());
}

/** @summary Draw TPolyLine
  * @private */
function drawPolyLine() {

   this.createG();

   let polyline = this.getObject(),
       lineatt = new TAttLineHandler(polyline),
       fillatt = this.createAttFill(polyline),
       kPolyLineNDC = BIT(14),
       isndc = polyline.TestBit(kPolyLineNDC),
       cmd = '', func = this.getAxisToSvgFunc(isndc);

   for (let n = 0; n <= polyline.fLastPoint; ++n)
      cmd += `${n>0?'L':'M'}${func.x(polyline.fX[n])},${func.y(polyline.fY[n])}`;

   if (polyline._typename != clTPolyLine)
      fillatt.setSolidColor('none');

   if (!fillatt.empty())
      cmd += 'Z';

   this.draw_g
       .append('svg:path')
       .attr('d', cmd)
       .call(lineatt.func)
       .call(fillatt.func);
}

/** @summary Draw TEllipse
  * @private */
function drawEllipse() {

   let ellipse = this.getObject();

   this.createAttLine({ attr: ellipse });
   this.createAttFill({ attr: ellipse });

   this.createG();

   let funcs = this.getAxisToSvgFunc(),
       x = funcs.x(ellipse.fX1),
       y = funcs.y(ellipse.fY1),
       rx = funcs.x(ellipse.fX1 + ellipse.fR1) - x,
       ry = y - funcs.y(ellipse.fY1 + ellipse.fR2),
       path = '', closed_ellipse = (ellipse.fPhimin == 0) && (ellipse.fPhimax == 360);

   // handle same as ellipse with equal radius
   if ((ellipse._typename == 'TCrown') && (ellipse.fR1 <= 0))
      rx = funcs.x(ellipse.fX1 + ellipse.fR2) - x;

   if ((ellipse._typename == 'TCrown') && (ellipse.fR1 > 0)) {
      let rx1 = rx, ry2 = ry,
          ry1 = y - funcs.y(ellipse.fY1 + ellipse.fR1),
          rx2 = funcs.x(ellipse.fX1 + ellipse.fR2) - x;

      if (closed_ellipse) {
         path = `M${-rx1},0A${rx1},${ry1},0,1,0,${rx1},0A${rx1},${ry1},0,1,0,${-rx1},0` +
                `M${-rx2},0A${rx2},${ry2},0,1,0,${rx2},0A${rx2},${ry2},0,1,0,${-rx2},0`;
      } else {
         let large_arc = (ellipse.fPhimax-ellipse.fPhimin>=180) ? 1 : 0,
             a1 = ellipse.fPhimin*Math.PI/180, a2 = ellipse.fPhimax*Math.PI/180,
             dx1 = Math.round(rx1*Math.cos(a1)), dy1 = Math.round(ry1*Math.sin(a1)),
             dx2 = Math.round(rx1*Math.cos(a2)), dy2 = Math.round(ry1*Math.sin(a2)),
             dx3 = Math.round(rx2*Math.cos(a1)), dy3 = Math.round(ry2*Math.sin(a1)),
             dx4 = Math.round(rx2*Math.cos(a2)), dy4 = Math.round(ry2*Math.sin(a2));

         path = `M${dx2},${dy2}A${rx1},${ry1},0,${large_arc},0,${dx1},${dy1}` +
                `L${dx3},${dy3}A${rx2},${ry2},0,${large_arc},1,${dx4},${dy4}Z`;
      }
   } else if (ellipse.fTheta == 0) {
      if (closed_ellipse) {
         path = `M${-rx},0A${rx},${ry},0,1,0,${rx},0A${rx},${ry},0,1,0,${-rx},0Z`;
      } else {
         let x1 = Math.round(rx * Math.cos(ellipse.fPhimin*Math.PI/180)),
             y1 = Math.round(ry * Math.sin(ellipse.fPhimin*Math.PI/180)),
             x2 = Math.round(rx * Math.cos(ellipse.fPhimax*Math.PI/180)),
             y2 = Math.round(ry * Math.sin(ellipse.fPhimax*Math.PI/180));
         path = `M0,0L${x1},${y1}A${rx},${ry},0,1,1,${x2},${y2}Z`;
      }
   } else {
     let ct = Math.cos(ellipse.fTheta*Math.PI/180),
         st = Math.sin(ellipse.fTheta*Math.PI/180),
         phi1 = ellipse.fPhimin*Math.PI/180,
         phi2 = ellipse.fPhimax*Math.PI/180,
         np = 200,
         dphi = (phi2-phi1) / (np - (closed_ellipse ? 0 : 1)),
         lastx = 0, lasty = 0;
     if (!closed_ellipse) path = 'M0,0';
     for (let n = 0; n < np; ++n) {
         let angle = phi1 + n*dphi,
             dx = ellipse.fR1 * Math.cos(angle),
             dy = ellipse.fR2 * Math.sin(angle),
             px = funcs.x(ellipse.fX1 + dx*ct - dy*st) - x,
             py = funcs.y(ellipse.fY1 + dx*st + dy*ct) - y;
         if (!path)
            path = `M${px},${py}`;
         else if (lastx == px)
            path += `v${py-lasty}`;
         else if (lasty == py)
            path += `h${px-lastx}`;
         else
            path += `l${px-lastx},${py-lasty}`;
         lastx = px; lasty = py;
     }
     path += 'Z';
   }

   this.draw_g
      .append('svg:path')
      .attr('transform',`translate(${x},${y})`)
      .attr('d', path)
      .call(this.lineatt.func).call(this.fillatt.func);
}

/** @summary Draw TPie
  * @private */
function drawPie() {
   let pie = this.getObject();

   this.createG();

   let xc = this.axisToSvg('x', pie.fX),
       yc = this.axisToSvg('y', pie.fY),
       rx = this.axisToSvg('x', pie.fX + pie.fRadius) - xc,
       ry = this.axisToSvg('y', pie.fY + pie.fRadius) - yc;

   this.draw_g.attr('transform', `translate(${xc},${yc})`);

   // Draw the slices
   let nb = pie.fPieSlices.length, total = 0,
       af = (pie.fAngularOffset*Math.PI)/180,
       x1 = Math.round(rx*Math.cos(af)),
       y1 = Math.round(ry*Math.sin(af));

   for (let n = 0; n < nb; n++)
      total += pie.fPieSlices[n].fValue;

   for (let n = 0; n < nb; n++) {
      let slice = pie.fPieSlices[n],
          lineatt = new TAttLineHandler({attr: slice}),
          fillatt = this.createAttFill(slice);

      af += slice.fValue/total*2*Math.PI;
      let x2 = Math.round(rx*Math.cos(af)), y2 = Math.round(ry*Math.sin(af));

      this.draw_g
          .append('svg:path')
          .attr('d', `M0,0L${x1},${y1}A${rx},${ry},0,0,0,${x2},${y2}z`)
          .call(lineatt.func)
          .call(fillatt.func);
      x1 = x2; y1 = y2;
   }
}

/** @summary Draw TBox
  * @private */
function drawBox$1() {
   let box = this.getObject(),
       opt = this.getDrawOpt(),
       draw_line = (opt.toUpperCase().indexOf('L') >= 0),
       lineatt = this.createAttLine(box),
       fillatt = this.createAttFill(box);

   this.createG();

   let x1 = this.axisToSvg('x', box.fX1),
       x2 = this.axisToSvg('x', box.fX2),
       y1 = this.axisToSvg('y', box.fY1),
       y2 = this.axisToSvg('y', box.fY2),
       xx = Math.min(x1,x2), yy = Math.min(y1,y2),
       ww = Math.abs(x2-x1), hh = Math.abs(y1-y2);

   // if box filled, contour line drawn only with 'L' draw option:
   if (!fillatt.empty() && !draw_line) lineatt.color = 'none';

   this.draw_g
       .append('svg:path')
       .attr('d', `M${xx},${yy}h${ww}v${hh}h${-ww}z`)
       .call(lineatt.func)
       .call(fillatt.func);

   if (box.fBorderMode && box.fBorderSize && fillatt.hasColor()) {
      let pww = box.fBorderSize, phh = box.fBorderSize,
          side1 = `M${xx},${yy}h${ww}l${-pww},${phh}h${2*pww-ww}v${hh-2*phh}l${-pww},${phh}z`,
          side2 = `M${xx+ww},${yy+hh}v${-hh}l${-pww},${phh}v${hh-2*phh}h${2*pww-ww}l${-pww},${phh}z`;

      if (box.fBorderMode < 0) { let s = side1; side1 = side2; side2 = s; }

      this.draw_g.append('svg:path')
                 .attr('d', side1)
                 .call(fillatt.func)
                 .style('fill', rgb(fillatt.color).brighter(0.5).formatHex());

      this.draw_g.append('svg:path')
          .attr('d', side2)
          .call(fillatt.func)
          .style('fill', rgb(fillatt.color).darker(0.5).formatHex());
   }
}

/** @summary Draw TMarker
  * @private */
function drawMarker$1() {
   const marker = this.getObject(),
         att = new TAttMarkerHandler(marker),
         kMarkerNDC = BIT(14),
         isndc = marker.TestBit(kMarkerNDC);

   this.createG();

   let x = this.axisToSvg('x', marker.fX, isndc),
       y = this.axisToSvg('y', marker.fY, isndc),
       path = att.create(x, y);

   if (path)
      this.draw_g.append('svg:path')
          .attr('d', path)
          .call(att.func);
}

/** @summary Draw TPolyMarker
  * @private */
function drawPolyMarker() {
   this.createG();

   let poly = this.getObject(),
       att = new TAttMarkerHandler(poly),
       path = '',
       func = this.getAxisToSvgFunc();

   for (let n = 0; n < poly.fN; ++n)
      path += att.create(func.x(poly.fX[n]), func.y(poly.fY[n]));

   if (path)
      this.draw_g.append('svg:path')
          .attr('d', path)
          .call(att.func);
}

/** @summary Draw JS image
  * @private */
function drawJSImage(dom, obj, opt) {
   let painter = new BasePainter(dom),
       main = painter.selectDom(),
       img = main.append('img').attr('src', obj.fName).attr('title', obj.fTitle || obj.fName);

   if (opt && opt.indexOf('scale') >= 0) {
      img.style('width','100%').style('height','100%');
   } else if (opt && opt.indexOf('center') >= 0) {
      main.style('position', 'relative');
      img.attr('style', 'margin: 0; position: absolute;  top: 50%; left: 50%; transform: translate(-50%, -50%);');
   }

   painter.setTopPainter();

   return painter;
}

var more = /*#__PURE__*/Object.freeze({
__proto__: null,
drawText: drawText$1,
drawTLine: drawTLine,
drawPolyLine: drawPolyLine,
drawEllipse: drawEllipse,
drawPie: drawPie,
drawBox: drawBox$1,
drawMarker: drawMarker$1,
drawPolyMarker: drawPolyMarker,
drawJSImage: drawJSImage
});

/**
 * @summary Painter class for THStack
 *
 * @private
 */

class THStackPainter extends ObjectPainter {

   /** @summary constructor
     * @param {object|string} dom - DOM element for drawing or element id
     * @param {object} stack - THStack object
     * @param {string} [opt] - draw options */
   constructor(dom, stack, opt) {
      super(dom, stack, opt);
      this.firstpainter = null;
      this.painters = []; // keep painters to be able update objects
   }

   /** @summary Cleanup THStack painter */
   cleanup() {
      this.getPadPainter()?.cleanPrimitives(objp => { return (objp === this.firstpainter) || (this.painters.indexOf(objp) >= 0); });
      delete this.firstpainter;
      delete this.painters;
      super.cleanup();
   }

   /** @summary Build sum of all histograms
     * @desc Build a separate list fStack containing the running sum of all histograms */
   buildStack(stack) {
      if (!stack.fHists) return false;
      let nhists = stack.fHists.arr.length;
      if (nhists <= 0) return false;
      let lst = create$1(clTList);
      lst.Add(clone(stack.fHists.arr[0]), stack.fHists.opt[0]);
      for (let i = 1; i < nhists; ++i) {
         let hnext = clone(stack.fHists.arr[i]),
             hnextopt = stack.fHists.opt[i],
             hprev = lst.arr[i-1];

         if ((hnext.fNbins != hprev.fNbins) ||
             (hnext.fXaxis.fXmin != hprev.fXaxis.fXmin) ||
             (hnext.fXaxis.fXmax != hprev.fXaxis.fXmax)) {
            console.warn(`When drawing THStack, cannot sum-up histograms ${hnext.fName} and ${hprev.fName}`);
            lst.Clear();
            return false;
         }

         // trivial sum of histograms
         for (let n = 0; n < hnext.fArray.length; ++n)
            hnext.fArray[n] += hprev.fArray[n];

         lst.Add(hnext, hnextopt);
      }
      stack.fStack = lst;
      return true;
   }

   /** @summary Returns stack min/max values */
   getMinMax(iserr) {
      let min = 0, max = 0,
          stack = this.getObject(),
          pad = this.getPadPainter().getRootPad(true);

      const getHistMinMax = (hist, witherr) => {
         let res = { min: 0, max: 0 },
             domin = true, domax = true;
         if (hist.fMinimum !== kNoZoom) {
            res.min = hist.fMinimum;
            domin = false;
         }
         if (hist.fMaximum !== kNoZoom) {
            res.max = hist.fMaximum;
            domax = false;
         }

         if (!domin && !domax) return res;

         let i1 = 1, i2 = hist.fXaxis.fNbins, j1 = 1, j2 = 1, first = true;

         if (hist.fXaxis.TestBit(EAxisBits.kAxisRange)) {
            i1 = hist.fXaxis.fFirst;
            i2 = hist.fXaxis.fLast;
         }

         if (hist._typename.indexOf(clTH2) === 0) {
            j2 = hist.fYaxis.fNbins;
            if (hist.fYaxis.TestBit(EAxisBits.kAxisRange)) {
               j1 = hist.fYaxis.fFirst;
               j2 = hist.fYaxis.fLast;
            }
         }
         for (let j = j1; j <= j2; ++j)
            for (let i = i1; i <= i2; ++i) {
               let val = hist.getBinContent(i, j),
                   err = witherr ? hist.getBinError(hist.getBin(i,j)) : 0;
               if (domin && (first || (val-err < res.min))) res.min = val-err;
               if (domax && (first || (val+err > res.max))) res.max = val+err;
               first = false;
           }

         return res;
      };

      if (this.options.nostack) {
         for (let i = 0; i < stack.fHists.arr.length; ++i) {
            let resh = getHistMinMax(stack.fHists.arr[i], iserr);
            if (i == 0) {
               min = resh.min; max = resh.max;
             } else {
               min = Math.min(min, resh.min);
               max = Math.max(max, resh.max);
            }
         }
      } else {
         min = getHistMinMax(stack.fStack.arr[0], iserr).min;
         max = getHistMinMax(stack.fStack.arr[stack.fStack.arr.length-1], iserr).max;
      }

      const adjustRange = () => {
         if (pad && (this.options.ndim == 1 ? pad.fLogy : pad.fLogz)) {
            if (max <= 0) max = 1;
            if (min <= 0) min = 1e-4*max;
            let kmin = 1/(1 + 0.5*Math.log10(max / min)),
                kmax = 1 + 0.2*Math.log10(max / min);
            min *= kmin;
            max *= kmax;
         } else if ((min > 0) && (min < 0.05*max)) {
            min = 0;
         }
      };

      max *= (1 + gStyle.fHistTopMargin);

      adjustRange();

      let max0 = max, min0 = min, zoomed = false;

      if (stack.fMaximum != kNoZoom) {
         max = stack.fMaximum;
         max0 = Math.max(max, max0);
         zoomed = true;
      }

      if (stack.fMinimum != kNoZoom) {
         min = stack.fMinimum;
         min0 = Math.min(min, min0);
         zoomed = true;
      }

      if (zoomed)
         adjustRange();
      else
         min = max = kNoZoom;

      return { min, max, min0, max0, zoomed, hopt: `hmin:${min0};hmax:${max0};minimum:${min};maximum:${max}` };
   }

   /** @summary Draw next stack histogram */
   async drawNextHisto(indx, pad_painter) {

      let stack = this.getObject(),
          hlst = this.options.nostack ? stack.fHists : stack.fStack,
          nhists = hlst?.arr?.length || 0;

      if (indx >= nhists)
         return this;

      let rindx = this.options.horder ? indx : nhists-indx-1,
          hist = hlst.arr[rindx],
          hopt = hlst.opt[rindx] || hist.fOption || this.options.hopt;

      if (hopt.toUpperCase().indexOf(this.options.hopt) < 0)
         hopt += ' ' + this.options.hopt;
      if (this.options.draw_errors && !hopt)
         hopt = 'E';

      if (this.options._pfc || this.options._plc || this.options._pmc) {
         let mp = this.getMainPainter();
         if (isFunc(mp?.createAutoColor)) {
            let icolor = mp.createAutoColor(nhists);
            if (this.options._pfc) hist.fFillColor = icolor;
            if (this.options._plc) hist.fLineColor = icolor;
            if (this.options._pmc) hist.fMarkerColor = icolor;
         }
      }

      // handling of 'pads' draw option
      if (pad_painter) {
         let subpad_painter = pad_painter.getSubPadPainter(indx+1);
         if (!subpad_painter)
            return this;

         let prev_name = subpad_painter.selectCurrentPad(subpad_painter.this_pad_name);

         return this.hdraw_func(subpad_painter.getDom(), hist, hopt).then(subp => {
            this.painters.push(subp);
            subpad_painter.selectCurrentPad(prev_name);
            return this.drawNextHisto(indx+1, pad_painter);
         });
      }

      // special handling of stacked histograms - set $baseh object for correct drawing
      // also used to provide tooltips
      if ((rindx > 0) && !this.options.nostack)
         hist.$baseh = hlst.arr[rindx - 1];

      return this.hdraw_func(this.getDom(), hist, hopt + ' same nostat').then(subp => {
          this.painters.push(subp);
          return this.drawNextHisto(indx+1, pad_painter);
      });
   }

   /** @summary Decode draw options of THStack painter */
   decodeOptions(opt) {
      if (!this.options) this.options = {};
      Object.assign(this.options, { ndim: 1, nostack: false, same: false, horder: true, has_errors: false, draw_errors: false, hopt: '' });

      let stack = this.getObject(),
          hist = stack.fHistogram || (stack.fHists ? stack.fHists.arr[0] : null) || (stack.fStack ? stack.fStack.arr[0] : null);

      const hasErrors = hist => {
         if (hist.fSumw2 && (hist.fSumw2.length > 0))
            for (let n = 0; n < hist.fSumw2.length; ++n)
               if (hist.fSumw2[n] > 0) return true;
         return false;
      };

      if (hist && (hist._typename.indexOf(clTH2) == 0))
         this.options.ndim = 2;

      if ((this.options.ndim == 2) && !opt)
         opt = 'lego1';

      if (stack.fHists && !this.options.nostack)
         for (let k = 0; k < stack.fHists.arr.length; ++k)
            this.options.has_errors = this.options.has_errors || hasErrors(stack.fHists.arr[k]);

      this.options.nhist = stack.fHists ? stack.fHists.arr.length : 1;

      let d = new DrawOptions(opt);

      this.options.nostack = d.check('NOSTACK');
      if (d.check('STACK')) this.options.nostack = false;
      this.options.same = d.check('SAME');

      d.check('NOCLEAR'); // ignore noclear option

      this.options._pfc = d.check('PFC');
      this.options._plc = d.check('PLC');
      this.options._pmc = d.check('PMC');

      this.options.pads = d.check('PADS');
      if (this.options.pads) this.options.nostack = true;

      this.options.hopt = d.remain(); // use remaining draw options for histogram draw

      let dolego = d.check('LEGO');

      this.options.errors = d.check('E');

      // if any histogram appears with pre-calculated errors, use E for all histograms
      if (!this.options.nostack && this.options.has_errors && !dolego && !d.check('HIST') && (this.options.hopt.indexOf('E') < 0))
         this.options.draw_errors = true;

      this.options.horder = this.options.nostack || dolego;
   }

   /** @summary Create main histogram for THStack axis drawing */
   createHistogram(stack) {
      let histos = stack.fHists,
          numhistos = histos ? histos.arr.length : 0;

      if (!numhistos) {
         let histo = createHistogram('TH1I', 100);
         histo.fTitle = stack.fTitle;
         return histo;
      }

      let h0 = histos.arr[0],
          histo = createHistogram((this.options.ndim == 1) ? 'TH1I' : 'TH2I', h0.fXaxis.fNbins, h0.fYaxis.fNbins);
      histo.fName = 'axis_hist';
      Object.assign(histo.fXaxis, h0.fXaxis);
      if (this.options.ndim==2)
         Object.assign(histo.fYaxis, h0.fYaxis);

      // this code is not exists in ROOT painter, can be skipped?
      for (let n = 1; n < numhistos; ++n) {
         let h = histos.arr[n];

         if (!histo.fXaxis.fLabels) {
            histo.fXaxis.fXmin = Math.min(histo.fXaxis.fXmin, h.fXaxis.fXmin);
            histo.fXaxis.fXmax = Math.max(histo.fXaxis.fXmax, h.fXaxis.fXmax);
         }

         if ((this.options.ndim==2) && !histo.fYaxis.fLabels) {
            histo.fYaxis.fXmin = Math.min(histo.fYaxis.fXmin, h.fYaxis.fXmin);
            histo.fYaxis.fXmax = Math.max(histo.fYaxis.fXmax, h.fYaxis.fXmax);
         }
      }

      histo.fTitle = stack.fTitle;

      return histo;
   }

   /** @summary Update thstack object */
   updateObject(obj) {
      if (!this.matchObjectType(obj)) return false;

      let stack = this.getObject();

      stack.fHists = obj.fHists;
      stack.fStack = obj.fStack;
      stack.fTitle = obj.fTitle;
      stack.fMinimum = obj.fMinimum;
      stack.fMaximum = obj.fMaximum;

      if (!this.options.nostack)
         this.options.nostack = !this.buildStack(stack);

      if (this.firstpainter) {
         let src = obj.fHistogram;
         if (!src)
            src = stack.fHistogram = this.createHistogram(stack);

         let mm = this.getMinMax(this.options.errors || this.options.draw_errors);

         this.firstpainter.options.minimum = mm.min;
         this.firstpainter.options.maximum = mm.max;
         this.firstpainter._checked_zooming = false; // force to check 3d zooming

         if (this.options.ndim == 1) {
            this.firstpainter.ymin = mm.min0;
            this.firstpainter.ymax = mm.max0;
         } else {
            this.firstpainter.zmin = mm.min0;
            this.firstpainter.zmax = mm.max0;
         }

         this.firstpainter.updateObject(src);
      }

      // and now update histograms
      let hlst = this.options.nostack ? stack.fHists : stack.fStack,
          nhists = (hlst && hlst.arr) ? hlst.arr.length : 0;

      if (nhists !== this.painters.length) {
         this.getPadPainter()?.cleanPrimitives(objp => { return this.painters.indexOf(objp) >= 0; });
         this.painters = [];
         this.did_update = true;
      } else {
         for (let indx = 0; indx < nhists; ++indx) {
            let rindx = this.options.horder ? indx : nhists-indx-1;
            let hist = hlst.arr[rindx];
            this.painters[indx].updateObject(hist);
         }
      }

      return true;
   }

   /** @summary Redraw THStack
     * @desc Do something if previous update had changed number of histograms */
   redraw() {
      if (this.did_update) {
         delete this.did_update;
         return this.drawNextHisto(0, this.options.pads ? this.getPadPainter() : null);
      }
   }

   /** @summary draw THStack object */
   static async draw(dom, stack, opt) {
      if (!stack.fHists || !stack.fHists.arr)
         return null; // drawing not needed

      let painter = new THStackPainter(dom, stack, opt),
          pad_painter = null,
          skip_drawing = false;

      return ensureTCanvas(painter, false).then(() => {

         painter.decodeOptions(opt);

         painter.hdraw_func = (painter.options.ndim == 1) ? TH1Painter.draw : TH2Painter.draw;

         if (painter.options.pads) {
            pad_painter = painter.getPadPainter();
            if (pad_painter.doingDraw() && pad_painter.pad?.fPrimitives &&
                pad_painter.pad.fPrimitives.arr.length > 1 && (pad_painter.pad.fPrimitives.arr.indexOf(stack) == 0)) {
               skip_drawing = true;
               console.log('special case with THStack with is already rendered - do nothing');
               return;
            }

            pad_painter.cleanPrimitives(p => p !== painter);
            return pad_painter.divide(painter.options.nhist);
         }

         if (!painter.options.nostack)
             painter.options.nostack = !painter.buildStack(stack);

         if (painter.options.same) return;

         let no_histogram = !stack.fHistogram;

         if (no_histogram)
             stack.fHistogram = painter.createHistogram(stack);

         let mm = painter.getMinMax(painter.options.errors || painter.options.draw_errors),
             hopt = painter.options.hopt + ';axis;' + mm.hopt;

         return painter.hdraw_func(dom, stack.fHistogram, hopt).then(subp => {
            painter.addToPadPrimitives();
            painter.firstpainter = subp;
            subp.$secondary = 'hist'; // mark histogram painter as secondary
            if (!no_histogram) painter.$primary = true; // mark stack as provider for histogram
         });
      }).then(() => skip_drawing ? painter : painter.drawNextHisto(0, pad_painter));
   }

} // class THStackPainter

var THStackPainter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
THStackPainter: THStackPainter
});

/** @summary direct draw function for TPolyMarker3D object
  * @private */
async function drawPolyMarker3D$1() {

   let fp = this.$fp || this.getFramePainter();

   delete this.$fp;

   if (!isObject(fp) || !fp.grx || !fp.gry || !fp.grz)
      return this;

   let poly = this.getObject(), step = 1, sizelimit = 50000, numselect = 0, fP = poly.fP;

   for (let i = 0; i < fP.length; i += 3) {
      if ((fP[i] < fp.scale_xmin) || (fP[i] > fp.scale_xmax) ||
          (fP[i+1] < fp.scale_ymin) || (fP[i+1] > fp.scale_ymax) ||
          (fP[i+2] < fp.scale_zmin) || (fP[i+2] > fp.scale_zmax)) continue;
      ++numselect;
   }

   if ((settings.OptimizeDraw > 0) && (numselect > sizelimit)) {
      step = Math.floor(numselect/sizelimit);
      if (step <= 2) step = 2;
   }

   let size = Math.floor(numselect/step),
       pnts = new PointsCreator(size, fp.webgl, fp.size_x3d/100),
       index = new Int32Array(size),
       select = 0, icnt = 0;

   for (let i = 0; i < fP.length; i += 3) {

      if ((fP[i] < fp.scale_xmin) || (fP[i] > fp.scale_xmax) ||
          (fP[i+1] < fp.scale_ymin) || (fP[i+1] > fp.scale_ymax) ||
          (fP[i+2] < fp.scale_zmin) || (fP[i+2] > fp.scale_zmax)) continue;

      if (step > 1) {
         select = (select+1) % step;
         if (select !== 0) continue;
      }

      index[icnt++] = i;

      pnts.addPoint(fp.grx(fP[i]), fp.gry(fP[i+1]), fp.grz(fP[i+2]));
   }

   return pnts.createPoints({ color: this.getColor(poly.fMarkerColor), style: poly.fMarkerStyle }).then(mesh => {

      mesh.tip_color = (poly.fMarkerColor === 3) ? 0xFF0000 : 0x00FF00;
      mesh.tip_name = poly.fName || 'Poly3D';
      mesh.poly = poly;
      mesh.painter = fp;
      mesh.scale0 = 0.7*pnts.scale;
      mesh.index = index;

      fp.toplevel.add(mesh);

      mesh.tooltip = function(intersect) {
         if (!Number.isInteger(intersect.index)) {
            console.error(`intersect.index not provided, three.js version ${REVISION}`);
            return null;
         }
         let indx = Math.floor(intersect.index / this.nvertex);
         if ((indx < 0) || (indx >= this.index.length)) return null;

         indx = this.index[indx];

         let p = this.painter,
             grx = p.grx(this.poly.fP[indx]),
             gry = p.gry(this.poly.fP[indx+1]),
             grz = p.grz(this.poly.fP[indx+2]);

         return  {
            x1: grx - this.scale0,
            x2: grx + this.scale0,
            y1: gry - this.scale0,
            y2: gry + this.scale0,
            z1: grz - this.scale0,
            z2: grz + this.scale0,
            color: this.tip_color,
            lines: [ this.tip_name,
                     'pnt: ' + indx/3,
                     'x: ' + p.axisAsText('x', this.poly.fP[indx]),
                     'y: ' + p.axisAsText('y', this.poly.fP[indx+1]),
                     'z: ' + p.axisAsText('z', this.poly.fP[indx+2])
                   ]
         };
      };

      fp.render3D(100); // set timeout to be able draw other points

      return this;
   });
}

/** @summary Prepare frame painter for 3D drawing
  * @private */
function before3DDraw(painter, obj) {
   let fp = painter.getFramePainter();

   if (!fp?.mode3d || !obj)
      return null;

   if (fp?.toplevel)
      return fp;

   let geop = painter.getMainPainter();
   if(!geop)
      return drawDummy3DGeom(painter);
   if (isFunc(geop.drawExtras))
      return geop.drawExtras(obj);

   return null;
}


/** @summary direct draw function for TPolyMarker3D object (optionally with geo painter)
  * @private */
async function drawPolyMarker3D() {

   let poly = this.getObject(),
       fp = before3DDraw(this, poly);

   if (!isObject(fp) || !fp.grx || !fp.gry || !fp.grz)
      return fp;

   this.$fp = fp;

   return drawPolyMarker3D$1.bind(this)();
}

/** @summary Direct draw function for TPolyLine3D object
  * @desc Takes into account dashed properties
  * @private */
async function drawPolyLine3D() {
   let line = this.getObject(),
       fp = before3DDraw(this, line);

   if (!isObject(fp) || !fp.grx || !fp.gry || !fp.grz)
      return fp;

   let limit = 3*line.fN, p = line.fP, pnts = [];

   for (let n = 3; n < limit; n += 3)
      pnts.push(fp.grx(p[n-3]), fp.gry(p[n-2]), fp.grz(p[n-1]),
                fp.grx(p[n]), fp.gry(p[n+1]), fp.grz(p[n+2]));

   let lines = createLineSegments(pnts, create3DLineMaterial(this, line));

   fp.toplevel.add(lines);

   return true;
}

var draw3d = /*#__PURE__*/Object.freeze({
__proto__: null,
drawPolyMarker3D: drawPolyMarker3D,
drawPolyLine3D: drawPolyLine3D
});

/**
 * @summary Painter for TGraphTime object
 *
 * @private
 */

class TGraphTimePainter extends ObjectPainter {

   /** @summary Redraw object */
   redraw() {
      if (this.step === undefined) this.startDrawing();
   }

   /** @summary Decode drawing options */
   decodeOptions(opt) {

      let d = new DrawOptions(opt || 'REPEAT');

      if (!this.options) this.options = {};

      Object.assign(this.options, {
          once: d.check('ONCE'),
          repeat: d.check('REPEAT'),
          first: d.check('FIRST')
      });

      this.storeDrawOpt(opt);
   }

   /** @summary Draw primitives */
   async drawPrimitives(indx) {

      if (!indx) {
         indx = 0;
         this._doing_primitives = true;
      }

      let lst = this.getObject()?.fSteps.arr[this.step];

      if (!lst || (indx >= lst.arr.length)) {
         delete this._doing_primitives;
         return;
      }

      return draw(this.getDom(), lst.arr[indx], lst.opt[indx]).then(p => {

         if (p) {
            p.$grtimeid = this.selfid; // indicator that painter created by ourself
            p.$grstep = this.step; // remember step
         }
         return this.drawPrimitives(indx+1);

      });
   }

   /** @summary Continue drawing */
   continueDrawing() {
      if (!this.options) return;

      let gr = this.getObject();

      if (this.options.first) {
         // draw only single frame, cancel all others
         delete this.step;
         return;
      }

      if (this.wait_animation_frame) {
         delete this.wait_animation_frame;

         // clear pad
         let pp = this.getPadPainter();
         if (!pp) {
            // most probably, pad is cleared
            delete this.step;
            return;
         }

         // draw ptrimitives again
         this.drawPrimitives().then(() => {
            // clear primitives produced by previous drawing to avoid flicking
            pp.cleanPrimitives(p => { return (p.$grtimeid === this.selfid) && (p.$grstep !== this.step); });

            this.continueDrawing();
         });
      } else if (this.running_timeout) {
         clearTimeout(this.running_timeout);
         delete this.running_timeout;

         this.wait_animation_frame = true;
         // use animation frame to disable update in inactive form
         requestAnimationFrame(() => this.continueDrawing());
      } else {

         let sleeptime = Math.max(gr.fSleepTime, 10);

         if (++this.step > gr.fSteps.arr.length) {
            if (this.options.repeat) {
               this.step = 0; // start again
               sleeptime = Math.max(5000, 5*sleeptime); // increase sleep time
            } else {
               delete this.step;    // clear indicator that animation running
               return;
            }
         }

         this.running_timeout = setTimeout(() => this.continueDrawing(), sleeptime);
      }
   }

   /** @ummary Start drawing of graph time */
   startDrawing() {
      this.step = 0;

      return this.drawPrimitives().then(() => {
         this.continueDrawing();
         return this;
      });
   }

   /** @summary Draw TGraphTime object */
   static async draw(dom, gr, opt) {
      if (!gr.fFrame) {
        console.error('Frame histogram not exists');
        return null;
      }

      let painter = new TGraphTimePainter(dom, gr);

      if (painter.getMainPainter()) {
         console.error('Cannot draw graph time on top of other histograms');
         return null;
      }

      painter.decodeOptions(opt);

      if (!gr.fFrame.fTitle && gr.fTitle) {
         let arr = gr.fTitle.split(";");
         gr.fFrame.fTitle = arr[0];
         if (arr[1]) gr.fFrame.fXaxis.fTitle = arr[1];
         if (arr[2]) gr.fFrame.fYaxis.fTitle = arr[2];
      }

      painter.selfid = 'grtime_' + internals.id_counter++; // use to identify primitives which should be clean

      return TH1Painter$2.draw(dom, gr.fFrame, 'AXIS').then(() => {
         painter.addToPadPrimitives();
         return painter.startDrawing();
      });
   }

} // class TGraphTimePainter

var TGraphTimePainter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
TGraphTimePainter: TGraphTimePainter
});

/**
 * @summary Painter for TGraph2D classes
 * @private
 */

class TGraph2DPainter extends ObjectPainter {

   /** @summary Decode options string  */
   decodeOptions(opt, gr) {
      let d = new DrawOptions(opt);

      if (!this.options)
         this.options = {};

      let res = this.options;

      res.Color = d.check('COL');
      res.Line = d.check('LINE');
      res.Error = d.check('ERR') && (this.matchObjectType('TGraph2DErrors') || this.matchObjectType('TGraph2DAsymmErrors'));
      res.Circles = d.check('P0');
      res.Markers = d.check('P');

      if (!res.Markers && !res.Error && !res.Circles && !res.Line) {
         if ((gr.fMarkerSize == 1) && (gr.fMarkerStyle == 1))
            res.Circles = true;
         else
            res.Markers = true;
      }
      if (!res.Markers) res.Color = false;

      this.storeDrawOpt(opt);
   }

   /** @summary Create histogram for axes drawing */
   createHistogram() {
      let gr = this.getObject(),
          asymm = this.matchObjectType('TGraph2DAsymmErrors'),
          xmin = gr.fX[0], xmax = xmin,
          ymin = gr.fY[0], ymax = ymin,
          zmin = gr.fZ[0], zmax = zmin;

      for (let p = 0; p < gr.fNpoints;++p) {

         let x = gr.fX[p], y = gr.fY[p], z = gr.fZ[p];

         if (this.options.Error) {
            xmin = Math.min(xmin, x - (asymm ? gr.fEXlow[p] : gr.fEX[p]));
            xmax = Math.max(xmax, x + (asymm ? gr.fEXhigh[p] : gr.fEX[p]));
            ymin = Math.min(ymin, y - (asymm ? gr.fEYlow[p] : gr.fEY[p]));
            ymax = Math.max(ymax, y + (asymm ? gr.fEYhigh[p] : gr.fEY[p]));
            zmin = Math.min(zmin, z - (asymm ? gr.fEZlow[p] : gr.fEZ[p]));
            zmax = Math.max(zmax, z + (asymm ? gr.fEZhigh[p] : gr.fEZ[p]));
         } else {
            xmin = Math.min(xmin, x);
            xmax = Math.max(xmax, x);
            ymin = Math.min(ymin, y);
            ymax = Math.max(ymax, y);
            zmin = Math.min(zmin, z);
            zmax = Math.max(zmax, z);
         }
      }

      if (xmin >= xmax) xmax = xmin+1;
      if (ymin >= ymax) ymax = ymin+1;
      if (zmin >= zmax) zmax = zmin+1;
      let dx = (xmax-xmin)*0.02, dy = (ymax-ymin)*0.02, dz = (zmax-zmin)*0.02,
          uxmin = xmin - dx, uxmax = xmax + dx,
          uymin = ymin - dy, uymax = ymax + dy,
          uzmin = zmin - dz, uzmax = zmax + dz;

      if ((uxmin < 0) && (xmin >= 0)) uxmin = xmin*0.98;
      if ((uxmax > 0) && (xmax <= 0)) uxmax = 0;

      if ((uymin < 0) && (ymin >= 0)) uymin = ymin*0.98;
      if ((uymax > 0) && (ymax <= 0)) uymax = 0;

      if ((uzmin < 0) && (zmin >= 0)) uzmin = zmin*0.98;
      if ((uzmax > 0) && (zmax <= 0)) uzmax = 0;

      let graph = this.getObject();

      if (graph.fMinimum != kNoZoom) uzmin = graph.fMinimum;
      if (graph.fMaximum != kNoZoom) uzmax = graph.fMaximum;

      let histo = createHistogram('TH2I', 10, 10);
      histo.fName = graph.fName + '_h';
      histo.fTitle = graph.fTitle;
      histo.fXaxis.fXmin = uxmin;
      histo.fXaxis.fXmax = uxmax;
      histo.fYaxis.fXmin = uymin;
      histo.fYaxis.fXmax = uymax;
      histo.fZaxis.fXmin = uzmin;
      histo.fZaxis.fXmax = uzmax;
      histo.fMinimum = uzmin;
      histo.fMaximum = uzmax;
      let kNoStats = BIT(9);
      histo.fBits = histo.fBits | kNoStats;
      return histo;
   }

   /** @summary Function handles tooltips in the mesh */
   graph2DTooltip(intersect) {
      if (!Number.isInteger(intersect.index)) {
         console.error(`intersect.index not provided, three.js version ${REVISION}`);
         return null;
      }

      let indx = Math.floor(intersect.index / this.nvertex);
      if ((indx < 0) || (indx >= this.index.length)) return null;
      let sqr = v => v*v;

      indx = this.index[indx];

      let p = this.painter, gr = this.graph,
          grx = p.grx(gr.fX[indx]),
          gry = p.gry(gr.fY[indx]),
          grz = p.grz(gr.fZ[indx]);

      if (this.check_next && indx+1<gr.fX.length) {
         let d = intersect.point,
             grx1 = p.grx(gr.fX[indx+1]),
             gry1 = p.gry(gr.fY[indx+1]),
             grz1 = p.grz(gr.fZ[indx+1]);
         if (sqr(d.x-grx1)+sqr(d.y-gry1)+sqr(d.z-grz1) < sqr(d.x-grx)+sqr(d.y-gry)+sqr(d.z-grz)) {
            grx = grx1; gry = gry1; grz = grz1; indx++;
         }
      }

      return {
         x1: grx - this.scale0,
         x2: grx + this.scale0,
         y1: gry - this.scale0,
         y2: gry + this.scale0,
         z1: grz - this.scale0,
         z2: grz + this.scale0,
         color: this.tip_color,
         lines: [ this.tip_name,
                  'pnt: ' + indx,
                  'x: ' + p.axisAsText('x', gr.fX[indx]),
                  'y: ' + p.axisAsText('y', gr.fY[indx]),
                  'z: ' + p.axisAsText('z', gr.fZ[indx])
                ]
      };
   }

   /** @summary Actual drawing of TGraph2D object
     * @return {Promise} for drawing ready */
   async redraw() {

      let main = this.getMainPainter(),
          fp = this.getFramePainter(),
          graph = this.getObject(),
          step = 1;

      if (!graph || !main || !fp || !fp.mode3d)
         return this;

      let countSelected = (zmin, zmax) => {
         let cnt = 0;
         for (let i = 0; i < graph.fNpoints; ++i) {
            if ((graph.fX[i] < fp.scale_xmin) || (graph.fX[i] > fp.scale_xmax) ||
                (graph.fY[i] < fp.scale_ymin) || (graph.fY[i] > fp.scale_ymax) ||
                (graph.fZ[i] < zmin) || (graph.fZ[i] >= zmax)) continue;

            ++cnt;
         }
         return cnt;
      };

      // try to define scale-down factor
      if ((settings.OptimizeDraw > 0) && !fp.webgl) {
         let numselected = countSelected(fp.scale_zmin, fp.scale_zmax),
             sizelimit = 50000;

         if (numselected > sizelimit) {
            step = Math.floor(numselected / sizelimit);
            if (step <= 2) step = 2;
         }
      }

      let markeratt = new TAttMarkerHandler(graph),
          palette = null,
          levels = [fp.scale_zmin, fp.scale_zmax],
          scale = fp.size_x3d / 100 * markeratt.getFullSize(),
          promises = [];

      if (this.options.Circles) scale = 0.06*fp.size_x3d;

      if (fp.usesvg) scale *= 0.3;

      if (this.options.Color) {
         levels = main.getContourLevels();
         palette = main.getHistPalette();
      }

      for (let lvl = 0; lvl < levels.length-1; ++lvl) {

         let lvl_zmin = Math.max(levels[lvl], fp.scale_zmin),
             lvl_zmax = Math.min(levels[lvl+1], fp.scale_zmax);

         if (lvl_zmin >= lvl_zmax) continue;

         let size = Math.floor(countSelected(lvl_zmin, lvl_zmax) / step),
             pnts = null, select = 0,
             index = new Int32Array(size), icnt = 0,
             err = null, asymm = false, line = null, ierr = 0, iline = 0;

         if (this.options.Markers || this.options.Circles)
            pnts = new PointsCreator(size, fp.webgl, scale/3);

         if (this.options.Error) {
            err = new Float32Array(size*6*3);
            asymm = this.matchObjectType('TGraph2DAsymmErrors');
          }

         if (this.options.Line)
            line = new Float32Array((size-1)*6);

         for (let i = 0; i < graph.fNpoints; ++i) {
            if ((graph.fX[i] < fp.scale_xmin) || (graph.fX[i] > fp.scale_xmax) ||
                (graph.fY[i] < fp.scale_ymin) || (graph.fY[i] > fp.scale_ymax) ||
                (graph.fZ[i] < lvl_zmin) || (graph.fZ[i] >= lvl_zmax)) continue;

            if (step > 1) {
               select = (select+1) % step;
               if (select !== 0) continue;
            }

            index[icnt++] = i; // remember point index for tooltip

            let x = fp.grx(graph.fX[i]),
                y = fp.gry(graph.fY[i]),
                z = fp.grz(graph.fZ[i]);

            if (pnts) pnts.addPoint(x,y,z);

            if (err) {
               err[ierr]   = fp.grx(graph.fX[i] - (asymm ? graph.fEXlow[i] : graph.fEX[i]));
               err[ierr+1] = y;
               err[ierr+2] = z;
               err[ierr+3] = fp.grx(graph.fX[i] + (asymm ? graph.fEXhigh[i] : graph.fEX[i]));
               err[ierr+4] = y;
               err[ierr+5] = z;
               ierr+=6;
               err[ierr]   = x;
               err[ierr+1] = fp.gry(graph.fY[i] - (asymm ? graph.fEYlow[i] : graph.fEY[i]));
               err[ierr+2] = z;
               err[ierr+3] = x;
               err[ierr+4] = fp.gry(graph.fY[i] + (asymm ? graph.fEYhigh[i] : graph.fEY[i]));
               err[ierr+5] = z;
               ierr+=6;
               err[ierr]   = x;
               err[ierr+1] = y;
               err[ierr+2] = fp.grz(graph.fZ[i] - (asymm ? graph.fEZlow[i] : graph.fEZ[i]));
               err[ierr+3] = x;
               err[ierr+4] = y;
               err[ierr+5] = fp.grz(graph.fZ[i] + (asymm ? graph.fEZhigh[i] : graph.fEZ[i]));
               ierr+=6;
            }

            if (line) {
               if (iline>=6) {
                  line[iline] = line[iline-3];
                  line[iline+1] = line[iline-2];
                  line[iline+2] = line[iline-1];
                  iline+=3;
               }
               line[iline] = x;
               line[iline+1] = y;
               line[iline+2] = z;
               iline+=3;
            }
         }

         if (line && (iline > 3) && (line.length == iline)) {
            let lcolor = this.getColor(graph.fLineColor),
                material = new LineBasicMaterial({ color: new Color$1(lcolor), linewidth: graph.fLineWidth }),
                linemesh = createLineSegments(line, material);
            fp.toplevel.add(linemesh);

            linemesh.graph = graph;
            linemesh.index = index;
            linemesh.painter = fp;
            linemesh.scale0 = 0.7*scale;
            linemesh.tip_name = this.getObjectHint();
            linemesh.tip_color = (graph.fMarkerColor === 3) ? 0xFF0000 : 0x00FF00;
            linemesh.nvertex = 2;
            linemesh.check_next = true;

            linemesh.tooltip = this.graph2DTooltip;
         }

         if (err) {
            let lcolor = this.getColor(graph.fLineColor),
                material = new LineBasicMaterial({ color: new Color$1(lcolor), linewidth: graph.fLineWidth }),
                errmesh = createLineSegments(err, material);
            fp.toplevel.add(errmesh);

            errmesh.graph = graph;
            errmesh.index = index;
            errmesh.painter = fp;
            errmesh.scale0 = 0.7*scale;
            errmesh.tip_name = this.getObjectHint();
            errmesh.tip_color = (graph.fMarkerColor === 3) ? 0xFF0000 : 0x00FF00;
            errmesh.nvertex = 6;

            errmesh.tooltip = this.graph2DTooltip;
         }

         if (pnts) {
            let fcolor = 'blue';

            if (!this.options.Circles)
               fcolor = palette ? palette.calcColor(lvl, levels.length)
                                : this.getColor(graph.fMarkerColor);

            let pr = pnts.createPoints({ color: fcolor, style: this.options.Circles ? 4 : graph.fMarkerStyle }).then(mesh => {
               mesh.graph = graph;
               mesh.painter = fp;
               mesh.tip_color = (graph.fMarkerColor === 3) ? 0xFF0000 : 0x00FF00;
               mesh.scale0 = 0.3*scale;
               mesh.index = index;

               mesh.tip_name = this.getObjectHint();
               mesh.tooltip = this.graph2DTooltip;
               fp.toplevel.add(mesh);
            });

            promises.push(pr);
         }
      }

      return Promise.all(promises).then(() => {
         fp.render3D(100);
         return this;
      });
   }

   /** @summary draw TGraph2D object */
   static async draw(dom, gr, opt) {
      let painter = new TGraph2DPainter(dom, gr);
      painter.decodeOptions(opt, gr);

      let promise = Promise.resolve(true);

      if (!painter.getMainPainter()) {
         if (!gr.fHistogram)
            gr.fHistogram = painter.createHistogram();
         promise = TH2Painter.draw(dom, gr.fHistogram, 'lego;axis');
         painter.ownhisto = true;
      }

      return promise.then(() => {
         painter.addToPadPrimitives();
         return painter.redraw();
      });
   }

} // class TGraph2DPainter

var TGraph2DPainter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
TGraph2DPainter: TGraph2DPainter
});

/**
 * @summary Painter for TGraphPolargram objects.
 *
 * @private */

class TGraphPolargramPainter extends ObjectPainter {

   /** @summary Create painter
     * @param {object|string} dom - DOM element for drawing or element id
     * @param {object} polargram - object to draw */
   constructor(dom, polargram) {
      super(dom, polargram);
      this.$polargram = true; // indicate that this is polargram
      this.zoom_rmin = this.zoom_rmax = 0;
   }

   /** @summary Translate coordinates */
   translate(angle, radius, keep_float) {
      let _rx = this.r(radius), _ry = _rx/this.szx*this.szy,
          pos = {
            x: _rx * Math.cos(-angle - this.angle),
            y: _ry * Math.sin(-angle - this.angle),
            rx: _rx,
            ry: _ry
         };

      if (!keep_float) {
         pos.x = Math.round(pos.x);
         pos.y = Math.round(pos.y);
         pos.rx =  Math.round(pos.rx);
         pos.ry =  Math.round(pos.ry);
      }
      return pos;
   }

   /** @summary format label for radius ticks */
   format(radius) {

      if (radius === Math.round(radius)) return radius.toString();
      if (this.ndig > 10) return radius.toExponential(4);

      return radius.toFixed((this.ndig > 0) ? this.ndig : 0);
   }

   /** @summary Convert axis values to text */
   axisAsText(axis, value) {

      if (axis == 'r') {
         if (value === Math.round(value)) return value.toString();
         if (this.ndig>10) return value.toExponential(4);
         return value.toFixed(this.ndig+2);
      }

      value *= 180/Math.PI;
      return (value === Math.round(value)) ? value.toString() : value.toFixed(1);
   }

   /** @summary Returns coordinate of frame - without using frame itself */
   getFrameRect() {
      let pp = this.getPadPainter(),
          pad = pp.getRootPad(true),
          w = pp.getPadWidth(),
          h = pp.getPadHeight(),
          rect = {};

      if (pad) {
         rect.szx = Math.round(Math.max(0.1, 0.5 - Math.max(pad.fLeftMargin, pad.fRightMargin))*w);
         rect.szy = Math.round(Math.max(0.1, 0.5 - Math.max(pad.fBottomMargin, pad.fTopMargin))*h);
      } else {
         rect.szx = Math.round(0.5*w);
         rect.szy = Math.round(0.5*h);
      }

      rect.width = 2*rect.szx;
      rect.height = 2*rect.szy;
      rect.x = Math.round(w/2 - rect.szx);
      rect.y = Math.round(h/2 - rect.szy);

      rect.hint_delta_x = rect.szx;
      rect.hint_delta_y = rect.szy;

      rect.transform = `translate(${rect.x},${rect.y})`;

      return rect;
   }

   /** @summary Process mouse event */
   mouseEvent(kind, evnt) {
      let layer = this.getLayerSvg('primitives_layer'),
          interactive = layer.select('.interactive_ellipse');
      if (interactive.empty()) return;

      let pnt = null;

      if (kind !== 'leave') {
         let pos = pointer(evnt, interactive.node());
         pnt = { x: pos[0], y: pos[1], touch: false };
      }

      this.processFrameTooltipEvent(pnt);
   }

   /** @summary Process mouse wheel event */
   mouseWheel(evnt) {
      evnt.stopPropagation();
      evnt.preventDefault();

      this.processFrameTooltipEvent(null); // remove all tooltips

      let polar = this.getObject();

      if (!polar) return;

      let delta = evnt.wheelDelta ? -evnt.wheelDelta : (evnt.deltaY || evnt.detail);
      if (!delta) return;

      delta = (delta < 0) ? -0.2 : 0.2;

      let rmin = this.scale_rmin, rmax = this.scale_rmax, range = rmax - rmin;

      // rmin -= delta*range;
      rmax += delta*range;

      if ((rmin<polar.fRwrmin) || (rmax>polar.fRwrmax)) rmin = rmax = 0;

      if ((this.zoom_rmin != rmin) || (this.zoom_rmax != rmax)) {
         this.zoom_rmin = rmin;
         this.zoom_rmax = rmax;
         this.redrawPad();
      }
   }

   /** @summary Redraw polargram */
   redraw() {
      if (!this.isMainPainter()) return;

      let polar = this.getObject(),
          rect = this.getPadPainter().getFrameRect();

      this.createG();

      this.draw_g.attr('transform', `translate(${Math.round(rect.x + rect.width/2)},${Math.round(rect.y + rect.height/2)})`);
      this.szx = rect.szx;
      this.szy = rect.szy;

      this.scale_rmin = polar.fRwrmin;
      this.scale_rmax = polar.fRwrmax;
      if (this.zoom_rmin != this.zoom_rmax) {
         this.scale_rmin = this.zoom_rmin;
         this.scale_rmax = this.zoom_rmax;
      }

      this.r = linear().domain([this.scale_rmin, this.scale_rmax]).range([ 0, this.szx ]);
      this.angle = polar.fAxisAngle || 0;

      let ticks = this.r.ticks(5),
          nminor = Math.floor((polar.fNdivRad % 10000) / 100);

      this.createAttLine({ attr: polar });
      if (!this.gridatt) this.gridatt = new TAttLineHandler({ color: polar.fLineColor, style: 2, width: 1 });

      let range = Math.abs(polar.fRwrmax - polar.fRwrmin);
      this.ndig = (range <= 0) ? -3 : Math.round(Math.log10(ticks.length / range));

      // verify that all radius labels are unique
      let lbls = [], indx = 0;
      while (indx<ticks.length) {
         let lbl = this.format(ticks[indx]);
         if (lbls.indexOf(lbl) >= 0) {
            if (++this.ndig>10) break;
            lbls = []; indx = 0; continue;
          }
         lbls.push(lbl);
         indx++;
      }

      let exclude_last = false;

      if ((ticks[ticks.length-1] < polar.fRwrmax) && (this.zoom_rmin == this.zoom_rmax)) {
         ticks.push(polar.fRwrmax);
         exclude_last = true;
      }

      this.startTextDrawing(polar.fRadialLabelFont, Math.round(polar.fRadialTextSize * this.szy * 2));

      for (let n = 0; n < ticks.length; ++n) {
         let rx = this.r(ticks[n]), ry = rx/this.szx*this.szy;
         this.draw_g.append('ellipse')
             .attr('cx',0)
             .attr('cy',0)
             .attr('rx',Math.round(rx))
             .attr('ry',Math.round(ry))
             .style('fill', 'none')
             .call(this.lineatt.func);

         if ((n < ticks.length-1) || !exclude_last)
            this.drawText({ align: 23, x: Math.round(rx), y: Math.round(polar.fRadialTextSize * this.szy * 0.5),
                            text: this.format(ticks[n]), color: this.getColor(polar.fRadialLabelColor), latex: 0 });

         if ((nminor>1) && ((n < ticks.length-1) || !exclude_last)) {
            let dr = (ticks[1] - ticks[0]) / nminor;
            for (let nn = 1; nn < nminor; ++nn) {
               let gridr = ticks[n] + dr*nn;
               if (gridr > this.scale_rmax) break;
               rx = this.r(gridr); ry = rx/this.szx*this.szy;
               this.draw_g.append('ellipse')
                   .attr('cx',0)
                   .attr('cy',0)
                   .attr('rx',Math.round(rx))
                   .attr('ry',Math.round(ry))
                   .style('fill', 'none')
                   .call(this.gridatt.func);
            }
         }
      }

      let nmajor = polar.fNdivPol % 100;
      if ((nmajor !== 8) && (nmajor !== 3)) nmajor = 8;

      return this.finishTextDrawing().then(() => {

         let fontsize = Math.round(polar.fPolarTextSize * this.szy * 2);
         this.startTextDrawing(polar.fPolarLabelFont, fontsize);

         lbls = (nmajor==8) ? ['0', '#frac{#pi}{4}', '#frac{#pi}{2}', '#frac{3#pi}{4}', '#pi', '#frac{5#pi}{4}', '#frac{3#pi}{2}', '#frac{7#pi}{4}'] : ['0', '#frac{2#pi}{3}', '#frac{4#pi}{3}'];
         let aligns = [12, 11, 21, 31, 32, 33, 23, 13];

         for (let n = 0; n < nmajor; ++n) {
            let angle = -n*2*Math.PI/nmajor - this.angle;
            this.draw_g.append('svg:path')
                .attr('d',`M0,0L${Math.round(this.szx*Math.cos(angle))},${Math.round(this.szy*Math.sin(angle))}`)
                .call(this.lineatt.func);

            let aindx = Math.round(16 -angle/Math.PI*4) % 8; // index in align table, here absolute angle is important

            this.drawText({ align: aligns[aindx],
                            x: Math.round((this.szx+fontsize)*Math.cos(angle)),
                            y: Math.round((this.szy + fontsize/this.szx*this.szy)*(Math.sin(angle))),
                            text: lbls[n],
                            color: this.getColor(polar.fPolarLabelColor), latex: 1 });
         }

         return this.finishTextDrawing();
      }).then(() => {

         nminor = Math.floor((polar.fNdivPol % 10000) / 100);

         if (nminor > 1)
            for (let n = 0; n < nmajor*nminor; ++n) {
               if (n % nminor === 0) continue;
               let angle = -n*2*Math.PI/nmajor/nminor - this.angle;
               this.draw_g.append('svg:path')
                   .attr('d',`M0,0L${Math.round(this.szx*Math.cos(angle))},${Math.round(this.szy*Math.sin(angle))}`)
                   .call(this.gridatt.func);
            }

         if (isBatchMode()) return;

         TooltipHandler.assign(this);

         let layer = this.getLayerSvg('primitives_layer'),
             interactive = layer.select('.interactive_ellipse');

         if (interactive.empty())
            interactive = layer.append('g')
                               .classed('most_upper_primitives', true)
                               .append('ellipse')
                               .classed('interactive_ellipse', true)
                               .attr('cx', 0)
                               .attr('cy', 0)
                               .style('fill', 'none')
                               .style('pointer-events', 'visibleFill')
                               .on('mouseenter', evnt => this.mouseEvent('enter', evnt))
                               .on('mousemove', evnt => this.mouseEvent('move', evnt))
                               .on('mouseleave', evnt => this.mouseEvent('leave', evnt));

         interactive.attr('rx', this.szx).attr('ry', this.szy);

         select(interactive.node().parentNode).attr('transform', this.draw_g.attr('transform'));

         if (settings.Zooming && settings.ZoomWheel)
            interactive.on('wheel', evnt => this.mouseWheel(evnt));
      });
   }

   /** @summary Draw TGraphPolargram */
   static async draw(dom, polargram /*, opt*/) {

      let main = getElementMainPainter(dom);
      if (main) {
         if (main.getObject() === polargram)
            return main;
         throw Error('Cannot superimpose TGraphPolargram with any other drawings');
      }

      let painter = new TGraphPolargramPainter(dom, polargram);
      return ensureTCanvas(painter, false).then(() => {
         painter.setAsMainPainter();
         return painter.redraw();
      }).then(() => painter);
   }

} // class TGraphPolargramPainter


/**
 * @summary Painter for TGraphPolar objects.
 *
 * @private
 */

class TGraphPolarPainter extends ObjectPainter {

   /** @summary Redraw TGraphPolar */
   redraw() {
      this.drawGraphPolar();
   }

   /** @summary Decode options for drawing TGraphPolar */
   decodeOptions(opt) {

      let d = new DrawOptions(opt || 'L');

      if (!this.options) this.options = {};

      Object.assign(this.options, {
          mark: d.check('P'),
          err: d.check('E'),
          fill: d.check('F'),
          line: d.check('L'),
          curve: d.check('C')
      });

      this.storeDrawOpt(opt);
   }

   /** @summary Drawing TGraphPolar */
   drawGraphPolar() {
      let graph = this.getObject(),
          main = this.getMainPainter();

      if (!graph || !main?.$polargram) return;

      if (this.options.mark) this.createAttMarker({ attr: graph });
      if (this.options.err || this.options.line || this.options.curve) this.createAttLine({ attr: graph });
      if (this.options.fill) this.createAttFill({ attr: graph });

      this.createG();

      this.draw_g.attr('transform', main.draw_g.attr('transform'));

      let mpath = '', epath = '', lpath = '', bins = [];

      for (let n = 0; n < graph.fNpoints; ++n) {

         if (graph.fY[n] > main.scale_rmax) continue;

         if (this.options.err) {
            let pos1 = main.translate(graph.fX[n], graph.fY[n] - graph.fEY[n]),
                pos2 = main.translate(graph.fX[n], graph.fY[n] + graph.fEY[n]);
            epath += `M${pos1.x},${pos1.y}L${pos2.x},${pos2.y}`;

            pos1 = main.translate(graph.fX[n] + graph.fEX[n], graph.fY[n]);
            pos2 = main.translate(graph.fX[n] - graph.fEX[n], graph.fY[n]);

            epath += `M${pos1.x},${pos1.y}A${pos2.rx},${pos2.ry},0,0,1,${pos2.x},${pos2.y}`;
         }

         let pos = main.translate(graph.fX[n], graph.fY[n]);

         if (this.options.mark) {
            mpath += this.markeratt.create(pos.x, pos.y);
         }

         if (this.options.line || this.options.fill) {
            lpath += (lpath ? 'L' : 'M') + pos.x + ',' + pos.y;
         }

         if (this.options.curve) {
            pos.grx = pos.x;
            pos.gry = pos.y;
            bins.push(pos);
         }
      }

      if (this.options.fill && lpath)
         this.draw_g.append('svg:path')
             .attr('d', lpath + 'Z')
             .call(this.fillatt.func);

      if (this.options.line && lpath)
         this.draw_g.append('svg:path')
             .attr('d', lpath)
             .style('fill', 'none')
             .call(this.lineatt.func);

      if (this.options.curve && bins.length)
         this.draw_g.append('svg:path')
                 .attr('d', buildSvgPath('bezier', bins).path)
                 .style('fill', 'none')
                 .call(this.lineatt.func);

      if (epath)
         this.draw_g.append('svg:path')
             .attr('d', epath)
             .style('fill','none')
             .call(this.lineatt.func);

      if (mpath)
         this.draw_g.append('svg:path')
               .attr('d', mpath)
               .call(this.markeratt.func);
   }

   /** @summary Create polargram object */
   createPolargram() {
      let polargram = create$1('TGraphPolargram'),
          gr = this.getObject();

      let rmin = gr.fY[0] || 0, rmax = rmin;
      for (let n = 0; n < gr.fNpoints; ++n) {
         rmin = Math.min(rmin, gr.fY[n] - gr.fEY[n]);
         rmax = Math.max(rmax, gr.fY[n] + gr.fEY[n]);
      }

      polargram.fRwrmin = rmin - (rmax-rmin)*0.1;
      polargram.fRwrmax = rmax + (rmax-rmin)*0.1;

      return polargram;
   }

   /** @summary Provide tooltip at specified point */
   extractTooltip(pnt) {
      if (!pnt) return null;

      let graph = this.getObject(),
          main = this.getMainPainter(),
          best_dist2 = 1e10, bestindx = -1, bestpos = null;

      for (let n = 0; n < graph.fNpoints; ++n) {
         let pos = main.translate(graph.fX[n], graph.fY[n]),
             dist2 = (pos.x-pnt.x)**2 + (pos.y-pnt.y)**2;
         if (dist2 < best_dist2) { best_dist2 = dist2; bestindx = n; bestpos = pos; }
      }

      let match_distance = 5;
      if (this.markeratt && this.markeratt.used) match_distance = this.markeratt.getFullSize();

      if (Math.sqrt(best_dist2) > match_distance) return null;

      let res = { name: this.getObject().fName, title: this.getObject().fTitle,
                  x: bestpos.x, y: bestpos.y,
                  color1: this.markeratt && this.markeratt.used ? this.markeratt.color : this.lineatt.color,
                  exact: Math.sqrt(best_dist2) < 4,
                  lines: [ this.getObjectHint() ],
                  binindx: bestindx,
                  menu_dist: match_distance,
                  radius: match_distance
                };

      res.lines.push('r = ' + main.axisAsText('r', graph.fY[bestindx]));
      res.lines.push('phi = ' + main.axisAsText('phi',graph.fX[bestindx]));

      if (graph.fEY && graph.fEY[bestindx])
         res.lines.push('error r = ' + main.axisAsText('r', graph.fEY[bestindx]));

      if (graph.fEX && graph.fEX[bestindx])
         res.lines.push('error phi = ' + main.axisAsText('phi', graph.fEX[bestindx]));

      return res;
   }

   /** @summary Show tooltip */
   showTooltip(hint) {

      if (!this.draw_g) return;

      let ttcircle = this.draw_g.select('.tooltip_bin');

      if (!hint) {
         ttcircle.remove();
         return;
      }

      if (ttcircle.empty())
         ttcircle = this.draw_g.append('svg:ellipse')
                             .attr('class','tooltip_bin')
                             .style('pointer-events','none');

      hint.changed = ttcircle.property('current_bin') !== hint.binindx;

      if (hint.changed)
         ttcircle.attr('cx', hint.x)
               .attr('cy', hint.y)
               .attr('rx', Math.round(hint.radius))
               .attr('ry', Math.round(hint.radius))
               .style('fill', 'none')
               .style('stroke', hint.color1)
               .property('current_bin', hint.binindx);
   }

   /** @summary Process tooltip event */
   processTooltipEvent(pnt) {
      let hint = this.extractTooltip(pnt);
      if (!pnt || !pnt.disabled) this.showTooltip(hint);
      return hint;
   }

   /** @summary Draw TGraphPolar */
   static async draw(dom, graph, opt) {
      let painter = new TGraphPolarPainter(dom, graph);
      painter.decodeOptions(opt);

      let main = painter.getMainPainter();
      if (main && !main.$polargram) {
         console.error('Cannot superimpose TGraphPolar with plain histograms');
         return null;
      }

      let pr = Promise.resolve(null);
      if (!main) {
         if (!graph.fPolargram)
            graph.fPolargram = painter.createPolargram();
         pr = TGraphPolargramPainter.draw(dom, graph.fPolargram);
      }

      return pr.then(() => {
         painter.addToPadPrimitives();
         painter.drawGraphPolar();
         return painter;
      });
   }

} // class TGraphPolarPainter

var TGraphPolarPainter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
TGraphPolargramPainter: TGraphPolargramPainter,
TGraphPolarPainter: TGraphPolarPainter
});

const kNotEditable = BIT(18),   // bit set if graph is non editable
      clTGraphErrors = 'TGraphErrors',
      clTGraphAsymmErrors = 'TGraphAsymmErrors',
      clTGraphBentErrors = 'TGraphBentErrors',
      clTGraphMultiErrors = 'TGraphMultiErrors';

/**
 * @summary Painter for TGraph object.
 *
 * @private
 */

class TGraphPainter$1 extends ObjectPainter {

   constructor(dom, graph) {
      super(dom, graph);
      this.axes_draw = false; // indicate if graph histogram was drawn for axes
      this.bins = null;
      this.xmin = this.ymin = this.xmax = this.ymax = 0;
      this.wheel_zoomy = true;
      this.is_bent = (graph._typename == clTGraphBentErrors);
      this.has_errors = (graph._typename == clTGraphErrors) ||
                        (graph._typename == clTGraphMultiErrors) ||
                        (graph._typename == clTGraphAsymmErrors) ||
                         this.is_bent || graph._typename.match(/^RooHist/);
   }

   /** @summary Redraw graph
     * @desc may redraw histogram which was used to draw axes
     * @return {Promise} for ready */
   async redraw() {
      let promise = Promise.resolve(true);

      if (this.$redraw_hist) {
         delete this.$redraw_hist;
         let hist_painter = this.getMainPainter();
         if (hist_painter?.$secondary && this.axes_draw)
            promise = hist_painter.redraw();
      }

      return promise.then(() => this.drawGraph());
   }

   /** @summary Cleanup graph painter */
   cleanup() {
      delete this.interactive_bin; // break mouse handling
      delete this.bins;
      super.cleanup();
   }

   /** @summary Returns object if this drawing TGraphMultiErrors object */
   get_gme() {
      let graph = this.getObject();
      return graph?._typename == clTGraphMultiErrors ? graph : null;
   }

   /** @summary Decode options */
   decodeOptions(opt, first_time) {

      if (isStr(opt) && (opt.indexOf('same ') == 0))
         opt = opt.slice(5);

      let graph = this.getObject(),
          is_gme = !!this.get_gme(),
          blocks_gme = [],
          has_main = first_time ? !!this.getMainPainter() : !this.axes_draw;

      if (!this.options) this.options = {};

      // decode main draw options for the graph
      const decodeBlock = (d, res) => {
         Object.assign(res, { Line: 0, Curve: 0, Rect: 0, Mark: 0, Bar: 0, OutRange: 0, EF:0, Fill: 0, MainError: 1, Ends: 1, ScaleErrX: 1 });

         if (is_gme && d.check('S=', true)) res.ScaleErrX = d.partAsFloat();

         if (d.check('L')) res.Line = 1;
         if (d.check('F')) res.Fill = 1;
         if (d.check('CC')) res.Curve = 2; // draw all points without reduction
         if (d.check('C')) res.Curve = 1;
         if (d.check('*')) res.Mark = 103;
         if (d.check('P0')) res.Mark = 104;
         if (d.check('P')) res.Mark = 1;
         if (d.check('B')) { res.Bar = 1; res.Errors = 0; }
         if (d.check('Z')) { res.Errors = 1; res.Ends = 0; }
         if (d.check('||')) { res.Errors = 1; res.MainError = 0; res.Ends = 1; }
         if (d.check('[]')) { res.Errors = 1; res.MainError = 0; res.Ends = 2; }
         if (d.check('|>')) { res.Errors = 1; res.Ends = 3; }
         if (d.check('>')) { res.Errors = 1; res.Ends = 4; }
         if (d.check('0')) { res.Mark = 1; res.Errors = 1; res.OutRange = 1; }
         if (d.check('1')) { if (res.Bar == 1) res.Bar = 2; }
         if (d.check('2')) { res.Rect = 1; res.Errors = 0; }
         if (d.check('3')) { res.EF = 1; res.Errors = 0;  }
         if (d.check('4')) { res.EF = 2; res.Errors = 0; }
         if (d.check('5')) { res.Rect = 2; res.Errors = 0; }
         if (d.check('X')) res.Errors = 0;
      };

      Object.assign(this.options, { Axis: '', NoOpt: 0, PadStats: false, original: opt, second_x: false, second_y: false, individual_styles: false });

      if (is_gme && opt) {
         if (opt.indexOf(';') > 0) {
            blocks_gme = opt.split(';');
            opt = blocks_gme.shift();
         } else if (opt.indexOf('_') > 0) {
            blocks_gme = opt.split('_');
            opt = blocks_gme.shift();
         }
      }

      let res = this.options,
          d = new DrawOptions(opt);

      // check pad options first
      res.PadStats = d.check('USE_PAD_STATS');
      let hopt = '', checkhopt = ['USE_PAD_TITLE', 'LOGXY', 'LOGX', 'LOGY', 'LOGZ', 'GRIDXY', 'GRIDX', 'GRIDY', 'TICKXY', 'TICKX', 'TICKY'];
      checkhopt.forEach(name => { if (d.check(name)) hopt += ';' + name; });
      if (d.check('XAXIS_', true)) hopt += ';XAXIS_' + d.part;
      if (d.check('YAXIS_', true)) hopt += ';YAXIS_' + d.part;

      if (d.empty()) {
         res.original = has_main ? 'lp' : 'alp';
         d = new DrawOptions(res.original);
      }

      if (d.check('NOOPT')) res.NoOpt = 1;

      if (d.check('POS3D_', true)) res.pos3d = d.partAsInt() - 0.5;

      res._pfc = d.check('PFC');
      res._plc = d.check('PLC');
      res._pmc = d.check('PMC');

      if (d.check('A')) res.Axis = d.check('I') ? 'A' : 'AXIS'; // I means invisible axis
      if (d.check('X+')) { res.Axis += 'X+'; res.second_x = has_main; }
      if (d.check('Y+')) { res.Axis += 'Y+'; res.second_y = has_main; }
      if (d.check('RX')) res.Axis += 'RX';
      if (d.check('RY')) res.Axis += 'RY';

      if (is_gme) {
         res.blocks = [];
         res.skip_errors_x0 = res.skip_errors_y0 = false;
         if (d.check('X0')) res.skip_errors_x0 = true;
         if (d.check('Y0')) res.skip_errors_y0 = true;
      }

      decodeBlock(d, res);

      if (is_gme) {
         if (d.check('S')) res.individual_styles = true;
      }

      // if (d.check('E')) res.Errors = 1; // E option only defined for TGraphPolar

      if (res.Errors === undefined)
         res.Errors = this.has_errors && (!is_gme || !blocks_gme.length) ? 1 : 0;

      // special case - one could use svg:path to draw many pixels (
      if ((res.Mark == 1) && (graph.fMarkerStyle == 1)) res.Mark = 101;

      // if no drawing option is selected and if opt == '' nothing is done.
      if (res.Line + res.Fill + res.Curve + res.Mark + res.Bar + res.EF + res.Rect + res.Errors == 0) {
         if (d.empty()) res.Line = 1;
      }

      if (graph._typename == clTGraphErrors) {
         let len = graph.fEX.length, m = 0;
         for (let k = 0; k < len; ++k)
            m = Math.max(m, graph.fEX[k], graph.fEY[k]);
         if (m < 1e-100)
            res.Errors = 0;
      }

      if (!res.Axis) {
         // check if axis should be drawn
         // either graph drawn directly or
         // graph is first object in list of primitives
         let pp = this.getPadPainter(),
             pad = pp?.getRootPad(true);
         if (!pad || (pad?.fPrimitives?.arr[0] === graph)) res.Axis = 'AXIS';
      } else if (res.Axis.indexOf('A') < 0) {
         res.Axis = 'AXIS,' + res.Axis;
      }

      res.Axis += hopt;

      for (let bl = 0; bl < blocks_gme.length; ++bl) {
         let subd = new DrawOptions(blocks_gme[bl]), subres = {};
         decodeBlock(subd, subres);
         subres.skip_errors_x0 = res.skip_errors_x0;
         subres.skip_errors_y0 = res.skip_errors_y0;
         res.blocks.push(subres);
      }
   }

   /** @summary Extract errors for TGraphMultiErrors */
   extractGmeErrors(nblock) {
      if (!this.bins) return;
      let gr = this.getObject();
      this.bins.forEach(bin => {
         bin.eylow  = gr.fEyL[nblock][bin.indx];
         bin.eyhigh = gr.fEyH[nblock][bin.indx];
      });
   }

   /** @summary Create bins for TF1 drawing */
   createBins() {
      let gr = this.getObject();
      if (!gr) return;

      let kind = 0, npoints = gr.fNpoints;
      if ((gr._typename === clTCutG) && (npoints > 3)) npoints--;

      if (gr._typename == clTGraphErrors)
         kind = 1;
      else if (gr._typename == clTGraphMultiErrors)
         kind = 2;
      else if (gr._typename == clTGraphAsymmErrors || gr._typename == clTGraphBentErrors || gr._typename.match(/^RooHist/))
         kind = 3;

      this.bins = new Array(npoints);

      for (let p = 0; p < npoints; ++p) {
         let bin = this.bins[p] = { x: gr.fX[p], y: gr.fY[p], indx: p };
         switch(kind) {
            case 1:
               bin.exlow = bin.exhigh = gr.fEX[p];
               bin.eylow = bin.eyhigh = gr.fEY[p];
               break;
            case 2:
               bin.exlow  = gr.fExL[p];
               bin.exhigh = gr.fExH[p];
               bin.eylow  = gr.fEyL[0][p];
               bin.eyhigh = gr.fEyH[0][p];
               break;
            case 3:
               bin.exlow  = gr.fEXlow[p];
               bin.exhigh = gr.fEXhigh[p];
               bin.eylow  = gr.fEYlow[p];
               bin.eyhigh = gr.fEYhigh[p];
               break;
         }

         if (p === 0) {
            this.xmin = this.xmax = bin.x;
            this.ymin = this.ymax = bin.y;
         }

         if (kind > 0) {
            this.xmin = Math.min(this.xmin, bin.x - bin.exlow, bin.x + bin.exhigh);
            this.xmax = Math.max(this.xmax, bin.x - bin.exlow, bin.x + bin.exhigh);
            this.ymin = Math.min(this.ymin, bin.y - bin.eylow, bin.y + bin.eyhigh);
            this.ymax = Math.max(this.ymax, bin.y - bin.eylow, bin.y + bin.eyhigh);
         } else {
            this.xmin = Math.min(this.xmin, bin.x);
            this.xmax = Math.max(this.xmax, bin.x);
            this.ymin = Math.min(this.ymin, bin.y);
            this.ymax = Math.max(this.ymax, bin.y);
         }
      }
   }

   /** @summary Create histogram for graph
     * @desc graph bins should be created when calling this function
     * @param {boolean} [set_x] - set X axis range
     * @param {boolean} [set_y] - set Y axis range */
   createHistogram(set_x, set_y) {
      if (!set_x && !set_y)
         set_x = set_y = true;

      let xmin = this.xmin, xmax = this.xmax, ymin = this.ymin, ymax = this.ymax;

      if (xmin >= xmax) xmax = xmin+1;
      if (ymin >= ymax) ymax = ymin+1;
      let dx = (xmax-xmin)*0.1, dy = (ymax-ymin)*0.1,
          uxmin = xmin - dx, uxmax = xmax + dx,
          minimum = ymin - dy, maximum = ymax + dy;

      if ((uxmin < 0) && (xmin >= 0)) uxmin = xmin*0.9;
      if ((uxmax > 0) && (xmax <= 0)) uxmax = 0;

      let graph = this.getObject(),
          histo = graph.fHistogram,
          minimum0 = minimum, maximum0 = maximum;

      if (!histo) {
         histo = graph.fHistogram = createHistogram('TH1F', 100);
         histo.fName = graph.fName + '_h';
         const kNoStats = BIT(9);
         histo.fBits = histo.fBits | kNoStats;
         this._own_histogram = true;
      } else if ((histo.fMaximum != kNoZoom) && (histo.fMinimum != kNoZoom)) {
         minimum = histo.fMinimum;
         maximum = histo.fMaximum;
      }

      if (graph.fMinimum != kNoZoom) minimum = ymin = graph.fMinimum;
      if (graph.fMaximum != kNoZoom) maximum = graph.fMaximum;
      if ((minimum < 0) && (ymin >= 0)) minimum = 0.9*ymin;

      histo.fTitle = graph.fTitle;

      if (set_x) {
         histo.fXaxis.fXmin = uxmin;
         histo.fXaxis.fXmax = uxmax;
      }

      if (set_y) {
         histo.fYaxis.fXmin = Math.min(minimum0, minimum);
         histo.fYaxis.fXmax = Math.max(maximum0, maximum);
         histo.fMinimum = minimum;
         histo.fMaximum = maximum;
      }

      return histo;
   }

   /** @summary Check if user range can be unzommed
     * @desc Used when graph points covers larger range than provided histogram */
   unzoomUserRange(dox, doy /*, doz*/) {
      let graph = this.getObject();
      if (this._own_histogram || !graph) return false;

      let histo = graph.fHistogram;

      dox = dox && histo && ((histo.fXaxis.fXmin > this.xmin) || (histo.fXaxis.fXmax < this.xmax));
      doy = doy && histo && ((histo.fYaxis.fXmin > this.ymin) || (histo.fYaxis.fXmax < this.ymax));
      if (!dox && !doy) return false;

      this.createHistogram(dox, doy);
      this.getMainPainter()?.extractAxesProperties(1); // just to enforce ranges extraction

      return true;
   }

   /** @summary Returns true if graph drawing can be optimize */
   canOptimize() {
      return (settings.OptimizeDraw > 0) && !this.options.NoOpt;
   }

   /** @summary Returns optimized bins - if optimization enabled */
   optimizeBins(maxpnt, filter_func) {
      if ((this.bins.length < 30) && !filter_func) return this.bins;

      let selbins = null;
      if (isFunc(filter_func)) {
         for (let n = 0; n < this.bins.length; ++n) {
            if (filter_func(this.bins[n],n)) {
               if (!selbins) selbins = (n == 0) ? [] : this.bins.slice(0, n);
            } else {
               if (selbins) selbins.push(this.bins[n]);
            }
         }
      }
      if (!selbins) selbins = this.bins;

      if (!maxpnt) maxpnt = 500000;

      if ((selbins.length < maxpnt) || !this.canOptimize()) return selbins;
      let step = Math.floor(selbins.length / maxpnt);
      if (step < 2) step = 2;
      let optbins = [];
      for (let n = 0; n < selbins.length; n+=step)
         optbins.push(selbins[n]);

      return optbins;
   }

   /** @summary Returns tooltip for specified bin */
   getTooltips(d) {
      let pmain = this.get_main(), lines = [],
          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),
          gme = this.get_gme();

      lines.push(this.getObjectHint());

      if (d && funcs) {
         if (d.indx !== undefined)
            lines.push('p = ' + d.indx);
         lines.push('x = ' + funcs.axisAsText('x', d.x), 'y = ' + funcs.axisAsText('y', d.y));
         if (gme)
            lines.push('error x = -' + funcs.axisAsText('x', gme.fExL[d.indx]) + '/+' + funcs.axisAsText('x', gme.fExH[d.indx]));
         else if (this.options.Errors && (funcs.x_handle.kind == 'normal') && (d.exlow || d.exhigh))
            lines.push('error x = -' + funcs.axisAsText('x', d.exlow) + '/+' + funcs.axisAsText('x', d.exhigh));

         if (gme) {
            for (let ny = 0; ny < gme.fNYErrors; ++ny)
               lines.push(`error y${ny} = -${funcs.axisAsText('y', gme.fEyL[ny][d.indx])}/+${funcs.axisAsText('y', gme.fEyH[ny][d.indx])}`);
         } else if ((this.options.Errors || (this.options.EF > 0)) && (funcs.y_handle.kind == 'normal') && (d.eylow || d.eyhigh))
            lines.push('error y = -' + funcs.axisAsText('y', d.eylow) + '/+' + funcs.axisAsText('y', d.eyhigh));

      }
      return lines;
   }

   /** @summary Provide frame painter for graph
     * @desc If not exists, emulate its behaviour */
   get_main() {
      let pmain = this.getFramePainter();

      if (pmain && pmain.grx && pmain.gry) return pmain;

      // FIXME: check if needed, can be removed easily
      let pp = this.getPadPainter(),
          rect = pp?.getPadRect() || { width: 800, height: 600 };

      pmain = {
          pad_layer: true,
          pad: pp?.getRootPad(true),
          pw: rect.width,
          ph: rect.height,
          getFrameWidth() { return this.pw; },
          getFrameHeight() { return this.ph; },
          grx(value) {
             if (this.pad.fLogx)
                value = (value > 0) ? Math.log10(value) : this.pad.fUxmin;
             else
                value = (value - this.pad.fX1) / (this.pad.fX2 - this.pad.fX1);
             return value * this.pw;
          },
          gry(value) {
             if (this.pad.fLogy)
                value = (value > 0) ? Math.log10(value) : this.pad.fUymin;
             else
                value = (value - this.pad.fY1) / (this.pad.fY2 - this.pad.fY1);
             return (1 - value) * this.ph;
          },
          revertAxis(name, v) {
            if (name == 'x')
               return v / this.pw * (this.pad.fX2 - this.pad.fX1) + this.pad.fX1;
            if (name == 'y')
               return (1 - v / this.ph) * (this.pad.fY2 - this.pad.fY1) + this.pad.fY1;
            return v;
          },
          getGrFuncs() { return this; }
      };

      return pmain.pad ? pmain : null;
   }

   /** @summary append exclusion area to created path */
   appendExclusion(is_curve, path, drawbins, excl_width) {
      let extrabins = [];
      for (let n = drawbins.length-1; n >= 0; --n) {
         let bin = drawbins[n],
             dlen = Math.sqrt(bin.dgrx**2 + bin.dgry**2);
         // shift point
         bin.grx += excl_width*bin.dgry/dlen;
         bin.gry -= excl_width*bin.dgrx/dlen;
         extrabins.push(bin);
      }

      let path2 = buildSvgPath(is_curve ? 'Lbezier' : 'Lline', extrabins);

      this.draw_g.append('svg:path')
                 .attr('d', path.path + path2.path + 'Z')
                 .call(this.fillatt.func)
                 .style('opacity', 0.75);
   }

   /** @summary draw TGraph bins with specified options
     * @desc Can be called several times */
   drawBins(funcs, options, draw_g, w, h, lineatt, fillatt, main_block) {
      let graph = this.getObject(),
          excl_width = 0, drawbins = null;

      if (main_block && lineatt.excl_side) {
         excl_width = lineatt.excl_width;
         if ((lineatt.width > 0) && !options.Line && !options.Curve) options.Line = 1;
      }

      if (options.EF) {
         drawbins = this.optimizeBins((options.EF > 1) ? 20000 : 0);

         // build lower part
         for (let n = 0; n < drawbins.length; ++n) {
            let bin = drawbins[n];
            bin.grx = funcs.grx(bin.x);
            bin.gry = funcs.gry(bin.y - bin.eylow);
         }

         let path1 = buildSvgPath((options.EF > 1) ? 'bezier' : 'line', drawbins),
             bins2 = [];

         for (let n = drawbins.length-1; n >= 0; --n) {
            let bin = drawbins[n];
            bin.gry = funcs.gry(bin.y + bin.eyhigh);
            bins2.push(bin);
         }

         // build upper part (in reverse direction)
         let path2 = buildSvgPath((options.EF > 1) ? 'Lbezier' : 'Lline', bins2);

         draw_g.append('svg:path')
               .attr('d', path1.path + path2.path + 'Z')
               .call(fillatt.func);
         if (main_block)
            this.draw_kind = 'lines';
      }

      if (options.Line || options.Fill) {

         let close_symbol = '';
         if (graph._typename == clTCutG) options.Fill = 1;

         if (options.Fill) {
            close_symbol = 'Z'; // always close area if we want to fill it
            excl_width = 0;
         }

         if (!drawbins) drawbins = this.optimizeBins(0);

         for (let n = 0; n < drawbins.length; ++n) {
            let bin = drawbins[n];
            bin.grx = funcs.grx(bin.x);
            bin.gry = funcs.gry(bin.y);
         }

         let kind = 'line'; // simple line
         if (excl_width) kind += 'calc'; // we need to calculated deltas to build exclusion points

         let path = buildSvgPath(kind, drawbins);

         if (excl_width)
             this.appendExclusion(false, path, drawbins, excl_width);

         let elem = draw_g.append('svg:path').attr('d', path.path + close_symbol);
         if (options.Line)
            elem.call(lineatt.func);

         if (options.Fill)
            elem.call(fillatt.func);
         else
            elem.style('fill', 'none');

         if (main_block)
            this.draw_kind = 'lines';
      }

      if (options.Curve) {
         let curvebins = drawbins;
         if ((this.draw_kind != 'lines') || !curvebins || ((options.Curve == 1) && (curvebins.length > 20000))) {
            curvebins = this.optimizeBins((options.Curve == 1) ? 20000 : 0);
            for (let n = 0; n < curvebins.length; ++n) {
               let bin = curvebins[n];
               bin.grx = funcs.grx(bin.x);
               bin.gry = funcs.gry(bin.y);
            }
         }

         let kind = 'bezier';
         if (excl_width) kind += 'calc'; // we need to calculated deltas to build exclusion points

         let path = buildSvgPath(kind, curvebins);

         if (excl_width)
             this.appendExclusion(true, path, curvebins, excl_width);

         draw_g.append('svg:path')
               .attr('d', path.path)
               .call(lineatt.func)
               .style('fill', 'none');
         if (main_block)
            this.draw_kind = 'lines'; // handled same way as lines
      }

      let nodes = null;

      if (options.Errors || options.Rect || options.Bar) {

         drawbins = this.optimizeBins(5000, (pnt,i) => {

            let grx = funcs.grx(pnt.x);

            // when drawing bars, take all points
            if (!options.Bar && ((grx < 0) || (grx > w))) return true;

            let gry = funcs.gry(pnt.y);

            if (!options.Bar && !options.OutRange && ((gry < 0) || (gry > h))) return true;

            pnt.grx1 = Math.round(grx);
            pnt.gry1 = Math.round(gry);

            if (this.has_errors) {
               pnt.grx0 = Math.round(funcs.grx(pnt.x - options.ScaleErrX*pnt.exlow) - grx);
               pnt.grx2 = Math.round(funcs.grx(pnt.x + options.ScaleErrX*pnt.exhigh) - grx);
               pnt.gry0 = Math.round(funcs.gry(pnt.y - pnt.eylow) - gry);
               pnt.gry2 = Math.round(funcs.gry(pnt.y + pnt.eyhigh) - gry);

               if (this.is_bent) {
                  pnt.grdx0 = Math.round(funcs.gry(pnt.y + graph.fEXlowd[i]) - gry);
                  pnt.grdx2 = Math.round(funcs.gry(pnt.y + graph.fEXhighd[i]) - gry);
                  pnt.grdy0 = Math.round(funcs.grx(pnt.x + graph.fEYlowd[i]) - grx);
                  pnt.grdy2 = Math.round(funcs.grx(pnt.x + graph.fEYhighd[i]) - grx);
               } else {
                  pnt.grdx0 = pnt.grdx2 = pnt.grdy0 = pnt.grdy2 = 0;
               }
            }

            return false;
         });

         if (main_block)
            this.draw_kind = 'nodes';

         nodes = draw_g.selectAll('.grpoint')
                       .data(drawbins)
                       .enter()
                       .append('svg:g')
                       .attr('class', 'grpoint')
                       .attr('transform', d => `translate(${d.grx1},${d.gry1})`);
      }

      if (options.Bar) {
         // calculate bar width
         for (let i = 1; i < drawbins.length-1; ++i)
            drawbins[i].width = Math.max(2, (drawbins[i+1].grx1 - drawbins[i-1].grx1) / 2 - 2);

         // first and last bins
         switch (drawbins.length) {
            case 0: break;
            case 1: drawbins[0].width = w/4; break; // pathologic case of single bin
            case 2: drawbins[0].width = drawbins[1].width = (drawbins[1].grx1-drawbins[0].grx1)/2; break;
            default:
               drawbins[0].width = drawbins[1].width;
               drawbins[drawbins.length-1].width = drawbins[drawbins.length-2].width;
         }

         let yy0 = Math.round(funcs.gry(0)), usefill = fillatt;

         if (main_block) {
            let fp = this.getFramePainter(),
                fpcol = fp?.fillatt && !fp?.fillatt.empty() ? fp.fillatt.getFillColor() : -1;
            if (fpcol === fillatt.getFillColor())
               usefill = new TAttFillHandler({ color: fpcol == 'white' ? 1 : 0, pattern: 1001 });
         }

         nodes.append('svg:path')
              .attr('d', d => {
                 d.bar = true; // element drawn as bar
                 let dx = Math.round(-d.width/2),
                     dw = Math.round(d.width),
                     dy = (options.Bar !== 1) ? 0 : ((d.gry1 > yy0) ? yy0-d.gry1 : 0),
                     dh = (options.Bar !== 1) ? (h > d.gry1 ? h - d.gry1 : 0) : Math.abs(yy0 - d.gry1);
                 return `M${dx},${dy}h${dw}v${dh}h${-dw}z`;
              })
            .call(usefill.func);
      }

      if (options.Rect) {
         nodes.filter(d => (d.exlow > 0) && (d.exhigh > 0) && (d.eylow > 0) && (d.eyhigh > 0))
           .append('svg:path')
           .attr('d', d => {
               d.rect = true;
               return `M${d.grx0},${d.gry0}H${d.grx2}V${d.gry2}H${d.grx0}Z`;
            })
           .call(fillatt.func)
           .call(options.Rect === 2 ? lineatt.func : () => {});
      }

      this.error_size = 0;

      if (options.Errors) {
         // to show end of error markers, use line width attribute
         let lw = lineatt.width + gStyle.fEndErrorSize, bb = 0,
             vv = options.Ends ? `m0,${lw}v${-2*lw}` : '',
             hh = options.Ends ? `m${lw},0h${-2*lw}` : '',
             vleft = vv, vright = vv, htop = hh, hbottom = hh;

         const mainLine = (dx,dy) => {
            if (!options.MainError) return `M${dx},${dy}`;
            let res = 'M0,0';
            if (dx) return res + (dy ? `L${dx},${dy}` : `H${dx}`);
            return dy ? res + `V${dy}` : res;
         };

         switch (options.Ends) {
            case 2:  // option []
               bb = Math.max(lineatt.width+1, Math.round(lw*0.66));
               vleft = `m${bb},${lw}h${-bb}v${-2*lw}h${bb}`;
               vright = `m${-bb},${lw}h${bb}v${-2*lw}h${-bb}`;
               htop = `m${-lw},${bb}v${-bb}h${2*lw}v${bb}`;
               hbottom = `m${-lw},${-bb}v${bb}h${2*lw}v${-bb}`;
               break;
            case 3: // option |>
               lw = Math.max(lw, Math.round(graph.fMarkerSize*8*0.66));
               bb = Math.max(lineatt.width+1, Math.round(lw*0.66));
               vleft = `l${bb},${lw}v${-2*lw}l${-bb},${lw}`;
               vright = `l${-bb},${lw}v${-2*lw}l${bb},${lw}`;
               htop = `l${-lw},${bb}h${2*lw}l${-lw},${-bb}`;
               hbottom = `l${-lw},${-bb}h${2*lw}l${-lw},${bb}`;
               break;
            case 4: // option >
               lw = Math.max(lw, Math.round(graph.fMarkerSize*8*0.66));
               bb = Math.max(lineatt.width+1, Math.round(lw*0.66));
               vleft = `l${bb},${lw}m0,${-2*lw}l${-bb},${lw}`;
               vright = `l${-bb},${lw}m0,${-2*lw}l${bb},${lw}`;
               htop = `l${-lw},${bb}m${2*lw},0l${-lw},${-bb}`;
               hbottom = `l${-lw},${-bb}m${2*lw},0l${-lw},${bb}`;
               break;
         }

         this.error_size = lw;

         lw = Math.floor((lineatt.width-1)/2); // one should take into account half of end-cup line width

         let visible = nodes.filter(d => (d.exlow > 0) || (d.exhigh > 0) || (d.eylow > 0) || (d.eyhigh > 0));
         if (options.skip_errors_x0 || options.skip_errors_y0)
            visible = visible.filter(d => ((d.x != 0) || !options.skip_errors_x0) && ((d.y != 0) || !options.skip_errors_y0));

         if (!isBatchMode() && settings.Tooltip && main_block)
            visible.append('svg:path')
                   .style('fill', 'none')
                   .style('pointer-events', 'visibleFill')
                   .attr('d', d => `M${d.grx0},${d.gry0}h${d.grx2-d.grx0}v${d.gry2-d.gry0}h${d.grx0-d.grx2}z`);

         visible.append('svg:path')
             .call(lineatt.func)
             .style('fill', 'none')
             .attr('d', d => {
                d.error = true;
                return ((d.exlow > 0)  ? mainLine(d.grx0+lw, d.grdx0) + vleft : '') +
                       ((d.exhigh > 0) ? mainLine(d.grx2-lw, d.grdx2) + vright : '') +
                       ((d.eylow > 0)  ? mainLine(d.grdy0, d.gry0-lw) + hbottom : '') +
                       ((d.eyhigh > 0) ? mainLine(d.grdy2, d.gry2+lw) + htop : '');
              });
      }

      if (options.Mark) {
         // for tooltips use markers only if nodes were not created
         this.createAttMarker({ attr: graph, style: options.Mark - 100 });

         this.marker_size = this.markeratt.getFullSize();

         this.markeratt.resetPos();

         let path = '', pnt, grx, gry,
             want_tooltip = !isBatchMode() && settings.Tooltip && (!this.markeratt.fill || (this.marker_size < 7)) && !nodes && main_block,
             hints_marker = '', hsz = Math.max(5, Math.round(this.marker_size*0.7)),
             maxnummarker = 1000000 / (this.markeratt.getMarkerLength() + 7), step = 1; // let produce SVG at maximum 1MB

         if (!drawbins)
            drawbins = this.optimizeBins(maxnummarker);
         else if (this.canOptimize() && (drawbins.length > 1.5*maxnummarker))
            step = Math.min(2, Math.round(drawbins.length/maxnummarker));

         for (let n = 0; n < drawbins.length; n += step) {
            pnt = drawbins[n];
            grx = funcs.grx(pnt.x);
            if ((grx > -this.marker_size) && (grx < w + this.marker_size)) {
               gry = funcs.gry(pnt.y);
               if ((gry > -this.marker_size) && (gry < h + this.marker_size)) {
                  path += this.markeratt.create(grx, gry);
                  if (want_tooltip) hints_marker += `M${grx-hsz},${gry-hsz}h${2*hsz}v${2*hsz}h${-2*hsz}z`;
               }
            }
         }

         if (path) {
            draw_g.append('svg:path')
                  .attr('d', path)
                  .call(this.markeratt.func);
            if ((nodes === null) && (this.draw_kind == 'none') && main_block)
               this.draw_kind = (options.Mark == 101) ? 'path' : 'mark';
         }
         if (want_tooltip && hints_marker)
            draw_g.append('svg:path')
                  .attr('d', hints_marker)
                  .style('fill', 'none')
                  .style('pointer-events', 'visibleFill');
      }
   }

   /** @summary append TGraphQQ part */
   appendQQ(funcs, graph) {
      let xqmin = Math.max(funcs.scale_xmin, graph.fXq1),
          xqmax = Math.min(funcs.scale_xmax, graph.fXq2),
          yqmin = Math.max(funcs.scale_ymin, graph.fYq1),
          yqmax = Math.min(funcs.scale_ymax, graph.fYq2),
          path2 = '',
          makeLine = (x1,y1,x2,y2) => `M${funcs.grx(x1)},${funcs.gry(y1)}L${funcs.grx(x2)},${funcs.gry(y2)}`,
          yxmin = (graph.fYq2 - graph.fYq1)*(funcs.scale_xmin-graph.fXq1)/(graph.fXq2-graph.fXq1) + graph.fYq1,
          yxmax = (graph.fYq2-graph.fYq1)*(funcs.scale_xmax-graph.fXq1)/(graph.fXq2-graph.fXq1) + graph.fYq1;

      if (yxmin < funcs.scale_ymin) {
         let xymin = (graph.fXq2 - graph.fXq1)*(funcs.scale_ymin-graph.fYq1)/(graph.fYq2-graph.fYq1) + graph.fXq1;
         path2 = makeLine(xymin, funcs.scale_ymin, xqmin, yqmin);
      } else {
         path2 = makeLine(funcs.scale_xmin, yxmin, xqmin, yqmin);
      }

      if (yxmax > funcs.scale_ymax) {
         let xymax = (graph.fXq2-graph.fXq1)*(funcs.scale_ymax-graph.fYq1)/(graph.fYq2-graph.fYq1) + graph.fXq1;
         path2 += makeLine(xqmax, yqmax, xymax, funcs.scale_ymax);
      } else {
         path2 += makeLine(xqmax, yqmax, funcs.scale_xmax, yxmax);
      }

      let latt1 = new TAttLineHandler({ style: 1, width: 1, color: 'black' }),
          latt2 = new TAttLineHandler({ style: 2, width: 1, color: 'black' });

      this.draw_g.append('path')
                 .attr('d', makeLine(xqmin,yqmin,xqmax,yqmax))
                 .call(latt1.func)
                 .style('fill', 'none');

      this.draw_g.append('path')
                 .attr('d', path2)
                 .call(latt2.func)
                 .style('fill', 'none');
   }

   drawBins3D(/*fp, graph*/) {
      console.log('Load ./hist/TGraphPainter.mjs to draw graph in 3D');
   }

   /** @summary draw TGraph */
   drawGraph() {

      let pmain = this.get_main(),
          graph = this.getObject();
      if (!pmain) return;

      // special mode for TMultiGraph 3d drawing
      if (this.options.pos3d)
         return this.drawBins3D(pmain, graph);

      let is_gme = !!this.get_gme(),
          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),
          w = pmain.getFrameWidth(),
          h = pmain.getFrameHeight();

      this.createG(!pmain.pad_layer);

      if (this.options._pfc || this.options._plc || this.options._pmc) {
         let mp = this.getMainPainter();
         if (isFunc(mp?.createAutoColor)) {
            let icolor = mp.createAutoColor();
            if (this.options._pfc) { graph.fFillColor = icolor; delete this.fillatt; }
            if (this.options._plc) { graph.fLineColor = icolor; delete this.lineatt; }
            if (this.options._pmc) { graph.fMarkerColor = icolor; delete this.markeratt; }
            this.options._pfc = this.options._plc = this.options._pmc = false;
         }
      }

      this.createAttLine({ attr: graph, can_excl: true });
      this.createAttFill({ attr: graph });

      this.fillatt.used = false; // mark used only when really used

      this.draw_kind = 'none'; // indicate if special svg:g were created for each bin
      this.marker_size = 0; // indicate if markers are drawn
      let draw_g = is_gme ? this.draw_g.append('svg:g') : this.draw_g;

      this.drawBins(funcs, this.options, draw_g, w, h, this.lineatt, this.fillatt, true);

      if (graph._typename == 'TGraphQQ')
         this.appendQQ(funcs, graph);

      if (is_gme) {
         for (let k = 0; k < graph.fNYErrors; ++k) {
            let lineatt = this.lineatt, fillatt = this.fillatt;
            if (this.options.individual_styles) {
               lineatt = new TAttLineHandler({ attr: graph.fAttLine[k], std: false });
               fillatt = new TAttFillHandler({ attr: graph.fAttFill[k], std: false, svg: this.getCanvSvg() });
            }
            let sub_g = this.draw_g.append('svg:g'),
                options = k < this.options.blocks.length ? this.options.blocks[k] : this.options;
            this.extractGmeErrors(k);
            this.drawBins(funcs, options, sub_g, w, h, lineatt, fillatt);
         }
         this.extractGmeErrors(0); // ensure that first block kept at the end
      }

      if (!isBatchMode())
         addMoveHandler(this, this.testEditable());
   }

   /** @summary Provide tooltip at specified point */
   extractTooltip(pnt) {
      if (!pnt) return null;

      if ((this.draw_kind == 'lines') || (this.draw_kind == 'path') || (this.draw_kind == 'mark'))
         return this.extractTooltipForPath(pnt);

      if (this.draw_kind != 'nodes') return null;

      let pmain = this.get_main(),
          height = pmain.getFrameHeight(),
          esz = this.error_size,
          isbar1 = (this.options.Bar === 1),
          funcs = isbar1 ? pmain.getGrFuncs(this.options.second_x, this.options.second_y) : null,
          findbin = null, best_dist2 = 1e10, best = null,
          msize = this.marker_size ? Math.round(this.marker_size/2 + 1.5) : 0;

      this.draw_g.selectAll('.grpoint').each(function() {
         let d = select(this).datum();
         if (d === undefined) return;
         let dist2 = (pnt.x - d.grx1) ** 2;
         if (pnt.nproc === 1) dist2 += (pnt.y - d.gry1) ** 2;
         if (dist2 >= best_dist2) return;

         let rect;

         if (d.error || d.rect || d.marker) {
            rect = { x1: Math.min(-esz, d.grx0, -msize),
                     x2: Math.max(esz, d.grx2, msize),
                     y1: Math.min(-esz, d.gry2, -msize),
                     y2: Math.max(esz, d.gry0, msize) };
         } else if (d.bar) {
             rect = { x1: -d.width/2, x2: d.width/2, y1: 0, y2: height - d.gry1 };

             if (isbar1) {
                let yy0 = funcs.gry(0);
                rect.y1 = (d.gry1 > yy0) ? yy0-d.gry1 : 0;
                rect.y2 = (d.gry1 > yy0) ? 0 : yy0-d.gry1;
             }
          } else {
             rect = { x1: -5, x2: 5, y1: -5, y2: 5 };
          }
          let matchx = (pnt.x >= d.grx1 + rect.x1) && (pnt.x <= d.grx1 + rect.x2),
              matchy = (pnt.y >= d.gry1 + rect.y1) && (pnt.y <= d.gry1 + rect.y2);

          if (matchx && (matchy || (pnt.nproc > 1))) {
             best_dist2 = dist2;
             findbin = this;
             best = rect;
             best.exact = /* matchx && */ matchy;
          }
       });

      if (findbin === null) return null;

      let d = select(findbin).datum(),
          gr = this.getObject(),
          res = { name: gr.fName, title: gr.fTitle,
                  x: d.grx1, y: d.gry1,
                  color1: this.lineatt.color,
                  lines: this.getTooltips(d),
                  rect: best, d3bin: findbin };

       res.user_info = { obj: gr, name: gr.fName, bin: d.indx, cont: d.y, grx: d.grx1, gry: d.gry1 };

      if (this.fillatt && this.fillatt.used && !this.fillatt.empty())
         res.color2 = this.fillatt.getFillColor();

      if (best.exact) res.exact = true;
      res.menu = res.exact; // activate menu only when exactly locate bin
      res.menu_dist = 3; // distance always fixed
      res.bin = d;
      res.binindx = d.indx;

      return res;
   }

   /** @summary Show tooltip */
   showTooltip(hint) {

      if (!hint) {
         if (this.draw_g) this.draw_g.select('.tooltip_bin').remove();
         return;
      }

      if (hint.usepath) return this.showTooltipForPath(hint);

      let d = select(hint.d3bin).datum(),
          ttrect = this.draw_g.select('.tooltip_bin');

      if (ttrect.empty())
         ttrect = this.draw_g.append('svg:rect')
                             .attr('class', 'tooltip_bin h1bin')
                             .style('pointer-events', 'none');

      hint.changed = ttrect.property('current_bin') !== hint.d3bin;

      if (hint.changed)
         ttrect.attr('x', d.grx1 + hint.rect.x1)
               .attr('width', hint.rect.x2 - hint.rect.x1)
               .attr('y', d.gry1 + hint.rect.y1)
               .attr('height', hint.rect.y2 - hint.rect.y1)
               .style('opacity', '0.3')
               .property('current_bin', hint.d3bin);
   }

   /** @summary Process tooltip event */
   processTooltipEvent(pnt) {
      let hint = this.extractTooltip(pnt);
      if (!pnt || !pnt.disabled) this.showTooltip(hint);
      return hint;
   }

   /** @summary Find best bin index for specified point */
   findBestBin(pnt) {
      if (!this.bins) return null;

      let islines = (this.draw_kind == 'lines'),
          bestindx = -1,
          bestbin = null,
          bestdist = 1e10,
          funcs = this.get_main().getGrFuncs(this.options.second_x, this.options.second_y),
          dist, grx, gry, n, bin;

      for (n = 0; n < this.bins.length; ++n) {
         bin = this.bins[n];

         grx = funcs.grx(bin.x);
         gry = funcs.gry(bin.y);

         dist = (pnt.x-grx)**2 + (pnt.y-gry)**2;

         if (dist < bestdist) {
            bestdist = dist;
            bestbin = bin;
            bestindx = n;
         }
      }

      // check last point
      if ((bestdist > 100) && islines) bestbin = null;

      let radius = Math.max(this.lineatt.width + 3, 4);

      if (this.marker_size > 0) radius = Math.max(this.marker_size, radius);

      if (bestbin)
         bestdist = Math.sqrt((pnt.x-funcs.grx(bestbin.x))**2 + (pnt.y-funcs.gry(bestbin.y))**2);

      if (!islines && (bestdist > radius)) bestbin = null;

      if (!bestbin) bestindx = -1;

      let res = { bin: bestbin, indx: bestindx, dist: bestdist, radius: Math.round(radius) };

      if (!bestbin && islines) {

         bestdist = 1e10;

         const IsInside = (x, x1, x2) => ((x1 >= x) && (x >= x2)) || ((x1 <= x) && (x <= x2));

         let bin0 = this.bins[0], grx0 = funcs.grx(bin0.x), gry0, posy = 0;
         for (n = 1; n < this.bins.length; ++n) {
            bin = this.bins[n];
            grx = funcs.grx(bin.x);

            if (IsInside(pnt.x, grx0, grx)) {
               // if inside interval, check Y distance
               gry0 = funcs.gry(bin0.y);
               gry = funcs.gry(bin.y);

               if (Math.abs(grx - grx0) < 1) {
                  // very close x - check only y
                  posy = pnt.y;
                  dist = IsInside(pnt.y, gry0, gry) ? 0 : Math.min(Math.abs(pnt.y-gry0), Math.abs(pnt.y-gry));
               } else {
                  posy = gry0 + (pnt.x - grx0) / (grx - grx0) * (gry - gry0);
                  dist = Math.abs(posy - pnt.y);
               }

               if (dist < bestdist) {
                  bestdist = dist;
                  res.linex = pnt.x;
                  res.liney = posy;
               }
            }

            bin0 = bin;
            grx0 = grx;
         }

         if (bestdist < radius*0.5) {
            res.linedist = bestdist;
            res.closeline = true;
         }
      }

      return res;
   }

   /** @summary Check editable flag for TGraph
     * @desc if arg specified changes or toggles editable flag */
   testEditable(arg) {
      let obj = this.getObject();
      if (!obj) return false;
      if ((arg == 'toggle') || ((arg !== undefined) && (!arg != obj.TestBit(kNotEditable))))
         obj.InvertBit(kNotEditable);
      return !obj.TestBit(kNotEditable);
   }

   /** @summary Provide tooltip at specified point for path-based drawing */
   extractTooltipForPath(pnt) {

      if (this.bins === null) return null;

      let best = this.findBestBin(pnt);

      if (!best || (!best.bin && !best.closeline)) return null;

      let islines = (this.draw_kind == 'lines'),
          ismark = (this.draw_kind == 'mark'),
          pmain = this.get_main(),
          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),
          gr = this.getObject(),
          res = { name: gr.fName, title: gr.fTitle,
                  x: best.bin ? funcs.grx(best.bin.x) : best.linex,
                  y: best.bin ? funcs.gry(best.bin.y) : best.liney,
                  color1: this.lineatt.color,
                  lines: this.getTooltips(best.bin),
                  usepath: true };

      res.user_info = { obj: gr, name: gr.fName, bin: 0, cont: 0, grx: res.x, gry: res.y };

      res.ismark = ismark;
      res.islines = islines;

      if (best.closeline) {
         res.menu = res.exact = true;
         res.menu_dist = best.linedist;
      } else if (best.bin) {
         if (this.options.EF && islines) {
            res.gry1 = funcs.gry(best.bin.y - best.bin.eylow);
            res.gry2 = funcs.gry(best.bin.y + best.bin.eyhigh);
         } else {
            res.gry1 = res.gry2 = funcs.gry(best.bin.y);
         }

         res.binindx = best.indx;
         res.bin = best.bin;
         res.radius = best.radius;
         res.user_info.bin = best.indx;
         res.user_info.cont = best.bin.y;

         res.exact = (Math.abs(pnt.x - res.x) <= best.radius) &&
            ((Math.abs(pnt.y - res.gry1) <= best.radius) || (Math.abs(pnt.y - res.gry2) <= best.radius));

         res.menu = res.exact;
         res.menu_dist = Math.sqrt((pnt.x-res.x)**2 + Math.min(Math.abs(pnt.y-res.gry1), Math.abs(pnt.y-res.gry2))**2);
      }

      if (this.fillatt && this.fillatt.used && !this.fillatt.empty())
         res.color2 = this.fillatt.getFillColor();

      if (!islines) {
         res.color1 = this.getColor(gr.fMarkerColor);
         if (!res.color2) res.color2 = res.color1;
      }

      return res;
   }

   /** @summary Show tooltip for path drawing */
   showTooltipForPath(hint) {

      let ttbin = this.draw_g.select('.tooltip_bin');

      if (!hint || !hint.bin) {
         ttbin.remove();
         return;
      }

      if (ttbin.empty())
         ttbin = this.draw_g.append('svg:g').attr('class', 'tooltip_bin');

      hint.changed = ttbin.property('current_bin') !== hint.bin;

      if (hint.changed) {
         ttbin.selectAll('*').remove(); // first delete all children
         ttbin.property('current_bin', hint.bin);

         if (hint.ismark) {
            ttbin.append('svg:rect')
                 .attr('class','h1bin')
                 .style('pointer-events','none')
                 .style('opacity', '0.3')
                 .attr('x', Math.round(hint.x - hint.radius))
                 .attr('y', Math.round(hint.y - hint.radius))
                 .attr('width', 2*hint.radius)
                 .attr('height', 2*hint.radius);
         } else {
            ttbin.append('svg:circle').attr('cy', Math.round(hint.gry1));
            if (Math.abs(hint.gry1-hint.gry2) > 1)
               ttbin.append('svg:circle').attr('cy', Math.round(hint.gry2));

            let elem = ttbin.selectAll('circle')
                            .attr('r', hint.radius)
                            .attr('cx', Math.round(hint.x));

            if (!hint.islines) {
               elem.style('stroke', hint.color1 == 'black' ? 'green' : 'black').style('fill','none');
            } else {
               if (this.options.Line || this.options.Curve)
                  elem.call(this.lineatt.func);
               else
                  elem.style('stroke','black');
               if (this.options.Fill)
                  elem.call(this.fillatt.func);
               else
                  elem.style('fill','none');
            }
         }
      }
   }

   /** @summary Check if graph moving is enabled */
   moveEnabled() {
      return this.testEditable();
   }

   /** @summary Start moving of TGraph */
   moveStart(x,y) {
      this.pos_dx = this.pos_dy = 0;
      this.move_funcs = this.get_main().getGrFuncs(this.options.second_x, this.options.second_y);
      let hint = this.extractTooltip({x, y});
      if (hint && hint.exact && (hint.binindx !== undefined)) {
         this.move_binindx = hint.binindx;
         this.move_bin = hint.bin;
         this.move_x0 = this.move_funcs.grx(this.move_bin.x);
         this.move_y0 = this.move_funcs.gry(this.move_bin.y);
      } else {
         delete this.move_binindx;
      }
   }

   /** @summary Perform moving */
   moveDrag(dx,dy) {
      this.pos_dx += dx;
      this.pos_dy += dy;

      if (this.move_binindx === undefined) {
         this.draw_g.attr('transform', `translate(${this.pos_dx},${this.pos_dy})`);
      } else if (this.move_funcs && this.move_bin) {
         this.move_bin.x = this.move_funcs.revertAxis('x', this.move_x0 + this.pos_dx);
         this.move_bin.y = this.move_funcs.revertAxis('y', this.move_y0 + this.pos_dy);
         this.drawGraph();
      }
   }

   /** @summary Complete moving */
   moveEnd(not_changed) {
      let exec = '';

      if (this.move_binindx === undefined) {
         this.draw_g.attr('transform', null);

         if (this.move_funcs && this.bins && !not_changed) {
            for (let k = 0; k < this.bins.length; ++k) {
               let bin = this.bins[k];
               bin.x = this.move_funcs.revertAxis('x', this.move_funcs.grx(bin.x) + this.pos_dx);
               bin.y = this.move_funcs.revertAxis('y', this.move_funcs.gry(bin.y) + this.pos_dy);
               exec += `SetPoint(${bin.indx},${bin.x},${bin.y});;`;
               if ((bin.indx == 0) && this.matchObjectType(clTCutG))
                  exec += `SetPoint(${this.getObject().fNpoints-1},${bin.x},${bin.y});;`;
            }
            this.drawGraph();
         }
      } else {
         exec = `SetPoint(${this.move_bin.indx},${this.move_bin.x},${this.move_bin.y});;`;
         if ((this.move_bin.indx == 0) && this.matchObjectType(clTCutG))
            exec += `SetPoint(${this.getObject().fNpoints-1},${this.move_bin.x},${this.move_bin.y});;`;
         delete this.move_binindx;
      }

      delete this.move_funcs;

      if (exec && !not_changed)
         this.submitCanvExec(exec);
   }

   /** @summary Fill context menu */
   fillContextMenu(menu) {
      super.fillContextMenu(menu);

      if (!this.snapid)
         menu.addchk(this.testEditable(), 'Editable', () => { this.testEditable('toggle'); this.drawGraph(); });

      return menu.size() > 0;
   }

   /** @summary Execute menu command
     * @private */
   executeMenuCommand(method, args) {
      if (super.executeMenuCommand(method,args)) return true;

      let canp = this.getCanvPainter(), pmain = this.get_main();

      if ((method.fName == 'RemovePoint') || (method.fName == 'InsertPoint')) {
         if (!canp || canp._readonly) return true; // ignore function

         let pnt = isFunc(pmain?.getLastEventPos) ? pmain.getLastEventPos() : null,
             hint = this.extractTooltip(pnt);

         if (method.fName == 'InsertPoint') {
            if (pnt) {
               let funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),
                   userx = funcs.revertAxis('x', pnt.x) ?? 0,
                   usery = funcs.revertAxis('y', pnt.y) ?? 0;
               this.submitCanvExec(`AddPoint(${userx.toFixed(3)}, ${usery.toFixed(3)})`, this.args_menu_id);
            }
         } else if (this.args_menu_id && (hint?.binindx !== undefined)) {
            this.submitCanvExec(`RemovePoint(${hint.binindx})`, this.args_menu_id);
         }

         return true; // call is processed
      }

      return false;
   }

   /** @summary Update TGraph object */
   updateObject(obj, opt) {
      if (!this.matchObjectType(obj)) return false;

      if (opt && (opt != this.options.original))
         this.decodeOptions(opt);

      let graph = this.getObject();
      // TODO: make real update of TGraph object content
      graph.fBits = obj.fBits;
      graph.fTitle = obj.fTitle;
      graph.fX = obj.fX;
      graph.fY = obj.fY;
      graph.fNpoints = obj.fNpoints;
      graph.fMinimum = obj.fMinimum;
      graph.fMaximum = obj.fMaximum;
      this.createBins();

      delete this.$redraw_hist;

      // if our own histogram was used as axis drawing, we need update histogram as well
      if (this.axes_draw) {
         let histo = this.createHistogram();
         histo.fTitle = graph.fTitle; // copy title

         let hist_painter = this.getMainPainter();
         if (hist_painter?.$secondary) {
            hist_painter.updateObject(histo, this.options.Axis);
            this.$redraw_hist = true;
         }
      }

      return true;
   }

   /** @summary Checks if it makes sense to zoom inside specified axis range
     * @desc allow to zoom TGraph only when at least one point in the range */
   canZoomInside(axis,min,max) {
      let gr = this.getObject();
      if (!gr || (axis !== (this.options.pos3d ? 'y' : 'x'))) return false;

      for (let n = 0; n < gr.fNpoints; ++n)
         if ((min < gr.fX[n]) && (gr.fX[n] < max)) return true;

      return false;
   }

   /** @summary Process click on graph-defined buttons */
   clickButton(funcname) {
      if (funcname !== 'ToggleZoom') return false;

      let main = this.getFramePainter();
      if (!main) return false;

      if ((this.xmin === this.xmax) && (this.ymin === this.ymax)) return false;

      main.zoom(this.xmin, this.xmax, this.ymin, this.ymax);

      return true;
   }

   /** @summary Find TF1/TF2 in TGraph list of functions */
   findFunc() {
      let gr = this.getObject();
      if (gr?.fFunctions?.arr)
         return gr?.fFunctions?.arr.find(func => (func._typename == clTF1) || (func._typename == clTF2));
      return null;
   }

   /** @summary Find stat box in TGraph list of functions */
   findStat() {
      let gr = this.getObject();
      if (gr?.fFunctions?.arr)
         for (let i = 0; i < gr.fFunctions.arr.length; ++i) {
            let func = gr.fFunctions.arr[i];
            if ((func._typename == clTPaveStats) && (func.fName == 'stats')) return func;
         }
      return null;
   }

   /** @summary Create stat box */
   createStat() {
      let func = this.findFunc();
      if (!func) return null;

      let stats = this.findStat();
      if (stats) return stats;

      // do not create stats box when drawing canvas
      if (this.getCanvPainter()?.normal_canvas || this.options.PadStats) return null;

      this.create_stats = true;

      const st = gStyle;

      stats = create$1(clTPaveStats);
      Object.assign(stats, { fName : 'stats', fOptStat: 0, fOptFit: st.fOptFit || 111, fBorderSize: 1 });

      stats.fX1NDC = st.fStatX - st.fStatW;
      stats.fY1NDC = st.fStatY - st.fStatH;
      stats.fX2NDC = st.fStatX;
      stats.fY2NDC = st.fStatY;

      stats.fFillColor = st.fStatColor;
      stats.fFillStyle = st.fStatStyle;

      stats.fTextAngle = 0;
      stats.fTextSize = st.fStatFontSize; // 9 ??
      stats.fTextAlign = 12;
      stats.fTextColor = st.fStatTextColor;
      stats.fTextFont = st.fStatFont;

      stats.AddText(func.fName);

      // while TF1 was found, one can be sure that stats is existing
      this.getObject().fFunctions.Add(stats);

      return stats;
   }

   /** @summary Fill statistic */
   fillStatistic(stat, dostat, dofit) {

      // cannot fill stats without func
      let func = this.findFunc();

      if (!func || !dofit || !this.create_stats) return false;

      stat.clearPave();

      stat.fillFunctionStat(func, dofit);

      return true;
   }

   /** @summary method draws next function from the functions list
     * @return {Promise} */
   async drawNextFunction(indx) {

      let graph = this.getObject();

      if (indx >= (graph?.fFunctions?.arr?.length || 0))
         return this;

      let pp = this.getPadPainter(),
          func = graph.fFunctions.arr[indx],
          opt = graph.fFunctions.opt[indx];

      //  required for stats filling
      // TODO: use weak reference (via pad list of painters and any kind of string)
      func.$main_painter = this;

      return pp.drawObject(this.getDom(), func, opt).then(() => this.drawNextFunction(indx+1));
   }

   /** @summary Draw axis histogram
     * @private */
   async drawAxisHisto() {
      let histo = this.createHistogram();
      return TH1Painter$2.draw(this.getDom(), histo, this.options.Axis)
   }

   /** @summary Draw TGraph
     * @private */
   static async _drawGraph(painter, opt) {
      painter.decodeOptions(opt, true);
      painter.createBins();
      painter.createStat();
      if (!settings.DragGraphs && !graph.TestBit(kNotEditable))
         graph.InvertBit(kNotEditable);

      let promise = Promise.resolve();

      if ((!painter.getMainPainter() || painter.options.second_x || painter.options.second_y) && painter.options.Axis)
         promise = painter.drawAxisHisto().then(hist_painter => {
            if (hist_painter) {
               painter.axes_draw = true;
               if (!painter._own_histogram) painter.$primary = true;
               hist_painter.$secondary = 'hist';
            }
         });

      return promise.then(() => {
         painter.addToPadPrimitives();
         return painter.drawGraph();
      }).then(() => painter.drawNextFunction(0));
   }

   static async draw(dom, graph, opt) {
      return TGraphPainter$1._drawGraph(new TGraphPainter$1(dom, graph), opt);
   }

} // class TGraphPainter

var TGraphPainter$2 = /*#__PURE__*/Object.freeze({
__proto__: null,
clTGraphAsymmErrors: clTGraphAsymmErrors,
TGraphPainter: TGraphPainter$1
});

function proivdeEvalPar(obj) {

   obj._math = jsroot_math;

   let _func = obj.fTitle, isformula = false, pprefix = '[';
   if (_func === 'gaus') _func = 'gaus(0)';
   if (obj.fFormula && isStr(obj.fFormula.fFormula)) {
     if (obj.fFormula.fFormula.indexOf('[](double*x,double*p)') == 0) {
        isformula = true; pprefix = 'p[';
        _func = obj.fFormula.fFormula.slice(21);
     } else {
        _func = obj.fFormula.fFormula;
        pprefix = '[p';
     }

     if (obj.fFormula.fClingParameters && obj.fFormula.fParams)
        obj.fFormula.fParams.forEach(pair => {
           let regex = new RegExp(`(\\[${pair.first}\\])`, 'g'),
               parvalue = obj.fFormula.fClingParameters[pair.second];
           _func = _func.replace(regex, (parvalue < 0) ? `(${parvalue})` : parvalue);
        });
  }

  if ('formulas' in obj)
     obj.formulas.forEach(entry => {
       _func = _func.replaceAll(entry.fName, entry.fTitle);
     });

  _func = _func.replace(/\b(abs)\b/g, 'TMath::Abs')
               .replace(/\b(TMath::Exp)/g, 'Math.exp')
               .replace(/\b(TMath::Abs)/g, 'Math.abs');

  _func = _func.replace(/xygaus\(/g, 'this._math.gausxy(this, x, y, ')
               .replace(/gaus\(/g, 'this._math.gaus(this, x, ')
               .replace(/gausn\(/g, 'this._math.gausn(this, x, ')
               .replace(/expo\(/g, 'this._math.expo(this, x, ')
               .replace(/landau\(/g, 'this._math.landau(this, x, ')
               .replace(/landaun\(/g, 'this._math.landaun(this, x, ')
               .replace(/TMath::/g, 'this._math.')
               .replace(/ROOT::Math::/g, 'this._math.');

  for (let i = 0; i < obj.fNpar; ++i)
    _func = _func.replaceAll(pprefix + i + ']', `(${obj.GetParValue(i)})`);

  _func = _func.replace(/\b(sin)\b/gi, 'Math.sin')
               .replace(/\b(cos)\b/gi, 'Math.cos')
               .replace(/\b(tan)\b/gi, 'Math.tan')
               .replace(/\b(exp)\b/gi, 'Math.exp')
               .replace(/\b(pow)\b/gi, 'Math.pow')
               .replace(/pi/g, 'Math.PI');
  for (let n = 2; n < 10; ++n)
     _func = _func.replaceAll(`x^${n}`, `Math.pow(x,${n})`);

  if (isformula) {
     _func = _func.replace(/x\[0\]/g,'x');
     if (obj._typename === clTF2) {
        _func = _func.replace(/x\[1\]/g,'y');
        obj.evalPar = new Function('x', 'y', _func).bind(obj);
     } else {
        obj.evalPar = new Function('x', _func).bind(obj);
     }
  } else if (obj._typename === clTF2)
     obj.evalPar = new Function('x', 'y', 'return ' + _func).bind(obj);
  else
     obj.evalPar = new Function('x', 'return ' + _func).bind(obj);
}

/**
  * @summary Painter for TF1 object
  *
  * @private
  */

class TF1Painter extends ObjectPainter {

   /** @summary Create bins for TF1 drawing */
   createBins(ignore_zoom) {
      let tf1 = this.getObject(),
          main = this.getFramePainter(),
          gxmin = 0, gxmax = 0;

      if (main && !ignore_zoom)  {
         let gr = main.getGrFuncs(this.second_x, this.second_y);
         gxmin = gr.scale_xmin;
         gxmax = gr.scale_xmax;
      }

      let xmin = tf1.fXmin, xmax = tf1.fXmax, logx = false;

      if (gxmin !== gxmax) {
         if (gxmin > xmin) xmin = gxmin;
         if (gxmax < xmax) xmax = gxmax;
      }

      if (main && main.logx && (xmin > 0) && (xmax > 0)) {
         logx = true;
         xmin = Math.log(xmin);
         xmax = Math.log(xmax);
      }

      let np = Math.max(tf1.fNpx, 101),
          dx = (xmax - xmin) / (np - 1),
          res = [], iserror = false,
          has_saved_points = tf1.fSave.length > 3,
          force_use_save = has_saved_points && (ignore_zoom || settings.PreferSavedPoints);

      if (!force_use_save) {
         if (!tf1.evalPar)
            proivdeEvalPar(tf1);

         for (let n = 0; n < np; n++) {
            let x = xmin + n*dx, y = 0;
            if (logx) x = Math.exp(x);
            try {
               y = tf1.evalPar(x);
            } catch(err) {
               iserror = true;
            }

            if (iserror) break;

            if (Number.isFinite(y))
               res.push({ x, y });
         }
      }

      // in the case there were points have saved and we cannot calculate function
      // if we don't have the user's function
      if ((iserror || ignore_zoom || !res.length) && has_saved_points) {

         np = tf1.fSave.length - 2;
         xmin = tf1.fSave[np];
         xmax = tf1.fSave[np+1];
         res = [];
         dx = 0;
         let use_histo = tf1.$histo && (xmin === xmax), bin = 0;

         if (use_histo) {
            xmin = tf1.fSave[--np];
            bin = tf1.$histo.fXaxis.FindBin(xmin, 0);
         } else {
            dx = (xmax - xmin) / (np-1);
         }

         for (let n = 0; n < np; ++n) {
            let x = use_histo ? tf1.$histo.fXaxis.GetBinCenter(bin+n+1) : xmin + dx*n;
            // check if points need to be displayed at all, keep at least 4-5 points for Bezier curves
            if ((gxmin !== gxmax) && ((x + 2*dx < gxmin) || (x - 2*dx > gxmax))) continue;
            let y = tf1.fSave[n];

            if (Number.isFinite(y)) res.push({ x, y });
         }
      }

      return res;
   }

   /** @summary Create histogram for axes drawing */
   createDummyHisto() {

      let xmin = 0, xmax = 1, ymin = 0, ymax = 1,
          bins = this.createBins(true);

      if (bins?.length) {

         xmin = xmax = bins[0].x;
         ymin = ymax = bins[0].y;

         bins.forEach(bin => {
            xmin = Math.min(bin.x, xmin);
            xmax = Math.max(bin.x, xmax);
            ymin = Math.min(bin.y, ymin);
            ymax = Math.max(bin.y, ymax);
         });

         if (ymax > 0.0) ymax *= (1 + gStyle.fHistTopMargin);
         if (ymin < 0.0) ymin *= (1 + gStyle.fHistTopMargin);
      }

      let histo = create$1('TH1I'),
          tf1 = this.getObject();

      histo.fName = tf1.fName + '_hist';
      histo.fTitle = tf1.fTitle;

      histo.fXaxis.fXmin = xmin;
      histo.fXaxis.fXmax = xmax;
      histo.fYaxis.fXmin = ymin;
      histo.fYaxis.fXmax = ymax;

      histo.fMinimum = tf1.fMinimum;
      histo.fMaximum = tf1.fMaximum;

      return histo;
   }

   updateObject(obj /*, opt */) {
      if (!this.matchObjectType(obj)) return false;
      let tf1 = this.getObject();
      Object.assign(tf1, obj);
      delete tf1.evalPar;
      return true;
   }

   /** @summary Process tooltip event */
   processTooltipEvent(pnt) {
      let cleanup = false;

      if (!pnt || !this.bins || pnt.disabled) {
         cleanup = true;
      } else if (!this.bins.length || (pnt.x < this.bins[0].grx) || (pnt.x > this.bins[this.bins.length-1].grx)) {
         cleanup = true;
      }

      if (cleanup) {
         if (this.draw_g)
            this.draw_g.select('.tooltip_bin').remove();
         return null;
      }

      let min = 100000, best = -1, bin;

      for(let n = 0; n < this.bins.length; ++n) {
         bin = this.bins[n];
         let dist = Math.abs(bin.grx - pnt.x);
         if (dist < min) { min = dist; best = n; }
      }

      bin = this.bins[best];

      let gbin = this.draw_g.select('.tooltip_bin'),
          radius = this.lineatt.width + 3;

      if (gbin.empty())
         gbin = this.draw_g.append('svg:circle')
                           .attr('class', 'tooltip_bin')
                           .style('pointer-events', 'none')
                           .attr('r', radius)
                           .call(this.lineatt.func)
                           .call(this.fillatt.func);

      let res = { name: this.getObject().fName,
                  title: this.getObject().fTitle,
                  x: bin.grx,
                  y: bin.gry,
                  color1: this.lineatt.color,
                  color2: this.fillatt.getFillColor(),
                  lines: [],
                  exact: (Math.abs(bin.grx - pnt.x) < radius) && (Math.abs(bin.gry - pnt.y) < radius) };

      res.changed = gbin.property('current_bin') !== best;
      res.menu = res.exact;
      res.menu_dist = Math.sqrt((bin.grx - pnt.x)**2 + (bin.gry - pnt.y)**2);

      if (res.changed)
         gbin.attr('cx', bin.grx)
             .attr('cy', bin.gry)
             .property('current_bin', best);

      let name = this.getObjectHint();
      if (name) res.lines.push(name);

      let pmain = this.getFramePainter(),
          funcs = pmain?.getGrFuncs(this.second_x, this.second_y);
      if (funcs)
         res.lines.push(`x = ${funcs.axisAsText('x',bin.x)} y = ${funcs.axisAsText('y',bin.y)}`);

      return res;
   }

   /** @summary Redraw function */
   redraw() {

      let tf1 = this.getObject(),
          fp = this.getFramePainter(),
          h = fp.getFrameHeight(),
          pmain = this.getMainPainter();

      this.createG(true);

      // recalculate drawing bins when necessary
      this.bins = this.createBins(false);

      this.createAttLine({ attr: tf1 });
      this.lineatt.used = false;

      this.createAttFill({ attr: tf1, kind: 1 });
      this.fillatt.used = false;

      let funcs = fp.getGrFuncs(this.second_x, this.second_y);

      // first calculate graphical coordinates
      for(let n = 0; n < this.bins.length; ++n) {
         let bin = this.bins[n];
         bin.grx = funcs.grx(bin.x);
         bin.gry = funcs.gry(bin.y);
      }

      if (this.bins.length > 2) {

         let h0 = h;  // use maximal frame height for filling
         if (pmain.hmin && (pmain.hmin >= 0)) {
            h0 = Math.round(funcs.gry(0));
            if ((h0 > h) || (h0 < 0)) h0 = h;
         }

         let path = buildSvgPath('bezier', this.bins, h0, 2);

         if (!this.lineatt.empty())
            this.draw_g.append('svg:path')
                .attr('class', 'line')
                .attr('d', path.path)
                .style('fill', 'none')
                .call(this.lineatt.func);

         if (!this.fillatt.empty())
            this.draw_g.append('svg:path')
                .attr('class', 'area')
                .attr('d', path.path + path.close)
                .call(this.fillatt.func);
      }
   }

   /** @summary Checks if it makes sense to zoom inside specified axis range */
   canZoomInside(axis,min,max) {
      if (axis !== 'x') return false;

      let tf1 = this.getObject();

      if (tf1.fSave.length > 0) {
         // in the case where the points have been saved, useful for example
         // if we don't have the user's function
         let nb_points = tf1.fNpx,
             xmin = tf1.fSave[nb_points + 1],
             xmax = tf1.fSave[nb_points + 2];

         return Math.abs(xmin - xmax) / nb_points < Math.abs(min - max);
      }

      // if function calculated, one always could zoom inside
      return true;
   }

   /** @summary draw TF1 object */
   static async draw(dom, tf1, opt) {
      let painter = new TF1Painter(dom, tf1, opt),
          d = new DrawOptions(opt),
          has_main = !!painter.getMainPainter(),
          aopt = 'AXIS';
      d.check('SAME'); // just ignore same
      if (d.check('X+')) { aopt += 'X+'; painter.second_x = has_main; }
      if (d.check('Y+')) { aopt += 'Y+'; painter.second_y = has_main; }
      if (d.check('RX')) aopt += 'RX';
      if (d.check('RY')) aopt += 'RY';

      let pr = Promise.resolve(true);

      if (!has_main || painter.second_x || painter.second_y)
         pr = TH1Painter$2.draw(dom, painter.createDummyHisto(), aopt);

      return pr.then(() => {
         painter.addToPadPrimitives();
         painter.redraw();
         return painter;
      });
   }

} // class TF1Painter

var TF1Painter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
TF1Painter: TF1Painter,
proivdeEvalPar: proivdeEvalPar
});

const kIsBayesian       = BIT(14),  ///< Bayesian statistics are used
      kPosteriorMode    = BIT(15),  ///< Use posterior mean for best estimate (Bayesian statistics)
 //   kShortestInterval = BIT(16),  ///< Use shortest interval, not implemented - too complicated
      kUseBinPrior      = BIT(17),  ///< Use a different prior for each bin
      kUseWeights       = BIT(18),  ///< Use weights
      getBetaAlpha      = (obj,bin) => (obj.fBeta_bin_params.length > bin) ? obj.fBeta_bin_params[bin].first : obj.fBeta_alpha,
      getBetaBeta       = (obj,bin) => (obj.fBeta_bin_params.length > bin) ? obj.fBeta_bin_params[bin].second : obj.fBeta_beta;

/**
 * @summary Painter for TEfficiency object
 *
 * @private
 */

class TEfficiencyPainter extends ObjectPainter {

   /** @summary Caluclate efficiency */
   getEfficiency(obj, bin) {

      const BetaMean = (a,b) => (a <= 0 || b <= 0 ) ? 0 : a / (a + b),
            BetaMode = (a,b) => {
         if (a <= 0 || b <= 0 ) return 0;
         if ( a <= 1 || b <= 1) {
            if (a < b) return 0;
            if (a > b) return 1;
            if (a == b) return 0.5; // cannot do otherwise
         }
         return (a - 1.0) / (a + b -2.0);
      };

      let total = obj.fTotalHistogram.fArray[bin], // should work for both 1-d and 2-d
          passed = obj.fPassedHistogram.fArray[bin]; // should work for both 1-d and 2-d

      if(obj.TestBit(kIsBayesian)) {
         // parameters for the beta prior distribution
         let alpha = obj.TestBit(kUseBinPrior) ? getBetaAlpha(obj, bin) : obj.fBeta_alpha,
             beta  = obj.TestBit(kUseBinPrior) ? getBetaBeta(obj, bin)  : obj.fBeta_beta;

         let aa,bb;
         if(obj.TestBit(kUseWeights)) {
            let tw =  total, // fTotalHistogram->GetBinContent(bin);
                tw2 = obj.fTotalHistogram.fSumw2 ? obj.fTotalHistogram.fSumw2[bin] : Math.abs(total),
                pw = passed; // fPassedHistogram->GetBinContent(bin);

            if (tw2 <= 0 ) return pw/tw;

            // tw/tw2 renormalize the weights
            let norm = tw/tw2;
            aa =  pw * norm + alpha;
            bb =  (tw - pw) * norm + beta;
         } else {
            aa = passed + alpha;
            bb = total - passed + beta;
         }

         if (!obj.TestBit(kPosteriorMode) )
            return BetaMean(aa,bb);
         else
            return BetaMode(aa,bb);
      }

      return total ? passed/total : 0;
   }

   /** @summary Caluclate efficiency error low */
   getEfficiencyErrorLow(obj, bin, value) {
      let total = obj.fTotalHistogram.fArray[bin],
          passed = obj.fPassedHistogram.fArray[bin],
          alpha = 0, beta = 0;
      if (obj.TestBit(kIsBayesian)) {
         alpha = obj.TestBit(kUseBinPrior) ? getBetaAlpha(obj, bin) : obj.fBeta_alpha;
         beta  = obj.TestBit(kUseBinPrior) ? getBetaBeta(obj, bin)  : obj.fBeta_beta;
      }

      return value - this.fBoundary(total, passed, obj.fConfLevel, false, alpha, beta);
   }

   /** @summary Caluclate efficiency error low up */
   getEfficiencyErrorUp(obj, bin, value) {
      let total = obj.fTotalHistogram.fArray[bin],
          passed = obj.fPassedHistogram.fArray[bin],
          alpha = 0, beta = 0;
      if (obj.TestBit(kIsBayesian)) {
         alpha = obj.TestBit(kUseBinPrior) ? getBetaAlpha(obj, bin) : obj.fBeta_alpha;
         beta  = obj.TestBit(kUseBinPrior) ? getBetaBeta(obj, bin)  : obj.fBeta_beta;
      }

      return this.fBoundary(total, passed, obj.fConfLevel, true, alpha, beta) - value;
   }

   /** @summary Copy drawning attributes */
   copyAttributes(obj, eff) {
      ['fLineColor', 'fLineStyle', 'fLineWidth', 'fFillColor', 'fFillStyle', 'fMarkerColor', 'fMarkerStyle', 'fMarkerSize'].forEach(name => obj[name] = eff[name]);
   }

   /** @summary Create graph for the drawing of 1-dim TEfficiency */
   createGraph(/*eff*/) {
      let gr = create$1(clTGraphAsymmErrors);
      gr.fName = 'eff_graph';
      return gr;
   }

   /** @summary Create histogram for the drawing of 2-dim TEfficiency */
   createHisto(eff) {
      const nbinsx = eff.fTotalHistogram.fXaxis.fNbins,
            nbinsy = eff.fTotalHistogram.fYaxis.fNbins,
            hist = createHistogram('TH2F', nbinsx, nbinsy);
      Object.assign(hist.fXaxis, eff.fTotalHistogram.fXaxis);
      Object.assign(hist.fYaxis, eff.fTotalHistogram.fYaxis);
      hist.fName = 'eff_histo';
      return hist;
   }

   /** @summary Fill graph with points from efficiency object */
   fillGraph(gr, opt) {
      const eff = this.getObject(),
            xaxis = eff.fTotalHistogram.fXaxis,
            npoints = xaxis.fNbins,
            plot0Bins = (opt.indexOf('e0') >= 0);

      for (let n = 0, j = 0; n < npoints; ++n) {
         if (!plot0Bins && eff.fTotalHistogram.getBinContent(n+1) === 0) continue;

         let value = this.getEfficiency(eff, n+1);

         gr.fX[j] = xaxis.GetBinCenter(n+1);
         gr.fY[j] = value;
         gr.fEXlow[j] = xaxis.GetBinCenter(n+1) - xaxis.GetBinLowEdge(n+1);
         gr.fEXhigh[j] = xaxis.GetBinLowEdge(n+2) - xaxis.GetBinCenter(n+1);
         gr.fEYlow[j] = this.getEfficiencyErrorLow(eff, n+1, value);
         gr.fEYhigh[j] = this.getEfficiencyErrorUp(eff, n+1, value);

         gr.fNpoints = ++j;
      }

      gr.fTitle = eff.fTitle;
      this.copyAttributes(gr, eff);
   }

   /** @summary Fill graph with points from efficiency object */
   fillHisto(hist) {
      const eff = this.getObject(),
            nbinsx = hist.fXaxis.fNbins,
            nbinsy = hist.fYaxis.fNbins,
            kNoStats = BIT(9);

      for (let i = 0; i < nbinsx+2; ++i)
         for (let j = 0; j < nbinsy+2; ++j) {
            let bin = hist.getBin(i, j),
                value = this.getEfficiency(eff, bin);
            hist.fArray[bin] = value;
         }

      hist.fTitle = eff.fTitle;
      hist.fBits = hist.fBits | kNoStats;
      this.copyAttributes(hist, eff);
   }

   /** @summary Draw function */
   drawFunction(indx) {
      const eff = this.getObject();

      if (!eff || !eff.fFunctions || indx >= eff.fFunctions.arr.length)
         return this;

       return TF1Painter.draw(this.getDom(), eff.fFunctions.arr[indx], eff.fFunctions.opt[indx]).then(() => this.drawFunction(indx+1));
   }

   /** @summary Draw TEfficiency object */
   static async draw(dom, eff, opt) {
      if (!eff || !eff.fTotalHistogram)
         return null;

      if (!opt || !isStr(opt)) opt = '';
      opt = opt.toLowerCase();

      let ndim = 0;
      if (eff.fTotalHistogram._typename.indexOf(clTH1) == 0)
         ndim = 1;
      else if (eff.fTotalHistogram._typename.indexOf(clTH2) == 0)
         ndim = 2;
      else
         return null;

      let painter = new TEfficiencyPainter(dom, eff);
      painter.ndim = ndim;

      painter.fBoundary = getTEfficiencyBoundaryFunc(eff.fStatisticOption, eff.TestBit(kIsBayesian));

      let promise;

      if (ndim == 1) {
         if (!opt) opt = 'ap';
         if ((opt.indexOf('same') < 0) && (opt.indexOf('a') < 0)) opt += 'a';
         if (opt.indexOf('p') < 0) opt += 'p';

         let gr = painter.createGraph(eff);
         painter.fillGraph(gr, opt);
         promise = TGraphPainter$1.draw(dom, gr, opt);
      } else {
         if (!opt) opt = 'col';
         let hist = painter.createHisto(eff);
         painter.fillHisto(hist, opt);
         promise = TH2Painter$2.draw(dom, hist, opt);
      }

      return promise.then(() => {
         painter.addToPadPrimitives();
         return painter.drawFunction(0);
      });
   }

} // class TEfficiencyPainter

var TEfficiencyPainter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
TEfficiencyPainter: TEfficiencyPainter
});

/**
 * @summary Painter class for TRatioPlot
 *
 * @private
 */

class TRatioPlotPainter extends ObjectPainter {

   /** @summary Set grids range */
   setGridsRange(xmin, xmax) {
      let ratio = this.getObject();
      if (xmin === xmax) {
         let x_handle = this.getPadPainter()?.findPainterFor(ratio.fLowerPad, 'lower_pad', clTPad)?.getFramePainter()?.x_handle;
         if (!x_handle) return;
         xmin = x_handle.full_min;
         xmax = x_handle.full_max;
      }

      ratio.fGridlines.forEach(line => {
         line.fX1 = xmin;
         line.fX2 = xmax;
      });
   }

   /** @summary Redraw TRatioPlot */
   async redraw() {
      let ratio = this.getObject(),
          pp = this.getPadPainter();

      let top_p = pp.findPainterFor(ratio.fTopPad, 'top_pad', clTPad);
      if (top_p) top_p.disablePadDrawing();

      let up_p = pp.findPainterFor(ratio.fUpperPad, 'upper_pad', clTPad),
          up_main = up_p?.getMainPainter(),
          up_fp = up_p?.getFramePainter(),
          low_p = pp.findPainterFor(ratio.fLowerPad, 'lower_pad', clTPad),
          low_main = low_p?.getMainPainter(),
          low_fp = low_p?.getFramePainter(),
          lbl_size = 20, promise_up = Promise.resolve(true);

      if (up_p && up_main && up_fp && low_fp && !up_p._ratio_configured) {
         up_p._ratio_configured = true;
         up_main.options.Axis = 0; // draw both axes

         lbl_size = up_main.getHisto().fYaxis.fLabelSize;
         if (lbl_size < 1) lbl_size = Math.round(lbl_size*Math.min(up_p.getPadWidth(), up_p.getPadHeight()));

         let h = up_main.getHisto();
         h.fXaxis.fLabelSize = 0; // do not draw X axis labels
         h.fXaxis.fTitle = ''; // do not draw X axis title
         h.fYaxis.fLabelSize = lbl_size;
         h.fYaxis.fTitleSize = lbl_size;

         up_p.getRootPad().fTicky = 1;

         promise_up = up_p.redrawPad().then(() => {
            up_fp.o_zoom = up_fp.zoom;
            up_fp._ratio_low_fp = low_fp;
            up_fp._ratio_painter = this;

            up_fp.zoom = function(xmin,xmax,ymin,ymax,zmin,zmax) {
               return this.o_zoom(xmin,xmax,ymin,ymax,zmin,zmax).then(res => {
                  this._ratio_painter.setGridsRange(up_fp.scale_xmin, up_fp.scale_xmax);
                  this._ratio_low_fp.o_zoom(up_fp.scale_xmin, up_fp.scale_xmax);
                  return res;
               });
            };

            up_fp.o_sizeChanged = up_fp.sizeChanged;
            up_fp.sizeChanged = function() {
               this.o_sizeChanged();
               this._ratio_low_fp.fX1NDC = this.fX1NDC;
               this._ratio_low_fp.fX2NDC = this.fX2NDC;
               this._ratio_low_fp.o_sizeChanged();
            };
            return true;
         });
      }

      return promise_up.then(() => {

         if (!low_p || !low_main || !low_fp || !up_fp || low_p._ratio_configured)
            return this;

         low_p._ratio_configured = true;
         low_main.options.Axis = 0; // draw both axes
         let h = low_main.getHisto();
         h.fXaxis.fTitle = 'x';
         h.fXaxis.fLabelSize = lbl_size;
         h.fXaxis.fTitleSize = lbl_size;
         h.fYaxis.fLabelSize = lbl_size;
         h.fYaxis.fTitleSize = lbl_size;
         low_p.getRootPad().fTicky = 1;

         low_p.forEachPainterInPad(objp => {
            if (isFunc(objp?.testEditable))
               objp.testEditable(false);
         });

         let arr = [], currpad;

         if ((ratio.fGridlinePositions.length > 0) && (ratio.fGridlines.length < ratio.fGridlinePositions.length)) {
            ratio.fGridlinePositions.forEach(gridy => {
               let found = false;
               ratio.fGridlines.forEach(line => {
                  if ((line.fY1 == line.fY2) && (Math.abs(line.fY1 - gridy) < 1e-6)) found = true;
               });
               if (!found) {
                  let line = create$1(clTLine);
                  line.fX1 = up_fp.scale_xmin;
                  line.fX2 = up_fp.scale_xmax;
                  line.fY1 = line.fY2 = gridy;
                  line.fLineStyle = 2;
                  ratio.fGridlines.push(line);
                  if (currpad === undefined)
                     currpad = this.selectCurrentPad(ratio.fLowerPad.fName);
                  arr.push(drawTLine(this.getDom(), line));
               }
            });
         }

         return Promise.all(arr).then(() => low_fp.zoom(up_fp.scale_xmin,  up_fp.scale_xmax)).then(() => {

            low_fp.o_zoom = low_fp.zoom;
            low_fp._ratio_up_fp = up_fp;
            low_fp._ratio_painter = this;

            low_fp.zoom = function(xmin,xmax,ymin,ymax,zmin,zmax) {
               this._ratio_painter.setGridsRange(xmin, xmax);
               this._ratio_up_fp.o_zoom(xmin,xmax);
               return this.o_zoom(xmin,xmax,ymin,ymax,zmin,zmax);
            };

            low_fp.o_sizeChanged = low_fp.sizeChanged;
            low_fp.sizeChanged = function() {
               this.o_sizeChanged();
               this._ratio_up_fp.fX1NDC = this.fX1NDC;
               this._ratio_up_fp.fX2NDC = this.fX2NDC;
               this._ratio_up_fp.o_sizeChanged();
            };
            return this;
         });
      });
   }

   /** @summary Draw TRatioPlot */
   static async draw(dom, ratio, opt) {
      let painter = new TRatioPlotPainter(dom, ratio, opt);

      return ensureTCanvas(painter, false).then(() => painter.redraw());
   }

} // class TRatioPlotPainter

var TRatioPlotPainter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
TRatioPlotPainter: TRatioPlotPainter
});

/**
 * @summary Painter for TMultiGraph object.
 *
 * @private
 */

class TMultiGraphPainter$2 extends ObjectPainter {

   /** @summary Create painter
     * @param {object|string} dom - DOM element for drawing or element id
     * @param {object} obj - TMultiGraph object to draw */
   constructor(dom, mgraph) {
      super(dom, mgraph);
      this.firstpainter = null;
      this.autorange = false;
      this.painters = []; // keep painters to be able update objects
   }

   /** @summary Cleanup multigraph painter */
   cleanup() {
      this.painters = [];
      super.cleanup();
   }

   /** @summary Update multigraph object */
   updateObject(obj) {
      if (!this.matchObjectType(obj)) return false;

      let mgraph = this.getObject(),
          graphs = obj.fGraphs,
          pp = this.getPadPainter();

      mgraph.fTitle = obj.fTitle;

      let isany = false;
      if (this.firstpainter) {
         let histo = obj.fHistogram;
         if (this.autorange && !histo)
            histo = this.scanGraphsRange(graphs);

         if (this.firstpainter.updateObject(histo))
            isany = true;
      }

      for (let i = 0; i < graphs.arr.length; ++i)
         if ((i < this.painters.length) && this.painters[i].updateObject(graphs.arr[i]))
            isany = true;

      obj.fFunctions?.arr?.forEach(func => {
         if (func?._typename && func?.fName)
            pp?.findPainterFor(null, func.fName, func._typename)?.updateObject(func);
      });

      return isany;
   }

   /** @summary Scan graphs range
     * @return {object} histogram for axes drawing */
   scanGraphsRange(graphs, histo, pad) {
      let mgraph = this.getObject(),
          maximum, minimum, logx = false, logy = false,
          time_display = false, time_format = '',
          rw = {  xmin: 0, xmax: 0, ymin: 0, ymax: 0, first: true };

      if (pad) {
         logx = pad.fLogx;
         logy = pad.fLogy;
         rw.xmin = pad.fUxmin;
         rw.xmax = pad.fUxmax;
         rw.ymin = pad.fUymin;
         rw.ymax = pad.fUymax;
         rw.first = false;
      }

      // ignore existing histo in 3d case
      if (this._3d && histo && !histo.fXaxis.fLabels)
         histo = null;

      if (!histo) {
         this.autorange = true;

         if (graphs.arr[0]?.fHistogram?.fXaxis?.fTimeDisplay) {
            time_display = true;
            time_format = graphs.arr[0].fHistogram.fXaxis.fTimeFormat;
         }
      }

      graphs.arr.forEach(gr => {
         if (gr.fNpoints == 0) return;
         if (rw.first) {
            rw.xmin = rw.xmax = gr.fX[0];
            rw.ymin = rw.ymax = gr.fY[0];
            rw.first = false;
         }
         for (let i = 0; i < gr.fNpoints; ++i) {
            rw.xmin = Math.min(rw.xmin, gr.fX[i]);
            rw.xmax = Math.max(rw.xmax, gr.fX[i]);
            rw.ymin = Math.min(rw.ymin, gr.fY[i]);
            rw.ymax = Math.max(rw.ymax, gr.fY[i]);
         }
      });

      if (rw.xmin == rw.xmax)
         rw.xmax += 1.;
      if (rw.ymin == rw.ymax)
         rw.ymax += 1.;
      let dx = 0.05 * (rw.xmax - rw.xmin),
          dy = 0.05 * (rw.ymax - rw.ymin),
          uxmin = rw.xmin - dx,
          uxmax = rw.xmax + dx;
      if (logy) {
         if (rw.ymin <= 0)
            rw.ymin = 0.001 * rw.ymax;
         minimum = rw.ymin / (1 + 0.5 * Math.log10(rw.ymax / rw.ymin));
         maximum = rw.ymax * (1 + 0.2 * Math.log10(rw.ymax / rw.ymin));
      } else {
         minimum = rw.ymin - dy;
         maximum = rw.ymax + dy;
      }
      if (minimum < 0 && rw.ymin >= 0)
         minimum = 0;
      if (maximum > 0 && rw.ymax <= 0)
         maximum = 0;

       let glob_minimum = minimum, glob_maximum = maximum;

      if (uxmin < 0 && rw.xmin >= 0)
         uxmin = logx ? 0.9 * rw.xmin : 0;
      if (uxmax > 0 && rw.xmax <= 0)
         uxmax = logx? 1.1 * rw.xmax : 0;

      if (mgraph.fMinimum != kNoZoom)
         rw.ymin = minimum = mgraph.fMinimum;
      if (mgraph.fMaximum != kNoZoom)
         rw.ymax = maximum = mgraph.fMaximum;

      if (minimum < 0 && rw.ymin >= 0 && logy)
         minimum = 0.9 * rw.ymin;
      if (maximum > 0 && rw.ymax <= 0 && logy)
         maximum = 1.1 * rw.ymax;
      if (minimum <= 0 && logy)
         minimum = 0.001 * maximum;
      if (!logy && minimum > 0 && minimum < 0.05*maximum)
         minimum = 0;
      if (uxmin <= 0 && logx)
         uxmin = (uxmax > 1000) ? 1 : 0.001 * uxmax;

      // Create a temporary histogram to draw the axis (if necessary)
      if (!histo) {
         let xaxis, yaxis;
         if (this._3d) {
            histo = create$1('TH2I');
            xaxis = histo.fXaxis;
            xaxis.fXmin = 0;
            xaxis.fXmax = graphs.arr.length;
            xaxis.fNbins = graphs.arr.length;
            xaxis.fLabels = create$1(clTHashList);
            for (let i = 0; i < graphs.arr.length; i++) {
               let lbl = create$1(clTObjString);
               lbl.fString = graphs.arr[i].fTitle || `gr${i}`;
               lbl.fUniqueID = graphs.arr.length - i; // graphs drawn in reverse order
               xaxis.fLabels.Add(lbl, '');
            }
            xaxis = histo.fYaxis;
            yaxis = histo.fZaxis;
         } else {
            histo = create$1('TH1I');
            xaxis = histo.fXaxis;
            yaxis = histo.fYaxis;
         }
         histo.fTitle = mgraph.fTitle;
         if (histo.fTitle.indexOf(';') >= 0) {
            let t = histo.fTitle.split(';');
            histo.fTitle = t[0];
            if (t[1]) xaxis.fTitle = t[1];
            if (t[2]) yaxis.fTitle = t[2];
         }

         xaxis.fXmin = uxmin;
         xaxis.fXmax = uxmax;
         xaxis.fTimeDisplay = time_display;
         if (time_display) xaxis.fTimeFormat = time_format;
      }

      let axis = this._3d ? histo.fZaxis : histo.fYaxis;
      axis.fXmin = Math.min(minimum, glob_minimum);
      axis.fXmax = Math.max(maximum, glob_maximum);
      histo.fMinimum = minimum;
      histo.fMaximum = maximum;

      return histo;
   }

   /** @summary draw speical histogram for axis
     * @return {Promise} when ready */
   async drawAxisHist(histo, hopt) {
      return TH1Painter$2.draw(this.getDom(), histo, 'AXIS' + hopt);
   }

   /** @summary method draws next function from the functions list  */
   async drawNextFunction(indx) {

      let mgraph = this.getObject();

      if (!mgraph.fFunctions || (indx >= mgraph.fFunctions.arr.length))
         return this;

      let pp = this.getPadPainter();

      return pp.drawObject(this.getDom(), mgraph.fFunctions.arr[indx], mgraph.fFunctions.opt[indx])
               .then(() => this.drawNextFunction(indx+1));
   }

   /** @summary Draw graph  */
   async drawGraph(gr, opt /*, pos3d */ ) {
      return TGraphPainter$1.draw(this.getDom(), gr, opt);
   }

   /** @summary method draws next graph  */
   async drawNextGraph(indx, opt) {

      let graphs = this.getObject().fGraphs;

      // at the end of graphs drawing draw functions (if any)
      if (indx >= graphs.arr.length) {
         this._pfc = this._plc = this._pmc = false; // disable auto coloring at the end
         return this.drawNextFunction(0);
      }

      // if there is auto colors assignment, try to provide it
      if (this._pfc || this._plc || this._pmc) {
         let mp = this.getMainPainter();
         if (isFunc(mp?.createAutoColor)) {
            let icolor = mp.createAutoColor(graphs.arr.length);
            if (this._pfc) graphs.arr[indx].fFillColor = icolor;
            if (this._plc) graphs.arr[indx].fLineColor = icolor;
            if (this._pmc) graphs.arr[indx].fMarkerColor = icolor;
         }
      }

      let o = graphs.opt[indx] || opt || '';

      return this.drawGraph(graphs.arr[indx], o, graphs.arr.length - indx).then(subp => {
         if (subp) this.painters.push(subp);

         return this.drawNextGraph(indx+1, opt);
      });
   }

   /** @summary Draw multigraph object using painter instance
     * @private */
   static async _drawMG(painter, opt) {

      let d = new DrawOptions(opt);

      painter._3d = d.check('3D');
      painter._pfc = d.check('PFC');
      painter._plc = d.check('PLC');
      painter._pmc = d.check('PMC');

      let hopt = '', checkhopt = ['USE_PAD_TITLE', 'LOGXY', 'LOGX', 'LOGY', 'LOGZ', 'GRIDXY', 'GRIDX', 'GRIDY', 'TICKXY', 'TICKX', 'TICKY', 'FB'];
      checkhopt.forEach(name => { if (d.check(name)) hopt += ';' + name; });

      let promise = Promise.resolve(true);
      if (d.check('A') || !painter.getMainPainter()) {
          let mgraph = painter.getObject(),
              pp = painter.getPadPainter(),
              histo = painter.scanGraphsRange(mgraph.fGraphs, mgraph.fHistogram, pp?.getRootPad(true));

         promise = painter.drawAxisHist(histo, hopt).then(ap => {
            painter.firstpainter = ap;
            ap.$secondary = 'hist'; // mark histogram painter as secondary
            if (mgraph.fHistogram) painter.$primary = true; // mark mg painter as primary
         });
      }

      return promise.then(() => {
         painter.addToPadPrimitives();
         return painter.drawNextGraph(0, d.remain());
      });
   }

   /** @summary Draw TMultiGraph object */
   static async draw(dom, mgraph, opt) {
      return TMultiGraphPainter$2._drawMG(new TMultiGraphPainter$2(dom, mgraph), opt);
   }

} // class TMultiGraphPainter

class TGraphPainter extends TGraphPainter$1 {

   /** @summary Draw TGraph points in 3D
     * @private */
   drawBins3D(fp, graph) {

      if (!fp.mode3d || !fp.grx || !fp.gry || !fp.grz || !fp.toplevel)
         return console.log('Frame painter missing base 3d elements');

      if (fp.zoom_xmin != fp.zoom_xmax)
        if ((this.options.pos3d < fp.zoom_xmin) || (this.options.pos3d > fp.zoom_xmax)) return;

      let drawbins = this.optimizeBins(1000),
          first = 0, last = drawbins.length-1;

      if (fp.zoom_ymin != fp.zoom_ymax) {
         while ((first < last) && (drawbins[first].x < fp.zoom_ymin)) first++;
         while ((first < last) && (drawbins[last].x > fp.zoom_ymax)) last--;
      }

      if (first == last) return;

      let pnts = [], grx = fp.grx(this.options.pos3d),
          p0 = drawbins[first];

      for (let n = first + 1; n <= last; ++n) {
         let p1 = drawbins[n];
         pnts.push(grx, fp.gry(p0.x), fp.grz(p0.y),
                   grx, fp.gry(p1.x), fp.grz(p1.y));
         p0 = p1;
      }

      let lines = createLineSegments(pnts, create3DLineMaterial(this, graph));

      fp.toplevel.add(lines);

      fp.render3D(100);
   }

   /** @summary Draw axis histogram
     * @private */
   async drawAxisHisto() {
      return TH1Painter.draw(this.getDom(), this.createHistogram(), this.options.Axis);
   }

   static async draw(dom, graph, opt) {
      return TGraphPainter._drawGraph(new TGraphPainter(dom, graph), opt);
   }

} // class TGraphPainter

class TMultiGraphPainter extends TMultiGraphPainter$2 {

   /** @summary draw speical histogram for axis
     * @return {Promise} when ready */
   async drawAxisHist(histo, hopt) {
      return this._3d ? TH2Painter.draw(this.getDom(), histo, 'AXIS3D' + hopt)
                      : TH1Painter$2.draw(this.getDom(), histo, 'AXIS' + hopt);
   }

   /** @summary draw multigraph in 3D */
   async drawGraph(gr, opt, pos3d) {
      if (this._3d) opt += 'pos3d_'+pos3d;
      return TGraphPainter.draw(this.getDom(), gr, opt);
   }

   /** @summary Draw TMultiGraph object */
   static async draw(dom, mgraph, opt) {
      return TMultiGraphPainter._drawMG(new TMultiGraphPainter(dom, mgraph), opt);
   }

} // class TMultiGraphPainter

var TMultiGraphPainter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
TMultiGraphPainter: TMultiGraphPainter
});

/** @summary Draw direct TVirtualX commands into SVG
  * @private */

class TWebPaintingPainter extends ObjectPainter {

   /** @summary Update TWebPainting object */
   updateObject(obj) {
      if (!this.matchObjectType(obj)) return false;
      this.assignObject(obj);
      return true;
   }

   /** @summary draw TWebPainting object */
   async redraw() {

      const obj = this.getObject(), func = this.getAxisToSvgFunc();

      if (!obj?.fOper || !func) return;

      let indx = 0, attr = {}, lastpath = null, lastkind = 'none', d = '',
          oper, npoints, n, arr = obj.fOper.split(';');

      const check_attributes = kind => {
         if (kind == lastkind) return;

         if (lastpath) {
            lastpath.attr('d', d); // flush previous
            d = ''; lastpath = null; lastkind = 'none';
         }

         if (!kind) return;

         lastkind = kind;
         lastpath = this.draw_g.append('svg:path');
         switch (kind) {
            case 'f': lastpath.call(this.fillatt.func); break;
            case 'l': lastpath.call(this.lineatt.func).style('fill', 'none'); break;
            case 'm': lastpath.call(this.markeratt.func); break;
         }
      }, read_attr = (str, names) => {
         let lastp = 0, obj = { _typename: 'any' };
         for (let k = 0; k < names.length; ++k) {
            let p = str.indexOf(':', lastp+1);
            obj[names[k]] = parseInt(str.slice(lastp+1, (p > lastp) ? p : undefined));
            lastp = p;
         }
         return obj;
      }, process = k => {
         while (++k < arr.length) {
            oper = arr[k][0];
            switch (oper) {
               case 'z':
                  this.createAttLine({ attr: read_attr(arr[k], ['fLineColor', 'fLineStyle', 'fLineWidth']), force: true });
                  check_attributes();
                  continue;
               case 'y':
                  this.createAttFill({ attr: read_attr(arr[k], ['fFillColor', 'fFillStyle']), force: true });
                  check_attributes();
                  continue;
               case 'x':
                  this.createAttMarker({ attr: read_attr(arr[k], ['fMarkerColor', 'fMarkerStyle', 'fMarkerSize']), force: true });
                  check_attributes();
                  continue;
               case 'o':
                  attr = read_attr(arr[k], ['fTextColor', 'fTextFont', 'fTextSize', 'fTextAlign', 'fTextAngle']);
                  if (attr.fTextSize < 0) attr.fTextSize *= -0.001;
                  check_attributes();
                  continue;
               case 'r':
               case 'b': {

                  check_attributes((oper == 'b') ? 'f' : 'l');

                  let x1 = func.x(obj.fBuf[indx++]),
                      y1 = func.y(obj.fBuf[indx++]),
                      x2 = func.x(obj.fBuf[indx++]),
                      y2 = func.y(obj.fBuf[indx++]);

                  d += `M${x1},${y1}h${x2-x1}v${y2-y1}h${x1-x2}z`;

                  continue;
               }
               case 'l':
               case 'f': {

                  check_attributes(oper);

                  npoints = parseInt(arr[k].slice(1));

                  for (n = 0; n < npoints; ++n)
                     d += ((n > 0) ? 'L' : 'M') +
                           func.x(obj.fBuf[indx++]) + ',' + func.y(obj.fBuf[indx++]);

                  if (oper == 'f') d+='Z';

                  continue;
               }

               case 'm': {

                  check_attributes(oper);

                  npoints = parseInt(arr[k].slice(1));

                  this.markeratt.resetPos();
                  for (n = 0; n < npoints; ++n)
                     d += this.markeratt.create(func.x(obj.fBuf[indx++]), func.y(obj.fBuf[indx++]));

                  continue;
               }

               case 'h':
               case 't': {
                  if (attr.fTextSize) {

                     check_attributes();

                     let height = (attr.fTextSize > 1) ? attr.fTextSize : this.getPadPainter().getPadHeight() * attr.fTextSize,
                         angle = attr.fTextAngle,
                         txt = arr[k].slice(1),
                         group = this.draw_g.append('svg:g');

                     if (angle >= 360) angle -= Math.floor(angle/360) * 360;

                     this.startTextDrawing(attr.fTextFont, height, group);

                     if (oper == 'h') {
                        let res = '';
                        for (n = 0; n < txt.length; n += 2)
                           res += String.fromCharCode(parseInt(txt.slice(n,n+2), 16));
                        txt = res;
                     }

                     // todo - correct support of angle
                     this.drawText({ align: attr.fTextAlign,
                                     x: func.x(obj.fBuf[indx++]),
                                     y: func.y(obj.fBuf[indx++]),
                                     rotate: -angle,
                                     text: txt,
                                     color: getColor(attr.fTextColor),
                                     latex: 0, draw_g: group });

                     return this.finishTextDrawing(group).then(() => process(k));
                  }
                  continue;
               }

               default:
                  console.log(`unsupported operation ${oper}`);
            }
         }
         return Promise.resolve(true);
      };

      this.createG();

      return process(-1).then(() => { check_attributes(); return this; });
   }

   static async draw(dom, obj) {
      let painter = new TWebPaintingPainter(dom, obj);
      painter.addToPadPrimitives();
      return painter.redraw();
   }

} // class TWebPaintingPainter

var TWebPaintingPainter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
TWebPaintingPainter: TWebPaintingPainter
});

/** @summary Create histogram for TF2 drawing
  * @private */
function createTF2Histogram(func, hist = undefined) {
   let nsave = func.fSave.length, use_middle = true;
   if ((nsave > 6) && (nsave !== (func.fSave[nsave-2]+1)*(func.fSave[nsave-1]+1) + 6)) nsave = 0;

   // check if exact min/max range is used or created histogram has to be extended
   if ((nsave > 6) && (func.fXmin < func.fXmax) && (func.fSave[nsave-6] < func.fSave[nsave-5]) &&
      ((func.fSave[nsave-5] - func.fSave[nsave-6]) / (func.fXmax - func.fXmin) > 0.99999)) use_middle = false;

   let npx = Math.max(func.fNpx, 2),
       npy = Math.max(func.fNpy, 2),
       iserr = false, isany = false,
       dx = (func.fXmax - func.fXmin) / (use_middle ? npx : (npx-1)),
       dy = (func.fYmax - func.fYmin) / (use_middle ? npy : (npy-1)),
       extra = use_middle ? 0.5 : 0,
       use_saved_points = (nsave > 6) && settings.PreferSavedPoints;

   if (!use_saved_points) {
      if (!func.evalPar)
         proivdeEvalPar(func);

      for (let j = 0; j < npy; ++j)
        for (let i = 0; (i < npx) && !iserr; ++i) {
            let x = func.fXmin + (i + extra) * dx,
                y = func.fYmin + (j + extra) * dy,
                z = 0;

            try {
               z = func.evalPar(x, y);
            } catch {
               iserr = true;
            }

            if (!iserr && Number.isFinite(z)) {
               if (!hist) hist = createHistogram('TH2F', npx, npy);
               isany = true;
               hist.setBinContent(hist.getBin(i+1,j+1), z);
            }
         }

      if ((iserr || !isany) && (nsave > 6))
         use_saved_points = true;
   }

   if (!use_saved_points && !hist)
      hist = createHistogram('TH2F', npx, npy);

   if (!iserr && isany) {
      hist.fXaxis.fXmin = func.fXmin - (use_middle ? 0 : dx/2);
      hist.fXaxis.fXmax = func.fXmax + (use_middle ? 0 : dx/2);

      hist.fYaxis.fXmin = func.fYmin - (use_middle ? 0 : dy/2);
      hist.fYaxis.fXmax = func.fYmax + (use_middle ? 0 : dy/2);
   }

   if (use_saved_points) {
      npx = Math.round(func.fSave[nsave-2]);
      npy = Math.round(func.fSave[nsave-1]);
      dx = (func.fSave[nsave-5] - func.fSave[nsave-6]) / npx;
      dy = (func.fSave[nsave-3] - func.fSave[nsave-4]) / npy;

      if (!hist) hist = createHistogram('TH2F', npx+1, npy+1);

      hist.fXaxis.fXmin = func.fSave[nsave-6] - dx/2;
      hist.fXaxis.fXmax = func.fSave[nsave-5] + dx/2;

      hist.fYaxis.fXmin = func.fSave[nsave-4] - dy/2;
      hist.fYaxis.fXmax = func.fSave[nsave-3] + dy/2;

      for (let k = 0, j = 0; j <= npy; ++j)
         for (let i = 0; i <= npx; ++i)
            hist.setBinContent(hist.getBin(i+1,j+1), func.fSave[k++]);
   }

   hist.fName = 'Func';
   hist.fTitle = func.fTitle;
   hist.fMinimum = func.fMinimum;
   hist.fMaximum = func.fMaximum;
   //fHistogram->SetContour(fContour.fN, levels);
   hist.fLineColor = func.fLineColor;
   hist.fLineStyle = func.fLineStyle;
   hist.fLineWidth = func.fLineWidth;
   hist.fFillColor = func.fFillColor;
   hist.fFillStyle = func.fFillStyle;
   hist.fMarkerColor = func.fMarkerColor;
   hist.fMarkerStyle = func.fMarkerStyle;
   hist.fMarkerSize = func.fMarkerSize;
   const kNoStats = BIT(9);
   hist.fBits |= kNoStats;

   return hist;
}

/** @summary draw TF2 object
  * @desc TF2 always drawn via temporary TH2 object,
  * therefore there is no special painter class
  * @private */
function drawTF2(dom, func, opt) {

   let hist = createTF2Histogram(func);
   if (!hist) return;

   let d = new DrawOptions(opt);

   if (d.empty())
      opt = 'cont3';
   else if (d.opt === 'SAME')
      opt = 'cont2 same';
   else
      opt = d.opt;

   // workaround for old waves.C
   if (opt == 'SAMECOLORZ' || opt == 'SAMECOLOR' || opt == 'SAMECOLZ') opt = 'SAMECOL';

   if (opt.indexOf('SAME') == 0)
      if (!getElementMainPainter(dom))
         opt = 'A_ADJUST_FRAME_' + opt.slice(4);

   return TH2Painter.draw(dom, hist, opt).then(hpainter => {

      hpainter.tf2_typename = func._typename;

      hpainter.updateObject = function(obj /*, opt*/) {
         if (!obj || (this.tf2_typename != obj._typename)) return false;
         delete obj.evalPar;
         createTF2Histogram(obj, this.getHisto());
         return true;
      };

      return hpainter;
   });
}

var TF2 = /*#__PURE__*/Object.freeze({
__proto__: null,
drawTF2: drawTF2
});

/**
 * @summary Painter for TSpline objects.
 *
 * @private
 */

class TSplinePainter extends ObjectPainter {

   /** @summary Update TSpline object
     * @private */
   updateObject(obj, opt) {
      let spline = this.getObject();

      if (spline._typename != obj._typename) return false;

      if (spline !== obj) Object.assign(spline, obj);

      if (opt !== undefined) this.decodeOptions(opt);

      return true;
   }

   /** @summary Evaluate spline at given position
     * @private */
   eval(knot, x) {
      let dx = x - knot.fX;

      if (knot._typename == 'TSplinePoly3')
         return knot.fY + dx*(knot.fB + dx*(knot.fC + dx*knot.fD));

      if (knot._typename == 'TSplinePoly5')
         return knot.fY + dx*(knot.fB + dx*(knot.fC + dx*(knot.fD + dx*(knot.fE + dx*knot.fF))));

      return knot.fY + dx;
   }

   /** @summary Find idex for x value
     * @private */
   findX(x) {
      let spline = this.getObject(),
          klow = 0, khig = spline.fNp - 1;

      if (x <= spline.fXmin) return 0;
      if (x >= spline.fXmax) return khig;

      if(spline.fKstep) {
         // Equidistant knots, use histogramming
         klow = Math.round((x - spline.fXmin)/spline.fDelta);
         // Correction for rounding errors
         if (x < spline.fPoly[klow].fX) {
            klow = Math.max(klow-1,0);
         } else if (klow < khig) {
            if (x > spline.fPoly[klow+1].fX) ++klow;
         }
      } else {
         // Non equidistant knots, binary search
         while(khig - klow > 1) {
            let khalf = Math.round((klow + khig)/2);
            if(x > spline.fPoly[khalf].fX) klow = khalf;
                                      else khig = khalf;
         }
      }
      return klow;
   }

   /** @summary Create histogram for axes drawing
     * @private */
   createDummyHisto() {

      let xmin = 0, xmax = 1, ymin = 0, ymax = 1,
          spline = this.getObject();

      if (spline?.fPoly) {

         xmin = xmax = spline.fPoly[0].fX;
         ymin = ymax = spline.fPoly[0].fY;

         spline.fPoly.forEach(knot => {
            xmin = Math.min(knot.fX, xmin);
            xmax = Math.max(knot.fX, xmax);
            ymin = Math.min(knot.fY, ymin);
            ymax = Math.max(knot.fY, ymax);
         });

         if (ymax > 0.0) ymax *= (1 + gStyle.fHistTopMargin);
         if (ymin < 0.0) ymin *= (1 + gStyle.fHistTopMargin);
      }

      let histo = create$1('TH1I');

      histo.fName = spline.fName + '_hist';
      histo.fTitle = spline.fTitle;

      histo.fXaxis.fXmin = xmin;
      histo.fXaxis.fXmax = xmax;
      histo.fYaxis.fXmin = ymin;
      histo.fYaxis.fXmax = ymax;

      return histo;
   }

   /** @summary Process tooltip event
     * @private */
   processTooltipEvent(pnt) {

      let cleanup = false,
          spline = this.getObject(),
          main = this.getFramePainter(),
          funcs = main?.getGrFuncs(this.options.second_x, this.options.second_y),
          xx, yy, knot = null, indx = 0;

      if ((pnt === null) || !spline || !funcs) {
         cleanup = true;
      } else {
         xx = funcs.revertAxis('x', pnt.x);
         indx = this.findX(xx);
         knot = spline.fPoly[indx];
         yy = this.eval(knot, xx);

         if ((indx < spline.fN-1) && (Math.abs(spline.fPoly[indx+1].fX-xx) < Math.abs(xx-knot.fX))) knot = spline.fPoly[++indx];

         if (Math.abs(funcs.grx(knot.fX) - pnt.x) < 0.5*this.knot_size) {
            xx = knot.fX; yy = knot.fY;
         } else {
            knot = null;
            if ((xx < spline.fXmin) || (xx > spline.fXmax)) cleanup = true;
         }
      }

      if (cleanup) {
         if (this.draw_g)
            this.draw_g.select('.tooltip_bin').remove();
         return null;
      }

      let gbin = this.draw_g.select('.tooltip_bin'),
          radius = this.lineatt.width + 3;

      if (gbin.empty())
         gbin = this.draw_g.append('svg:circle')
                           .attr('class', 'tooltip_bin')
                           .style('pointer-events','none')
                           .attr('r', radius)
                           .style('fill', 'none')
                           .call(this.lineatt.func);

      let res = { name: this.getObject().fName,
                  title: this.getObject().fTitle,
                  x: funcs.grx(xx),
                  y: funcs.gry(yy),
                  color1: this.lineatt.color,
                  lines: [],
                  exact: (knot !== null) || (Math.abs(funcs.gry(yy) - pnt.y) < radius) };

      res.changed = gbin.property('current_xx') !== xx;
      res.menu = res.exact;
      res.menu_dist = Math.sqrt((res.x-pnt.x)**2 + (res.y-pnt.y)**2);

      if (res.changed)
         gbin.attr('cx', Math.round(res.x))
             .attr('cy', Math.round(res.y))
             .property('current_xx', xx);

      let name = this.getObjectHint();
      if (name) res.lines.push(name);
      res.lines.push('x = ' + funcs.axisAsText('x', xx));
      res.lines.push('y = ' + funcs.axisAsText('y', yy));
      if (knot !== null) {
         res.lines.push('knot = ' + indx);
         res.lines.push('B = ' + floatToString(knot.fB, gStyle.fStatFormat));
         res.lines.push('C = ' + floatToString(knot.fC, gStyle.fStatFormat));
         res.lines.push('D = ' + floatToString(knot.fD, gStyle.fStatFormat));
         if ((knot.fE !== undefined) && (knot.fF !== undefined)) {
            res.lines.push('E = ' + floatToString(knot.fE, gStyle.fStatFormat));
            res.lines.push('F = ' + floatToString(knot.fF, gStyle.fStatFormat));
         }
      }

      return res;
   }

   /** @summary Redraw object
     * @private */
   redraw() {

      let spline = this.getObject(),
          pmain = this.getFramePainter(),
          funcs = pmain?.getGrFuncs(this.options.second_x, this.options.second_y),
          w = pmain.getFrameWidth(),
          h = pmain.getFrameHeight();

      this.createG(true);

      this.knot_size = 5; // used in tooltip handling

      this.createAttLine({ attr: spline });

      if (this.options.Line || this.options.Curve) {

         let npx = Math.max(10, spline.fNpx),
             xmin = Math.max(pmain.scale_xmin, spline.fXmin),
             xmax = Math.min(pmain.scale_xmax, spline.fXmax),
             indx = this.findX(xmin),
             bins = []; // index of current knot

         if (pmain.logx) {
            xmin = Math.log(xmin);
            xmax = Math.log(xmax);
         }

         for (let n = 0; n < npx; ++n) {
            let x = xmin + (xmax-xmin)/npx*(n-1);
            if (pmain.logx) x = Math.exp(x);

            while ((indx < spline.fNp-1) && (x > spline.fPoly[indx+1].fX)) ++indx;

            let y = this.eval(spline.fPoly[indx], x);

            bins.push({ x, y, grx: funcs.grx(x), gry: funcs.gry(y) });
         }

         let h0 = h;  // use maximal frame height for filling
         if ((pmain.hmin !== undefined) && (pmain.hmin >= 0)) {
            h0 = Math.round(funcs.gry(0));
            if ((h0 > h) || (h0 < 0)) h0 = h;
         }

         let path = buildSvgPath('bezier', bins, h0, 2);

         this.draw_g.append('svg:path')
             .attr('class', 'line')
             .attr('d', path.path)
             .style('fill', 'none')
             .call(this.lineatt.func);
      }

      if (this.options.Mark) {

         // for tooltips use markers only if nodes where not created
         let path = '';

         this.createAttMarker({ attr: spline });

         this.markeratt.resetPos();

         this.knot_size = this.markeratt.getFullSize();

         for (let n = 0; n < spline.fPoly.length; n++) {
            let knot = spline.fPoly[n],
                grx = funcs.grx(knot.fX);
            if ((grx > -this.knot_size) && (grx < w + this.knot_size)) {
               let gry = funcs.gry(knot.fY);
               if ((gry > -this.knot_size) && (gry < h + this.knot_size)) {
                  path += this.markeratt.create(grx, gry);
               }
            }
         }

         if (path)
            this.draw_g.append('svg:path')
                       .attr('d', path)
                       .call(this.markeratt.func);
      }
   }

   /** @summary Checks if it makes sense to zoom inside specified axis range */
   canZoomInside(axis/*,min,max*/) {
      if (axis !== 'x') return false;

      let spline = this.getObject();
      if (!spline) return false;

      // if function calculated, one always could zoom inside
      return true;
   }

   /** @summary Decode options for TSpline drawing */
   decodeOptions(opt) {
      let d = new DrawOptions(opt);

      if (!this.options) this.options = {};

      let has_main = !!this.getMainPainter();

      Object.assign(this.options, {
         Same: d.check('SAME'),
         Line: d.check('L'),
         Curve: d.check('C'),
         Mark: d.check('P'),
         Hopt: 'AXIS',
         second_x: false,
         second_y: false
      });

      if (!this.options.Line && !this.options.Curve && !this.options.Mark)
         this.options.Curve = true;

      if (d.check('X+')) { this.options.Hopt += 'X+'; this.options.second_x = has_main; }
      if (d.check('Y+')) { this.options.Hopt += 'Y+'; this.options.second_y = has_main; }

      this.storeDrawOpt(opt);
   }

   /** @summary Draw TSpline */
   static async draw(dom, spline, opt) {
      let painter = new TSplinePainter(dom, spline);
      painter.decodeOptions(opt);

      let promise = Promise.resolve(), no_main = !painter.getMainPainter();
      if (no_main || painter.options.second_x || painter.options.second_y) {
         if (painter.options.Same && no_main) {
            console.warn('TSpline painter requires histogram to be drawn');
            return null;
         }
         let histo = painter.createDummyHisto();
         promise = TH1Painter.draw(dom, histo, painter.options.Hopt);
      }

      return promise.then(() => {
         painter.addToPadPrimitives();
         painter.redraw();
         return painter;
      });
   }

} // class TSplinePainter

var TSplinePainter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
TSplinePainter: TSplinePainter
});

/** @summary Drawing TArrow
  * @private */
class TArrowPainter extends ObjectPainter {

   /** @summary Create line segment with rotation */
   rotate(angle, x0, y0) {
      let dx = this.wsize * Math.cos(angle), dy = this.wsize * Math.sin(angle), res = '';
      if ((x0 !== undefined) && (y0 !== undefined)) {
         res =  `M${Math.round(x0-dx)},${Math.round(y0-dy)}`;
      } else {
         dx = -dx; dy = -dy;
      }
      res += `l${Math.round(dx)},${Math.round(dy)}`;
      if (x0 && (y0 === undefined)) res += 'z';
      return res;
   }

   /** @summary Create SVG path for the arrow */
   createPath() {
      let angle = Math.atan2(this.y2 - this.y1, this.x2 - this.x1),
          dlen = this.wsize * Math.cos(this.angle2),
          dx = dlen*Math.cos(angle), dy = dlen*Math.sin(angle),
          path = '';

      if (this.beg)
         path += this.rotate(angle - Math.PI - this.angle2, this.x1, this.y1) +
                 this.rotate(angle - Math.PI + this.angle2, this.beg > 10);

      if (this.mid % 10 == 2)
         path += this.rotate(angle - Math.PI - this.angle2, (this.x1+this.x2-dx)/2, (this.y1+this.y2-dy)/2) +
                 this.rotate(angle - Math.PI + this.angle2, this.mid > 10);

      if (this.mid % 10 == 1)
         path += this.rotate(angle - this.angle2, (this.x1+this.x2+dx)/2, (this.y1+this.y2+dy)/2) +
                 this.rotate(angle + this.angle2, this.mid > 10);

      if (this.end)
         path += this.rotate(angle - this.angle2, this.x2, this.y2) +
                 this.rotate(angle + this.angle2, this.end > 10);

      return `M${Math.round(this.x1 + (this.beg > 10 ? dx : 0))},${Math.round(this.y1 + (this.beg > 10 ? dy : 0))}` +
             `L${Math.round(this.x2 - (this.end > 10 ? dx : 0))},${Math.round(this.y2 - (this.end > 10 ? dy : 0))}` +
              path;
   }

   /** @summary Start interactive moving */
   moveStart(x,y) {
      let fullsize = Math.sqrt((this.x1-this.x2)**2 + (this.y1-this.y2)**2),
          sz1 = Math.sqrt((x-this.x1)**2 + (y-this.y1)**2)/fullsize,
          sz2 = Math.sqrt((x-this.x2)**2 + (y-this.y2)**2)/fullsize;
      if (sz1 > 0.9)
         this.side = 1;
      else if (sz2 > 0.9)
         this.side = -1;
      else
         this.side = 0;
   }

   /** @summary Continue interactive moving */
   moveDrag(dx,dy) {
      if (this.side != 1) { this.x1 += dx; this.y1 += dy; }
      if (this.side != -1) { this.x2 += dx; this.y2 += dy; }
      this.draw_g.select('path').attr('d', this.createPath());
   }

   /** @summary Finish interactive moving */
   moveEnd(not_changed) {
      if (not_changed) return;
      let arrow = this.getObject(), exec = '';
      arrow.fX1 = this.svgToAxis('x', this.x1, this.isndc);
      arrow.fX2 = this.svgToAxis('x', this.x2, this.isndc);
      arrow.fY1 = this.svgToAxis('y', this.y1, this.isndc);
      arrow.fY2 = this.svgToAxis('y', this.y2, this.isndc);
      if (this.side != 1) exec += `SetX1(${arrow.fX1});;SetY1(${arrow.fY1});;`;
      if (this.side != -1) exec += `SetX2(${arrow.fX2});;SetY2(${arrow.fY2});;`;
      this.submitCanvExec(exec + 'Notify();;');
   }

   /** @summary Redraw arrow */
   redraw() {
      let arrow = this.getObject(), kLineNDC = BIT(14),
          oo = arrow.fOption, rect = this.getPadPainter().getPadRect();

      this.wsize = Math.max(3, Math.round(Math.max(rect.width, rect.height) * arrow.fArrowSize*0.8));
      this.isndc = arrow.TestBit(kLineNDC);
      this.angle2 = arrow.fAngle/2/180 * Math.PI;
      this.beg = this.mid = this.end = 0;

      if (oo.indexOf('<') == 0)
         this.beg = (oo.indexOf('<|') == 0) ? 12 : 2;
      if (oo.indexOf('->-') >= 0)
         this.mid = 1;
      else if (oo.indexOf('-|>-') >= 0)
         this.mid = 11;
      else if (oo.indexOf('-<-') >= 0)
         this.mid = 2;
      else if (oo.indexOf('-<|-') >= 0)
         this.mid = 12;

      let p1 = oo.lastIndexOf('>'), p2 = oo.lastIndexOf('|>'), len = oo.length;
      if ((p1 >= 0) && (p1 == len-1))
         this.end = ((p2 >= 0) && (p2 == len-2)) ? 11 : 1;

      this.createAttLine({ attr: arrow });

      this.createG();

      this.x1 = this.axisToSvg('x', arrow.fX1, this.isndc, true);
      this.y1 = this.axisToSvg('y', arrow.fY1, this.isndc, true);
      this.x2 = this.axisToSvg('x', arrow.fX2, this.isndc, true);
      this.y2 = this.axisToSvg('y', arrow.fY2, this.isndc, true);

      let elem = this.draw_g.append('svg:path')
                     .attr('d', this.createPath())
                     .call(this.lineatt.func);

      if ((this.beg > 10) || (this.end > 10)) {
         this.createAttFill({ attr: arrow });
         elem.call(this.fillatt.func);
      } else {
         elem.style('fill','none');
      }

     if (!isBatchMode())
        addMoveHandler(this);

      return this;
   }

   /** @summary Draw TArrow object */
   static async draw(dom, obj, opt) {
      let painter = new TArrowPainter(dom, obj,opt);
      return ensureTCanvas(painter, false).then(() => painter.redraw());
   }

} // class TArrowPainter

var TArrowPainter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
TArrowPainter: TArrowPainter
});

/**
 * @summary Painter for TASImage object.
 *
 * @private
 */

class TASImagePainter extends ObjectPainter {

   /** @summary Decode options string  */
   decodeOptions(opt) {
      this.options = { Zscale: false };

      if (opt && (opt.indexOf('z') >= 0)) this.options.Zscale = true;
   }

   /** @summary Create RGBA buffers */
   createRGBA(nlevels) {
      let obj = this.getObject();

      if (!obj?.fPalette) return null;

      let rgba = new Array((nlevels+1) * 4), indx = 1, pal = obj.fPalette; // precaclucated colors

      for(let lvl = 0; lvl <= nlevels; ++lvl) {
         let l = 1.*lvl/nlevels;
         while ((pal.fPoints[indx] < l) && (indx < pal.fPoints.length-1)) indx++;

         let r1 = (pal.fPoints[indx] - l) / (pal.fPoints[indx] - pal.fPoints[indx-1]),
             r2 = (l - pal.fPoints[indx-1]) / (pal.fPoints[indx] - pal.fPoints[indx-1]);

         rgba[lvl*4]   = Math.min(255, Math.round((pal.fColorRed[indx-1] * r1 + pal.fColorRed[indx] * r2) / 256));
         rgba[lvl*4+1] = Math.min(255, Math.round((pal.fColorGreen[indx-1] * r1 + pal.fColorGreen[indx] * r2) / 256));
         rgba[lvl*4+2] = Math.min(255, Math.round((pal.fColorBlue[indx-1] * r1 + pal.fColorBlue[indx] * r2) / 256));
         rgba[lvl*4+3] = Math.min(255, Math.round((pal.fColorAlpha[indx-1] * r1 + pal.fColorAlpha[indx] * r2) / 256));
      }

      return rgba;
   }

   /** @summary Create url using image buffer
     * @private */
   async makeUrlFromImageBuf(obj, fp) {

      let nlevels = 1000;
      this.rgba = this.createRGBA(nlevels); // precaclucated colors

      let min = obj.fImgBuf[0], max = obj.fImgBuf[0];
      for (let k = 1; k < obj.fImgBuf.length; ++k) {
         let v = obj.fImgBuf[k];
         min = Math.min(v, min);
         max = Math.max(v, max);
      }

      // does not work properly in Node.js, causes 'Maximum call stack size exceeded' error
      // min = Math.min.apply(null, obj.fImgBuf),
      // max = Math.max.apply(null, obj.fImgBuf);

      // create countor like in hist painter to allow palette drawing
      this.fContour = {
         arr: new Array(200),
         rgba: this.rgba,
         getLevels() { return this.arr; },
         getPaletteColor(pal, zval) {
            if (!this.arr || !this.rgba) return 'white';
            let indx = Math.round((zval - this.arr[0]) / (this.arr[this.arr.length-1] - this.arr[0]) * (this.rgba.length-4)/4) * 4;
            return '#' + toHex(this.rgba[indx],1) + toHex(this.rgba[indx+1],1) + toHex(this.rgba[indx+2],1) + toHex(this.rgba[indx+3],1);
         }
      };
      for (let k = 0; k < 200; k++)
         this.fContour.arr[k] = min + (max-min)/(200-1)*k;

      if (min >= max) max = min + 1;

      let xmin = 0, xmax = obj.fWidth, ymin = 0, ymax = obj.fHeight; // dimension in pixels

      if (fp && (fp.zoom_xmin != fp.zoom_xmax)) {
         xmin = Math.round(fp.zoom_xmin * obj.fWidth);
         xmax = Math.round(fp.zoom_xmax * obj.fWidth);
      }

      if (fp && (fp.zoom_ymin != fp.zoom_ymax)) {
         ymin = Math.round(fp.zoom_ymin * obj.fHeight);
         ymax = Math.round(fp.zoom_ymax * obj.fHeight);
      }

      let pr = isNodeJs() ?
                 Promise.resolve().then(function () { return _rollup_plugin_ignore_empty_module_placeholder$1; }).then(h => h.default.createCanvas(xmax - xmin, ymax - ymin)) :
                 new Promise(resolveFunc => {
                    let c = document.createElement('canvas');
                    c.width = xmax - xmin;
                    c.height = ymax - ymin;
                    resolveFunc(c);
                 });

      return pr.then(canvas => {

         let context = canvas.getContext('2d'),
             imageData = context.getImageData(0, 0, canvas.width, canvas.height),
             arr = imageData.data;

         for(let i = ymin; i < ymax; ++i) {
            let dst = (ymax - i - 1) * (xmax - xmin) * 4,
                row = i * obj.fWidth;
            for(let j = xmin; j < xmax; ++j) {
               let iii = Math.round((obj.fImgBuf[row + j] - min) / (max - min) * nlevels) * 4;
               // copy rgba value for specified point
               arr[dst++] = this.rgba[iii++];
               arr[dst++] = this.rgba[iii++];
               arr[dst++] = this.rgba[iii++];
               arr[dst++] = this.rgba[iii++];
            }
         }

         context.putImageData(imageData, 0, 0);

         return { url: canvas.toDataURL(), constRatio: obj.fConstRatio, is_buf: true };
      });
   }

   /** @summary Produce data url from png data */
   async makeUrlFromPngBuf(obj) {
      let buf = obj.fPngBuf, pngbuf = '';

      if (isStr(buf))
         pngbuf = buf;
      else
         for (let k = 0; k < buf.length; ++k)
            pngbuf += String.fromCharCode(buf[k] < 0 ? 256 + buf[k] : buf[k]);

      return { url: 'data:image/png;base64,' + btoa_func(pngbuf), constRatio: true };
   }

   /** @summary Draw image */
   async drawImage() {
      let obj = this.getObject(),
          fp = this.getFramePainter(),
          rect = fp ? fp.getFrameRect() : this.getPadPainter().getPadRect();

      this.wheel_zoomy = true;

      if (obj._blob) {
         // try to process blob data due to custom streamer
         if ((obj._blob.length == 15) && !obj._blob[0]) {
            obj.fImageQuality = obj._blob[1];
            obj.fImageCompression = obj._blob[2];
            obj.fConstRatio = obj._blob[3];
            obj.fPalette = {
                _typename: 'TImagePalette',
                fUniqueID: obj._blob[4],
                fBits: obj._blob[5],
                fNumPoints: obj._blob[6],
                fPoints: obj._blob[7],
                fColorRed: obj._blob[8],
                fColorGreen: obj._blob[9],
                fColorBlue: obj._blob[10],
                fColorAlpha: obj._blob[11]
            };

            obj.fWidth = obj._blob[12];
            obj.fHeight = obj._blob[13];
            obj.fImgBuf = obj._blob[14];

            if ((obj.fWidth * obj.fHeight != obj.fImgBuf.length) ||
                  (obj.fPalette.fNumPoints != obj.fPalette.fPoints.length)) {
               console.error(`TASImage _blob decoding error ${obj.fWidth * obj.fHeight} != ${obj.fImgBuf.length} ${obj.fPalette.fNumPoints} != ${obj.fPalette.fPoints.length}`);
               delete obj.fImgBuf;
               delete obj.fPalette;
            }

         } else if ((obj._blob.length == 3) && obj._blob[0]) {
            obj.fPngBuf = obj._blob[2];
            if (obj.fPngBuf?.length != obj._blob[1]) {
               console.error(`TASImage with png buffer _blob error ${obj._blob[1]} != ${obj.fPngBuf?.length}`);
               delete obj.fPngBuf;
            }
         } else {
            console.error(`TASImage _blob len ${obj._blob.length} not recognized`);
         }

         delete obj._blob;
      }

      let promise;

      if (obj.fImgBuf && obj.fPalette) {
         promise = this.makeUrlFromImageBuf(obj, fp);
      } else if (obj.fPngBuf) {
         promise = this.makeUrlFromPngBuf(obj);
      } else {
         promise = Promise.resolve({});
      }

      return promise.then(res => {

         if (res.url)
            this.createG(fp ? true : false)
                .append('image')
                .attr('href', res.url)
                .attr('width', rect.width)
                .attr('height', rect.height)
                .attr('preserveAspectRatio', res.constRatio ? null : 'none');

         if (!res.url || !this.isMainPainter() || !res.is_buf || !fp)
            return this;

         return this.drawColorPalette(this.options.Zscale, true).then(() => {
            fp.setAxesRanges(create$1(clTAxis), 0, 1, create$1(clTAxis), 0, 1, null, 0, 0);
            fp.createXY({ ndim: 2, check_pad_range: false });
            return fp.addInteractivity();
         })
      });
   }

   /** @summary Checks if it makes sense to zoom inside specified axis range */
   canZoomInside(axis,min,max) {
      let obj = this.getObject();

      if (!obj?.fImgBuf)
         return false;

      if ((axis == 'x') && ((max - min) * obj.fWidth > 3)) return true;

      if ((axis == 'y') && ((max - min) * obj.fHeight > 3)) return true;

      return false;
   }

   /** @summary Draw color palette
     * @private */
   async drawColorPalette(enabled, can_move) {

      if (!this.isMainPainter())
         return null;

      if (!this.draw_palette) {
         let pal = create$1(clTPaletteAxis);
         Object.assign(pal, { fX1NDC: 0.91, fX2NDC: 0.95, fY1NDC: 0.1, fY2NDC: 0.9, fInit: 1 });
         pal.fAxis.fChopt = '+';
         this.draw_palette = pal;
         this.fPalette = true; // to emulate behaviour of hist painter
      }

      let pal_painter = this.getPadPainter().findPainterFor(this.draw_palette);

      if (!enabled) {
         if (pal_painter) {
            pal_painter.Enabled = false;
            pal_painter.removeG(); // completely remove drawing without need to redraw complete pad
         }
         return null;
      }

      let frame_painter = this.getFramePainter();

      // keep palette width
      if (can_move && frame_painter) {
         let pal = this.draw_palette;
         pal.fX2NDC = frame_painter.fX2NDC + 0.01 + (pal.fX2NDC - pal.fX1NDC);
         pal.fX1NDC = frame_painter.fX2NDC + 0.01;
         pal.fY1NDC = frame_painter.fY1NDC;
         pal.fY2NDC = frame_painter.fY2NDC;
      }

      if (pal_painter) {
         pal_painter.Enabled = true;
         return pal_painter.drawPave('');
      }


      let prev_name = this.selectCurrentPad(this.getPadName());

      return TPavePainter.draw(this.getDom(), this.draw_palette).then(p => {

         pal_painter = p;

         this.selectCurrentPad(prev_name);
         // mark painter as secondary - not in list of TCanvas primitives
         pal_painter.$secondary = true;

         // make dummy redraw, palette will be updated only from histogram painter
         pal_painter.redraw = function() {};
      });
   }

   /** @summary Toggle colz draw option
     * @private */
   toggleColz() {
      let obj = this.getObject(),
          can_toggle = obj && obj.fPalette;

      if (can_toggle) {
         this.options.Zscale = !this.options.Zscale;
         this.drawColorPalette(this.options.Zscale, true);
      }
   }

   /** @summary Redraw image */
   redraw(reason) {
      let img = this.draw_g ? this.draw_g.select('image') : null,
          fp = this.getFramePainter();

      if (img && !img.empty() && (reason !== 'zoom') && fp) {
         img.attr('width', fp.getFrameWidth()).attr('height', fp.getFrameHeight());
      } else {
         return this.drawImage();
      }
   }

   /** @summary Process click on TASImage-defined buttons */
   clickButton(funcname) {
      if (!this.isMainPainter()) return false;

      switch(funcname) {
         case 'ToggleColorZ': this.toggleColz(); break;
         default: return false;
      }

      return true;
   }

   /** @summary Fill pad toolbar for TASImage */
   fillToolbar() {
      let pp = this.getPadPainter(), obj = this.getObject();
      if (pp && obj?.fPalette) {
         pp.addPadButton('th2colorz', 'Toggle color palette', 'ToggleColorZ');
         pp.showPadButtons();
      }
   }

   /** @summary Draw TASImage object */
   static async draw(dom, obj, opt) {
      let painter = new TASImagePainter(dom, obj, opt);
      painter.decodeOptions(opt);
      return ensureTCanvas(painter, false)
                 .then(() => painter.drawImage())
                 .then(() => {
                     painter.fillToolbar();
                     return painter;
                 });
   }

} // class TASImagePainter

var TASImagePainter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
TASImagePainter: TASImagePainter
});

/** @summary Show TTree::Draw progress during processing */
TDrawSelector.prototype.ShowProgress = function(value) {
   if ((typeof document == 'undefined') || isBatchMode()) return;

   if ((value === undefined) || !Number.isFinite(value))
      return showProgress();

   if (this.last_progress !== value) {
      let diff = value - this.last_progress;
      if (!this.aver_diff) this.aver_diff = diff;
      this.aver_diff = diff * 0.3 + this.aver_diff * 0.7;
   }

   let ndig = 0;
   if (this.aver_diff <= 0)
      ndig = 0;
   else if (this.aver_diff < 0.0001)
      ndig = 3;
   else if (this.aver_diff < 0.001)
      ndig = 2;
   else if (this.aver_diff < 0.01)
      ndig = 1;

   let main_box = document.createElement('p'),
      text_node = document.createTextNode('TTree draw ' + (value * 100).toFixed(ndig) + ' %  '),
      selector = this;

   main_box.appendChild(text_node);
   main_box.title = 'Click on element to break drawing';

   main_box.onclick = function() {
      if (++selector._break < 3) {
         main_box.title = 'Tree draw will break after next I/O operation';
         return text_node.nodeValue = 'Breaking ... ';
      }
      selector.Abort();
      showProgress();
   };

   showProgress(main_box);
   this.last_progress = value;
};

/** @summary Draw result of tree drawing
  * @private */
async function drawTreeDrawResult(dom, obj, opt) {

   let typ = obj?._typename;

   if (!typ || !isStr(typ))
      return Promise.reject(Error(`Object without type cannot be draw with TTree`));

   if (typ.indexOf(clTH1) == 0)
      return TH1Painter.draw(dom, obj, opt);
   if (typ.indexOf(clTH2) == 0)
      return TH2Painter.draw(dom, obj, opt);
   if (typ.indexOf(clTH3) == 0)
      return TH3Painter.draw(dom, obj, opt);
   if (typ.indexOf(clTGraph) == 0)
      return TGraphPainter.draw(dom, obj, opt);
   if ((typ == clTPolyMarker3D) && obj.$hist) {
      return TH3Painter.draw(dom, obj.$hist, opt).then(() => {
         let p2 = new ObjectPainter(dom, obj, opt);
         p2.addToPadPrimitives();
         p2.redraw = drawPolyMarker3D$1;
         return p2.redraw();
      });
   }

   return Promise.reject(Error(`Object of type ${typ} cannot be draw with TTree`));
}


/** @summary Handle callback function with progress of tree draw
  * @private */
async function treeDrawProgress(obj, final) {

   // no need to update drawing if previous is not yet completed
   if (!final && !this.last_pr)
      return;

   if (this.dump || this.testio) {
      if (!final) return;
      if (isBatchMode()) {
         let painter = new BasePainter(this.drawid);
         painter.selectDom().property('_json_object_', obj);
         return painter;
      }
      if (isFunc(internals.drawInspector))
         return internals.drawInspector(this.drawid, obj);
      let str = create$1(clTObjString);
      str.fString = toJSON(obj,2);
      return drawRawText(this.drawid, str);
   }

   // complex logic with intermediate update
   // while TTree reading not synchronized with drawing,
   // next portion can appear before previous is drawn
   // critical is last drawing which should wait for previous one
   // therefore last_pr is kept as inidication that promise is not yet processed

   if (!this.last_pr) this.last_pr = Promise.resolve(true);

    return this.last_pr.then(() => {
       if (this.obj_painter)
          this.last_pr = this.obj_painter.redrawObject(obj).then(() => this.obj_painter);
       else
          this.last_pr = drawTreeDrawResult(this.drawid, obj).then(p => {
             this.obj_painter = p;
             if (!final) this.last_pr = null;
             return p; // return painter for histogram
          });

       return final ? this.last_pr : null;
   });
}


/** @summary Create painter to perform tree drawing on server side
  * @private */
function createTreePlayer(player) {

   player.draw_first = true;

   player.configureOnline = function(itemname, url, askey, root_version, expr) {
      this.setItemName(itemname, '', this);
      this.url = url;
      this.root_version = root_version;
      this.askey = askey;
      this.draw_expr = expr;
   };

   player.configureTree = function(tree) {
      this.local_tree = tree;
   };

   player.showExtraButtons = function(args) {
      let main = this.selectDom(),
         numentries = this.local_tree ? this.local_tree.fEntries : 0;

      main.select('.treedraw_more').remove(); // remove more button first

      main.select('.treedraw_buttons').node().innerHTML +=
          'Cut: <input class="treedraw_cut ui-corner-all ui-widget" style="width:8em;margin-left:5px" title="cut expression"></input>'+
          'Opt: <input class="treedraw_opt ui-corner-all ui-widget" style="width:5em;margin-left:5px" title="histogram draw options"></input>'+
          `Num: <input class="treedraw_number" type='number' min="0" max="${numentries}" step="1000" style="width:7em;margin-left:5px" title="number of entries to process (default all)"></input>`+
          `First: <input class="treedraw_first" type='number' min="0" max="${numentries}" step="1000" style="width:7em;margin-left:5px" title="first entry to process (default first)"></input>`+
          '<button class="treedraw_clear" title="Clear drawing">Clear</button>';

      main.select('.treedraw_exe').on('click', () => this.performDraw());
      main.select('.treedraw_cut').property('value', args?.parse_cut || '').on('change', () => this.performDraw());
      main.select('.treedraw_opt').property('value', args?.drawopt || '').on('change', () => this.performDraw());
      main.select('.treedraw_number').attr('value', args?.numentries || ''); // .on('change', () => this.performDraw());
      main.select('.treedraw_first').attr('value', args?.firstentry || ''); // .on('change', () => this.performDraw());
      main.select('.treedraw_clear').on('click', () => cleanup(this.drawid));
   };

   player.showPlayer = function(args) {

      let main = this.selectDom();

      this.drawid = 'jsroot_tree_player_' + internals.id_counter++ + '_draw';

      let show_extra = args?.parse_cut || args?.numentries || args?.firstentry;

      main.html('<div style="display:flex; flex-flow:column; height:100%; width:100%;">'+
                   '<div class="treedraw_buttons" style="flex: 0 1 auto;margin-top:0.2em;">' +
                      '<button class="treedraw_exe" title="Execute draw expression" style="margin-left:0.5em">Draw</button>' +
                      'Expr:<input class="treedraw_varexp treedraw_varexp_info" style="width:12em;margin-left:5px" title="draw expression"></input>'+
                      '<label class="treedraw_varexp_info">\u24D8</label>' +
                     '<button class="treedraw_more">More</button>' +
                   '</div>' +
                   '<div style="flex: 0 1 auto"><hr/></div>' +
                   `<div id="${this.drawid}" style="flex: 1 1 auto; overflow:hidden;"></div>` +
                '</div>');

      // only when main html element created, one can set painter
      // ObjectPainter allow such usage of methods from BasePainter
      this.setTopPainter();

      if (this.local_tree)
         main.select('.treedraw_buttons')
             .attr('title', 'Tree draw player for: ' + this.local_tree.fName);
      main.select('.treedraw_exe').on('click', () => this.performDraw());
      main.select('.treedraw_varexp')
          .attr('value', args?.parse_expr || this.draw_expr || 'px:py')
          .on('change', () => this.performDraw());
      main.select('.treedraw_varexp_info')
          .attr('title', 'Example of valid draw expressions:\n' +
                         '  px - 1-dim draw\n' +
                         '  px:py - 2-dim draw\n' +
                         '  px:py:pz - 3-dim draw\n' +
                         '  px+py:px-py - use any expressions\n' +
                         '  px:py>>Graph - create and draw TGraph\n' +
                         '  px:py>>dump - dump extracted variables\n' +
                         '  px:py>>h(50,-5,5,50,-5,5) - custom histogram\n' +
                         '  px:py;hbins:100 - custom number of bins');

      if (show_extra)
         this.showExtraButtons(args);
      else
         main.select('.treedraw_more').on('click', () => this.showExtraButtons(args));

      this.checkResize();

      registerForResize(this);
   };

   player.getValue = function(sel) {
      const elem = this.selectDom().select(sel);
      if (elem.empty()) return;
      const val = elem.property('value');
      if (val !== undefined) return val;
      return elem.attr('value');
   };

   player.performLocalDraw = function() {
      if (!this.local_tree) return;

      const frame = this.selectDom(),
            args = { expr: this.getValue('.treedraw_varexp') };

      if (frame.select('.treedraw_more').empty()) {
         args.cut = this.getValue('.treedraw_cut');
         if (!args.cut) delete args.cut;

         args.drawopt = this.getValue('.treedraw_opt');
         if (args.drawopt === 'dump') { args.dump = true; args.drawopt = ''; }
         if (!args.drawopt) delete args.drawopt;

         args.numentries = parseInt(this.getValue('.treedraw_number'));
         if (!Number.isInteger(args.numentries)) delete args.numentries;

         args.firstentry = parseInt(this.getValue('.treedraw_first'));
         if (!Number.isInteger(args.firstentry)) delete args.firstentry;
      }

      /* if (args.drawopt) */ cleanup(this.drawid);

      args.drawid = this.drawid;

      args.progress = treeDrawProgress.bind(args);

      treeDraw(this.local_tree, args).then(obj => args.progress(obj, true));
   };

   player.getDrawOpt = function() {
      let res = 'player',
          expr = this.getValue('.treedraw_varexp');
      if (expr) res += ':' + expr;
      return res;
   };

   player.performDraw = function() {

      if (this.local_tree)
         return this.performLocalDraw();

      let frame = this.selectDom(),
          url = this.url + '/exe.json.gz?compact=3&method=Draw',
          expr = this.getValue('.treedraw_varexp'),
          hname = 'h_tree_draw', option = '',
          pos = expr.indexOf('>>');

      if (pos < 0) {
         expr += '>>' + hname;
      } else {
         hname = expr.slice(pos+2);
         if (hname[0] == '+') hname = hname.slice(1);
         let pos2 = hname.indexOf('(');
         if (pos2 > 0) hname = hname.slice(0, pos2);
      }

      if (frame.select('.treedraw_more').empty()) {
         let cut = this.getValue('.treedraw_cut'),
             nentries = this.getValue('.treedraw_number'),
             firstentry = this.getValue('.treedraw_first');

         option = this.getValue('.treedraw_opt');

         url += `&prototype="const char*,const char*,Option_t*,Long64_t,Long64_t"&varexp="${expr}"&selection="${cut}"`;

         // provide all optional arguments - default value kMaxEntries not works properly in ROOT6
         if (nentries == '') nentries = (this.root_version >= 394499) ? 'TTree::kMaxEntries': '1000000000'; // kMaxEntries available since ROOT 6.05/03
         if (firstentry == '') firstentry = '0';
         url += `&option="${option}"&nentries=${nentries}&firstentry=${firstentry}`;
      } else {
         url += `&prototype="Option_t*"&opt="${expr}"`;
      }
      url += '&_ret_object_=' + hname;

      const submitDrawRequest = () => {
         httpRequest(url, 'object').then(res => {
            cleanup(this.drawid);
            drawTreeDrawResult(this.drawid, res, option);
         });
      };

      this.draw_expr = expr;

      if (this.askey) {
         // first let read tree from the file
         this.askey = false;
         httpRequest(this.url + '/root.json.gz?compact=3', 'text').then(submitDrawRequest);
      } else {
         submitDrawRequest();
      }
   };

   player.checkResize = function(/*arg*/) {
      resize(this.drawid);
   };

   return player;
}


/** @summary function used with THttpServer to assign player for the TTree object
  * @private */
function drawTreePlayer(hpainter, itemname, askey, asleaf) {

   let item = hpainter.findItem(itemname),
       top = hpainter.getTopOnlineItem(item),
       expr = '', leaf_cnt = 0;
   if (!item || !top) return null;

   if (asleaf) {
      expr = item._name;
      while (item && !item._ttree) item = item._parent;
      if (!item) return null;
      itemname = hpainter.itemFullName(item);
   }

   let url = hpainter.getOnlineItemUrl(itemname);
   if (!url) return null;

   let root_version = top._root_version || 400129; // by default use version number 6-27-01

   let mdi = hpainter.getDisplay();
   if (!mdi) return null;

   let frame = mdi.findFrame(itemname, true);
   if (!frame) return null;

   let divid = select(frame).attr('id'),
       player = new BasePainter(divid);

   if (item._childs && !asleaf)
      for (let n = 0; n < item._childs.length; ++n) {
         let leaf = item._childs[n];
         if (leaf && leaf._kind && (leaf._kind.indexOf('ROOT.TLeaf') == 0) && (leaf_cnt < 2)) {
            if (leaf_cnt++ > 0) expr += ':';
            expr += leaf._name;
         }
      }

   createTreePlayer(player);
   player.configureOnline(itemname, url, askey, root_version, expr);
   player.showPlayer();

   return player;
}

/** @summary function used with THttpServer when tree is not yet loaded
  * @private */
function drawTreePlayerKey(hpainter, itemname) {
   return drawTreePlayer(hpainter, itemname, true);
}

/** @summary function used with THttpServer when tree is not yet loaded
  * @private */
function drawLeafPlayer(hpainter, itemname) {
   return drawTreePlayer(hpainter, itemname, false, true);
}

/** @summary function called from draw()
  * @desc just envelope for real TTree::Draw method which do the main job
  * Can be also used for the branch and leaf object
  * @private */
async function drawTree(dom, obj, opt) {

   let tree = obj, args = opt;

   if (obj._typename == clTBranchFunc) {
      // fictional object, created only in browser
      args = { expr: `.${obj.func}()`, branch: obj.branch };
      if (opt && opt.indexOf('dump') == 0)
         args.expr += '>>' + opt;
      else if (opt)
         args.expr += opt;
      tree = obj.branch.$tree;
   } else if (obj.$branch) {
      // this is drawing of the single leaf from the branch
      args = { expr: `.${obj.fName}${opt || ''}`, branch: obj.$branch };
      if ((args.branch.fType === kClonesNode) || (args.branch.fType === kSTLNode)) {
         // special case of size
         args.expr = opt;
         args.direct_branch = true;
      }

      tree = obj.$branch.$tree;
   } else if (obj.$tree) {
      // this is drawing of the branch

      // if generic object tried to be drawn without specifying any options, it will be just dump
      if (!opt && obj.fStreamerType && (obj.fStreamerType !== kTString) &&
          (obj.fStreamerType >= kObject) && (obj.fStreamerType <= kAnyP)) opt = 'dump';

      args = { expr: opt, branch: obj };
      tree = obj.$tree;
   } else {
      if (!args) args = 'player';
      if (isStr(args)) args = { expr: args };
   }

   if (!tree)
      throw Error('No TTree object available for TTree::Draw');

   if (isStr(args.expr)) {
      let p = args.expr.indexOf('player');
      if (p == 0) {
         args.player = true;
         args.expr = args.expr.slice(6);
         if (args.expr[0] == ':') args.expr = args.expr.slice(1);
      } else if ((p >= 0) && (p == args.expr.length-6)) {
         args.player = true;
         args.expr = args.expr.slice(0, p);
         if ((p > 0) && (args.expr[p-1] == ';')) args.expr = args.expr.slice(0, p-1);
      }
   }

   let painter;

   if (args.player) {
      painter = new ObjectPainter(dom, obj, opt);
      createTreePlayer(painter);
      painter.configureTree(tree);
      painter.showPlayer(args);
      args.drawid = painter.drawid;
   } else {
      args.drawid = dom;
   }

   // use in result handling same function as for progress handling

   args.progress = treeDrawProgress.bind(args);

   let pr;
   if (args.expr === 'testio') {
      args.testio = true;
      args.showProgress = showProgress;
      pr = treeIOTest(tree, args);
   } else if (args.expr || args.branch) {
      pr = treeDraw(tree, args);
   } else
      return painter;

   return pr.then(res => args.progress(res, true));
}

var TTree = /*#__PURE__*/Object.freeze({
__proto__: null,
drawTree: drawTree,
drawTreePlayer: drawTreePlayer,
drawTreePlayerKey: drawTreePlayerKey,
drawLeafPlayer: drawLeafPlayer
});

const kNormal = 1, /* kLessTraffic = 2, */ kOffline = 3;

class RObjectPainter extends ObjectPainter {

   constructor(dom, obj, opt, csstype) {
      super(dom,obj,opt);
      this.csstype = csstype;
   }

   /** @summary Evaluate v7 attributes using fAttr storage and configured RStyle */
   v7EvalAttr(name, dflt) {
      let obj = this.getObject();
      if (!obj) return dflt;
      if (this.cssprefix) name = this.cssprefix + name;

      const type_check = res => {
         if (dflt === undefined) return res;
         let typ1 = typeof dflt, typ2 = typeof res;
         if (typ1 == typ2) return res;
         if (typ1 == 'boolean') {
            if (typ2 == 'string') return (res != '') && (res != '0') && (res != 'no') && (res != 'off');
            return !!res;
         }
         if ((typ1 == 'number') && (typ2 == 'string'))
            return parseFloat(res);
         return res;
      };

      if (obj.fAttr && obj.fAttr.m) {
         let value = obj.fAttr.m[name];
         if (value) return type_check(value.v); // found value direct in attributes
      }

      if (this.rstyle && this.rstyle.fBlocks) {
         let blks = this.rstyle.fBlocks;
         for (let k = 0; k < blks.length; ++k) {
            let block = blks[k],
                match = (this.csstype && (block.selector == this.csstype)) ||
                        (obj.fId && (block.selector == ('#' + obj.fId))) ||
                        (obj.fCssClass && (block.selector == ('.' + obj.fCssClass)));

            if (match && block.map && block.map.m) {
               let value = block.map.m[name.toLowerCase()];
               if (value) return type_check(value.v);
            }
         }
      }

      return dflt;
   }

   /** @summary Set v7 attributes value */
   v7SetAttr(name, value) {
      let obj = this.getObject();
      if (this.cssprefix) name = this.cssprefix + name;

      if (obj && obj.fAttr && obj.fAttr.m)
         obj.fAttr.m[name] = { v: value };
   }

   /** @summary Decode pad length from string, return pixel value */
   v7EvalLength(name, sizepx, dflt) {
      if (sizepx <= 0) sizepx = 1;

      let value = this.v7EvalAttr(name);

      if (value === undefined)
         return Math.round(dflt*sizepx);

      if (typeof value == 'number')
         return Math.round(value*sizepx);

      if (value === null)
         return 0;

      let norm = 0, px = 0, val = value, operand = 0, pos = 0;

      while (val) {
         // skip empty spaces
         while ((pos < val.length) && ((val[pos] == ' ') || (val[pos] == '\t')))
            ++pos;

         if (pos >= val.length)
            break;

         if ((val[pos] == '-') || (val[pos] == '+')) {
            if (operand) {
               console.log('Fail to parse RPadLength ' + value);
               return dflt;
            }
            operand = (val[pos] == '-') ? -1 : 1;
            pos++;
            continue;
         }

         if (pos > 0) { val = val.slice(pos); pos = 0; }

         while ((pos < val.length) && (((val[pos] >= '0') && (val[pos] <= '9')) || (val[pos] == '.'))) pos++;

         let v = parseFloat(val.slice(0, pos));
         if (!Number.isFinite(v)) {
            console.log('Fail to parse RPadLength ' + value);
            return Math.round(dflt*sizepx);
         }

         val = val.slice(pos);
         pos = 0;
         if (!operand) operand = 1;
         if (val && (val[0] == '%')) {
            val = val.slice(1);
            norm += operand*v*0.01;
         } else if ((val.length > 1) && (val[0] == 'p') && (val[1] == 'x')) {
            val = val.slice(2);
            px += operand*v;
         } else {
            norm += operand*v;
         }

         operand = 0;
      }

      return Math.round(norm*sizepx + px);
   }

   /** @summary Evaluate RColor using attribute storage and configured RStyle */
   v7EvalColor(name, dflt) {
      let val = this.v7EvalAttr(name, '');
      if (!val || !isStr(val)) return dflt;

      if (val == 'auto') {
         let pp = this.getPadPainter();
         if (pp?._auto_color_cnt !== undefined) {
            let pal = pp.getHistPalette(),
                cnt = pp._auto_color_cnt++,
                num = pp._num_primitives - 1;
            if (num < 2) num = 2;
            val = pal ? pal.getColorOrdinal((cnt % num) / num) : 'blue';
            if (!this._auto_colors) this._auto_colors = {};
            this._auto_colors[name] = val;
         } else if (this._auto_colors && this._auto_colors[name]) {
            val = this._auto_colors[name];
         } else {
            console.error(`Autocolor ${name} not defined yet - please check code`);
            val = '';
         }
      } else if (val[0] == '[') {
         let ordinal = parseFloat(val.slice(1, val.length-1));
         val = 'black';
         if (Number.isFinite(ordinal)) {
             let pp = this.getPadPainter(),
                 pal = pp?.getHistPalette();
             if (pal) val = pal.getColorOrdinal(ordinal);
         }
      }
      return val;
   }

   /** @summary Evaluate RAttrText properties
     * @return {Object} FontHandler, can be used directly for the text drawing */
   v7EvalFont(name, dflts, fontScale) {

      if (!dflts) dflts = {}; else
      if (typeof dflts == 'number') dflts = { size: dflts };

      let pp = this.getPadPainter(),
          rfont = pp?._dfltRFont || { fFamily: 'Arial', fStyle: '', fWeight: '' },
          text_size   = this.v7EvalAttr(name + '_size', dflts.size || 12),
          text_angle  = this.v7EvalAttr(name + '_angle', 0),
          text_align  = this.v7EvalAttr(name + '_align', dflts.align || 'none'),
          text_color  = this.v7EvalColor(name + '_color', dflts.color || 'none'),
          font_family = this.v7EvalAttr(name + '_font_family', rfont.fFamily || 'Arial'),
          font_style  = this.v7EvalAttr(name + '_font_style', rfont.fStyle || ''),
          font_weight = this.v7EvalAttr(name + '_font_weight', rfont.fWeight || '');

       if (isStr(text_size)) text_size = parseFloat(text_size);
       if (!Number.isFinite(text_size) || (text_size <= 0)) text_size = 12;
       if (!fontScale) fontScale = pp?.getPadHeight() || 100;

       let handler = new FontHandler(null, text_size, fontScale, font_family, font_style, font_weight);

       if (text_angle) handler.setAngle(360 - text_angle);
       if (text_align !== 'none') handler.setAlign(text_align);
       if (text_color !== 'none') handler.setColor(text_color);

       return handler;
    }

   /** @summary Create this.fillatt object based on v7 fill attributes */
   createv7AttFill(prefix) {
      if (!prefix || !isStr(prefix)) prefix = 'fill_';

      let color = this.v7EvalColor(prefix + 'color', ''),
          pattern = this.v7EvalAttr(prefix + 'style', 0);

      this.createAttFill({ pattern, color,  color_as_svg: true });
   }

   /** @summary Create this.lineatt object based on v7 line attributes */
   createv7AttLine(prefix) {
      if (!prefix || !isStr(prefix)) prefix = 'line_';

      let color = this.v7EvalColor(prefix + 'color', 'black'),
          width = this.v7EvalAttr(prefix + 'width', 1),
          style = this.v7EvalAttr(prefix + 'style', 1),
          pattern = this.v7EvalAttr(prefix + 'pattern');

      this.createAttLine({ color, width, style, pattern });

      if (prefix == 'border_')
         this.lineatt.setBorder(this.v7EvalAttr(prefix + 'rx', 0), this.v7EvalAttr(prefix + 'ry', 0));
   }

    /** @summary Create this.markeratt object based on v7 attributes */
   createv7AttMarker(prefix) {
      if (!prefix || !isStr(prefix)) prefix = 'marker_';

      let color = this.v7EvalColor(prefix + 'color', 'black'),
          size = this.v7EvalAttr(prefix + 'size', 0.01),
          style = this.v7EvalAttr(prefix + 'style', 1),
          refsize = 1;
      if (size < 1) {
         let pp = this.getPadPainter();
         refsize = pp?.getPadHeight() || 100;
      }

      this.createAttMarker({ color, size, style, refsize });
   }

   /** @summary Create RChangeAttr, which can be applied on the server side
     * @private */
   v7AttrChange(req, name, value, kind) {
      if (!this.snapid)
         return false;

      if (!req._typename) {
         req._typename = 'ROOT::Experimental::RChangeAttrRequest';
         req.ids = [];
         req.names = [];
         req.values = [];
         req.update = true;
      }

      if (this.cssprefix) name = this.cssprefix + name;
      req.ids.push(this.snapid);
      req.names.push(name);
      let obj = null;

      if ((value === null) || (value === undefined)) {
        if (!kind) kind = 'none';
        if (kind !== 'none') console.error(`Trying to set ${kind} for none value`);
      }

      if (!kind)
         switch(typeof value) {
            case 'number': kind = 'double'; break;
            case 'boolean': kind = 'boolean'; break;
         }

      obj = { _typename: 'ROOT::Experimental::RAttrMap::' };
      switch(kind) {
         case 'none': obj._typename += 'NoValue_t'; break;
         case 'boolean': obj._typename += 'BoolValue_t'; obj.v = value ? true : false; break;
         case 'int': obj._typename += 'IntValue_t'; obj.v = parseInt(value); break;
         case 'double': obj._typename += 'DoubleValue_t'; obj.v = parseFloat(value); break;
         default: obj._typename += 'StringValue_t'; obj.v = isStr(value) ? value : JSON.stringify(value); break;
      }

      req.values.push(obj);
      return true;
   }

   /** @summary Sends accumulated attribute changes to server */
   v7SendAttrChanges(req, do_update) {
      let canp = this.getCanvPainter();
      if (canp && req?._typename) {
         if (do_update !== undefined)
            req.update = do_update ? true : false;
         canp.v7SubmitRequest('', req);
      }
   }

   /** @summary Submit request to server-side drawable
    * @param kind defines request kind, only single request a time can be submitted
    * @param req is object derived from DrawableRequest, including correct _typename
    * @param method is method of painter object which will be called when getting reply */
   v7SubmitRequest(kind, req, method) {
      let canp = this.getCanvPainter();
      if (!isFunc(canp?.submitDrawableRequest)) return null;

      // special situation when snapid not yet assigned - just keep ref until snapid is there
      // maybe keep full list - for now not clear if really needed
      if (!this.snapid) {
         this._pending_request = { kind, req, method };
         return req;
      }

      return canp.submitDrawableRequest(kind, req, this, method);
   }

   /** @summary Assign snapid to the painter
     * @desc Overwrite default method */
   assignSnapId(id) {
      this.snapid = id;
      if (this.snapid && this._pending_request) {
         let p = this._pending_request;
         this.v7SubmitRequest(p.kind, p.req, p.method);
         delete this._pending_request;
      }
   }

   /** @summary Return communication mode with the server
     * @desc
     * kOffline means no server there,
     * kLessTraffic advise not to send commands if offline functionality available
     * kNormal is standard functionality with RCanvas on server side */
   v7CommMode() {
      let canp = this.getCanvPainter();
      if (!canp || !canp.submitDrawableRequest || !canp._websocket)
         return kOffline;

      return kNormal;
   }

   v7NormalMode() { return this.v7CommMode() == kNormal; }

   v7OfflineMode() { return this.v7CommMode() == kOffline; }

} // class RObjectPainter

/**
 * @summary Axis painter for v7
 *
 * @private
 */

class RAxisPainter extends RObjectPainter {

   /** @summary constructor */
   constructor(dom, arg1, axis, cssprefix) {
      let drawable = cssprefix ? arg1.getObject() : arg1;
      super(dom, drawable, '', cssprefix ? arg1.csstype : 'axis');
      Object.assign(this, AxisPainterMethods);
      this.initAxisPainter();

      this.axis = axis;
      if (cssprefix) { // drawing from the frame
         this.embedded = true; // indicate that painter embedded into the histo painter
         //this.csstype = arg1.csstype; // for the moment only via frame one can set axis attributes
         this.cssprefix = cssprefix;
         this.rstyle = arg1.rstyle;
      } else {
         // this.csstype = 'axis';
         this.cssprefix = 'axis_';
      }
   }

   /** @summary cleanup painter */
   cleanup() {
      delete this.axis;
      delete this.axis_g;
      this.cleanupAxisPainter();
      super.cleanup();
   }

   /** @summary Use in GED to identify kind of axis */
   getAxisType() { return 'RAttrAxis'; }

   /** @summary Configure only base parameters, later same handle will be used for drawing  */
   configureZAxis(name, fp) {
      this.name = name;
      this.kind = 'normal';
      this.log = false;
      let _log = this.v7EvalAttr('log', 0);
      if (_log) {
         this.log = true;
         this.logbase = 10;
         if (Math.abs(_log - Math.exp(1)) < 0.1)
            this.logbase = Math.exp(1);
         else if (_log > 1.9)
            this.logbase = Math.round(_log);
      }
      fp.logz = this.log;
   }

   /** @summary Configure axis painter
     * @desc Axis can be drawn inside frame <g> group with offset to 0 point for the frame
     * Therefore one should distinguish when caclulated coordinates used for axis drawing itself or for calculation of frame coordinates
     * @private */
   configureAxis(name, min, max, smin, smax, vertical, frame_range, axis_range, opts) {
      if (!opts) opts = {};
      this.name = name;
      this.full_min = min;
      this.full_max = max;
      this.kind = 'normal';
      this.vertical = vertical;
      this.log = false;
      let _log = this.v7EvalAttr('log', 0),
          _symlog = this.v7EvalAttr('symlog', 0);
      this.reverse = opts.reverse || false;

      if (this.v7EvalAttr('time')) {
         this.kind = 'time';
         this.timeoffset = 0;
         let toffset = this.v7EvalAttr('timeOffset');
         if (toffset !== undefined) {
            toffset = parseFloat(toffset);
            if (Number.isFinite(toffset)) this.timeoffset = toffset*1000;
         }
      } else if (this.axis && this.axis.fLabelsIndex) {
         this.kind = 'labels';
         delete this.own_labels;
      } else if (opts.labels) {
         this.kind = 'labels';
      } else {
         this.kind = 'normal';
      }

      if (this.kind == 'time') {
         this.func = time().domain([this.convertDate(smin), this.convertDate(smax)]);
      } else if (_symlog && (_symlog > 0)) {
         this.symlog = _symlog;
         this.func = symlog().constant(_symlog).domain([smin,smax]);
      } else if (_log) {
         if (smax <= 0) smax = 1;
         if ((smin <= 0) || (smin >= smax))
            smin = smax * 0.0001;
         this.log = true;
         this.logbase = 10;
         if (Math.abs(_log - Math.exp(1)) < 0.1)
            this.logbase = Math.exp(1);
         else if (_log > 1.9)
            this.logbase = Math.round(_log);
         this.func = log().base(this.logbase).domain([smin,smax]);
      } else {
         this.func = linear().domain([smin,smax]);
      }

      this.scale_min = smin;
      this.scale_max = smax;

      this.gr_range = axis_range || 1000; // when not specified, one can ignore it

      let range = frame_range ? frame_range : [0, this.gr_range];

      this.axis_shift = range[1] - this.gr_range;

      if (this.reverse)
         this.func.range([range[1], range[0]]);
      else
         this.func.range(range);

      if (this.kind == 'time')
         this.gr = val => this.func(this.convertDate(val));
      else if (this.log)
         this.gr = val => (val < this.scale_min) ? (this.vertical ? this.func.range()[0]+5 : -5) : this.func(val);
      else
         this.gr = this.func;

      delete this.format;// remove formatting func

      let ndiv = this.v7EvalAttr('ndiv', 508);

      this.nticks = ndiv % 100;
      this.nticks2 = (ndiv % 10000 - this.nticks) / 100;
      this.nticks3 = Math.floor(ndiv/10000);

      if (this.nticks > 20) this.nticks = 20;

      let gr_range = Math.abs(this.gr_range) || 100;

      if (this.kind == 'time') {
         if (this.nticks > 8) this.nticks = 8;

         let scale_range = this.scale_max - this.scale_min,
             tf1 = this.v7EvalAttr('timeFormat', ''),
             tf2 = chooseTimeFormat(scale_range / gr_range, false);

         if (!tf1 || (scale_range < 0.1 * (this.full_max - this.full_min)))
            tf1 = chooseTimeFormat(scale_range / this.nticks, true);

         this.tfunc1 = this.tfunc2 = timeFormat(tf1);
         if (tf2!==tf1)
            this.tfunc2 = timeFormat(tf2);

         this.format = this.formatTime;

      } else if (this.log) {
         if (this.nticks2 > 1) {
            this.nticks *= this.nticks2; // all log ticks (major or minor) created centrally
            this.nticks2 = 1;
         }
         this.noexp = this.v7EvalAttr('noexp', false);
         if ((this.scale_max < 300) && (this.scale_min > 0.3) && (this.logbase == 10)) this.noexp = true;
         this.moreloglabels = this.v7EvalAttr('moreloglbls', false);

         this.format = this.formatLog;
      } else if (this.kind == 'labels') {
         this.nticks = 50; // for text output allow max 50 names
         let scale_range = this.scale_max - this.scale_min;
         if (this.nticks > scale_range)
            this.nticks = Math.round(scale_range);
         this.nticks2 = 1;

         this.format = this.formatLabels;
      } else {
         this.order = 0;
         this.ndig = 0;
         this.format = this.formatNormal;
      }
   }

   /** @summary Return scale min */
   getScaleMin() {
      return this.func ? this.func.domain()[0] : 0;
   }

   /** @summary Return scale max */
   getScaleMax() {
      return this.func ? this.func.domain()[1] : 0;
   }

   /** @summary Provide label for axis value */
   formatLabels(d) {
      let indx = Math.round(d);
      if (this.axis && this.axis.fLabelsIndex) {
         if ((indx < 0) || (indx >= this.axis.fNBinsNoOver)) return null;
         for (let i = 0; i < this.axis.fLabelsIndex.length; ++i) {
            let pair = this.axis.fLabelsIndex[i];
            if (pair.second === indx) return pair.first;
         }
      } else {
         let labels = this.getObject().fLabels;
         if (labels && (indx >= 0) && (indx < labels.length))
            return labels[indx];
      }
      return null;
   }

   /** @summary Creates array with minor/middle/major ticks */
   createTicks(only_major_as_array, optionNoexp, optionNoopt, optionInt) {

      if (optionNoopt && this.nticks && (this.kind == 'normal')) this.noticksopt = true;

      let handle = { nminor: 0, nmiddle: 0, nmajor: 0, func: this.func };

      handle.minor = handle.middle = handle.major = this.produceTicks(this.nticks);

      if (only_major_as_array) {
         let res = handle.major, delta = (this.scale_max - this.scale_min)*1e-5;
         if (res[0] > this.scale_min + delta) res.unshift(this.scale_min);
         if (res[res.length-1] < this.scale_max - delta) res.push(this.scale_max);
         return res;
      }

      if ((this.nticks2 > 1) && (!this.log || (this.logbase === 10))) {
         handle.minor = handle.middle = this.produceTicks(handle.major.length, this.nticks2);

         let gr_range = Math.abs(this.func.range()[1] - this.func.range()[0]);

         // avoid black filling by middle-size
         if ((handle.middle.length <= handle.major.length) || (handle.middle.length > gr_range/3.5)) {
            handle.minor = handle.middle = handle.major;
         } else if ((this.nticks3 > 1) && !this.log)  {
            handle.minor = this.produceTicks(handle.middle.length, this.nticks3);
            if ((handle.minor.length <= handle.middle.length) || (handle.minor.length > gr_range/1.7)) handle.minor = handle.middle;
         }
      }

      handle.reset = function() {
         this.nminor = this.nmiddle = this.nmajor = 0;
      };

      handle.next = function(doround) {
         if (this.nminor >= this.minor.length) return false;

         this.tick = this.minor[this.nminor++];
         this.grpos = this.func(this.tick);
         if (doround) this.grpos = Math.round(this.grpos);
         this.kind = 3;

         if ((this.nmiddle < this.middle.length) && (Math.abs(this.grpos - this.func(this.middle[this.nmiddle])) < 1)) {
            this.nmiddle++;
            this.kind = 2;
         }

         if ((this.nmajor < this.major.length) && (Math.abs(this.grpos - this.func(this.major[this.nmajor])) < 1) ) {
            this.nmajor++;
            this.kind = 1;
         }
         return true;
      };

      handle.last_major = function() {
         return (this.kind !== 1) ? false : this.nmajor == this.major.length;
      };

      handle.next_major_grpos = function() {
         if (this.nmajor >= this.major.length) return null;
         return this.func(this.major[this.nmajor]);
      };

      this.order = 0;
      this.ndig = 0;

      // at the moment when drawing labels, we can try to find most optimal text representation for them

      if ((this.kind == 'normal') && !this.log && (handle.major.length > 0)) {

         let maxorder = 0, minorder = 0, exclorder3 = false;

         if (!optionNoexp) {
            let maxtick = Math.max(Math.abs(handle.major[0]),Math.abs(handle.major[handle.major.length-1])),
                mintick = Math.min(Math.abs(handle.major[0]),Math.abs(handle.major[handle.major.length-1])),
                ord1 = (maxtick > 0) ? Math.round(Math.log10(maxtick)/3)*3 : 0,
                ord2 = (mintick > 0) ? Math.round(Math.log10(mintick)/3)*3 : 0;

             exclorder3 = (maxtick < 2e4); // do not show 10^3 for values below 20000

             if (maxtick || mintick) {
                maxorder = Math.max(ord1,ord2) + 3;
                minorder = Math.min(ord1,ord2) - 3;
             }
         }

         // now try to find best combination of order and ndig for labels

         let bestorder = 0, bestndig = this.ndig, bestlen = 1e10;

         for (let order = minorder; order <= maxorder; order+=3) {
            if (exclorder3 && (order===3)) continue;
            this.order = order;
            this.ndig = 0;
            let lbls = [], indx = 0, totallen = 0;
            while (indx<handle.major.length) {
               let lbl = this.format(handle.major[indx], true);
               if (lbls.indexOf(lbl) < 0) {
                  lbls.push(lbl);
                  totallen += lbl.length;
                  indx++;
                  continue;
               }
               if (++this.ndig > 11) break; // not too many digits, anyway it will be exponential
               lbls = []; indx = 0; totallen = 0;
            }

            // for order == 0 we should virually remove '0.' and extra label on top
            if (!order && (this.ndig < 4))
               totallen -= (handle.major.length * 2 + 3);

            if (totallen < bestlen) {
               bestlen = totallen;
               bestorder = this.order;
               bestndig = this.ndig;
            }
         }

         this.order = bestorder;
         this.ndig = bestndig;

         if (optionInt) {
            if (this.order) console.warn(`Axis painter - integer labels are configured, but axis order ${this.order} is preferable`);
            if (this.ndig) console.warn(`Axis painter - integer labels are configured, but ${this.ndig} decimal digits are required`);
            this.ndig = 0;
            this.order = 0;
         }
      }

      return handle;
   }

   /** @summary Is labels should be centered */
   isCenteredLabels() {
      if (this.kind === 'labels') return true;
      if (this.kind === 'log') return false;
      return this.v7EvalAttr('labels_center', false);
   }

   /** @summary Used to move axis labels instead of zooming
     * @private */
   processLabelsMove(arg, pos) {
      if (this.optionUnlab || !this.axis_g) return false;

      let label_g = this.axis_g.select('.axis_labels');
      if (!label_g || (label_g.size() != 1)) return false;

      if (arg == 'start') {
         // no moving without labels
         let box = label_g.node().getBBox();

         label_g.append('rect')
                 .classed('zoom', true)
                 .attr('x', box.x)
                 .attr('y', box.y)
                 .attr('width', box.width)
                 .attr('height', box.height)
                 .style('cursor', 'move');
         if (this.vertical) {
            this.drag_pos0 = pos[0];
         } else {
            this.drag_pos0 = pos[1];
         }

         return true;
      }

      let offset = label_g.property('fix_offset');

      if (this.vertical) {
         offset += Math.round(pos[0] - this.drag_pos0);
         label_g.attr('transform', `translate(${offset})`);
      } else {
         offset += Math.round(pos[1] - this.drag_pos0);
         label_g.attr('transform', `translate(0,${offset})`);
      }
      if (!offset) label_g.attr('transform', null);

      if (arg == 'stop') {
         label_g.select('rect.zoom').remove();
         delete this.drag_pos0;
         if (offset != label_g.property('fix_offset')) {
            label_g.property('fix_offset', offset);
            let side = label_g.property('side') || 1;
            this.labelsOffset = offset / (this.vertical ? -side : side);
            this.changeAxisAttr(1, 'labels_offset', this.labelsOffset / this.scalingSize);
         }
      }

      return true;
   }

   /** @summary Add interactive elements to draw axes title */
   addTitleDrag(title_g, side) {
      if (!settings.MoveResize || isBatchMode()) return;

      let drag_rect = null,
          acc_x, acc_y, new_x, new_y, alt_pos, curr_indx,
          drag_move = drag().subject(Object);

      drag_move
         .on('start', evnt => {

            evnt.sourceEvent.preventDefault();
            evnt.sourceEvent.stopPropagation();

            let box = title_g.node().getBBox(), // check that elements visible, request precise value
                title_length = this.vertical ? box.height : box.width;

            new_x = acc_x = title_g.property('shift_x');
            new_y = acc_y = title_g.property('shift_y');

            if (this.titlePos == 'center')
               curr_indx = 1;
            else
               curr_indx = (this.titlePos == 'left') ? 0 : 2;

            // let d = ((this.gr_range > 0) && this.vertical) ? title_length : 0;
            alt_pos = [0, this.gr_range/2, this.gr_range]; // possible positions
            let off = this.vertical ? -title_length : title_length,
                swap = this.isReverseAxis() ? 2 : 0;
            if (this.title_align == 'middle') {
               alt_pos[swap] += off/2;
               alt_pos[2-swap] -= off/2;
            } else if ((this.title_align == 'begin') ^ this.isTitleRotated()) {
               alt_pos[1] -= off/2;
               alt_pos[2-swap] -= off;
            } else { // end
               alt_pos[swap] += off;
               alt_pos[1] += off/2;
            }

            alt_pos[curr_indx] = this.vertical ? acc_y : acc_x;

            drag_rect = title_g.append('rect')
                 .classed('zoom', true)
                 .attr('x', box.x)
                 .attr('y', box.y)
                 .attr('width', box.width)
                 .attr('height', box.height)
                 .style('cursor', 'move');
//                 .style('pointer-events','none'); // let forward double click to underlying elements
          }).on('drag', evnt => {
               if (!drag_rect) return;

               evnt.sourceEvent.preventDefault();
               evnt.sourceEvent.stopPropagation();

               acc_x += evnt.dx;
               acc_y += evnt.dy;

               let set_x, set_y,
                   p = this.vertical ? acc_y : acc_x, besti = 0;

               for (let i=1; i<3; ++i)
                  if (Math.abs(p - alt_pos[i]) < Math.abs(p - alt_pos[besti])) besti = i;

               if (this.vertical) {
                  set_x = acc_x;
                  set_y = alt_pos[besti];
               } else {
                  set_x = alt_pos[besti];
                  set_y = acc_y;
               }

               new_x = set_x; new_y = set_y; curr_indx = besti;
               title_g.attr('transform', 'translate(' + Math.round(new_x) + ',' + Math.round(new_y) +  ')');

          }).on('end', evnt => {
               if (!drag_rect) return;

               evnt.sourceEvent.preventDefault();
               evnt.sourceEvent.stopPropagation();

               let basepos = title_g.property('basepos') || 0;

               title_g.property('shift_x', new_x)
                      .property('shift_y', new_y);

               this.titleOffset = (this.vertical ? basepos - new_x : new_y - basepos) * side;

               if (curr_indx == 1) {
                  this.titlePos = 'center';
               } else if (curr_indx == 0) {
                  this.titlePos = 'left';
               } else {
                  this.titlePos = 'right';
               }

               this.changeAxisAttr(0, 'title_position', this.titlePos, 'title_offset', this.titleOffset / this.scalingSize);

               drag_rect.remove();
               drag_rect = null;
            });

      title_g.style('cursor', 'move').call(drag_move);
   }

   /** @summary checks if value inside graphical range, taking into account delta */
   isInsideGrRange(pos, delta1, delta2) {
      if (!delta1) delta1 = 0;
      if (delta2 === undefined) delta2 = delta1;
      if (this.gr_range < 0)
         return (pos >= this.gr_range - delta2) && (pos <= delta1);
      return (pos >= -delta1) && (pos <= this.gr_range + delta2);
   }

   /** @summary returns graphical range */
   getGrRange(delta) {
      if (!delta) delta = 0;
      if (this.gr_range < 0)
         return this.gr_range - delta;
      return this.gr_range + delta;
   }

   /** @summary If axis direction is negative coordinates direction */
   isReverseAxis() {
      return !this.vertical !== (this.getGrRange() > 0);
   }

   /** @summary Draw axis ticks
     * @private */
   drawMainLine(axis_g) {
      let ending = '';

      if (this.endingSize && this.endingStyle) {
         let sz = (this.gr_range > 0) ? -this.endingSize : this.endingSize,
             sz7 = Math.round(sz*0.7);
         sz = Math.round(sz);
         if (this.vertical)
            ending = `l${sz7},${sz}M0,${this.gr_range}l${-sz7},${sz}`;
         else
            ending = `l${sz},${sz7}M${this.gr_range},0l${sz},${-sz7}`;
      }

      axis_g.append('svg:path')
            .attr('d','M0,0' + (this.vertical ? 'v' : 'h') + this.gr_range + ending)
            .call(this.lineatt.func)
            .style('fill', ending ? 'none' : null);
   }

   /** @summary Draw axis ticks
     * @return {Object} with gaps on left and right side
     * @private */
   drawTicks(axis_g, side, main_draw) {
      if (main_draw) this.ticks = [];

      this.handle.reset();

      let res = '', ticks_plusminus = 0;
      if (this.ticksSide == 'both') {
         side = 1;
         ticks_plusminus = 1;
      }

      while (this.handle.next(true)) {

         let h1 = Math.round(this.ticksSize/4), h2 = 0;

         if (this.handle.kind < 3)
            h1 = Math.round(this.ticksSize/2);

         let grpos = this.handle.grpos - this.axis_shift;

         if ((this.startingSize || this.endingSize) && !this.isInsideGrRange(grpos, -Math.abs(this.startingSize), -Math.abs(this.endingSize))) continue;

         if (this.handle.kind == 1) {
            // if not showing labels, not show large tick
            if ((this.kind == 'labels') || (this.format(this.handle.tick,true) !== null)) h1 = this.ticksSize;

            if (main_draw) this.ticks.push(grpos); // keep graphical positions of major ticks
         }

         if (ticks_plusminus > 0) {
            h2 = -h1;
         } else if (side < 0) {
            h2 = -h1; h1 = 0;
         } else {
            h2 = 0;
         }

         res += this.vertical ? `M${h1},${grpos}H${h2}` : `M${grpos},${-h1}V${-h2}`;
      }

      if (res)
         axis_g.append('svg:path')
               .attr('d', res)
               .style('stroke', this.ticksColor || this.lineatt.color)
               .style('stroke-width', !this.ticksWidth || (this.ticksWidth == 1) ? null : this.ticksWidth);

       let gap0 = Math.round(0.25*this.ticksSize), gap = Math.round(1.25*this.ticksSize);
       return { '-1': (side > 0) || ticks_plusminus ? gap : gap0,
                 '1': (side < 0) || ticks_plusminus ? gap : gap0 };
   }

   /** @summary Performs labels drawing
     * @return {Promise} with gaps in both direction */
   async drawLabels(axis_g, side, gaps) {
      let center_lbls = this.isCenteredLabels(),
          rotate_lbls = this.labelsFont.angle != 0,
          textscale = 1, maxtextlen = 0, lbls_tilt = false,
          label_g = axis_g.append('svg:g').attr('class','axis_labels').property('side', side),
          lbl_pos = this.handle.lbl_pos || this.handle.major,
          max_lbl_width = 0, max_lbl_height = 0;

      // function called when text is drawn to analyze width, required to correctly scale all labels
      function process_drawtext_ready(painter) {

         max_lbl_width = Math.max(max_lbl_width, this.result_width);
         max_lbl_height = Math.max(max_lbl_height, this.result_height);

         let textwidth = this.result_width;

         if (textwidth && ((!painter.vertical && !rotate_lbls) || (painter.vertical && rotate_lbls)) && !painter.log) {
            let maxwidth = this.gap_before*0.45 + this.gap_after*0.45;
            if (!this.gap_before) maxwidth = 0.9*this.gap_after; else
            if (!this.gap_after) maxwidth = 0.9*this.gap_before;
            textscale = Math.min(textscale, maxwidth / textwidth);
         }

         if ((textscale > 0.0001) && (textscale < 0.8) && !painter.vertical && !rotate_lbls && (maxtextlen > 5) && (side > 0))
            lbls_tilt = true;

         let scale = textscale * (lbls_tilt ? 3 : 1);
         if ((scale > 0.0001) && (scale < 1))
            painter.scaleTextDrawing(1/scale, label_g);
      }

      let lastpos = 0,
          fix_offset = Math.round((this.vertical ? -side : side) * this.labelsOffset),
          fix_coord = Math.round((this.vertical ? -side : side) * gaps[side]);

      if (fix_offset)
         label_g.attr('transform', this.vertical ? `translate(${fix_offset})` : `translate(0,${fix_offset})`);

      label_g.property('fix_offset', fix_offset);

      this.startTextDrawing(this.labelsFont, 'font', label_g);

      for (let nmajor = 0; nmajor < lbl_pos.length; ++nmajor) {

         let lbl = this.format(lbl_pos[nmajor], true);
         if (lbl === null) continue;

         let pos = Math.round(this.func(lbl_pos[nmajor])),
             arg = { text: lbl, latex: 1, draw_g: label_g };

         arg.gap_before = (nmajor > 0) ? Math.abs(Math.round(pos - this.func(lbl_pos[nmajor-1]))) : 0,
         arg.gap_after = (nmajor < lbl_pos.length-1) ? Math.abs(Math.round(this.func(lbl_pos[nmajor+1])-pos)) : 0;

         if (center_lbls) {
            let gap = arg.gap_after || arg.gap_before;
            pos = Math.round(pos - (this.vertical ? 0.5*gap : -0.5*gap));
            if (!this.isInsideGrRange(pos, 5)) continue;
         }

         maxtextlen = Math.max(maxtextlen, lbl.length);

         pos -= this.axis_shift;

         if ((this.startingSize || this.endingSize) && !this.isInsideGrRange(pos, -Math.abs(this.startingSize), -Math.abs(this.endingSize))) continue;

         if (this.vertical) {
            arg.x = fix_coord;
            arg.y = pos;
            arg.align = rotate_lbls ? ((side < 0) ? 23 : 20) : ((side < 0) ? 12 : 32);
         } else {
            arg.x = pos;
            arg.y = fix_coord;
            arg.align = rotate_lbls ? ((side < 0) ? 12 : 32) : ((side < 0) ? 20 : 23);
         }

         arg.post_process = process_drawtext_ready;

         this.drawText(arg);

         if (lastpos && (pos!=lastpos) && ((this.vertical && !rotate_lbls) || (!this.vertical && rotate_lbls))) {
            let axis_step = Math.abs(pos-lastpos);
            textscale = Math.min(textscale, 0.9*axis_step/this.labelsFont.size);
         }

         lastpos = pos;
      }

      if (this.order)
         this.drawText({ x: this.vertical ? side*5 : this.getGrRange(5),
                         y: this.has_obstacle ? fix_coord : (this.vertical ? this.getGrRange(3) : -3*side),
                         align: this.vertical ? ((side < 0) ? 30 : 10) : ((this.has_obstacle ^ (side < 0)) ? 13 : 10),
                         latex: 1,
                         text: '#times' + this.formatExp(10, this.order),
                         draw_g: label_g
         });

      return this.finishTextDrawing(label_g).then(() => {

        if (lbls_tilt)
           label_g.selectAll('text').each(function () {
               let txt = select(this), tr = txt.attr('transform');
               txt.attr('transform', tr + ' rotate(25)').style('text-anchor', 'start');
           });

         if (this.vertical) {
            gaps[side] += Math.round(rotate_lbls ? 1.2*max_lbl_height : max_lbl_width + 0.4*this.labelsFont.size) - side*fix_offset;
         } else {
            let tilt_height = lbls_tilt ? max_lbl_width * Math.sin(25/180*Math.PI) + max_lbl_height * (Math.cos(25/180*Math.PI) + 0.2) : 0;

            gaps[side] += Math.round(Math.max(rotate_lbls ? max_lbl_width + 0.4*this.labelsFont.size : 1.2*max_lbl_height, 1.2*this.labelsFont.size, tilt_height)) + fix_offset;
         }

         return gaps;
      });
   }

   /** @summary Add zomming rect to axis drawing */
   addZoomingRect(axis_g, side, lgaps) {
      if (settings.Zooming && !this.disable_zooming && !isBatchMode()) {
         let sz = Math.max(lgaps[side], 10),
             d = this.vertical ? `v${this.gr_range}h${-side*sz}v${-this.gr_range}`
                               : `h${this.gr_range}v${side*sz}h${-this.gr_range}`;
         axis_g.append('svg:path')
               .attr('d',`M0,0${d}z`)
               .attr('class', 'axis_zoom')
               .style('opacity', '0')
               .style('cursor', 'crosshair');
      }
   }

   /** @summary Returns true if axis title is rotated */
   isTitleRotated() {
      return this.titleFont && (this.titleFont.angle != (this.vertical ? 270 : 0));
   }

   /** @summary Draw axis title */
   async drawTitle(axis_g, side, lgaps) {
      if (!this.fTitle)
         return this;

      let title_g = axis_g.append('svg:g').attr('class', 'axis_title'),
          title_shift_x = 0, title_shift_y = 0, title_basepos = 0;

      let rotated = this.isTitleRotated();

      this.startTextDrawing(this.titleFont, 'font', title_g);

      this.title_align = this.titleCenter ? 'middle' : (this.titleOpposite ^ (this.isReverseAxis() || rotated) ? 'begin' : 'end');

      if (this.vertical) {
         title_basepos = Math.round(-side*(lgaps[side]));
         title_shift_x = title_basepos + Math.round(-side*this.titleOffset);
         title_shift_y = Math.round(this.titleCenter ? this.gr_range/2 : (this.titleOpposite ? 0 : this.gr_range));
         this.drawText({ align: [this.title_align, ((side < 0) ^ rotated ? 'top' : 'bottom')],
                         text: this.fTitle, draw_g: title_g });
      } else {
         title_shift_x = Math.round(this.titleCenter ? this.gr_range/2 : (this.titleOpposite ? 0 : this.gr_range));
         title_basepos = Math.round(side*lgaps[side]);
         title_shift_y = title_basepos + Math.round(side*this.titleOffset);
         this.drawText({ align: [this.title_align, ((side > 0) ^ rotated ? 'top' : 'bottom')],
                         text: this.fTitle, draw_g: title_g });
      }

      title_g.attr('transform', `translate(${title_shift_x},${title_shift_y})`)
             .property('basepos', title_basepos)
             .property('shift_x', title_shift_x)
             .property('shift_y', title_shift_y);

      this.addTitleDrag(title_g, side);

      return this.finishTextDrawing(title_g);
   }

   /** @summary Extract major draw attributes, which are also used in interactive operations
     * @private  */
   extractDrawAttributes(scalingSize) {
      let pp = this.getPadPainter(),
          rect = pp?.getPadRect() || { width: 10, height: 10 };

      this.scalingSize = scalingSize || (this.vertical ? rect.width : rect.height);

      this.createv7AttLine('line_');

      this.optionUnlab = this.v7EvalAttr('labels_hide', false);

      this.endingStyle = this.v7EvalAttr('ending_style', '');
      this.endingSize = Math.round(this.v7EvalLength('ending_size', this.scalingSize, this.endingStyle ? 0.02 : 0));
      this.startingSize = Math.round(this.v7EvalLength('starting_size', this.scalingSize, 0));
      this.ticksSize = this.v7EvalLength('ticks_size', this.scalingSize, 0.02);
      this.ticksSide = this.v7EvalAttr('ticks_side', 'normal');
      this.ticksColor = this.v7EvalColor('ticks_color', '');
      this.ticksWidth = this.v7EvalAttr('ticks_width', 1);
      if (scalingSize && (this.ticksSize < 0))
         this.ticksSize = -this.ticksSize;

      this.fTitle = this.v7EvalAttr('title_value', '');

      if (this.fTitle) {
         this.titleFont = this.v7EvalFont('title', { size: 0.03 }, scalingSize || pp?.getPadHeight() || 10);
         this.titleFont.roundAngle(180, this.vertical ? 270 : 0);

         this.titleOffset = this.v7EvalLength('title_offset', this.scalingSize, 0);
         this.titlePos = this.v7EvalAttr('title_position', 'right');
         this.titleCenter = (this.titlePos == 'center');
         this.titleOpposite = (this.titlePos == 'left');
      } else {
         delete this.titleFont;
         delete this.titleOffset;
         delete this.titlePos;
      }

      // TODO: remove old scaling factors for labels and ticks
      this.labelsFont = this.v7EvalFont('labels', { size: scalingSize ? 0.05 : 0.03 });
      this.labelsFont.roundAngle(180);
      if (this.labelsFont.angle) this.labelsFont.angle = 270;
      this.labelsOffset = this.v7EvalLength('labels_offset', this.scalingSize, 0);

      if (scalingSize) this.ticksSize = this.labelsFont.size*0.5; // old lego scaling factor

      if (this.maxTickSize && (this.ticksSize > this.maxTickSize))
         this.ticksSize = this.maxTickSize;
   }

   /** @summary Performs axis drawing
     * @return {Promise} which resolved when drawing is completed */
   async drawAxis(layer, transform, side) {
      let axis_g = layer;

      if (side === undefined) side = 1;

      if (!this.standalone) {
         axis_g = layer.select('.' + this.name + '_container');
         if (axis_g.empty())
            axis_g = layer.append('svg:g').attr('class', this.name + '_container');
         else
            axis_g.selectAll('*').remove();
      }

      axis_g.attr('transform', transform || null);

      this.extractDrawAttributes();
      this.axis_g = axis_g;
      this.side = side;

      if (this.ticksSide == 'invert') side = -side;

      if (this.standalone)
         this.drawMainLine(axis_g);

      let optionNoopt = false,  // no ticks position optimization
          optionInt = false,    // integer labels
          optionNoexp = false;  // do not create exp

      this.handle = this.createTicks(false, optionNoexp, optionNoopt, optionInt);

      // first draw ticks
      let tgaps = this.drawTicks(axis_g, side, true);

      // draw labels
      let labelsPromise = this.optionUnlab ? Promise.resolve(tgaps) : this.drawLabels(axis_g, side, tgaps);

      return labelsPromise.then(lgaps => {
         // when drawing axis on frame, zoom rect should be always outside
         this.addZoomingRect(axis_g, this.standalone ? side : this.side, lgaps);

         return this.drawTitle(axis_g, side, lgaps);
      });
   }

   /** @summary Assign handler, which is called when axis redraw by interactive changes
     * @desc Used by palette painter to reassign iteractive handlers
     * @private */
   setAfterDrawHandler(handler) {
      this._afterDrawAgain = handler;
   }

   /** @summary Draw axis with the same settings, used by interactive changes */
   drawAxisAgain() {
      if (!this.axis_g || !this.side) return;

      this.axis_g.selectAll('*').remove();

      this.extractDrawAttributes();

      let side = this.side;
      if (this.ticksSide == 'invert') side = -side;

      if (this.standalone)
         this.drawMainLine(this.axis_g);

      // first draw ticks
      let tgaps = this.drawTicks(this.axis_g, side, false);

      let labelsPromise = this.optionUnlab ? Promise.resolve(tgaps) : this.drawLabels(this.axis_g, side, tgaps);

      return labelsPromise.then(lgaps => {
         // when drawing axis on frame, zoom rect should be always outside
         this.addZoomingRect(this.axis_g, this.standalone ? side : this.side, lgaps);

         return this.drawTitle(this.axis_g, side, lgaps);
      }).then(() => {
         if (isFunc(this._afterDrawAgain))
            this._afterDrawAgain();
      });
   }

   /** @summary Draw axis again on opposite frame size */
   drawAxisOtherPlace(layer, transform, side, only_ticks) {
      let axis_g = layer.select('.' + this.name + '_container2');
      if (axis_g.empty())
         axis_g = layer.append('svg:g').attr('class',this.name + '_container2');
      else
         axis_g.selectAll('*').remove();

      axis_g.attr('transform', transform || null);

      if (this.ticksSide == 'invert') side = -side;

      // draw ticks again
      let tgaps = this.drawTicks(axis_g, side, false);

      // draw labels again
      let promise = this.optionUnlab || only_ticks ? Promise.resolve(tgaps) : this.drawLabels(axis_g, side, tgaps);

      return promise.then(lgaps => {
         this.addZoomingRect(axis_g, side, lgaps);
         return true;
      });
   }

   /** @summary Change zooming in standalone mode */
   zoomStandalone(min,max) {
      this.changeAxisAttr(1, 'zoomMin', min, 'zoomMax', max);
   }

   /** @summary Redraw axis, used in standalone mode for RAxisDrawable */
   redraw() {

      let drawable = this.getObject(),
          pp   = this.getPadPainter(),
          pos  = pp.getCoordinate(drawable.fPos),
          len  = pp.getPadLength(drawable.fVertical, drawable.fLength),
          reverse = this.v7EvalAttr('reverse', false),
          labels_len = drawable.fLabels.length,
          min = (labels_len > 0) ? 0 : this.v7EvalAttr('min', 0),
          max = (labels_len > 0) ? labels_len : this.v7EvalAttr('max', 100);

      // in vertical direction axis drawn in negative direction
      if (drawable.fVertical) len -= pp.getPadHeight();

      let smin = this.v7EvalAttr('zoomMin'),
          smax = this.v7EvalAttr('zoomMax');
      if (smin === smax) {
         smin = min; smax = max;
      }

      this.configureAxis('axis', min, max, smin, smax, drawable.fVertical, undefined, len, { reverse, labels: labels_len > 0 });

      this.createG();

      this.standalone = true;  // no need to clean axis container

      let promise = this.drawAxis(this.draw_g, `translate(${pos.x},${pos.y})`);

      if (isBatchMode()) return promise;

      return promise.then(() => {
         if (settings.ContextMenu)
            this.draw_g.on('contextmenu', evnt => {
               evnt.stopPropagation(); // disable main context menu
               evnt.preventDefault();  // disable browser context menu
               createMenu$1(evnt, this).then(menu => {
                 menu.add('header:RAxisDrawable');
                 menu.add('Unzoom', () => this.zoomStandalone());
                 this.fillAxisContextMenu(menu, '');
                 menu.show();
               });
            });

         addDragHandler(this, { x: pos.x, y: pos.y, width: this.vertical ? 10 : len, height: this.vertical ? len : 10,
                                only_move: true, redraw: d => this.positionChanged(d) });

         this.draw_g.on('dblclick', () => this.zoomStandalone());

         if (settings.ZoomWheel)
            this.draw_g.on('wheel', evnt => {
               evnt.stopPropagation();
               evnt.preventDefault();

               let pos = pointer(evnt, this.draw_g.node()),
                   coord = this.vertical ? (1 - pos[1] / len) : pos[0] / len,
                   item = this.analyzeWheelEvent(evnt, coord);

               if (item.changed) this.zoomStandalone(item.min, item.max);
            });
      });
   }

   /** @summary Process interactive moving of the axis drawing */
   positionChanged(drag) {
      let drawable = this.getObject(),
          rect = this.getPadPainter().getPadRect(),
          xn = drag.x / rect.width,
          yn = 1 - drag.y / rect.height;

      drawable.fPos.fHoriz.fArr = [ xn ];
      drawable.fPos.fVert.fArr = [ yn ];

      this.submitCanvExec(`SetPos({${xn.toFixed(4)},${yn.toFixed(4)}})`);
   }

   /** @summary Change axis attribute, submit changes to server and redraw axis when specified
     * @desc Arguments as redraw_mode, name1, value1, name2, value2, ... */
   changeAxisAttr(redraw_mode) {
      let changes = {}, indx = 1;
      while (indx < arguments.length - 1) {
         this.v7AttrChange(changes, arguments[indx], arguments[indx+1]);
         this.v7SetAttr(arguments[indx], arguments[indx+1]);
         indx += 2;
      }
      this.v7SendAttrChanges(changes, false); // do not invoke canvas update on the server
      if (redraw_mode === 1) {
         if (this.standalone)
            this.redraw();
         else
            this.drawAxisAgain();
      } else if (redraw_mode)
         this.redrawPad();
   }

   /** @summary Change axis log scale kind */
   changeAxisLog(arg) {
      if ((this.kind == 'labels') || (this.kind == 'time')) return;
      if (arg === 'toggle') arg = this.log ? 0 : 10;

      arg = parseFloat(arg);
      if (Number.isFinite(arg)) this.changeAxisAttr(2, 'log', arg, 'symlog', 0);
   }

   /** @summary Provide context menu for axis */
   fillAxisContextMenu(menu, kind) {

      if (kind) menu.add('Unzoom', () => this.getFramePainter().unzoom(kind));

      menu.add('sub:Log scale', () => this.changeAxisLog('toggle'));
      menu.addchk(!this.log && !this.symlog, 'linear', 0, arg => this.changeAxisLog(arg));
      menu.addchk(this.log && !this.symlog && (this.logbase == 10), 'log10', () => this.changeAxisLog(10));
      menu.addchk(this.log && !this.symlog && (this.logbase == 2), 'log2', () => this.changeAxisLog(2));
      menu.addchk(this.log && !this.symlog && Math.abs(this.logbase - Math.exp(1)) < 0.1, 'ln', () => this.changeAxisLog(Math.exp(1)));
      menu.addchk(!this.log && this.symlog, 'symlog', 0, () =>
         menu.input('set symlog constant', this.symlog || 10, 'float').then(v => this.changeAxisAttr(2,'symlog', v)));
      menu.add('endsub:');

      menu.add('Divisions', () => menu.input('Set axis devisions', this.v7EvalAttr('ndiv', 508), 'int').then(val => this.changeAxisAttr(2, 'ndiv', val)));

      menu.add('sub:Ticks');
      menu.addRColorMenu('color', this.ticksColor, col => this.changeAxisAttr(1, 'ticks_color', col));
      menu.addSizeMenu('size', 0, 0.05, 0.01, this.ticksSize/this.scalingSize, sz => this.changeAxisAttr(1, 'ticks_size', sz));
      menu.addSelectMenu('side', ['normal', 'invert', 'both'], this.ticksSide, side => this.changeAxisAttr(1, 'ticks_side', side));
      menu.add('endsub:');

      if (!this.optionUnlab && this.labelsFont) {
         menu.add('sub:Labels');
         menu.addSizeMenu('offset', -0.05, 0.05, 0.01, this.labelsOffset/this.scalingSize,
                         offset => this.changeAxisAttr(1, 'labels_offset', offset));
         menu.addRAttrTextItems(this.labelsFont, { noangle: 1, noalign: 1 },
               change => this.changeAxisAttr(1, 'labels_' + change.name, change.value));
         menu.addchk(this.labelsFont.angle, 'rotate', res => this.changeAxisAttr(1, 'labels_angle', res ? 180 : 0));
         menu.add('endsub:');
      }

      menu.add('sub:Title', () => menu.input('Enter axis title', this.fTitle).then(t => this.changeAxisAttr(1, 'title_value', t)));

      if (this.fTitle) {
         menu.addSizeMenu('offset', -0.05, 0.05, 0.01, this.titleOffset/this.scalingSize,
                           offset => this.changeAxisAttr(1, 'title_offset', offset));

         menu.addSelectMenu('position', ['left', 'center', 'right'], this.titlePos,
                            pos => this.changeAxisAttr(1, 'title_position', pos));

         menu.addchk(this.isTitleRotated(), 'rotate', flag => this.changeAxisAttr(1, 'title_angle', flag ? 180 : 0));

         menu.addRAttrTextItems(this.titleFont, { noangle: 1, noalign: 1 }, change => this.changeAxisAttr(1, 'title_' + change.name, change.value));
      }

      menu.add('endsub:');
      return true;
   }

} // class RAxisPainter

/**
 * @summary Painter class for RFrame, main handler for interactivity
 *
 * @private
 */

class RFramePainter extends RObjectPainter {

   /** @summary constructor
     * @param {object|string} dom - DOM element for drawing or element id
     * @param {object} tframe - RFrame object */
   constructor(dom, tframe) {
      super(dom, tframe, '', 'frame');
      this.mode3d = false;
      this.xmin = this.xmax = 0; // no scale specified, wait for objects drawing
      this.ymin = this.ymax = 0; // no scale specified, wait for objects drawing
      this.axes_drawn = false;
      this.keys_handler = null;
      this.projection = 0; // different projections
      this.v7_frame = true; // indicator of v7, used in interactive part
   }

   /** @summary Returns frame painter - object itself */
   getFramePainter() { return this; }

   /** @summary Returns true if it is ROOT6 frame
    * @private */
   is_root6() { return false; }

   /** @summary Set active flag for frame - can block some events
    * @private */
   setFrameActive(on) {
      this.enabledKeys = on && settings.HandleKeys ? true : false;
      // used only in 3D mode
      if (this.control)
         this.control.enableKeys = this.enabledKeys;
   }

   setLastEventPos(pnt) {
      // set position of last context menu event, can be
      this.fLastEventPnt = pnt;
   }

   getLastEventPos() {
      // return position of last event
      return this.fLastEventPnt;
   }

   /** @summary Update graphical attributes */
   updateAttributes(force) {
      if ((this.fX1NDC === undefined) || (force && !this.modified_NDC)) {

         let rect = this.getPadPainter().getPadRect();
         this.fX1NDC = this.v7EvalLength('margins_left', rect.width, settings.FrameNDC.fX1NDC) / rect.width;
         this.fY1NDC = this.v7EvalLength('margins_bottom', rect.height, settings.FrameNDC.fY1NDC) / rect.height;
         this.fX2NDC = 1 - this.v7EvalLength('margins_right', rect.width, 1-settings.FrameNDC.fX2NDC) / rect.width;
         this.fY2NDC = 1 - this.v7EvalLength('margins_top', rect.height, 1-settings.FrameNDC.fY2NDC) / rect.height;
      }

      if (!this.fillatt)
         this.createv7AttFill();

      this.createv7AttLine('border_');
   }

   /** @summary Returns coordinates transformation func */
   getProjectionFunc() {
      switch (this.projection) {
         // Aitoff2xy
         case 1: return (l, b) => {
            const DegToRad = Math.PI/180,
                  alpha2 = (l/2)*DegToRad,
                  delta  = b*DegToRad,
                  r2     = Math.sqrt(2),
                  f      = 2*r2/Math.PI,
                  cdec   = Math.cos(delta),
                  denom  = Math.sqrt(1. + cdec*Math.cos(alpha2));
            return {
               x: cdec*Math.sin(alpha2)*2.*r2/denom/f/DegToRad,
               y: Math.sin(delta)*r2/denom/f/DegToRad
            };
         };
         // mercator
         case 2: return (l, b) => { return { x: l, y: Math.log(Math.tan((Math.PI/2 + b/180*Math.PI)/2)) }; };
         // sinusoidal
         case 3: return (l, b) => { return { x: l*Math.cos(b/180*Math.PI), y: b } };
         // parabolic
         case 4: return (l, b) => { return { x: l*(2.*Math.cos(2*b/180*Math.PI/3) - 1), y: 180*Math.sin(b/180*Math.PI/3) }; };
      }
   }

   /** @summary Rcalculate frame ranges using specified projection functions
     * @desc Not yet used in v7 */
   recalculateRange(Proj) {
      this.projection = Proj || 0;

      if ((this.projection == 2) && ((this.scale_ymin <= -90 || this.scale_ymax >=90))) {
         console.warn(`Mercator Projection: latitude out of range ${this.scale_ymin} ${this.scale_ymax}`);
         this.projection = 0;
      }

      let func = this.getProjectionFunc();
      if (!func) return;

      let pnts = [ func(this.scale_xmin, this.scale_ymin),
                   func(this.scale_xmin, this.scale_ymax),
                   func(this.scale_xmax, this.scale_ymax),
                   func(this.scale_xmax, this.scale_ymin) ];
      if (this.scale_xmin < 0 && this.scale_xmax > 0) {
         pnts.push(func(0, this.scale_ymin));
         pnts.push(func(0, this.scale_ymax));
      }
      if (this.scale_ymin < 0 && this.scale_ymax > 0) {
         pnts.push(func(this.scale_xmin, 0));
         pnts.push(func(this.scale_xmax, 0));
      }

      this.original_xmin = this.scale_xmin;
      this.original_xmax = this.scale_xmax;
      this.original_ymin = this.scale_ymin;
      this.original_ymax = this.scale_ymax;

      this.scale_xmin = this.scale_xmax = pnts[0].x;
      this.scale_ymin = this.scale_ymax = pnts[0].y;

      for (let n = 1; n < pnts.length; ++n) {
         this.scale_xmin = Math.min(this.scale_xmin, pnts[n].x);
         this.scale_xmax = Math.max(this.scale_xmax, pnts[n].x);
         this.scale_ymin = Math.min(this.scale_ymin, pnts[n].y);
         this.scale_ymax = Math.max(this.scale_ymax, pnts[n].y);
      }
   }

   /** @summary Draw axes grids
     * @desc Called immediately after axes drawing */
   drawGrids() {
      let layer = this.getFrameSvg().select('.grid_layer');

      layer.selectAll('.xgrid').remove();
      layer.selectAll('.ygrid').remove();

      let h = this.getFrameHeight(),
          w = this.getFrameWidth(),
          gridx = this.v7EvalAttr('gridX', false),
          gridy = this.v7EvalAttr('gridY', false),
          grid_style = getSvgLineStyle(gStyle.fGridStyle),
          grid_color = (gStyle.fGridColor > 0) ? this.getColor(gStyle.fGridColor) : 'black';

      if (this.x_handle)
         this.x_handle.draw_grid = gridx;

      // add a grid on x axis, if the option is set
      if (this.x_handle && this.x_handle.draw_grid) {
         let grid = '';
         for (let n = 0; n < this.x_handle.ticks.length; ++n)
            if (this.swap_xy)
               grid += `M0,${h+this.x_handle.ticks[n]}h${w}`;
            else
               grid += `M${this.x_handle.ticks[n]},0v${h}`;

         if (grid)
            layer.append('svg:path')
                 .attr('class', 'xgrid')
                 .attr('d', grid)
                 .style('stroke',grid_color)
                 .style('stroke-width', gStyle.fGridWidth)
                 .style('stroke-dasharray', grid_style);
      }

      if (this.y_handle)
         this.y_handle.draw_grid = gridy;

      // add a grid on y axis, if the option is set
      if (this.y_handle && this.y_handle.draw_grid) {
         let grid = '';
         for (let n = 0; n < this.y_handle.ticks.length; ++n)
            if (this.swap_xy)
               grid += `M${this.y_handle.ticks[n]},0v${h}`;
            else
               grid += `M0,${h+this.y_handle.ticks[n]}h${w}`;

         if (grid)
          layer.append('svg:path')
               .attr('class', 'ygrid')
               .attr('d', grid)
               .style('stroke', grid_color)
               .style('stroke-width', gStyle.fGridWidth)
               .style('stroke-dasharray', grid_style);
      }
   }

   /** @summary Converts 'raw' axis value into text */
   axisAsText(axis, value) {
      let handle = this[axis+'_handle'];

      if (handle)
         return handle.axisAsText(value, settings[axis.toUpperCase() + 'ValuesFormat']);

      return value.toPrecision(4);
   }

   /** @summary Set axix range */
   _setAxisRange(prefix, vmin, vmax) {
      let nmin = prefix + 'min', nmax = prefix + 'max';
      if (this[nmin] != this[nmax]) return;
      let min = this.v7EvalAttr(prefix + '_min'),
          max = this.v7EvalAttr(prefix + '_max');

      if (min !== undefined) vmin = min;
      if (max !== undefined) vmax = max;

      if (vmin < vmax) {
         this[nmin] = vmin;
         this[nmax] = vmax;
      }

      let nzmin = 'zoom_' + prefix + 'min', nzmax = 'zoom_' + prefix + 'max';

      if ((this[nzmin] == this[nzmax]) && !this.zoomChangedInteractive(prefix)) {
         min = this.v7EvalAttr(prefix + '_zoomMin');
         max = this.v7EvalAttr(prefix + '_zoomMax');

         if ((min !== undefined) || (max !== undefined)) {
            this[nzmin] = (min === undefined) ? this[nmin] : min;
            this[nzmax] = (max === undefined) ? this[nmax] : max;
         }
      }
   }

   /** @summary Set axes ranges for drawing, check configured attributes if range already specified */
   setAxesRanges(xaxis, xmin, xmax, yaxis, ymin, ymax, zaxis, zmin, zmax) {
      if (this.axes_drawn) return;
      this.xaxis = xaxis;
      this._setAxisRange('x', xmin, xmax);
      this.yaxis = yaxis;
      this._setAxisRange('y', ymin, ymax);
      this.zaxis = zaxis;
      this._setAxisRange('z', zmin, zmax);
   }

   /** @summary Set secondary axes ranges */
   setAxes2Ranges(second_x, xaxis, xmin, xmax, second_y, yaxis, ymin, ymax) {
      if (second_x) {
         this.x2axis = xaxis;
         this._setAxisRange('x2', xmin, xmax);
      }
      if (second_y) {
         this.y2axis = yaxis;
         this._setAxisRange('y2', ymin, ymax);
      }
   }

   /** @summary Create x,y objects which maps user coordinates into pixels
     * @desc Must be used only for v6 objects, see TFramePainter for more details
     * @private */
   createXY(opts) {
      if (this.self_drawaxes) return;

      this.cleanXY(); // remove all previous configurations

      if (!opts) opts = {};

      this.v6axes = true;
      this.swap_xy = opts.swap_xy || false;
      this.reverse_x = opts.reverse_x || false;
      this.reverse_y = opts.reverse_y || false;

      this.logx = this.v7EvalAttr('x_log', 0);
      this.logy = this.v7EvalAttr('y_log', 0);

      let w = this.getFrameWidth(), h = this.getFrameHeight();

      this.scale_xmin = this.xmin;
      this.scale_xmax = this.xmax;

      this.scale_ymin = this.ymin;
      this.scale_ymax = this.ymax;

      if (opts.extra_y_space) {
         let log_scale = this.swap_xy ? this.logx : this.logy;
         if (log_scale && (this.scale_ymax > 0))
            this.scale_ymax = Math.exp(Math.log(this.scale_ymax)*1.1);
         else
            this.scale_ymax += (this.scale_ymax - this.scale_ymin)*0.1;
      }

      // if (opts.check_pad_range) {
         // take zooming out of pad or axis attributes - skip!
      // }

      if ((this.zoom_ymin == this.zoom_ymax) && (opts.zoom_ymin != opts.zoom_ymax) && !this.zoomChangedInteractive('y')) {
         this.zoom_ymin = opts.zoom_ymin;
         this.zoom_ymax = opts.zoom_ymax;
      }

      if (this.zoom_xmin != this.zoom_xmax) {
         this.scale_xmin = this.zoom_xmin;
         this.scale_xmax = this.zoom_xmax;
      }

      if (this.zoom_ymin != this.zoom_ymax) {
         this.scale_ymin = this.zoom_ymin;
         this.scale_ymax = this.zoom_ymax;
      }

      let xaxis = this.xaxis, yaxis = this.yaxis;
      if (xaxis?._typename != clTAxis) xaxis = create$1(clTAxis);
      if (yaxis?._typename != clTAxis) yaxis = create$1(clTAxis);

      this.x_handle = new TAxisPainter(this.getDom(), xaxis, true);
      this.x_handle.setPadName(this.getPadName());
      this.x_handle.optionUnlab = this.v7EvalAttr('x_labels_hide', false);

      this.x_handle.configureAxis('xaxis', this.xmin, this.xmax, this.scale_xmin, this.scale_xmax, this.swap_xy, this.swap_xy ? [0,h] : [0,w],
                                      { reverse: this.reverse_x,
                                        log: this.swap_xy ? this.logy : this.logx,
                                        symlog: this.swap_xy ? opts.symlog_y : opts.symlog_x,
                                        logcheckmin: this.swap_xy,
                                        logminfactor: 0.0001 });

      this.x_handle.assignFrameMembers(this,'x');

      this.y_handle = new TAxisPainter(this.getDom(), yaxis, true);
      this.y_handle.setPadName(this.getPadName());
      this.y_handle.optionUnlab = this.v7EvalAttr('y_labels_hide', false);

      this.y_handle.configureAxis('yaxis', this.ymin, this.ymax, this.scale_ymin, this.scale_ymax, !this.swap_xy, this.swap_xy ? [0,w] : [0,h],
                                      { reverse: this.reverse_y,
                                        log: this.swap_xy ? this.logx : this.logy,
                                        symlog: this.swap_xy ? opts.symlog_x : opts.symlog_y,
                                        logcheckmin: (opts.ndim < 2) || this.swap_xy,
                                        log_min_nz: opts.ymin_nz && (opts.ymin_nz < 0.01*this.ymax) ? 0.3 * opts.ymin_nz : 0,
                                        logminfactor: 3e-4 });

      this.y_handle.assignFrameMembers(this,'y');
   }

   /** @summary Identify if requested axes are drawn
     * @desc Checks if x/y axes are drawn. Also if second side is already there */
   hasDrawnAxes(second_x, second_y) {
      return !second_x && !second_y ? this.axes_drawn : false;
   }

   /** @summary Draw configured axes on the frame
     * @desc axes can be drawn only for main histogram  */
   async drawAxes() {

      if (this.axes_drawn || (this.xmin == this.xmax) || (this.ymin == this.ymax))
         return this.axes_drawn;

      let ticksx = this.v7EvalAttr('ticksX', 1),
          ticksy = this.v7EvalAttr('ticksY', 1),
          sidex = 1, sidey = 1;

      if (this.v7EvalAttr('swapX', false)) sidex = -1;
      if (this.v7EvalAttr('swapY', false)) sidey = -1;

      let w = this.getFrameWidth(), h = this.getFrameHeight();

      if (!this.v6axes) {
         // this is partially same as v6 createXY method

         this.cleanupAxes();

         this.swap_xy = false;

         if (this.zoom_xmin != this.zoom_xmax) {
            this.scale_xmin = this.zoom_xmin;
            this.scale_xmax = this.zoom_xmax;
         } else {
            this.scale_xmin = this.xmin;
            this.scale_xmax = this.xmax;
         }

         if (this.zoom_ymin != this.zoom_ymax) {
            this.scale_ymin = this.zoom_ymin;
            this.scale_ymax = this.zoom_ymax;
         } else {
            this.scale_ymin = this.ymin;
            this.scale_ymax = this.ymax;
         }

         this.recalculateRange(0);

         this.x_handle = new RAxisPainter(this.getDom(), this, this.xaxis, 'x_');
         this.x_handle.setPadName(this.getPadName());
         this.x_handle.snapid = this.snapid;
         this.x_handle.draw_swapside = (sidex < 0);
         this.x_handle.draw_ticks = ticksx;

         this.y_handle = new RAxisPainter(this.getDom(), this, this.yaxis, 'y_');
         this.y_handle.setPadName(this.getPadName());
         this.y_handle.snapid = this.snapid;
         this.y_handle.draw_swapside = (sidey < 0);
         this.y_handle.draw_ticks = ticksy;

         this.z_handle = new RAxisPainter(this.getDom(), this, this.zaxis, 'z_');
         this.z_handle.setPadName(this.getPadName());
         this.z_handle.snapid = this.snapid;

         this.x_handle.configureAxis('xaxis', this.xmin, this.xmax, this.scale_xmin, this.scale_xmax, false, [0,w], w, { reverse: false });
         this.x_handle.assignFrameMembers(this,'x');

         this.y_handle.configureAxis('yaxis', this.ymin, this.ymax, this.scale_ymin, this.scale_ymax, true, [h,0], -h, { reverse: false });
         this.y_handle.assignFrameMembers(this,'y');

         // only get basic properties like log scale
         this.z_handle.configureZAxis('zaxis', this);
      }

      let layer = this.getFrameSvg().select('.axis_layer');

      this.x_handle.has_obstacle = false;

      let draw_horiz = this.swap_xy ? this.y_handle : this.x_handle,
          draw_vertical = this.swap_xy ? this.x_handle : this.y_handle,
          pp = this.getPadPainter(), pr;

      if (pp?._fast_drawing) {
         pr = Promise.resolve(true); // do nothing
      } else if (this.v6axes) {

         // in v7 ticksx/y values shifted by 1 relative to v6
         // In v7 ticksx == 0 means no ticks, ticksx == 1 equivalent to == 0 in v6

         let can_adjust_frame = false, disable_x_draw = false, disable_y_draw = false;

         draw_horiz.disable_ticks = (ticksx <= 0);
         draw_vertical.disable_ticks = (ticksy <= 0);

         let pr1 = draw_horiz.drawAxis(layer, w, h,
                                   draw_horiz.invert_side ? undefined : `translate(0,${h})`,
                                   (ticksx > 1) ? -h : 0, disable_x_draw,
                                   undefined, false);

         let pr2 =  draw_vertical.drawAxis(layer, w, h,
                                      draw_vertical.invert_side ? `translate(${w})` : undefined,
                                      (ticksy > 1) ? w : 0, disable_y_draw,
                                      draw_vertical.invert_side ? 0 : this._frame_x, can_adjust_frame);

         pr = Promise.all([pr1,pr2]).then(() => this.drawGrids());

      } else {

         let arr = [];

         if (ticksx > 0)
            arr.push(draw_horiz.drawAxis(layer, (sidex > 0) ? `translate(0,${h})` : '', sidex));

         if (ticksy > 0)
            arr.push(draw_vertical.drawAxis(layer, (sidey > 0) ? `translate(0,${h})` : `translate(${w},${h})`, sidey));

         pr = Promise.all(arr).then(() => {
            arr = [];
            if (ticksx > 1)
               arr.push(draw_horiz.drawAxisOtherPlace(layer, (sidex < 0) ? `translate(0,${h})` : '', -sidex, ticksx == 2));

            if (ticksy > 1)
               arr.push(draw_vertical.drawAxisOtherPlace(layer, (sidey < 0) ? `translate(0,${h})` : `translate(${w},${h})`, -sidey, ticksy == 2));
            return Promise.all(arr);
         }).then(() => this.drawGrids());
      }

      return pr.then(() => {
         this.axes_drawn = true;
         return true;
      });
   }

   /** @summary Draw secondary configuread axes */
   drawAxes2(second_x, second_y) {
      let w = this.getFrameWidth(), h = this.getFrameHeight(),
          layer = this.getFrameSvg().select('.axis_layer'),
          pr1, pr2;

      if (second_x) {
         if (this.zoom_x2min != this.zoom_x2max) {
            this.scale_x2min = this.zoom_x2min;
            this.scale_x2max = this.zoom_x2max;
         } else {
           this.scale_x2min = this.x2min;
           this.scale_x2max = this.x2max;
         }
         this.x2_handle = new RAxisPainter(this.getDom(), this, this.x2axis, 'x2_');
         this.x2_handle.setPadName(this.getPadName());
         this.x2_handle.snapid = this.snapid;

         this.x2_handle.configureAxis('x2axis', this.x2min, this.x2max, this.scale_x2min, this.scale_x2max, false, [0,w], w, { reverse: false });
         this.x2_handle.assignFrameMembers(this,'x2');

         pr1 = this.x2_handle.drawAxis(layer, '', -1);
      }

      if (second_y) {
         if (this.zoom_y2min != this.zoom_y2max) {
            this.scale_y2min = this.zoom_y2min;
            this.scale_y2max = this.zoom_y2max;
         } else {
            this.scale_y2min = this.y2min;
            this.scale_y2max = this.y2max;
         }

         this.y2_handle = new RAxisPainter(this.getDom(), this, this.y2axis, 'y2_');
         this.y2_handle.setPadName(this.getPadName());
         this.y2_handle.snapid = this.snapid;

         this.y2_handle.configureAxis('y2axis', this.y2min, this.y2max, this.scale_y2min, this.scale_y2max, true, [h,0], -h, { reverse: false });
         this.y2_handle.assignFrameMembers(this,'y2');

         pr2 = this.y2_handle.drawAxis(layer, `translate(${w},${h})`, -1);
      }

      return Promise.all([pr1,pr2]);
   }

   /** @summary Return functions to create x/y points based on coordinates
     * @desc In default case returns frame painter itself
     * @private */
   getGrFuncs(second_x, second_y) {
      let use_x2 = second_x && this.grx2,
          use_y2 = second_y && this.gry2;
      if (!use_x2 && !use_y2) return this;

      return {
         use_x2: use_x2,
         grx: use_x2 ? this.grx2 : this.grx,
         x_handle: use_x2 ? this.x2_handle : this.x_handle,
         logx: use_x2 ? this.x2_handle.log : this.x_handle.log,
         scale_xmin: use_x2 ? this.scale_x2min : this.scale_xmin,
         scale_xmax: use_x2 ? this.scale_x2max : this.scale_xmax,
         use_y2: use_y2,
         gry: use_y2 ? this.gry2 : this.gry,
         y_handle: use_y2 ? this.y2_handle : this.y_handle,
         logy: use_y2 ? this.y2_handle.log : this.y_handle.log,
         scale_ymin: use_y2 ? this.scale_y2min : this.scale_ymin,
         scale_ymax: use_y2 ? this.scale_y2max : this.scale_ymax,
         swap_xy: this.swap_xy,
         fp: this,
         revertAxis(name, v) {
            if ((name == 'x') && this.use_x2) name = 'x2';
            if ((name == 'y') && this.use_y2) name = 'y2';
            return this.fp.revertAxis(name, v);
         },
         axisAsText(name, v) {
            if ((name == 'x') && this.use_x2) name = 'x2';
            if ((name == 'y') && this.use_y2) name = 'y2';
            return this.fp.axisAsText(name, v);
         }
      };
   }

   /** @summary function called at the end of resize of frame
     * @desc Used to update attributes on the server
     * @private */
   sizeChanged() {

      let changes = {};
      this.v7AttrChange(changes, 'margins_left', this.fX1NDC);
      this.v7AttrChange(changes, 'margins_bottom', this.fY1NDC);
      this.v7AttrChange(changes, 'margins_right', 1 - this.fX2NDC);
      this.v7AttrChange(changes, 'margins_top', 1 - this.fY2NDC);
      this.v7SendAttrChanges(changes, false); // do not invoke canvas update on the server

      this.redrawPad();
   }

   /** @summary Remove all x/y functions
     * @private */
   cleanXY() {
      // remove all axes drawings
      let clean = (name,grname) => {
         if (this[name]) {
            this[name].cleanup();
            delete this[name];
         }
         delete this[grname];
      };

      clean('x_handle', 'grx');
      clean('y_handle', 'gry');
      clean('z_handle', 'grz');
      clean('x2_handle', 'grx2');
      clean('y2_handle', 'gry2');

      delete this.v6axes; // marker that v6 axes are used
   }

   /** @summary Remove all axes drawings
     * @private */
   cleanupAxes() {
      this.cleanXY();

      if (this.draw_g) {
         this.draw_g.select('.grid_layer').selectAll('*').remove();
         this.draw_g.select('.axis_layer').selectAll('*').remove();
      }
      this.axes_drawn = false;
   }

   /** @summary Removes all drawn elements of the frame
     * @private */
   cleanFrameDrawings() {
      // cleanup all 3D drawings if any
      if (isFunc(this.create3DScene))
         this.create3DScene(-1);

      this.cleanupAxes();

      let clean = (name) => {
         this[name+'min'] = this[name+'max'] = 0;
         this[`zoom_${name}min`] = this[`zoom_${name}max`] = 0;
         this[`scale_${name}min`] = this[`scale_${name}max`] = 0;
      };

      clean('x');
      clean('y');
      clean('z');
      clean('x2');
      clean('y2');

      if (this.draw_g) {
         this.draw_g.select('.main_layer').selectAll('*').remove();
         this.draw_g.select('.upper_layer').selectAll('*').remove();
      }
   }

   /** @summary Fully cleanup frame
     * @private */
   cleanup() {

      this.cleanFrameDrawings();

      if (this.draw_g) {
         this.draw_g.selectAll('*').remove();
         this.draw_g.on('mousedown', null)
                    .on('dblclick', null)
                    .on('wheel', null)
                    .on('contextmenu', null)
                    .property('interactive_set', null);
      }

      if (this.keys_handler) {
         window.removeEventListener('keydown', this.keys_handler, false);
         this.keys_handler = null;
      }
      delete this.enabledKeys;
      delete this.self_drawaxes;

      delete this.xaxis;
      delete this.yaxis;
      delete this.zaxis;
      delete this.x2axis;
      delete this.y2axis;

      delete this.draw_g; // frame <g> element managet by the pad

      delete this._click_handler;
      delete this._dblclick_handler;

      let pp = this.getPadPainter();
      if (pp?.frame_painter_ref === this)
         delete pp.frame_painter_ref;

      super.cleanup();
   }

   /** @summary Redraw frame
     * @private */
   redraw() {

      let pp = this.getPadPainter();
      if (pp) pp.frame_painter_ref = this;

      // first update all attributes from objects
      this.updateAttributes();

      let rect = pp?.getPadRect() ?? { width: 10, height: 10 },
          lm = Math.round(rect.width * this.fX1NDC),
          w = Math.round(rect.width * (this.fX2NDC - this.fX1NDC)),
          tm = Math.round(rect.height * (1 - this.fY2NDC)),
          h = Math.round(rect.height * (this.fY2NDC - this.fY1NDC)),
          rotate = false, fixpos = false, trans;

      if (pp?.options) {
         if (pp.options.RotateFrame) rotate = true;
         if (pp.options.FixFrame) fixpos = true;
      }

      if (rotate) {
         trans = `rotate(-90,${lm},${tm}) translate(${lm-h},${tm})`;
         [w, h] = [h, w];
      } else {
         trans = `translate(${lm},${tm})`;
      }

      // update values here to let access even when frame is not really updated
      this._frame_x = lm;
      this._frame_y = tm;
      this._frame_width = w;
      this._frame_height = h;
      this._frame_rotate = rotate;
      this._frame_fixpos = fixpos;

      if (this.mode3d) return this; // no need for real draw in mode3d

      // this is svg:g object - container for every other items belonging to frame
      this.draw_g = this.getFrameSvg();

      let top_rect, main_svg;

      if (this.draw_g.empty()) {

         this.draw_g = this.getLayerSvg('primitives_layer').append('svg:g').attr('class', 'root_frame');

         if (!isBatchMode())
            this.draw_g.append('svg:title').text('');

         top_rect = this.draw_g.append('svg:rect');

         // append for the moment three layers - for drawing and axis
         this.draw_g.append('svg:g').attr('class','grid_layer');

         main_svg = this.draw_g.append('svg:svg')
                           .attr('class','main_layer')
                           .attr('x', 0)
                           .attr('y', 0)
                           .attr('overflow', 'hidden');

         this.draw_g.append('svg:g').attr('class','axis_layer');
         this.draw_g.append('svg:g').attr('class','upper_layer');
      } else {
         top_rect = this.draw_g.select('rect');
         main_svg = this.draw_g.select('.main_layer');
      }

      this.axes_drawn = false;

      this.draw_g.attr('transform', trans);

      top_rect.attr('x', 0)
              .attr('y', 0)
              .attr('width', w)
              .attr('height', h)
              .attr('rx', this.lineatt.rx || null)
              .attr('ry', this.lineatt.ry || null)
              .call(this.fillatt.func)
              .call(this.lineatt.func);

      main_svg.attr('width', w)
              .attr('height', h)
              .attr('viewBox', `0 0 ${w} ${h}`);

      let pr = Promise.resolve(true);

      if (this.v7EvalAttr('drawAxes')) {
         this.self_drawaxes = true;
         this.setAxesRanges();
         pr = this.drawAxes().then(() => this.addInteractivity());
      }

      return pr.then(() => {
         if (!isBatchMode()) {
            top_rect.style('pointer-events', 'visibleFill');  // let process mouse events inside frame

            FrameInteractive.assign(this);
            this.addBasicInteractivity();
         }

         return this;
      });
   }

   /** @summary Returns frame width */
   getFrameWidth() { return this._frame_width || 0; }

   /** @summary Returns frame height */
   getFrameHeight() { return this._frame_height || 0; }

   /** @summary Returns frame rectangle plus extra info for hint display */
   getFrameRect() {
      return {
         x: this._frame_x || 0,
         y: this._frame_y || 0,
         width: this.getFrameWidth(),
         height: this.getFrameHeight(),
         transform: this.draw_g ? this.draw_g.attr('transform') : '',
         hint_delta_x: 0,
         hint_delta_y: 0
      }
   }

   /** @summary Returns palette associated with frame */
   getHistPalette() {
      return this.getPadPainter().getHistPalette();
   }

   /** @summary Configure user-defined click handler
     * @desc Function will be called every time when frame click was perfromed
     * As argument, tooltip object with selected bins will be provided
     * If handler function returns true, default handling of click will be disabled */
   configureUserClickHandler(handler) {
      this._click_handler = isFunc(handler) ? handler : null;
   }

   /** @summary Configure user-defined dblclick handler
     * @desc Function will be called every time when double click was called
     * As argument, tooltip object with selected bins will be provided
     * If handler function returns true, default handling of dblclick (unzoom) will be disabled */
   configureUserDblclickHandler(handler) {
      this._dblclick_handler = isFunc(handler) ? handler : null;
   }

   /** @summary function can be used for zooming into specified range
     * @desc if both limits for each axis 0 (like xmin == xmax == 0), axis will be unzoomed
     * @return {Promise} with boolean flag if zoom operation was performed */
   async zoom(xmin, xmax, ymin, ymax, zmin, zmax) {

      // disable zooming when axis conversion is enabled
      if (this.projection) return false;

      if (xmin === 'x') { xmin = xmax; xmax = ymin; ymin = undefined; } else
      if (xmin === 'y') { ymax = ymin; ymin = xmax; xmin = xmax = undefined; } else
      if (xmin === 'z') { zmin = xmax; zmax = ymin; xmin = xmax = ymin = undefined; }

      let zoom_x = (xmin !== xmax), zoom_y = (ymin !== ymax), zoom_z = (zmin !== zmax),
          unzoom_x = false, unzoom_y = false, unzoom_z = false;

      if (zoom_x) {
         let cnt = 0;
         if (xmin <= this.xmin) { xmin = this.xmin; cnt++; }
         if (xmax >= this.xmax) { xmax = this.xmax; cnt++; }
         if (cnt === 2) { zoom_x = false; unzoom_x = true; }
      } else {
         unzoom_x = (xmin === xmax) && (xmin === 0);
      }

      if (zoom_y) {
         let cnt = 0;
         if (ymin <= this.ymin) { ymin = this.ymin; cnt++; }
         if (ymax >= this.ymax) { ymax = this.ymax; cnt++; }
         if (cnt === 2) { zoom_y = false; unzoom_y = true; }
      } else {
         unzoom_y = (ymin === ymax) && (ymin === 0);
      }

      if (zoom_z) {
         let cnt = 0;
         // if (this.logz && this.ymin_nz && this.getDimension()===2) main_zmin = 0.3*this.ymin_nz;
         if (zmin <= this.zmin) { zmin = this.zmin; cnt++; }
         if (zmax >= this.zmax) { zmax = this.zmax; cnt++; }
         if (cnt === 2) { zoom_z = false; unzoom_z = true; }
      } else {
         unzoom_z = (zmin === zmax) && (zmin === 0);
      }

      let changed = false,
          r_x = '', r_y = '', r_z = '', is_any_check = false,
         req = {
            _typename: 'ROOT::Experimental::RFrame::RUserRanges',
            values: [0, 0, 0, 0, 0, 0],
            flags: [false, false, false, false, false, false]
         };

      const checkZooming = (painter, force) => {
         if (!force && !isFunc(painter.canZoomInside)) return;

         is_any_check = true;

         if (zoom_x && (force || painter.canZoomInside('x', xmin, xmax))) {
            this.zoom_xmin = xmin;
            this.zoom_xmax = xmax;
            changed = true; r_x = '0';
            zoom_x = false;
            req.values[0] = xmin; req.values[1] = xmax;
            req.flags[0] = req.flags[1] = true;
         }
         if (zoom_y && (force || painter.canZoomInside('y', ymin, ymax))) {
            this.zoom_ymin = ymin;
            this.zoom_ymax = ymax;
            changed = true; r_y = '1';
            zoom_y = false;
            req.values[2] = ymin; req.values[3] = ymax;
            req.flags[2] = req.flags[3] = true;
         }
         if (zoom_z && (force || painter.canZoomInside('z', zmin, zmax))) {
            this.zoom_zmin = zmin;
            this.zoom_zmax = zmax;
            changed = true; r_z = '2';
            zoom_z = false;
            req.values[4] = zmin; req.values[5] = zmax;
            req.flags[4] = req.flags[5] = true;
         }
      };

      // first process zooming (if any)
      if (zoom_x || zoom_y || zoom_z)
         this.forEachPainter(painter => checkZooming(painter));

      // force zooming when no any other painter can verify zoom range
      if (!is_any_check && this.self_drawaxes)
         checkZooming(null, true);

      // and process unzoom, if any
      if (unzoom_x || unzoom_y || unzoom_z) {
         if (unzoom_x) {
            if (this.zoom_xmin !== this.zoom_xmax) { changed = true; r_x = '0'; }
            this.zoom_xmin = this.zoom_xmax = 0;
            req.values[0] = req.values[1] = -1;
         }
         if (unzoom_y) {
            if (this.zoom_ymin !== this.zoom_ymax) { changed = true; r_y = '1'; }
            this.zoom_ymin = this.zoom_ymax = 0;
            req.values[2] = req.values[3] = -1;
         }
         if (unzoom_z) {
            if (this.zoom_zmin !== this.zoom_zmax) { changed = true; r_z = '2'; }
            this.zoom_zmin = this.zoom_zmax = 0;
            req.values[4] = req.values[5] = -1;
         }
      }

      if (!changed) return false;

      if (this.v7NormalMode())
         this.v7SubmitRequest('zoom', { _typename: 'ROOT::Experimental::RFrame::RZoomRequest', ranges: req });

      return this.interactiveRedraw('pad', 'zoom' + r_x + r_y + r_z).then(() => true);
   }

   /** @summary Provide zooming of single axis
     * @desc One can specify names like x/y/z but also second axis x2 or y2 */
   async zoomSingle(name, vmin, vmax) {

      let names = ['x','y','z','x2','y2'], indx = names.indexOf(name);

      // disable zooming when axis conversion is enabled
      if (this.projection || !this[name+'_handle'] || (indx < 0))
         return false;

      let zoom_v = (vmin !== vmax), unzoom_v = false;

      if (zoom_v) {
         let cnt = 0;
         if (vmin <= this[name+'min']) { vmin = this[name+'min']; cnt++; }
         if (vmax >= this[name+'max']) { vmax = this[name+'max']; cnt++; }
         if (cnt === 2) { zoom_v = false; unzoom_v = true; }
      } else {
         unzoom_v = (vmin === vmax) && (vmin === 0);
      }

      let changed = false, is_any_check = false,
          req = {
             _typename: 'ROOT::Experimental::RFrame::RUserRanges',
             values: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
             flags: [false, false, false, false, false, false, false, false, false, false]
          };

      let checkZooming = (painter, force) => {
         if (!force && !isFunc(painter?.canZoomInside)) return;

         is_any_check = true;

         if (zoom_v && (force || painter.canZoomInside(name[0], vmin, vmax))) {
            this['zoom_' + name + 'min'] = vmin;
            this['zoom_' + name + 'max'] = vmax;
            changed = true;
            zoom_v = false;
            req.values[indx*2] = vmin; req.values[indx*2+1] = vmax;
            req.flags[indx*2] = req.flags[indx*2+1] = true;
         }
      };

      // first process zooming (if any)
      if (zoom_v)
         this.forEachPainter(painter => checkZooming(painter));

      // force zooming when no any other painter can verify zoom range
      if (!is_any_check && this.self_drawaxes)
         checkZooming(null, true);

      if (unzoom_v) {
         if (this[`zoom_${name}min`] !== this[`zoom_${name}max`]) changed = true;
         this[`zoom_${name}min`] = this[`zoom_${name}max`] = 0;
         req.values[indx*2] = req.values[indx*2+1] = -1;
      }

      if (!changed) return false;

      if (this.v7NormalMode())
         this.v7SubmitRequest('zoom', { _typename: 'ROOT::Experimental::RFrame::RZoomRequest', ranges: req });

      return this.interactiveRedraw('pad', 'zoom' + indx).then(() => true);
   }

   /** @summary Checks if specified axis zoomed */
   isAxisZoomed(axis) {
      return this['zoom_'+axis+'min'] !== this['zoom_'+axis+'max'];
   }

   /** @summary Unzoom specified axes
     * @return {Promise} with boolean flag if zoom is changed */
   async unzoom(dox, doy, doz) {
      if (dox == 'all')
         return this.unzoom('x2').then(() => this.unzoom('y2')).then(() => this.unzoom('xyz'));

      if ((dox == 'x2') || (dox == 'y2'))
         return this.zoomSingle(dox, 0, 0).then(changed => {
            if (changed) this.zoomChangedInteractive(dox, 'unzoom');
            return changed;
         });

      if (typeof dox === 'undefined') { dox = doy = doz = true; } else
      if (isStr(dox)) { doz = dox.indexOf('z') >= 0; doy = dox.indexOf('y') >= 0; dox = dox.indexOf('x') >= 0; }

      return this.zoom(dox ? 0 : undefined, dox ? 0 : undefined,
                       doy ? 0 : undefined, doy ? 0 : undefined,
                       doz ? 0 : undefined, doz ? 0 : undefined).then(changed => {

         if (changed && dox) this.zoomChangedInteractive('x', 'unzoom');
         if (changed && doy) this.zoomChangedInteractive('y', 'unzoom');
         if (changed && doz) this.zoomChangedInteractive('z', 'unzoom');

         return changed;
      });
   }

   /** @summary Mark/check if zoom for specific axis was changed interactively
     * @private */
   zoomChangedInteractive(axis, value) {
      if (axis == 'reset') {
         this.zoom_changed_x = this.zoom_changed_y = this.zoom_changed_z = undefined;
         return;
      }
      if (!axis || axis == 'any')
         return this.zoom_changed_x || this.zoom_changed_y  || this.zoom_changed_z;

      if ((axis !== 'x') && (axis !== 'y') && (axis !== 'z')) return;

      let fld = 'zoom_changed_' + axis;
      if (value === undefined) return this[fld];

      if (value === 'unzoom') {
         // special handling of unzoom, only if was never changed before flag set to true
         this[fld] = (this[fld] === undefined);
         return;
      }

      if (value) this[fld] = true;
   }

   /** @summary Fill menu for frame when server is not there */
   fillObjectOfflineMenu(menu, kind) {
      if ((kind != 'x') && (kind != 'y')) return;

      menu.add('Unzoom', () => this.unzoom(kind));

      //if (this[kind+'_kind'] == 'normal')
      //   menu.addchk(this['log'+kind], 'SetLog'+kind, this.toggleAxisLog.bind(this, kind));

      // here should be all axes attributes in offline
   }

   /** @summary Set grid drawing for specified axis */
   changeFrameAttr(attr, value) {
      let changes = {};
      this.v7AttrChange(changes, attr, value);
      this.v7SetAttr(attr, value);
      this.v7SendAttrChanges(changes, false); // do not invoke canvas update on the server
      this.redrawPad();
   }

   /** @summary Fill context menu */
   fillContextMenu(menu, kind, /* obj */) {

      // when fill and show context menu, remove all zooming

      if ((kind == 'x') || (kind == 'y') || (kind == 'x2') || (kind == 'y2')) {
         let handle = this[kind+'_handle'];
         if (!handle) return false;
         menu.add('header: ' + kind.toUpperCase() + ' axis');
         return handle.fillAxisContextMenu(menu, kind);
      }

      let alone = menu.size() == 0;

      if (alone)
         menu.add('header:Frame');
      else
         menu.add('separator');

      if (this.zoom_xmin !== this.zoom_xmax)
         menu.add('Unzoom X', () => this.unzoom('x'));
      if (this.zoom_ymin !== this.zoom_ymax)
         menu.add('Unzoom Y', () => this.unzoom('y'));
      if (this.zoom_zmin !== this.zoom_zmax)
         menu.add('Unzoom Z', () => this.unzoom('z'));
      if (this.zoom_x2min !== this.zoom_x2max)
         menu.add('Unzoom X2', () => this.unzoom('x2'));
      if (this.zoom_y2min !== this.zoom_y2max)
         menu.add('Unzoom Y2', () => this.unzoom('y2'));
      menu.add('Unzoom all', () => this.unzoom('all'));

      menu.add('separator');

      menu.addchk(this.isTooltipAllowed(), 'Show tooltips', () => this.setTooltipAllowed('toggle'));

      if (this.x_handle)
         menu.addchk(this.x_handle.draw_grid, 'Grid x', flag => this.changeFrameAttr('gridX', flag));
      if (this.y_handle)
         menu.addchk(this.y_handle.draw_grid, 'Grid y', flag => this.changeFrameAttr('gridY', flag));
      if (this.x_handle && !this.x2_handle)
         menu.addchk(this.x_handle.draw_swapside, 'Swap x', flag => this.changeFrameAttr('swapX', flag));
      if (this.y_handle && !this.y2_handle)
         menu.addchk(this.y_handle.draw_swapside, 'Swap y', flag => this.changeFrameAttr('swapY', flag));
      if (this.x_handle && !this.x2_handle) {
         menu.add('sub:Ticks x');
         menu.addchk(this.x_handle.draw_ticks == 0, 'off', () => this.changeFrameAttr('ticksX', 0));
         menu.addchk(this.x_handle.draw_ticks == 1, 'normal', () => this.changeFrameAttr('ticksX', 1));
         menu.addchk(this.x_handle.draw_ticks == 2, 'ticks on both sides', () => this.changeFrameAttr('ticksX', 2));
         menu.addchk(this.x_handle.draw_ticks == 3, 'labels on both sides', () => this.changeFrameAttr('ticksX', 3));
         menu.add('endsub:');
       }
      if (this.y_handle && !this.y2_handle) {
         menu.add('sub:Ticks y');
         menu.addchk(this.y_handle.draw_ticks == 0, 'off', () => this.changeFrameAttr('ticksY', 0));
         menu.addchk(this.y_handle.draw_ticks == 1, 'normal', () => this.changeFrameAttr('ticksY', 1));
         menu.addchk(this.y_handle.draw_ticks == 2, 'ticks on both sides', () => this.changeFrameAttr('ticksY', 2));
         menu.addchk(this.y_handle.draw_ticks == 3, 'labels on both sides', () => this.changeFrameAttr('ticksY', 3));
         menu.add('endsub:');
       }

      menu.addAttributesMenu(this, alone ? '' : 'Frame ');
      menu.add('separator');
      menu.add('Save as frame.png', () => this.getPadPainter().saveAs('png', 'frame', 'frame.png'));
      menu.add('Save as frame.svg', () => this.getPadPainter().saveAs('svg', 'frame', 'frame.svg'));

      return true;
   }

   /** @summary Convert graphical coordinate into axis value */
   revertAxis(axis, pnt) {
      let handle = this[axis+'_handle'];
      return handle ? handle.revertPoint(pnt) : 0;
   }

   /** @summary Show axis status message
     * @desc method called normally when mouse enter main object element
     * @private */
   showAxisStatus(axis_name, evnt) {

      let hint_name = axis_name, hint_title = 'axis',
          m = pointer(evnt, this.getFrameSvg().node()), id = (axis_name == 'x') ? 0 : 1;

      if (this.swap_xy) id = 1-id;

      let axis_value = this.revertAxis(axis_name, m[id]);

      this.showObjectStatus(hint_name, hint_title, axis_name + ' : ' + this.axisAsText(axis_name, axis_value), Math.round(m[0]) + ',' + Math.round(m[1]));
   }

   /** @summary Add interactive keys handlers
    * @private */
   addKeysHandler() {
      if (isBatchMode()) return;
      FrameInteractive.assign(this);
      this.addFrameKeysHandler();
   }

   /** @summary Add interactive functionality to the frame
    * @private */
   addInteractivity(for_second_axes) {

      if (isBatchMode() || (!settings.Zooming && !settings.ContextMenu))
         return true;
      FrameInteractive.assign(this);
      return this.addFrameInteractivity(for_second_axes);
   }

   /** @summary Set selected range back to pad object - to be implemented
     * @private */
   setRootPadRange(/* pad, is3d */) {
      // TODO: change of pad range and send back to root application
   }

   /** @summary Toggle log scale on the specified axes */
   toggleAxisLog(axis) {
      let handle = this[axis+'_handle'];
      if (handle) handle.changeAxisLog('toggle');
   }

} // class RFramePainter

/**
 * @summary Painter class for RPad
 *
 * @private
 */

class RPadPainter extends RObjectPainter {

   /** @summary constructor */
   constructor(dom, pad, iscan) {
      super(dom, pad, '', 'pad');
      this.pad = pad;
      this.iscan = iscan; // indicate if working with canvas
      this.this_pad_name = '';
      if (!this.iscan && (pad !== null)) {
         if (pad.fObjectID)
            this.this_pad_name = 'pad' + pad.fObjectID; // use objectid as padname
         else
            this.this_pad_name = 'ppp' + internals.id_counter++; // artificical name
      }
      this.painters = []; // complete list of all painters in the pad
      this.has_canvas = true;
      this.forEachPainter = this.forEachPainterInPad;
   }

   /** @summary Indicates that is not Root6 pad painter
    * @private */
   isRoot6() { return false; }

  /** @summary Returns SVG element for the pad itself
    * @private */
   svg_this_pad() {
      return this.getPadSvg(this.this_pad_name);
   }

   /** @summary Returns main painter on the pad
     * @desc Typically main painter is TH1/TH2 object which is drawing axes
    * @private */
   getMainPainter() {
      return this.main_painter_ref || null;
   }

   /** @summary Assign main painter on the pad
    * @private */
   setMainPainter(painter, force) {
      if (!this.main_painter_ref || force)
         this.main_painter_ref = painter;
   }

   /** @summary cleanup pad and all primitives inside */
   cleanup() {
      if (this._doing_draw)
         console.error('pad drawing is not completed when cleanup is called');

      this.painters.forEach(p => p.cleanup());

      let svg_p = this.svg_this_pad();
      if (!svg_p.empty()) {
         svg_p.property('pad_painter', null);
         if (!this.iscan) svg_p.remove();
      }

      delete this.main_painter_ref;
      delete this.frame_painter_ref;
      delete this.pads_cache;
      delete this._pad_x;
      delete this._pad_y;
      delete this._pad_width;
      delete this._pad_height;
      delete this._doing_draw;
      delete this._dfltRFont;

      this.painters = [];
      this.pad = null;
      this.draw_object = null;
      this.pad_frame = null;
      this.this_pad_name = undefined;
      this.has_canvas = false;

      selectActivePad({ pp: this, active: false });

      super.cleanup();
   }

   /** @summary Returns frame painter inside the pad
    * @private */
   getFramePainter() { return this.frame_painter_ref; }

   /** @summary get pad width */
   getPadWidth() { return this._pad_width || 0; }

   /** @summary get pad height */
   getPadHeight() { return this._pad_height || 0; }

   /** @summary get pad rect */
   getPadRect() {
      return {
         x: this._pad_x || 0,
         y: this._pad_y || 0,
         width: this.getPadWidth(),
         height: this.getPadHeight()
      }
   }

   /** @summary Returns frame coordiantes - also when frame is not drawn */
   getFrameRect() {
      let fp = this.getFramePainter();
      if (fp) return fp.getFrameRect();

      let w = this.getPadWidth(),
          h = this.getPadHeight(),
          rect = {};

      rect.szx = Math.round(0.5*w);
      rect.szy = Math.round(0.5*h);
      rect.width = 2*rect.szx;
      rect.height = 2*rect.szy;
      rect.x = Math.round(w/2 - rect.szx);
      rect.y = Math.round(h/2 - rect.szy);
      rect.hint_delta_x = rect.szx;
      rect.hint_delta_y = rect.szy;
      rect.transform = `translate(${rect.x},${rect.y})`;
      return rect;
   }

   /** @summary return RPad object */
   getRootPad(is_root6) {
      return (is_root6 === undefined) || !is_root6 ? this.pad : null;
   }

   /** @summary Cleanup primitives from pad - selector lets define which painters to remove
    * @private */
   cleanPrimitives(selector) {
      if (!isFunc(selector)) return;

      for (let k = this.painters.length-1; k >= 0; --k)
         if (selector(this.painters[k])) {
            this.painters[k].cleanup();
            this.painters.splice(k, 1);
         }
   }

   /** @summary Try to find painter for specified object
     * @desc can be used to find painter for some special objects, registered as
     * histogram functions
     * @private */
   findPainterFor(selobj, selname, seltype) {
      return this.painters.find(p => {
         let pobj = p.getObject();
         if (!pobj) return;

         if (selobj && (pobj === selobj)) return true;
         if (!selname && !seltype) return;
         if (selname && (pobj.fName !== selname)) return;
         if (seltype && (pobj._typename !== seltype)) return;
         return true;
      });
   }

   /** @summary Returns palette associated with pad.
     * @desc Either from existing palette painter or just default palette */
   getHistPalette() {
      let pp = this.findPainterFor(undefined, undefined, 'ROOT::Experimental::RPaletteDrawable');

      if (pp) return pp.getHistPalette();

      if (!this.fDfltPalette) {
         this.fDfltPalette = {
            _typename: 'ROOT::Experimental::RPalette',
            fColors: [{ fOrdinal: 0,     fColor: { fColor: 'rgb(53, 42, 135)' } },
                      { fOrdinal: 0.125, fColor: { fColor: 'rgb(15, 92, 221)' } },
                      { fOrdinal: 0.25,  fColor: { fColor: 'rgb(20, 129, 214)' } },
                      { fOrdinal: 0.375, fColor: { fColor: 'rgb(6, 164, 202)' } },
                      { fOrdinal: 0.5,   fColor: { fColor: 'rgb(46, 183, 164)' } },
                      { fOrdinal: 0.625, fColor: { fColor: 'rgb(135, 191, 119)' } },
                      { fOrdinal: 0.75,  fColor: { fColor: 'rgb(209, 187, 89)' } },
                      { fOrdinal: 0.875, fColor: { fColor: 'rgb(254, 200, 50)' } },
                      { fOrdinal: 1,     fColor: { fColor: 'rgb(249, 251, 14)' } }],
             fInterpolate: true,
             fNormalized: true
         };
         addMethods(this.fDfltPalette, 'ROOT::Experimental::RPalette');
      }

      return this.fDfltPalette;
   }

   /** @summary Returns number of painters
     * @private */
   getNumPainters() { return this.painters.length; }

   /** @summary Call function for each painter in pad
     * @param {function} userfunc - function to call
     * @param {string} kind - 'all' for all objects (default), 'pads' only pads and subpads, 'objects' only for object in current pad
     * @private */
   forEachPainterInPad(userfunc, kind) {
      if (!kind) kind = 'all';
      if (kind != 'objects') userfunc(this);
      for (let k = 0; k < this.painters.length; ++k) {
         let sub = this.painters[k];
         if (isFunc(sub.forEachPainterInPad)) {
            if (kind!='objects') sub.forEachPainterInPad(userfunc, kind);
         } else if (kind != 'pads') userfunc(sub);
      }
   }

   /** @summary register for pad events receiver
     * @desc in pad painter, while pad may be drawn without canvas
     * @private */
   registerForPadEvents(receiver) {
      this.pad_events_receiver = receiver;
   }

   /** @summary Generate pad events, normally handled by GED
     * @desc in pad painter, while pad may be drawn without canvas
     * @private */
   producePadEvent(what, padpainter, painter, position, place) {
      if ((what == 'select') && isFunc(this.selectActivePad))
         this.selectActivePad(padpainter, painter, position);

      if (this.pad_events_receiver)
         this.pad_events_receiver({ what, padpainter, painter, position, place });
   }

   /** @summary method redirect call to pad events receiver */
   selectObjectPainter(painter, pos, place) {

      let istoppad = (this.iscan || !this.has_canvas),
          canp = istoppad ? this : this.getCanvPainter();

      if (painter === undefined) painter = this;

      if (pos && !istoppad)
         pos = getAbsPosInCanvas(this.svg_this_pad(), pos);

      selectActivePad({ pp: this, active: true });

      canp.producePadEvent('select', this, painter, pos, place);
   }

   /** @summary Create SVG element for the canvas */
   createCanvasSvg(check_resize, new_size) {

      let factor = null, svg = null, lmt = 5, rect = null, btns, frect;

      if (check_resize > 0) {

         if (this._fixed_size) return (check_resize > 1); // flag used to force re-drawing of all subpads

         svg = this.getCanvSvg();

         if (svg.empty()) return false;

         factor = svg.property('height_factor');

         rect = this.testMainResize(check_resize, null, factor);

         if (!rect.changed) return false;

         if (!isBatchMode())
            btns = this.getLayerSvg('btns_layer', this.this_pad_name);

         frect = svg.select('.canvas_fillrect');

      } else {

         let render_to = this.selectDom();

         if (render_to.style('position') == 'static')
            render_to.style('position', 'relative');

         svg = render_to.append('svg')
             .attr('class', 'jsroot root_canvas')
             .property('pad_painter', this) // this is custom property
             .property('current_pad', '') // this is custom property
             .property('redraw_by_resize', false); // could be enabled to force redraw by each resize

         this.setTopPainter(); //assign canvas as top painter of that element

         if (!isBatchMode() && !this.online_canvas)
            svg.append('svg:title').text('ROOT canvas');

         frect = svg.append('svg:path').attr('class','canvas_fillrect');
         if (!isBatchMode())
            frect.style('pointer-events', 'visibleFill')
                 .on('dblclick', evnt => this.enlargePad(evnt))
                 .on('click', () => this.selectObjectPainter(this, null))
                 .on('mouseenter', () => this.showObjectStatus())
                 .on('contextmenu', settings.ContextMenu ? evnt => this.padContextMenu(evnt) : null);

         svg.append('svg:g').attr('class', 'primitives_layer');
         svg.append('svg:g').attr('class', 'info_layer');
         if (!isBatchMode())
            btns = svg.append('svg:g')
                      .attr('class','btns_layer')
                      .property('leftside', settings.ToolBarSide == 'left')
                      .property('vertical', settings.ToolBarVert);

         factor = 0.66;
         if (this.pad && this.pad.fWinSize[0] && this.pad.fWinSize[1]) {
            factor = this.pad.fWinSize[1] / this.pad.fWinSize[0];
            if ((factor < 0.1) || (factor > 10)) factor = 0.66;
         }

         if (this._fixed_size) {
            render_to.style('overflow','auto');
            rect = { width: this.pad.fWinSize[0], height: this.pad.fWinSize[1] };
            if (!rect.width || !rect.height)
               rect = getElementRect(render_to);
         } else {
            rect = this.testMainResize(2, new_size, factor);
         }
      }

      this.createAttFill({ pattern: 1001, color: 0 });

      if ((rect.width <= lmt) || (rect.height <= lmt)) {
         svg.style('display', 'none');
         console.warn(`Hide canvas while geometry too small w=${rect.width} h=${rect.height}`);
         rect.width = 200; rect.height = 100; // just to complete drawing
      } else {
         svg.style('display', null);
      }

      if (this._fixed_size) {
         svg.attr('x', 0)
            .attr('y', 0)
            .attr('width', rect.width)
            .attr('height', rect.height)
            .style('position', 'absolute');
      } else {
        svg.attr('x', 0)
           .attr('y', 0)
           .style('width', '100%')
           .style('height', '100%')
           .style('position', 'absolute')
           .style('left', 0)
           .style('top', 0)
           .style('right', 0)
           .style('bottom', 0);
      }

      svg.style('filter', settings.DarkMode ? 'invert(100%)' : null);

      svg.attr('viewBox', `0 0 ${rect.width} ${rect.height}`)
         .attr('preserveAspectRatio', 'none')  // we do not preserve relative ratio
         .property('height_factor', factor)
         .property('draw_x', 0)
         .property('draw_y', 0)
         .property('draw_width', rect.width)
         .property('draw_height', rect.height);

      this._pad_x = 0;
      this._pad_y = 0;
      this._pad_width = rect.width;
      this._pad_height = rect.height;

      frect.attr('d', `M0,0H${rect.width}V${rect.height}H0Z`)
           .call(this.fillatt.func);

      this._fast_drawing = settings.SmallPad && ((rect.width < settings.SmallPad.width) || (rect.height < settings.SmallPad.height));

      if (this.alignButtons && btns)
         this.alignButtons(btns, rect.width, rect.height);

      return true;
   }

   /** @summary Draw item name on canvas, dummy for RPad
     * @private */
   drawItemNameOnCanvas() {
   }

   /** @summary Enlarge pad draw element when possible */
   enlargePad(evnt) {

      if (evnt) {
         evnt.preventDefault();
         evnt.stopPropagation();
      }

      let svg_can = this.getCanvSvg(),
          pad_enlarged = svg_can.property('pad_enlarged');

      if (this.iscan || !this.has_canvas || (!pad_enlarged && !this.hasObjectsToDraw() && !this.painters)) {
         if (this._fixed_size) return; // canvas cannot be enlarged in such mode
         if (!this.enlargeMain('toggle')) return;
         if (this.enlargeMain('state') == 'off') svg_can.property('pad_enlarged', null);
      } else if (!pad_enlarged) {
         this.enlargeMain(true, true);
         svg_can.property('pad_enlarged', this.pad);
      } else if (pad_enlarged === this.pad) {
         this.enlargeMain(false);
         svg_can.property('pad_enlarged', null);
      } else {
         console.error('missmatch with pad double click events');
      }

      let was_fast = this._fast_drawing;

      this.checkResize(true);

      if (this._fast_drawing != was_fast)
         this.showPadButtons();
   }

   /** @summary Create SVG element for the pad
     * @return true when pad is displayed and all its items should be redrawn */
   createPadSvg(only_resize) {

      if (!this.has_canvas) {
         this.createCanvasSvg(only_resize ? 2 : 0);
         return true;
      }

      let svg_parent = this.getPadSvg(this.pad_name), // this.pad_name MUST be here to select parent pad
          svg_can = this.getCanvSvg(),
          width = svg_parent.property('draw_width'),
          height = svg_parent.property('draw_height'),
          pad_enlarged = svg_can.property('pad_enlarged'),
          pad_visible = true,
          w = width, h = height, x = 0, y = 0,
          svg_pad = null, svg_rect = null, btns = null;

      if (this.pad && this.pad.fPos && this.pad.fSize) {
         x = Math.round(width * this.pad.fPos.fHoriz.fArr[0]);
         y = Math.round(height * this.pad.fPos.fVert.fArr[0]);
         w = Math.round(width * this.pad.fSize.fHoriz.fArr[0]);
         h = Math.round(height * this.pad.fSize.fVert.fArr[0]);
      }

      if (pad_enlarged) {
         pad_visible = false;
         if (pad_enlarged === this.pad)
            pad_visible = true;
         else
            this.forEachPainterInPad(pp => { if (pp.getObject() == pad_enlarged) pad_visible = true; }, 'pads');

         if (pad_visible) { w = width; h = height; x = y = 0; }
      }

      if (only_resize) {
         svg_pad = this.svg_this_pad();
         svg_rect = svg_pad.select('.root_pad_border');
         if (!isBatchMode())
            btns = this.getLayerSvg('btns_layer', this.this_pad_name);
      } else {
         svg_pad = svg_parent.select('.primitives_layer')
             .append('svg:svg') // here was g before, svg used to blend all drawin outside
             .classed('__root_pad_' + this.this_pad_name, true)
             .attr('pad', this.this_pad_name) // set extra attribute  to mark pad name
             .property('pad_painter', this); // this is custom property

         if (!isBatchMode())
            svg_pad.append('svg:title').text('ROOT subpad');

         svg_rect = svg_pad.append('svg:path').attr('class', 'root_pad_border');

         svg_pad.append('svg:g').attr('class','primitives_layer');
         if (!isBatchMode())
            btns = svg_pad.append('svg:g')
                          .attr('class','btns_layer')
                          .property('leftside', settings.ToolBarSide != 'left')
                          .property('vertical', settings.ToolBarVert);

         if (settings.ContextMenu)
            svg_rect.on('contextmenu', evnt => this.padContextMenu(evnt));

         if (!isBatchMode())
            svg_rect.style('pointer-events', 'visibleFill') // get events also for not visible rect
                    .on('dblclick', evnt => this.enlargePad(evnt))
                    .on('click', () => this.selectObjectPainter(this, null))
                    .on('mouseenter', () => this.showObjectStatus());
      }

      this.createAttFill({ attr: this.pad });

      this.createAttLine({ attr: this.pad, color0: this.pad.fBorderMode == 0 ? 'none' : '' });

      svg_pad.style('display', pad_visible ? null : 'none')
             .attr('viewBox', `0 0 ${w} ${h}`) // due to svg
             .attr('preserveAspectRatio', 'none')   // due to svg, we do not preserve relative ratio
             .attr('x', x)    // due to svg
             .attr('y', y)   // due to svg
             .attr('width', w)    // due to svg
             .attr('height', h)   // due to svg
             .property('draw_x', x) // this is to make similar with canvas
             .property('draw_y', y)
             .property('draw_width', w)
             .property('draw_height', h);

      this._pad_x = x;
      this._pad_y = y;
      this._pad_width = w;
      this._pad_height = h;

      svg_rect.attr('d', `M0,0H${w}V${h}H0Z`)
              .call(this.fillatt.func)
              .call(this.lineatt.func);

      this._fast_drawing = settings.SmallPad && ((w < settings.SmallPad.width) || (h < settings.SmallPad.height));

       // special case of 3D canvas overlay
      if (svg_pad.property('can3d') === constants$1.Embed3D.Overlay)
          this.selectDom().select('.draw3d_' + this.this_pad_name)
              .style('display', pad_visible ? '' : 'none');

      if (this.alignButtons && btns) this.alignButtons(btns, w, h);

      return pad_visible;
   }

   /** @summary returns true if any objects beside sub-pads exists in the pad */
   hasObjectsToDraw() {
      let arr = this.pad ? this.pad.fPrimitives : null;
      return arr && arr.find(obj => obj._typename != 'ROOT::Experimental::RPadDisplayItem') ? true : false;
   }

   /** @summary sync drawing/redrawing/resize of the pad
     * @param {string} kind - kind of draw operation, if true - always queued
     * @return {Promise} when pad is ready for draw operation or false if operation already queued
     * @private */
   syncDraw(kind) {
      let entry = { kind : kind || 'redraw' };
      if (this._doing_draw === undefined) {
         this._doing_draw = [ entry ];
         return Promise.resolve(true);
      }
      // if queued operation registered, ignore next calls, indx == 0 is running operation
      if ((entry.kind !== true) && (this._doing_draw.findIndex((e,i) => (i > 0) && (e.kind == entry.kind)) > 0))
         return false;
      this._doing_draw.push(entry);
      return new Promise(resolveFunc => {
         entry.func = resolveFunc;
      });
   }

   /** @summary confirms that drawing is completed, may trigger next drawing immediately
     * @private */
   confirmDraw() {
      if (this._doing_draw === undefined)
         return console.warn('failure, should not happen');
      this._doing_draw.shift();
      if (this._doing_draw.length == 0) {
         delete this._doing_draw;
      } else {
         let entry = this._doing_draw[0];
         if(entry.func) { entry.func(); delete entry.func; }
      }
   }

   /** @summary Draw single primitive */
   async drawObject(/*dom, obj, opt*/) {
      console.log('Not possible to draw object without loading of draw.mjs');
      return null;
   }

   /** @summary Draw pad primitives
     * @private */
   async drawPrimitives(indx) {

      if (indx === undefined) {
         if (this.iscan)
            this._start_tm = new Date().getTime();

         // set number of primitves
         this._num_primitives = this.pad && this.pad.fPrimitives ? this.pad.fPrimitives.length : 0;

         return this.syncDraw(true).then(() => this.drawPrimitives(0));
      }

      if (!this.pad || (indx >= this._num_primitives)) {

         this.confirmDraw();

         if (this._start_tm) {
            let spenttm = new Date().getTime() - this._start_tm;
            if (spenttm > 3000) console.log(`Canvas drawing took ${(spenttm*1e-3).toFixed(2)}s`);
            delete this._start_tm;
         }

         return;
      }

      // handle used to invoke callback only when necessary
      return this.drawObject(this.getDom(), this.pad.fPrimitives[indx], '').then(ppainter => {
         // mark painter as belonging to primitives
         if (isObject(ppainter))
            ppainter._primitive = true;

         return this.drawPrimitives(indx+1);
      });
   }

   /** @summary Process tooltip event in the pad
     * @private */
   processPadTooltipEvent(pnt) {
      let painters = [], hints = [];

      // first count - how many processors are there
      if (this.painters !== null)
         this.painters.forEach(obj => {
            if (isFunc(obj.processTooltipEvent)) painters.push(obj);
         });

      if (pnt) pnt.nproc = painters.length;

      painters.forEach(obj => {
         let hint = obj.processTooltipEvent(pnt);
         if (!hint) hint = { user_info: null };
         hints.push(hint);
         if (pnt && pnt.painters) hint.painter = obj;
      });

      return hints;
   }

   /** @summary Changes canvas dark mode
     * @private */
   changeDarkMode(mode) {
      this.getCanvSvg().style('filter', (mode ?? settings.DarkMode)  ? 'invert(100%)' : null);
   }

   /** @summary Fill pad context menu
     * @private */
   fillContextMenu(menu) {

      if (this.iscan)
         menu.add('header: RCanvas');
      else
         menu.add('header: RPad');

      menu.addchk(this.isTooltipAllowed(), 'Show tooltips', () => this.setTooltipAllowed('toggle'));

      if (!this._websocket) {
         menu.addAttributesMenu(this);
         if (this.iscan)
            menu.addSettingsMenu(false, false, arg => {
               if (arg == 'dark') this.changeDarkMode();
            });
      }

      menu.add('separator');

      if (isFunc(this.hasMenuBar) && isFunc(this.actiavteMenuBar))
         menu.addchk(this.hasMenuBar(), 'Menu bar', flag => this.actiavteMenuBar(flag));

      if (isFunc(this.hasEventStatus) && isFunc(this.activateStatusBar))
         menu.addchk(this.hasEventStatus(), 'Event status', () => this.activateStatusBar('toggle'));

      if (this.enlargeMain() || (this.has_canvas && this.hasObjectsToDraw()))
         menu.addchk((this.enlargeMain('state') == 'on'), 'Enlarge ' + (this.iscan ? 'canvas' : 'pad'), () => this.enlargePad());

      let fname = this.this_pad_name || (this.iscan ? 'canvas' : 'pad');
      menu.add(`Save as ${fname}.png`, fname+'.png', arg => this.saveAs('png', false, arg));
      menu.add(`Save as ${fname}.svg`, fname+'.svg', arg => this.saveAs('svg', false, arg));

      return true;
   }

   /** @summary Show pad context menu
     * @private */
   padContextMenu(evnt) {
      if (evnt.stopPropagation) {
         let pos = pointer(evnt, this.svg_this_pad().node());
         // this is normal event processing and not emulated jsroot event
         // for debug purposes keep original context menu for small region in top-left corner
         if ((pos.length==2) && (pos[0] >= 0) && (pos[0] < 10) && (pos[1] >= 0) && (pos[1] < 10)) return;

         evnt.stopPropagation(); // disable main context menu
         evnt.preventDefault();  // disable browser context menu

         this.getFramePainter()?.setLastEventPos();
      }

      createMenu$1(evnt, this).then(menu => {
         this.fillContextMenu(menu);
         return this.fillObjectExecMenu(menu);
      }).then(menu => menu.show());
   }

   /** @summary Redraw pad means redraw ourself
     * @return {Promise} when redrawing ready */
   async redrawPad(reason) {

      let sync_promise = this.syncDraw(reason);
      if (sync_promise === false) {
         console.log('Prevent RPad redrawing');
         return false;
      }

      let showsubitems = true;
      let redrawNext = indx => {
         while (indx < this.painters.length) {
            let sub = this.painters[indx++], res = 0;
            if (showsubitems || sub.this_pad_name)
               res = sub.redraw(reason);

            if (isPromise(res))
               return res.then(() => redrawNext(indx));
         }
         return true;
      };

      return sync_promise.then(() => {
         if (this.iscan) {
            this.createCanvasSvg(2);
         } else {
            showsubitems = this.createPadSvg(true);
         }
         return redrawNext(0);
      }).then(() => {
         if (getActivePad() === this)
            this.getCanvPainter()?.producePadEvent('padredraw', this);
         this.confirmDraw();
         return true;
      });
   }

   /** @summary redraw pad */
   redraw(reason) {
      return this.redrawPad(reason);
   }


   /** @summary Checks if pad should be redrawn by resize
     * @private */
   needRedrawByResize() {
      let elem = this.svg_this_pad();
      if (!elem.empty() && elem.property('can3d') === constants$1.Embed3D.Overlay) return true;

      for (let i = 0; i < this.painters.length; ++i)
         if (isFunc(this.painters[i].needRedrawByResize))
            if (this.painters[i].needRedrawByResize()) return true;

      return false;
   }

   /** @summary Check resize of canvas */
   checkCanvasResize(size, force) {

      if (!this.iscan && this.has_canvas) return false;

      let sync_promise = this.syncDraw('canvas_resize');
      if (sync_promise === false) return false;

      if ((size === true) || (size === false)) { force = size; size = null; }

      if (isObject(size) && size.force) force = true;

      if (!force) force = this.needRedrawByResize();

      let changed = false,
          redrawNext = indx => {
             if (!changed || (indx >= this.painters.length)) {
                this.confirmDraw();
                return changed;
             }

             return getPromise(this.painters[indx].redraw(force ? 'redraw' : 'resize')).then(() => redrawNext(indx+1));
          };

      return sync_promise.then(() => {

         changed = this.createCanvasSvg(force ? 2 : 1, size);

         // if canvas changed, redraw all its subitems.
         // If redrawing was forced for canvas, same applied for sub-elements
         return redrawNext(0);
      });
   }

   /** @summary update RPad object
     * @private */
   updateObject(obj) {
      if (!obj) return false;

      this.pad.fStyle = obj.fStyle;
      this.pad.fAttr = obj.fAttr;

      if (this.iscan) {
         this.pad.fTitle = obj.fTitle;
         this.pad.fWinSize = obj.fWinSize;
      } else {
         this.pad.fPos = obj.fPos;
         this.pad.fSize = obj.fSize;
      }

      return true;
   }


   /** @summary Add object painter to list of primitives
     * @private */
   addObjectPainter(objpainter, lst, indx) {
      if (objpainter && lst && lst[indx] && (objpainter.snapid === undefined)) {
         // keep snap id in painter, will be used for the
         if (this.painters.indexOf(objpainter) < 0)
            this.painters.push(objpainter);
         objpainter.assignSnapId(lst[indx].fObjectID);
         if (!objpainter.rstyle) objpainter.rstyle = lst[indx].fStyle || this.rstyle;
      }
   }

   /** @summary Extract properties from TObjectDisplayItem */
   extractTObjectProp(snap) {
      if (snap.fColIndex && snap.fColValue) {
         let colors = this.root_colors || getRootColors();
         for (let k = 0; k < snap.fColIndex.length; ++k)
            colors[snap.fColIndex[k]] = snap.fColValue[k];
       }

      // painter used only for evaluation of attributes
      let pattr = new RObjectPainter(), obj = snap.fObject;
      pattr.assignObject(snap);
      pattr.csstype = snap.fCssType;
      pattr.rstyle = snap.fStyle;

      snap.fOption = pattr.v7EvalAttr('options', '');

      const extract_color = (member_name, attr_name) => {
         let col = pattr.v7EvalColor(attr_name, '');
         if (col) obj[member_name] = addColor(col, this.root_colors);
      };

      // handle TAttLine
      if ((obj.fLineColor !== undefined) && (obj.fLineWidth !== undefined) && (obj.fLineStyle !== undefined)) {
         extract_color('fLineColor', 'line_color');
         obj.fLineWidth = pattr.v7EvalAttr('line_width', obj.fLineWidth);
         obj.fLineStyle = pattr.v7EvalAttr('line_style', obj.fLineStyle);
      }

      // handle TAttFill
      if ((obj.fFillColor !== undefined) && (obj.fFillStyle !== undefined)) {
         extract_color('fFillColor', 'fill_color');
         obj.fFillStyle = pattr.v7EvalAttr('fill_style', obj.fFillStyle);
      }

      // handle TAttMarker
      if ((obj.fMarkerColor !== undefined) && (obj.fMarkerStyle !== undefined) && (obj.fMarkerSize !== undefined)) {
         extract_color('fMarkerColor', 'marker_color');
         obj.fMarkerStyle = pattr.v7EvalAttr('marker_style', obj.fMarkerStyle);
         obj.fMarkerSize = pattr.v7EvalAttr('marker_size', obj.fMarkerSize);
      }

      // handle TAttText
      if ((obj.fTextColor !== undefined) && (obj.fTextAlign !== undefined) && (obj.fTextAngle !== undefined) && (obj.fTextSize !== undefined)) {
         extract_color('fTextColor', 'text_color');
         obj.fTextAlign = pattr.v7EvalAttr('text_align', obj.fTextAlign);
         obj.fTextAngle = pattr.v7EvalAttr('text_angle', obj.fTextAngle);
         obj.fTextSize = pattr.v7EvalAttr('text_size', obj.fTextSize);
         // TODO: v7 font handling differs much from v6, ignore for the moment
      }
   }

   /** @summary Function called when drawing next snapshot from the list
     * @return {Promise} with pad painter when ready
     * @private */
   async drawNextSnap(lst, indx) {

      if (indx === undefined) {
         indx = -1;
         // flag used to prevent immediate pad redraw during first draw
         this._snaps_map = {}; // to control how much snaps are drawn
         this._num_primitives = lst ? lst.length : 0;
         this._auto_color_cnt = 0;
      }

      delete this.next_rstyle;

      ++indx; // change to the next snap

      if (!lst || indx >= lst.length) {
         delete this._snaps_map;
         delete this._auto_color_cnt;
         return this;
      }

      let snap = lst[indx],
          snapid = snap.fObjectID,
          cnt = this._snaps_map[snapid],
          objpainter = null;

      if (cnt) cnt++; else cnt=1;
      this._snaps_map[snapid] = cnt; // check how many objects with same snapid drawn, use them again

      // empty object, no need to do something, take next
      if (snap.fDummy) return this.drawNextSnap(lst, indx);

      // first appropriate painter for the object
      // if same object drawn twice, two painters will exists
      for (let k = 0; k < this.painters.length; ++k) {
         if (this.painters[k].snapid === snapid)
            if (--cnt === 0) { objpainter = this.painters[k]; break;  }
      }

      if (objpainter) {

         if (snap._typename == 'ROOT::Experimental::RPadDisplayItem')  // subpad
            return objpainter.redrawPadSnap(snap).then(ppainter => {
               this.addObjectPainter(ppainter, lst, indx);
               return this.drawNextSnap(lst, indx);
            });

         if (snap._typename === 'ROOT::Experimental::TObjectDisplayItem')
            this.extractTObjectProp(snap);

         let promise;

         if (objpainter.updateObject(snap.fDrawable || snap.fObject || snap, snap.fOption || '', true))
            promise = objpainter.redraw();

         return getPromise(promise).then(() => this.drawNextSnap(lst, indx)); // call next
      }

      if (snap._typename == 'ROOT::Experimental::RPadDisplayItem') { // subpad

         let subpad = snap; // not subpad, but just attributes

         let padpainter = new RPadPainter(this.getDom(), subpad, false);
         padpainter.decodeOptions('');
         padpainter.addToPadPrimitives(this.this_pad_name); // only set parent pad name
         padpainter.assignSnapId(snap.fObjectID);
         padpainter.rstyle = snap.fStyle;

         padpainter.createPadSvg();

         if (snap.fPrimitives && snap.fPrimitives.length > 0)
            padpainter.addPadButtons();

         // we select current pad, where all drawing is performed
         let prev_name = padpainter.selectCurrentPad(padpainter.this_pad_name);

         return padpainter.drawNextSnap(snap.fPrimitives).then(() => {
            padpainter.selectCurrentPad(prev_name);
            return this.drawNextSnap(lst, indx);
         });
      }

      // will be used in addToPadPrimitives to assign style to sub-painters
      this.next_rstyle = lst[indx].fStyle || this.rstyle;

      if (snap._typename === 'ROOT::Experimental::TObjectDisplayItem') {

         // identifier used in RObjectDrawable
         const webSnapIds = { kNone: 0,  kObject: 1, kColors: 4, kStyle: 5, kPalette: 6 };

         if (snap.fKind == webSnapIds.kStyle) {
            Object.assign(gStyle, snap.fObject);
            return this.drawNextSnap(lst, indx);
         }

         if (snap.fKind == webSnapIds.kColors) {
            let ListOfColors = [], arr = snap.fObject.arr;
            for (let n = 0; n < arr.length; ++n) {
               let name = arr[n].fString, p = name.indexOf('=');
               if (p > 0)
                  ListOfColors[parseInt(name.slice(0,p))] = name.slice(p+1);
            }

            this.root_colors = ListOfColors;
            // set global list of colors
            // adoptRootColors(ListOfColors);
            return this.drawNextSnap(lst, indx);
         }

         if (snap.fKind == webSnapIds.kPalette) {
            let arr = snap.fObject.arr, palette = [];
            for (let n = 0; n < arr.length; ++n)
               palette[n] =  arr[n].fString;
            this.custom_palette = new ColorPalette(palette);
            return this.drawNextSnap(lst, indx);
         }

         if (!this.getFramePainter())
            return this.drawObject(this.getDom(), { _typename: 'TFrame', $dummy: true }, '')
                       .then(() => this.drawNextSnap(lst, indx-1)); // call same object again

         this.extractTObjectProp(snap);
      }

      // TODO - fDrawable is v7, fObject from v6, maybe use same data member?
      return this.drawObject(this.getDom(), snap.fDrawable || snap.fObject || snap, snap.fOption || '').then(objpainter => {
         this.addObjectPainter(objpainter, lst, indx);
         return this.drawNextSnap(lst, indx);
      });
   }

   /** @summary Search painter with specified snapid, also sub-pads are checked
     * @private */
   findSnap(snapid, onlyid) {

      function check(checkid) {
         if (!checkid || !isStr(checkid)) return false;
         if (checkid == snapid) return true;
         return onlyid && (checkid.length > snapid.length) &&
                (checkid.indexOf(snapid) == (checkid.length - snapid.length));
      }

      if (check(this.snapid)) return this;

      if (!this.painters) return null;

      for (let k=0;k<this.painters.length;++k) {
         let sub = this.painters[k];

         if (!onlyid && isFunc(sub.findSnap))
            sub = sub.findSnap(snapid);
         else if (!check(sub.snapid))
            sub = null;

         if (sub) return sub;
      }

      return null;
   }

   /** @summary Redraw pad snap
     * @desc Online version of drawing pad primitives
     * @return {Promise} with pad painter*/
   async redrawPadSnap(snap) {
      // for the pad/canvas display item contains list of primitives plus pad attributes

      if (!snap || !snap.fPrimitives)
         return this;

      // for the moment only window size attributes are provided
      // let padattr = { fCw: snap.fWinSize[0], fCh: snap.fWinSize[1], fTitle: snap.fTitle };

      // if canvas size not specified in batch mode, temporary use 900x700 size
      // if (this.batch_mode && this.iscan && (!padattr.fCw || !padattr.fCh)) { padattr.fCw = 900; padattr.fCh = 700; }

      if (this.iscan && this._websocket && snap.fTitle && !this.embed_canvas && (typeof document !== 'undefined'))
         document.title = snap.fTitle;

      if (this.snapid === undefined) {
         // first time getting snap, create all gui elements first

         this.assignSnapId(snap.fObjectID);

         this.draw_object = snap;
         this.pad = snap;

         if (this.batch_mode && this.iscan)
             this._fixed_size = true;

         let mainid = this.selectDom().attr('id');

         if (!this.batch_mode && !this.use_openui && !this.brlayout && mainid && isStr(mainid)) {
            this.brlayout = new BrowserLayout(mainid, null, this);
            this.brlayout.create(mainid, true);
            this.setDom(this.brlayout.drawing_divid()); // need to create canvas
            registerForResize(this.brlayout);
         }

         this.createCanvasSvg(0);
         this.addPadButtons(true);

         return this.drawNextSnap(snap.fPrimitives);
      }

      // update only pad/canvas attributes
      this.updateObject(snap);

      // apply all changes in the object (pad or canvas)
      if (this.iscan) {
         this.createCanvasSvg(2);
      } else {
         this.createPadSvg(true);
      }

      let isanyfound = false, isanyremove = false;

      // find and remove painters which no longer exists in the list
      for (let k = 0; k < this.painters.length; ++k) {
         let sub = this.painters[k];
         if (sub.snapid === undefined) continue; // look only for painters with snapid

         snap.fPrimitives.forEach(prim => {
            if (sub && (prim.fObjectID === sub.snapid)) {
               sub = null; isanyfound = true;
            }
         });

         if (sub) {
            // remove painter which does not found in the list of snaps
            this.painters.splice(k--,1);
            sub.cleanup(); // cleanup such painter
            isanyremove = true;
            if (this.main_painter_ref === sub)
               delete this.main_painter_ref;
         }
      }

      if (isanyremove)
         delete this.pads_cache;

      if (!isanyfound) {
         let fp = this.getFramePainter();
         // cannot preserve ROOT6 frame - it must be recreated
         if (fp?.is_root6()) fp = null;
         for (let k = 0; k < this.painters.length; ++k)
             if (fp !== this.painters[k])
               this.painters[k].cleanup();
         this.painters = [];
         delete this.main_painter_ref;
         if (fp) {
            this.painters.push(fp);
            fp.cleanFrameDrawings();
            fp.redraw(); // need to create all layers again
         }
         if (this.removePadButtons) this.removePadButtons();
         this.addPadButtons(true);
      }

      let prev_name = this.selectCurrentPad(this.this_pad_name);

      return this.drawNextSnap(snap.fPrimitives).then(() => {
         this.selectCurrentPad(prev_name);

         if (getActivePad() === this)
            this.getCanvPainter()?.producePadEvent('padredraw', this);
         return this;
      });
   }

   /** @summary Create image for the pad
     * @desc Used with web-based canvas to create images for server side
     * @return {Promise} with image data, coded with btoa() function
     * @private */
   async createImage(format) {
      // use https://github.com/MrRio/jsPDF in the future here
      if (format == 'pdf')
         return btoa_func('dummy PDF file');

      if ((format == 'png') || (format == 'jpeg') || (format == 'svg'))
         return this.produceImage(true, format).then(res => {
            if (!res || (format == 'svg')) return res;
            let separ = res.indexOf('base64,');
            return (separ > 0) ? res.slice(separ+7) : '';
         });

      return '';
   }

   /** @summary Show context menu for specified item
     * @private */
   itemContextMenu(name) {
       let rrr = this.svg_this_pad().node().getBoundingClientRect(),
           evnt = { clientX: rrr.left+10, clientY: rrr.top + 10 };

       // use timeout to avoid conflict with mouse click and automatic menu close
       if (name == 'pad')
          return setTimeout(() => this.padContextMenu(evnt), 50);

       let selp = null, selkind;

       switch(name) {
          case 'xaxis':
          case 'yaxis':
          case 'zaxis':
             selp = this.getMainPainter();
             selkind = name[0];
             break;
          case 'frame':
             selp = this.getFramePainter();
             break;
          default: {
             let indx = parseInt(name);
             if (Number.isInteger(indx)) selp = this.painters[indx];
          }
       }

       if (!isFunc(selp?.fillContextMenu)) return;

       createMenu$1(evnt, selp).then(menu => {
          if (selp.fillContextMenu(menu, selkind))
             selp.fillObjectExecMenu(menu, selkind).then(() => setTimeout(() => menu.show(), 50));
       });
   }

   /** @summary Save pad in specified format
     * @desc Used from context menu */
   saveAs(kind, full_canvas, filename) {
      if (!filename)
         filename = (this.this_pad_name || (this.iscan ? 'canvas' : 'pad')) + '.' + kind;

      this.produceImage(full_canvas, kind).then(imgdata => {
         if (!imgdata)
            return console.error(`Fail to produce image ${filename}`);

         saveFile(filename, (kind != 'svg') ? imgdata : 'data:image/svg+xml;charset=utf-8,'+encodeURIComponent(imgdata));
      });
   }

   /** @summary Search active pad
     * @return {Object} pad painter for active pad */
   findActivePad() {
      return null;
   }

   /** @summary Prodce image for the pad
     * @return {Promise} with created image */
   async produceImage(full_canvas, file_format) {

      let use_frame = (full_canvas === 'frame'),
          elem = use_frame ? this.getFrameSvg(this.this_pad_name) : (full_canvas ? this.getCanvSvg() : this.svg_this_pad()),
          painter = (full_canvas && !use_frame) ? this.getCanvPainter() : this,
          items = []; // keep list of replaced elements, which should be moved back at the end

      if (elem.empty())
         return '';

      if (!use_frame) // do not make transformations for the frame
      painter.forEachPainterInPad(pp => {

         let item = { prnt: pp.svg_this_pad() };
         items.push(item);

         // remove buttons from each subpad
         let btns = pp.getLayerSvg('btns_layer', this.this_pad_name);
         item.btns_node = btns.node();
         if (item.btns_node) {
            item.btns_prnt = item.btns_node.parentNode;
            item.btns_next = item.btns_node.nextSibling;
            btns.remove();
         }

         let main = pp.getFramePainter();
         if (!main || !isFunc(main.render3D) || !isFunc(main.access3dKind)) return;

         let can3d = main.access3dKind();

         if ((can3d !== constants$1.Embed3D.Overlay) && (can3d !== constants$1.Embed3D.Embed)) return;

         let sz2 = main.getSizeFor3d(constants$1.Embed3D.Embed), // get size and position of DOM element as it will be embed
             canvas = main.renderer.domElement;

         main.render3D(0); // WebGL clears buffers, therefore we should render scene and convert immediately

         let dataUrl = canvas.toDataURL('image/png');

         // remove 3D drawings

         if (can3d === constants$1.Embed3D.Embed) {
            item.foreign = item.prnt.select('.' + sz2.clname);
            item.foreign.remove();
         }

         let svg_frame = main.getFrameSvg();
         item.frame_node = svg_frame.node();
         if (item.frame_node) {
            item.frame_next = item.frame_node.nextSibling;
            svg_frame.remove();
         }

         // add svg image
         item.img = item.prnt.insert('image','.primitives_layer')     // create image object
                        .attr('x', sz2.x)
                        .attr('y', sz2.y)
                        .attr('width', canvas.width)
                        .attr('height', canvas.height)
                        .attr('href', dataUrl);

      }, 'pads');

      const reEncode = data => {
         data = encodeURIComponent(data);
         data = data.replace(/%([0-9A-F]{2})/g, function(match, p1) {
           let c = String.fromCharCode('0x'+p1);
           return c === '%' ? '%25' : c;
         });
         return decodeURIComponent(data);
      }, reconstruct = () => {
         for (let k = 0; k < items.length; ++k) {
            let item = items[k];

            if (item.img)
               item.img.remove(); // delete embed image

            let prim = item.prnt.select('.primitives_layer');

            if (item.foreign) // reinsert foreign object
               item.prnt.node().insertBefore(item.foreign.node(), prim.node());

            if (item.frame_node) // reinsert frame as first in list of primitives
               prim.node().insertBefore(item.frame_node, item.frame_next);

            if (item.btns_node) // reinsert buttons
               item.btns_prnt.insertBefore(item.btns_node, item.btns_next);
         }
      };

      let width = elem.property('draw_width'), height = elem.property('draw_height');
      if (use_frame) {
         let fp = this.getFramePainter();
         width = fp.getFrameWidth();
         height = fp.getFrameHeight();
      }

      let svg = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">${elem.node().innerHTML}</svg>`;

      if (internals.processSvgWorkarounds)
         svg = internals.processSvgWorkarounds(svg);

      svg = compressSVG(svg);

      if (file_format == 'svg') {
         reconstruct();
         return svg; // return SVG file as is
      }

      let doctype = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">',
          image = new Image();

      return new Promise(resolveFunc => {
         image.onload = function() {
            let canvas = document.createElement('canvas');
            canvas.width = image.width;
            canvas.height = image.height;
            let context = canvas.getContext('2d');
            context.drawImage(image, 0, 0);

            reconstruct();

            resolveFunc(canvas.toDataURL('image/' + file_format));
         };

         image.onerror = function(arg) {
            console.log(`IMAGE ERROR ${arg}`);
            reconstruct();
            resolveFunc(null);
         };

         image.src = 'data:image/svg+xml;base64,' + btoa_func(reEncode(doctype + svg));
      });
   }

   /** @summary Process pad button click */
   clickPadButton(funcname, evnt) {

      if (funcname == 'CanvasSnapShot')
         return this.saveAs('png', true);

      if (funcname == 'enlargePad')
         return this.enlargePad();

      if (funcname == 'PadSnapShot')
         return this.saveAs('png', false);

      if (funcname == 'PadContextMenus') {

         if (evnt) {
            evnt.preventDefault();
            evnt.stopPropagation();
         }

         if (closeMenu()) return;

         createMenu$1(evnt, this).then(menu => {
            menu.add('header:Menus');

            if (this.iscan)
               menu.add('Canvas', 'pad', this.itemContextMenu);
            else
               menu.add('Pad', 'pad', this.itemContextMenu);

            if (this.getFramePainter())
               menu.add('Frame', 'frame', this.itemContextMenu);

            let main = this.getMainPainter(); // here hist painter methods

            if (main) {
               menu.add('X axis', 'xaxis', this.itemContextMenu);
               menu.add('Y axis', 'yaxis', this.itemContextMenu);
               if (isFunc(main.getDimension) && (main.getDimension() > 1))
                  menu.add('Z axis', 'zaxis', this.itemContextMenu);
            }

            if (this.painters?.length) {
               menu.add('separator');
               let shown = [];
               for (let n = 0; n < this.painters.length; ++n) {
                  let obj = this.painters[n]?.getObject();
                  if (!obj || (shown.indexOf(obj) >= 0)) continue;

                  let name = obj._typename ? obj._typename + '::' : '';
                  if (obj.fName) name += obj.fName;
                  if (!name) name = 'item' + n;
                  menu.add(name, n, this.itemContextMenu);
               }
            }

            menu.show();
         });

         return;
      }

      // click automatically goes to all sub-pads
      // if any painter indicates that processing completed, it returns true
      let done = false;

      for (let i = 0; i < this.painters.length; ++i) {
         let pp = this.painters[i];

         if (isFunc(pp.clickPadButton))
            pp.clickPadButton(funcname);

         if (!done && isFunc(pp.clickButton))
            done = pp.clickButton(funcname);
      }
   }

   /** @summary Add button to the pad
     * @private */
   addPadButton(btn, tooltip, funcname, keyname) {
      if (!settings.ToolBar || isBatchMode() || this.batch_mode) return;

      if (!this._buttons) this._buttons = [];
      // check if there are duplications

      for (let k = 0; k < this._buttons.length; ++k)
         if (this._buttons[k].funcname == funcname) return;

      this._buttons.push({ btn, tooltip, funcname, keyname });

      let iscan = this.iscan || !this.has_canvas;
      if (!iscan && (funcname.indexOf('Pad') != 0) && (funcname !== 'enlargePad')) {
         let cp = this.getCanvPainter();
         if (cp && (cp !== this)) cp.addPadButton(btn, tooltip, funcname);
      }
   }

   /** @summary Add buttons for pad or canvas
     * @private */
   addPadButtons(is_online) {

      this.addPadButton('camera', 'Create PNG', this.iscan ? 'CanvasSnapShot' : 'PadSnapShot', 'Ctrl PrintScreen');

      if (settings.ContextMenu)
         this.addPadButton('question', 'Access context menus', 'PadContextMenus');

      let add_enlarge = !this.iscan && this.has_canvas && this.hasObjectsToDraw();

      if (add_enlarge || this.enlargeMain('verify'))
         this.addPadButton('circle', 'Enlarge canvas', 'enlargePad');

      if (is_online && this.brlayout) {
         this.addPadButton('diamand', 'Toggle Ged', 'ToggleGed');
         this.addPadButton('three_circles', 'Toggle Status', 'ToggleStatus');
      }

   }

   /** @summary Show pad buttons
     * @private */
   showPadButtons() {
      if (!this._buttons) return;

      PadButtonsHandler.assign(this);
      this.showPadButtons();
   }

   /** @summary Calculates RPadLength value */
   getPadLength(vertical, len, frame_painter) {
      let sign = vertical ? -1 : 1,
          rect, res,
          getV = (indx, dflt) => (indx < len.fArr.length) ? len.fArr[indx] : dflt,
          getRect = () => {
             if (!rect)
                rect = frame_painter ? frame_painter.getFrameRect() : this.getPadRect();
             return rect;
          };

      if (frame_painter) {
         let user = getV(2), func = vertical ? 'gry' : 'grx';
         if ((user !== undefined) && frame_painter[func])
            res = frame_painter[func](user);
      }

      if (res === undefined)
         res = vertical ? getRect().height : 0;

      let norm = getV(0, 0), pixel = getV(1, 0);

      res += sign*pixel;

      if (norm)
         res += sign * (vertical ? getRect().height : getRect().width) * norm;

      return Math.round(res);
   }


   /** @summary Calculates pad position for RPadPos values
     * @param {object} pos - instance of RPadPos
     * @param {object} frame_painter - if drawing will be performed inside frame, frame painter */
   getCoordinate(pos, frame_painter) {
      return {
         x: this.getPadLength(false, pos.fHoriz, frame_painter),
         y: this.getPadLength(true, pos.fVert, frame_painter)
      }
   }

   /** @summary Decode pad draw options */
   decodeOptions(opt) {
      let pad = this.getObject();
      if (!pad) return;

      let d = new DrawOptions(opt);

      if (!this.options) this.options = {};

      Object.assign(this.options, { GlobalColors: true, LocalColors: false, IgnorePalette: false, RotateFrame: false, FixFrame: false });

      if (d.check('NOCOLORS') || d.check('NOCOL')) this.options.GlobalColors = this.options.LocalColors = false;
      if (d.check('LCOLORS') || d.check('LCOL')) { this.options.GlobalColors = false; this.options.LocalColors = true; }
      if (d.check('NOPALETTE') || d.check('NOPAL')) this.options.IgnorePalette = true;
      if (d.check('ROTATE')) this.options.RotateFrame = true;
      if (d.check('FIXFRAME')) this.options.FixFrame = true;

      if (d.check('WHITE')) pad.fFillColor = 0;
      if (d.check('LOGX')) pad.fLogx = 1;
      if (d.check('LOGY')) pad.fLogy = 1;
      if (d.check('LOGZ')) pad.fLogz = 1;
      if (d.check('LOG')) pad.fLogx = pad.fLogy = pad.fLogz = 1;
      if (d.check('GRIDX')) pad.fGridx = 1;
      if (d.check('GRIDY')) pad.fGridy = 1;
      if (d.check('GRID')) pad.fGridx = pad.fGridy = 1;
      if (d.check('TICKX')) pad.fTickx = 1;
      if (d.check('TICKY')) pad.fTicky = 1;
      if (d.check('TICK')) pad.fTickx = pad.fTicky = 1;
   }

   /** @summary draw RPad object */
   static async draw(dom, pad, opt) {
      let painter = new RPadPainter(dom, pad, false);
      painter.decodeOptions(opt);

      if (painter.getCanvSvg().empty()) {
         painter.has_canvas = false;
         painter.this_pad_name = '';
         painter.setTopPainter();
      } else {
         painter.addToPadPrimitives(painter.pad_name); // must be here due to pad painter
      }

      painter.createPadSvg();

      if (painter.matchObjectType(clTPad) && (!painter.has_canvas || painter.hasObjectsToDraw())) {
         painter.addPadButtons();
      }

      // we select current pad, where all drawing is performed
      let prev_name = painter.has_canvas ? painter.selectCurrentPad(painter.this_pad_name) : undefined;

      selectActivePad({ pp: painter, active: false });

      // flag used to prevent immediate pad redraw during first draw
      return painter.drawPrimitives().then(() => {
         painter.showPadButtons();
         // we restore previous pad name
         painter.selectCurrentPad(prev_name);
         return painter;
      });
   }

} // class RPadPainter

/**
 * @summary Class emulating web socket with long-poll http requests
 *
 * @private
 */

class LongPollSocket {

   constructor(addr, _raw, _args) {
      this.path = addr;
      this.connid = null;
      this.req = null;
      this.raw = _raw;
      this.args = _args;

      this.nextRequest('', 'connect');
   }

   /** @summary Submit next request */
   nextRequest(data, kind) {
      let url = this.path, reqmode = 'buf', post = null;
      if (kind === 'connect') {
         url += this.raw ? '?raw_connect' : '?txt_connect';
         if (this.args) url += '&' + this.args;
         console.log(`longpoll connect ${url} raw = ${this.raw}`);
         this.connid = 'connect';
      } else if (kind === 'close') {
         if ((this.connid === null) || (this.connid === 'close')) return;
         url += `?connection=${this.connid}&close`;
         this.connid = 'close';
         reqmode = 'text;sync'; // use sync mode to close connection before browser window closed
      } else if ((this.connid === null) || (typeof this.connid !== 'number')) {
         if (!browser$1.qt5) console.error('No connection');
         return;
      } else {
         url += '?connection=' + this.connid;
         if (kind === 'dummy') url += '&dummy';
      }

      if (data) {
         if (this.raw) {
            // special workaround to avoid POST request, use base64 coding
            url += '&post=' + btoa_func(data);
         } else {
            // send data with post request - most efficient way
            reqmode = 'postbuf';
            post = data;
         }
      }

      createHttpRequest(url, reqmode, function(res) {
         // this set to the request itself, res is response

         if (this.handle.req === this)
            this.handle.req = null; // get response for existing dummy request

         if (res === null)
            return this.handle.processRequest(null);

         if (this.handle.raw) {
            // raw mode - all kind of reply data packed into binary buffer
            // first 4 bytes header 'txt:' or 'bin:'
            // after the 'bin:' there is length of optional text argument like 'bin:14  :optional_text'
            // and immedaitely after text binary data. Server sends binary data so, that offset should be multiple of 8

            let str = '', i = 0, u8Arr = new Uint8Array(res), offset = u8Arr.length;
            if (offset < 4) {
               if (!browser$1.qt5) console.error(`longpoll got short message in raw mode ${offset}`);
               return this.handle.processRequest(null);
            }

            while (i < 4) str += String.fromCharCode(u8Arr[i++]);
            if (str != 'txt:') {
               str = '';
               while ((i < offset) && (String.fromCharCode(u8Arr[i]) != ':'))
                  str += String.fromCharCode(u8Arr[i++]);
               ++i;
               offset = i + parseInt(str.trim());
            }

            str = '';
            while (i < offset) str += String.fromCharCode(u8Arr[i++]);

            if (str) {
               if (str == '<<nope>>')
                  this.handle.processRequest(-1111);
               else
                   this.handle.processRequest(str);
            }
            if (offset < u8Arr.length)
               this.handle.processRequest(res, offset);
         } else if (this.getResponseHeader('Content-Type') == 'application/x-binary') {
            // binary reply with optional header
            let extra_hdr = this.getResponseHeader('LongpollHeader');
            if (extra_hdr) this.handle.processRequest(extra_hdr);
            this.handle.processRequest(res, 0);
         } else {
            // text reply
            if (res && !isStr(res)) {
               let str = '', u8Arr = new Uint8Array(res);
               for (let i = 0; i < u8Arr.length; ++i)
                  str += String.fromCharCode(u8Arr[i]);
               res = str;
            }
            if (res == '<<nope>>')
               this.handle.processRequest(-1111);
            else
               this.handle.processRequest(res);
         }
      }, function(/*err,status*/) {
         this.handle.processRequest(null, 'error');
      }, true).then(req => {
         req.handle = this;
         if (!this.req)
            this.req = req; // any request can be used for response, do not submit dummy until req is there
         req.send(post);
      });
   }

   /** @summary Process request */
   processRequest(res, _offset) {
      if (res === null) {
         if (isFunc(this.onerror))
            this.onerror('receive data with connid ' + (this.connid || '---'));
         if ((_offset == 'error') && isFunc(this.onclose))
            this.onclose('force_close');
         this.connid = null;
         return;
      } else if (res === -1111) {
         res = '';
      }

      let dummy_tmout = 5;

      if (this.connid === 'connect') {
         if (!res) {
            this.connid = null;
            if (isFunc(this.onerror))
               this.onerror('connection rejected');
            return;
         }

         this.connid = parseInt(res);
         dummy_tmout = 100; // when establishing connection, wait a bit longer to submit dummy package
         console.log(`Get new longpoll connection with id ${this.connid}`);
         if (isFunc(this.onopen))
            this.onopen();
      } else if (this.connid === 'close') {
         if (isFunc(this.onclose))
            this.onclose();
         return;
      } else {
         if (isFunc(this.onmessage) && res)
            this.onmessage({ data: res, offset: _offset });
      }

      // minimal timeout to reduce load, generate dummy only if client not submit new request immediately
      if (!this.req)
         setTimeout(() => { if (!this.req) this.nextRequest('', 'dummy'); }, dummy_tmout);
   }

   /** @summary Send data */
   send(str) { this.nextRequest(str); }

   /** @summary Close connection */
   close() { this.nextRequest('', 'close'); }

} // class LongPollSocket

// ========================================================================================

/**
 * @summary Class re-playing socket data from stored protocol
 *
 * @private
 */

class FileDumpSocket {

   constructor(receiver) {
      this.receiver = receiver;
      this.protocol = [];
      this.cnt = 0;
      httpRequest('protocol.json', 'text').then(res => this.getProtocol(res));
   }

   /** @summary Get stored protocol */
   getProtocol(res) {
      if (!res) return;
      this.protocol = JSON.parse(res);
      if (isFunc(this.onopen)) this.onopen();
      this.nextOperation();
   }

   /** @summary Emulate send - just cound operation */
   send(/* str */) {
      if (this.protocol[this.cnt] == 'send') {
         this.cnt++;
         setTimeout(() => this.nextOperation(), 10);
      }
   }

   /** @summary Emulate close */
   close() {}

   /** @summary Read data for next operation */
   nextOperation() {
      // when file request running - just ignore
      if (this.wait_for_file) return;
      let fname = this.protocol[this.cnt];
      if (!fname) return;
      if (fname == 'send') return; // waiting for send
      this.wait_for_file = true;
      this.cnt++;
      httpRequest(fname, (fname.indexOf('.bin') > 0 ? 'buf' : 'text')).then(res => {
         this.wait_for_file = false;
         if (!res) return;
         if (this.receiver.provideData)
            this.receiver.provideData(1, res, 0);
         setTimeout(() => this.nextOperation(), 10);
      });
   }

} // class FileDumpSocket


/**
 * @summary Client communication handle for RWebWindow.
 *
 * @desc Should be created with {@link connectWebWindow} function
 */

class WebWindowHandle {

   constructor(socket_kind, credits) {
      this.kind = socket_kind;
      this.state = 0;
      this.credits = credits || 10;
      this.cansend = this.credits;
      this.ackn = this.credits;
   }

   /** @summary Returns arguments specified in the RWebWindow::SetUserArgs() method
     * @desc Can be any valid JSON expression. Undefined by default.
     * @param {string} [field] - if specified and user args is object, returns correspondent object member
     * @return user arguments object */
   getUserArgs(field) {
      if (field && isStr(field))
         return isObject(this.user_args) ? this.user_args[field] : undefined;

      return this.user_args;
   }

   /** @summary Set user args
     * @desc Normally set via RWebWindow::SetUserArgs() method */
   setUserArgs(args) { this.user_args = args; }

   /** @summary Set callbacks receiver.
     * @param {object} obj - object with receiver functions
     * @param {function} obj.onWebsocketMsg - called when new data receieved from RWebWindow
     * @param {function} obj.onWebsocketOpened - called when connection established
     * @param {function} obj.onWebsocketClosed - called when connection closed
     * @param {function} obj.onWebsocketError - called when get error via the connection */
   setReceiver(obj) { this.receiver = obj; }

   /** @summary Cleanup and close connection. */
   cleanup() {
      delete this.receiver;
      this.close(true);
   }

   /** @summary Invoke method in the receiver.
    * @private */
   invokeReceiver(brdcst, method, arg, arg2) {
      if (this.receiver && isFunc(this.receiver[method]))
         this.receiver[method](this, arg, arg2);

      if (brdcst && this.channels) {
         let ks = Object.keys(this.channels);
         for (let n = 0; n < ks.length; ++n)
            this.channels[ks[n]].invokeReceiver(false, method, arg, arg2);
      }
   }

   /** @summary Provide data for receiver. When no queue - do it directly.
    * @private */
   provideData(chid, _msg, _len) {
      if (this.wait_first_recv) {
         delete this.wait_first_recv;
         return this.invokeReceiver(false, 'onWebsocketOpened');
      }

      if ((chid > 1) && this.channels) {
         const channel = this.channels[chid];
         if (channel)
            return channel.provideData(1, _msg, _len);
      }

      const force_queue = _len && (_len < 0);

      if (!force_queue && (!this.msgqueue || !this.msgqueue.length))
         return this.invokeReceiver(false, 'onWebsocketMsg', _msg, _len);

      if (!this.msgqueue) this.msgqueue = [];
      if (force_queue) _len = undefined;

      this.msgqueue.push({ ready: true, msg: _msg, len: _len });
   }

   /** @summary Reserve entry in queue for data, which is not yet decoded.
    * @private */
   reserveQueueItem() {
      if (!this.msgqueue) this.msgqueue = [];
      let item = { ready: false, msg: null, len: 0 };
      this.msgqueue.push(item);
      return item;
   }

   /** @summary Provide data for item which was reserved before.
    * @private */
   markQueueItemDone(item, _msg, _len) {
      item.ready = true;
      item.msg = _msg;
      item.len = _len;
      this.processQueue();
   }

   /** @summary Process completed messages in the queue
     * @private */
   processQueue() {
      if (this._loop_msgqueue || !this.msgqueue) return;
      this._loop_msgqueue = true;
      while ((this.msgqueue.length > 0) && this.msgqueue[0].ready) {
         let front = this.msgqueue.shift();
         this.invokeReceiver(false, 'onWebsocketMsg', front.msg, front.len);
      }
      if (this.msgqueue.length == 0)
         delete this.msgqueue;
      delete this._loop_msgqueue;
   }

   /** @summary Close connection */
   close(force) {
      if (this.master) {
         this.master.send('CLOSECH=' + this.channelid, 0);
         delete this.master.channels[this.channelid];
         delete this.master;
         return;
      }

      if (this.timerid) {
         clearTimeout(this.timerid);
         delete this.timerid;
      }

      if (this._websocket && (this.state > 0)) {
         this.state = force ? -1 : 0; // -1 prevent socket from reopening
         this._websocket.onclose = null; // hide normal handler
         this._websocket.close();
         delete this._websocket;
      }
   }

   /** @summary Checks number of credits for send operation
     * @param {number} [numsend = 1] - number of required send operations
     * @return true if one allow to send specified number of text message to server */
   canSend(numsend) { return this.cansend >= (numsend || 1); }

   /** @summary Returns number of possible send operations relative to number of credits */
   getRelCanSend() { return !this.credits ? 1 : this.cansend / this.credits; }

   /** @summary Send text message via the connection.
     * @param {string} msg - text message to send
     * @param {number} [chid] - channel id, 1 by default, 0 used only for internal communication */
   send(msg, chid) {
      if (this.master)
         return this.master.send(msg, this.channelid);

      if (!this._websocket || (this.state <= 0)) return false;

      if (!Number.isInteger(chid)) chid = 1; // when not configured, channel 1 is used - main widget

      if (this.cansend <= 0) console.error(`should be queued before sending cansend: ${this.cansend}`);

      let prefix = `${this.ackn}:${this.cansend}:${chid}:`;
      this.ackn = 0;
      this.cansend--; // decrease number of allowed send packets

      this._websocket.send(prefix + msg);

      if ((this.kind === 'websocket') || (this.kind === 'longpoll')) {
         if (this.timerid) clearTimeout(this.timerid);
         this.timerid = setTimeout(() => this.keepAlive(), 10000);
      }

      return true;
   }

   /** @summary Inject message(s) into input queue, for debug purposes only
     * @private */
   inject(msg, chid, immediate) {
      // use timeout to avoid too deep call stack
      if (!immediate)
         return setTimeout(this.inject.bind(this, msg, chid, true), 0);

      if (chid === undefined) chid = 1;

      if (Array.isArray(msg)) {
         for (let k = 0; k < msg.length; ++k)
            this.provideData(chid, isStr(msg[k]) ? msg[k] : JSON.stringify(msg[k]), -1);
         this.processQueue();
      } else if (msg) {
         this.provideData(chid, isStr(msg) ? msg : JSON.stringify(msg));
      }
   }

   /** @summary Send keep-alive message.
     * @desc Only for internal use, only when used with websockets
     * @private */
   keepAlive() {
      delete this.timerid;
      this.send('KEEPALIVE', 0);
   }

   /** @summary Method open channel, which will share same connection, but can be used independently from main
     * @private */
   createChannel() {
      if (this.master)
         return master.createChannel();

      let channel = new WebWindowHandle('channel', this.credits);
      channel.wait_first_recv = true; // first received message via the channel is confirmation of established connection

      if (!this.channels) {
         this.channels = {};
         this.freechannelid = 2;
      }

      channel.master = this;
      channel.channelid = this.freechannelid++;

      // register
      this.channels[channel.channelid] = channel;

      // now server-side entity should be initialized and init message send from server side!
      return channel;
   }

   /** @summary Returns used channel ID, 1 by default */
   getChannelId() { return this.channelid && this.master ? this.channelid : 1; }

   /** @summary Assign href parameter
     * @param {string} [path] - absolute path, when not specified window.location.url will be used
     * @private */
   setHRef(path) { this.href = path; }

   /** @summary Return href part
     * @param {string} [relative_path] - relative path to the handle
     * @private */
   getHRef(relative_path) {
      if (!relative_path || !this.kind || !this.href) return this.href;

      let addr = this.href;
      if (relative_path.indexOf('../') == 0) {
         let ddd = addr.lastIndexOf('/',addr.length-2);
         addr = addr.slice(0,ddd) + relative_path.slice(2);
      } else {
         addr += relative_path;
      }

      return addr;
   }

   /** @summary Create configured socket for current object.
     * @private */
   connect(href) {

      this.close();
      if (!href && this.href) href = this.href;

      let ntry = 0, args = (this.key ? ('key=' + this.key) : '');
      if (this.token) {
         if (args) args += '&';
         args += 'token=' + this.token;
      }

      const retry_open = first_time => {

         if (this.state != 0) return;

         if (!first_time) console.log(`try connect window again ${new Date().toString()}`);

         if (this._websocket) {
            this._websocket.close();
            delete this._websocket;
         }

         if (!href) {
            href = window.location.href;
            if (href && href.indexOf('#') > 0) href = href.slice(0, href.indexOf('#'));
            if (href && href.lastIndexOf('/') > 0) href = href.slice(0, href.lastIndexOf('/') + 1);
         }
         this.href = href;
         ntry++;

         if (first_time) console.log(`Opening web socket at ${href}`);

         if (ntry > 2) showProgress(`Trying to connect ${href}`);

         let path = href;

         if (this.kind == 'file') {
            path += 'root.filedump';
            this._websocket = new FileDumpSocket(this);
            console.log(`configure protocol log ${path}`);
         } else if ((this.kind === 'websocket') && first_time) {
            path = path.replace('http://', 'ws://').replace('https://', 'wss://') + 'root.websocket';
            if (args) path += '?' + args;
            console.log(`configure websocket ${path}`);
            this._websocket = new WebSocket(path);
         } else {
            path += 'root.longpoll';
            console.log(`configure longpoll ${path}`);
            this._websocket = new LongPollSocket(path, (this.kind === 'rawlongpoll'), args);
         }

         if (!this._websocket) return;

         this._websocket.onopen = () => {
            if (ntry > 2) showProgress();
            this.state = 1;

            let key = this.key || '';

            this.send('READY=' + key, 0); // need to confirm connection
            this.invokeReceiver(false, 'onWebsocketOpened');
         };

         this._websocket.onmessage = e => {
            let msg = e.data;

            if (this.next_binary) {

               let binchid = this.next_binary;
               delete this.next_binary;

               if (msg instanceof Blob) {
                  // convert Blob object to BufferArray
                  let reader = new FileReader, qitem = this.reserveQueueItem();
                  // The file's text will be printed here
                  reader.onload = event => this.markQueueItemDone(qitem, event.target.result, 0);
                  reader.readAsArrayBuffer(msg, e.offset || 0);
               } else {
                  // this is from CEF or LongPoll handler
                  this.provideData(binchid, msg, e.offset || 0);
               }

               return;
            }

            if (!isStr(msg))
               return console.log(`unsupported message kind: ${typeof msg}`);

            let i1 = msg.indexOf(':'),
               credit = parseInt(msg.slice(0, i1)),
               i2 = msg.indexOf(':', i1 + 1),
               // cansend = parseInt(msg.slice(i1 + 1, i2)),  // TODO: take into account when sending messages
               i3 = msg.indexOf(':', i2 + 1),
               chid = parseInt(msg.slice(i2 + 1, i3));

            this.ackn++;            // count number of received packets,
            this.cansend += credit; // how many packets client can send

            msg = msg.slice(i3 + 1);

            if (chid == 0) {
               console.log(`GET chid=0 message ${msg}`);
               if (msg == 'CLOSE') {
                  this.close(true); // force closing of socket
                  this.invokeReceiver(true, 'onWebsocketClosed');
               } else if (msg.indexOf('NEW_KEY=') == 0) {
                  let newkey = msg.slice(8);
                  this.close(true);
                  if (typeof sessionStorage !== 'undefined')
                     sessionStorage.setItem('RWebWindow_Key', newkey);
                  location.reload(true);
               }
            } else if (msg == '$$binary$$') {
               this.next_binary = chid;
            } else if (msg == '$$nullbinary$$') {
               this.provideData(chid, new ArrayBuffer(0), 0);
            } else {
               this.provideData(chid, msg);
            }

            if (this.ackn > 7)
               this.send('READY', 0); // send dummy message to server
         };

         this._websocket.onclose = arg => {
            delete this._websocket;
            if ((this.state > 0) || (arg === 'force_close')) {
               console.log('websocket closed');
               this.state = 0;
               this.invokeReceiver(true, 'onWebsocketClosed');
            }
         };

         this._websocket.onerror = err => {
            console.log(`websocket error ${err} state ${this.state}`);
            if (this.state > 0) {
               this.invokeReceiver(true, 'onWebsocketError', err);
               this.state = 0;
            }
         };

         // only in interactive mode try to reconnect
         if (!isBatchMode())
            setTimeout(retry_open, 3000); // after 3 seconds try again

      }; // retry_open

      retry_open(true); // call for the first time
   }

   /** @summary Send newkey request to application
     * @desc If server creates newkey and response - webpage will be reaload
     * After key generation done, connection will not be working any longer
     * WARNING - only call when you know that you are doing
     * @private */
   askReload() {
      this.send('GENERATE_KEY', 0);
   }

   /** @summary Instal Ctrl-R handler to realod web window
     * @desc Instead of default window reload invokes {@link askReload} method
     * WARNING - only call when you know that you are doing
     * @private */
   addReloadKeyHandler() {

      if (this.kind == 'file') return;

      window.addEventListener( 'keydown', evnt => {
         if (((evnt.key == 'R') || (evnt.key == 'r')) && evnt.ctrlKey) {
            evnt.stopPropagation();
            evnt.preventDefault();
            console.log('Prevent Ctrl-R propogation - ask reload RWebWindow!');
            this.askReload();
          }
      });
   }

} // class WebWindowHandle

/**
 * @summary Painter class for RCanvas
 *
 * @private
 */

class RCanvasPainter extends RPadPainter {

   /** @summary constructor */
   constructor(dom, canvas) {
      super(dom, canvas, true);
      this._websocket = null;
      this.tooltip_allowed = settings.Tooltip;
      this.v7canvas = true;
   }

   /** @summary Cleanup canvas painter */
   cleanup() {
      delete this._websocket;
      delete this._submreq;

     if (this._changed_layout)
         this.setLayoutKind('simple');
      delete this._changed_layout;

      super.cleanup();
   }

   /** @summary Returns layout kind */
   getLayoutKind() {
      let origin = this.selectDom('origin'),
         layout = origin.empty() ? '' : origin.property('layout');
      return layout || 'simple';
   }

   /** @summary Set canvas layout kind */
   setLayoutKind(kind, main_selector) {
      let origin = this.selectDom('origin');
      if (!origin.empty()) {
         if (!kind) kind = 'simple';
         origin.property('layout', kind);
         origin.property('layout_selector', (kind != 'simple') && main_selector ? main_selector : null);
         this._changed_layout = (kind !== 'simple'); // use in cleanup
      }
   }

   /** @summary Changes layout
     * @return {Promise} indicating when finished */
   async changeLayout(layout_kind, mainid) {
      let current = this.getLayoutKind();
      if (current == layout_kind)
         return true;

      let origin = this.selectDom('origin'),
          sidebar = origin.select('.side_panel'),
          main = this.selectDom(), lst = [];

      while (main.node().firstChild)
         lst.push(main.node().removeChild(main.node().firstChild));

      if (!sidebar.empty())
         cleanup(sidebar.node());

      this.setLayoutKind('simple'); // restore defaults
      origin.html(''); // cleanup origin

      if (layout_kind == 'simple') {
         main = origin;
         for (let k = 0; k < lst.length; ++k)
            main.node().appendChild(lst[k]);
         this.setLayoutKind(layout_kind);
      } else {
         let grid = new GridDisplay(origin.node(), layout_kind);

         if (mainid == undefined)
            mainid = (layout_kind.indexOf('vert') == 0) ? 0 : 1;

         main = select(grid.getGridFrame(mainid));
         sidebar = select(grid.getGridFrame(1 - mainid));

         main.classed('central_panel', true).style('position', 'relative');
         sidebar.classed('side_panel', true).style('position', 'relative');

         // now append all childs to the new main
         for (let k = 0; k < lst.length; ++k)
            main.node().appendChild(lst[k]);

         this.setLayoutKind(layout_kind, '.central_panel');

         // remove reference to MDIDisplay, solves resize problem
         origin.property('mdi', null);
      }

      // resize main drawing and let draw extras
      resize(main.node());
      return true;
   }

   /** @summary Toggle projection
     * @return {Promise} indicating when ready
     * @private */
   async toggleProjection(kind) {
      delete this.proj_painter;

      if (kind) this.proj_painter = 1; // just indicator that drawing can be preformed

      if (isFunc(this.showUI5ProjectionArea))
         return this.showUI5ProjectionArea(kind);

      let layout = 'simple', mainid;

      switch(kind) {
         case 'X':
         case 'bottom': layout = 'vert2_31'; mainid = 0; break;
         case 'Y':
         case 'left': layout = 'horiz2_13'; mainid = 1; break;
         case 'top': layout = 'vert2_13'; mainid = 1; break;
         case 'right': layout = 'horiz2_31'; mainid = 0; break;
      }

      return this.changeLayout(layout, mainid);
   }

   /** @summary Draw projection for specified histogram
     * @private */
   async drawProjection( /*kind,hist*/) {
      // dummy for the moment
      return false;
   }

   /** @summary Draw in side panel
     * @private */
   async drawInSidePanel(canv, opt) {
      let side = this.selectDom('origin').select('.side_panel');
      return side.empty() ?  null : this.drawObject(side.node(), canv, opt);
   }

   /** @summary Checks if canvas shown inside ui5 widget
     * @desc Function should be used only from the func which supposed to be replaced by ui5
     * @private */
   testUI5() {
      if (!this.use_openui) return false;
      console.warn('full ui5 should be used - not loaded yet? Please check!!');
      return true;
   }

   /** @summary Show message
     * @desc Used normally with web-based canvas and handled in ui5
     * @private */
   showMessage(msg) {
      if (!this.testUI5())
         showProgress(msg, 7000);
   }

   /** @summary Function called when canvas menu item Save is called */
   saveCanvasAsFile(fname) {
      let pnt = fname.indexOf('.');
      this.createImage(fname.slice(pnt+1))
          .then(res => { console.log('save', fname, res.length); this.sendWebsocket('SAVE:' + fname + ':' + res); });
   }

   /** @summary Send command to server to save canvas with specified name
     * @desc Should be only used in web-based canvas
     * @private */
   sendSaveCommand(fname) {
      this.sendWebsocket('PRODUCE:' + fname);
   }

   /** @summary Send message via web socket
     * @private */
   sendWebsocket(msg) {
      if (this._websocket?.canSend()) {
         this._websocket.send(msg);
         return true;
      }

      return false;
   }

   /** @summary Close websocket connection to canvas
     * @private */
   closeWebsocket(force) {
      if (this._websocket) {
         this._websocket.close(force);
         this._websocket.cleanup();
         delete this._websocket;
      }
   }

   /** @summary Use provided connection for the web canvas
     * @private */
   useWebsocket(handle) {
      this.closeWebsocket();

      this._websocket = handle;
      this._websocket.setReceiver(this);
      this._websocket.connect();
   }

   /** @summary Hanler for websocket open event
     * @private */
   onWebsocketOpened(/*handle*/) {
   }

   /** @summary Hanler for websocket close event
     * @private */
   onWebsocketClosed(/*handle*/) {
      if (!this.embed_canvas)
         closeCurrentWindow();
   }

   /** @summary Hanler for websocket message
     * @private */
   onWebsocketMsg(handle, msg) {
      console.log('GET_MSG ' + msg.slice(0,30));

      if (msg == 'CLOSE') {
         this.onWebsocketClosed();
         this.closeWebsocket(true);
      } else if (msg.slice(0,5) == 'SNAP:') {
         msg = msg.slice(5);
         let p1 = msg.indexOf(':'),
             snapid = msg.slice(0,p1),
             snap = parse(msg.slice(p1+1));
         this.syncDraw(true)
             .then(() => this.redrawPadSnap(snap))
             .then(() => {
                 handle.send('SNAPDONE:' + snapid); // send ready message back when drawing completed
                 this.confirmDraw();
              });
      } else if (msg.slice(0,4) == 'JSON') {
         let obj = parse(msg.slice(4));
         // console.log('get JSON ', msg.length-4, obj._typename);
         this.redrawObject(obj);
      } else if (msg.slice(0,9) == 'REPL_REQ:') {
         this.processDrawableReply(msg.slice(9));
      } else if (msg.slice(0,4) == 'CMD:') {
         msg = msg.slice(4);
         let p1 = msg.indexOf(':'),
             cmdid = msg.slice(0,p1),
             cmd = msg.slice(p1+1),
             reply = 'REPLY:' + cmdid + ':';
         if ((cmd == 'SVG') || (cmd == 'PNG') || (cmd == 'JPEG')) {
            this.createImage(cmd.toLowerCase())
                .then(res => handle.send(reply + res));
         } else if (cmd.indexOf('ADDPANEL:') == 0) {
            let relative_path = cmd.slice(9);
            if (!isFunc(this.showUI5Panel)) {
               handle.send(reply + 'false');
            } else {

               let conn = new WebWindowHandle(handle.kind);

               // set interim receiver until first message arrives
               conn.setReceiver({
                  cpainter: this,

                  onWebsocketOpened() {
                  },

                  onWebsocketMsg(panel_handle, msg) {
                     let panel_name = (msg.indexOf('SHOWPANEL:') == 0) ? msg.slice(10) : '';
                     this.cpainter.showUI5Panel(panel_name, panel_handle)
                                  .then(res => handle.send(reply + (res ? 'true' : 'false')));
                  },

                  onWebsocketClosed() {
                     // if connection failed,
                     handle.send(reply + 'false');
                  },

                  onWebsocketError() {
                     // if connection failed,
                     handle.send(reply + 'false');
                  }

               });

               let addr = handle.href;
               if (relative_path.indexOf('../') == 0) {
                  let ddd = addr.lastIndexOf('/',addr.length-2);
                  addr = addr.slice(0,ddd) + relative_path.slice(2);
               } else {
                  addr += relative_path;
               }
               // only when connection established, panel will be activated
               conn.connect(addr);
            }
         } else {
            console.log('Unrecognized command ' + cmd);
            handle.send(reply);
         }
      } else if ((msg.slice(0,7) == 'DXPROJ:') || (msg.slice(0,7) == 'DYPROJ:')) {
         let kind = msg[1],
             hist = parse(msg.slice(7));
         this.drawProjection(kind, hist);
      } else if (msg.slice(0,5) == 'SHOW:') {
         let that = msg.slice(5),
             on = that[that.length-1] == '1';
         this.showSection(that.slice(0,that.length-2), on);
      } else {
         console.log(`unrecognized msg len: ${msg.length} msg: ${msg.slice(0,30)}`);
      }
   }

   /** @summary Submit request to RDrawable object on server side */
   submitDrawableRequest(kind, req, painter, method) {

      if (!this._websocket || !req || !req._typename ||
          !painter.snapid || !isStr(painter.snapid)) return null;

      if (kind && method) {
         // if kind specified - check if such request already was submitted
         if (!painter._requests) painter._requests = {};

         let prevreq = painter._requests[kind];

         if (prevreq) {
            let tm = new Date().getTime();
            if (!prevreq._tm || (tm - prevreq._tm < 5000)) {
               prevreq._nextreq = req; // submit when got reply
               return false;
            }
            delete painter._requests[kind]; // let submit new request after timeout
         }

         painter._requests[kind] = req; // keep reference on the request
      }

      req.id = painter.snapid;

      if (method) {
         if (!this._nextreqid) this._nextreqid = 1;
         req.reqid = this._nextreqid++;
      } else {
         req.reqid = 0; // request will not be replied
      }

      let msg = JSON.stringify(req);

      if (req.reqid) {
         req._kind = kind;
         req._painter = painter;
         req._method = method;
         req._tm = new Date().getTime();

         if (!this._submreq) this._submreq = {};
         this._submreq[req.reqid] = req; // fast access to submitted requests
      }

      // console.log('Sending request ', msg.slice(0,60));

      this.sendWebsocket('REQ:' + msg);
      return req;
   }

   /** @summary Submit menu request
     * @private */
   async submitMenuRequest(painter, menukind, reqid) {
      return new Promise(resolveFunc => {
         this.submitDrawableRequest('', {
            _typename: 'ROOT::Experimental::RDrawableMenuRequest',
            menukind: menukind || '',
            menureqid: reqid, // used to identify menu request
         }, painter, resolveFunc);
      });
   }

   /** @summary Submit executable command for given painter */
   submitExec(painter, exec, subelem) {
      // snapid is intentionally ignored - only painter.snapid has to be used
      if (!this._websocket) return;

      if (subelem && isStr(subelem)) {
         let len = subelem.length;
         if ((len > 2) && (subelem.indexOf('#x') == len - 2)) subelem = 'x'; else
         if ((len > 2) && (subelem.indexOf('#y') == len - 2)) subelem = 'y'; else
         if ((len > 2) && (subelem.indexOf('#z') == len - 2)) subelem = 'z';

         if ((subelem == 'x') || (subelem == 'y') || (subelem == 'z'))
            exec = subelem + 'axis#' + exec;
         else
            return console.log(`not recoginzed subelem ${subelem} in SubmitExec`);
       }

      this.submitDrawableRequest('', {
         _typename: 'ROOT::Experimental::RDrawableExecRequest',
         exec: exec
      }, painter);
   }

   /** @summary Process reply from request to RDrawable */
   processDrawableReply(msg) {
      let reply = parse(msg);
      if (!reply || !reply.reqid || !this._submreq) return false;

      let req = this._submreq[reply.reqid];
      if (!req) return false;

      // remove reference first
      delete this._submreq[reply.reqid];

      // remove blocking reference for that kind
      if (req._kind && req._painter?._requests)
         if (req._painter._requests[req._kind] === req)
            delete req._painter._requests[req._kind];

      if (req._method)
         req._method(reply, req);

      // resubmit last request of that kind
      if (req._nextreq && !req._painter._requests[req._kind])
         this.submitDrawableRequest(req._kind, req._nextreq, req._painter, req._method);
   }

   /** @summary Show specified section in canvas */
   async showSection(that, on) {
      switch(that) {
         case 'Menu': break;
         case 'StatusBar': break;
         case 'Editor': break;
         case 'ToolBar': break;
         case 'ToolTips': this.setTooltipAllowed(on); break;
      }
      return true;
   }

   /** @summary Method informs that something was changed in the canvas
     * @desc used to update information on the server (when used with web6gui)
     * @private */
   processChanges(kind, painter, subelem) {
      // check if we could send at least one message more - for some meaningful actions
      if (!this._websocket || !this._websocket.canSend(2) || !isStr(kind)) return;
      if (!painter) painter = this;
      switch (kind) {
         case 'sbits':
            console.log('Status bits in RCanvas are changed - that to do?');
            break;
         case 'frame': // when moving frame
         case 'zoom':  // when changing zoom inside frame
            console.log('Frame moved or zoom is changed - that to do?');
            break;
         case 'pave_moved':
            console.log('TPave is moved inside RCanvas - that to do?');
            break;
         default:
            if ((kind.slice(0,5) == 'exec:') && painter?.snapid) {
               this.submitExec(painter, kind.slice(5), subelem);
            } else {
               console.log('UNPROCESSED CHANGES', kind);
            }
      }
   }

   /** @summary Handle pad button click event
     * @private */
   clickPadButton(funcname, evnt) {
      if (funcname == 'ToggleGed') return this.activateGed(this, null, 'toggle');
      if (funcname == 'ToggleStatus') return this.activateStatusBar('toggle');
      super.clickPadButton(funcname, evnt);
   }

   /** @summary returns true when event status area exist for the canvas */
   hasEventStatus() {
      if (this.testUI5()) return false;
      if (this.brlayout)
         return this.brlayout.hasStatus();
      let hp = getHPainter();
      return hp ? hp.hasStatusLine() : false;
   }

   /** @summary Show/toggle event status bar
     * @private */
   activateStatusBar(state) {
      if (this.testUI5()) return;
      if (this.brlayout)
         this.brlayout.createStatusLine(23, state);
      else
         getHPainter()?.createStatusLine(23, state);

      this.processChanges('sbits', this);
   }

   /** @summary Show online canvas status
     * @private */
   showCanvasStatus(...msgs) {
      if (this.testUI5()) return;

      let br = this.brlayout || getHPainter()?.brlayout;

      br?.showStatus(...msgs);
   }

   /** @summary Returns true if GED is present on the canvas */
   hasGed() {
      if (this.testUI5()) return false;
      return this.brlayout?.hasContent() ?? false;
   }

   /** @summary Function used to de-activate GED
     * @private */
   removeGed() {
      if (this.testUI5()) return;

      this.registerForPadEvents(null);

      if (this.ged_view) {
         this.ged_view.getController().cleanupGed();
         this.ged_view.destroy();
         delete this.ged_view;
      }
      this.brlayout?.deleteContent(true);
      this.processChanges('sbits', this);
   }

   /** @summary Get view data for ui5 panel
     * @private */
   getUi5PanelData(/* panel_name */) {
      return { jsroot: { settings, create: create$1, parse, toJSON, loadScript, EAxisBits, getColorExec } };
   }

   /** @summary Function used to activate GED
     * @return {Promise} when GED is there
     * @private */
   async activateGed(objpainter, kind, mode) {
      if (this.testUI5() || !this.brlayout)
         return false;

      if (this.brlayout.hasContent()) {
         if ((mode === 'toggle') || (mode === false))
            this.removeGed();
         else
            objpainter?.getPadPainter()?.selectObjectPainter(objpainter);

         return true;
      }

      if (mode === false)
         return false;

      let btns = this.brlayout.createBrowserBtns();

      ToolbarIcons.createSVG(btns, ToolbarIcons.diamand, 15, 'toggle fix-pos mode')
                  .style('margin','3px').on('click', () => this.brlayout.toggleKind('fix'));

      ToolbarIcons.createSVG(btns, ToolbarIcons.circle, 15, 'toggle float mode')
                  .style('margin','3px').on('click', () => this.brlayout.toggleKind('float'));

      ToolbarIcons.createSVG(btns, ToolbarIcons.cross, 15, 'delete GED')
                  .style('margin','3px').on('click', () => this.removeGed());

      // be aware, that jsroot_browser_hierarchy required for flexible layout that element use full browser area
      this.brlayout.setBrowserContent("<div class='jsroot_browser_hierarchy' id='ged_placeholder'>Loading GED ...</div>");
      this.brlayout.setBrowserTitle('GED');
      this.brlayout.toggleBrowserKind(kind || 'float');

      return new Promise(resolveFunc => {

         loadOpenui5.then(sap => {

            select('#ged_placeholder').text('');

            sap.ui.define(['sap/ui/model/json/JSONModel', 'sap/ui/core/mvc/XMLView'], (JSONModel,XMLView) => {

               let oModel = new JSONModel({ handle: null });

               XMLView.create({
                  viewName: 'rootui5.canv.view.Ged',
                  viewData: this.getUi5PanelData('Ged')
               }).then(oGed => {

                  oGed.setModel(oModel);

                  oGed.placeAt('ged_placeholder');

                  this.ged_view = oGed;

                  // TODO: should be moved into Ged controller - it must be able to detect canvas painter itself
                  this.registerForPadEvents(oGed.getController().padEventsReceiver.bind(oGed.getController()));

                  objpainter?.getPadPainter()?.selectObjectPainter(objpainter);

                  this.processChanges('sbits', this);

                  resolveFunc(true);
               });
            });
         });
      });
   }

   /** @summary produce JSON for RCanvas, which can be used to display canvas once again
     * @private */
   produceJSON() {
      console.error('RCanvasPainter.produceJSON not yet implemented');
      return '';
   }

   /** @summary draw RCanvas object */
   static async draw(dom, can /*, opt */) {
      let nocanvas = !can;
      if (nocanvas)
         can = create$1('ROOT::Experimental::RCanvas');

      let painter = new RCanvasPainter(dom, can);
      painter.normal_canvas = !nocanvas;
      painter.createCanvasSvg(0);

      selectActivePad({ pp: painter, active: false });

      return painter.drawPrimitives().then(() => {
         painter.addPadButtons();
         painter.showPadButtons();
         return painter;
      });
   }

} // class RCanvasPainter


/** @summary draw RPadSnapshot object
  * @private */
function drawRPadSnapshot(dom, snap /*, opt*/) {
   let painter = new RCanvasPainter(dom, null);
   painter.normal_canvas = false;
   painter.batch_mode = isBatchMode();
   return painter.syncDraw(true).then(() => painter.redrawPadSnap(snap)).then(() => {
      painter.confirmDraw();
      painter.showPadButtons();
      return painter;
   });
}

/** @summary Ensure RCanvas and RFrame for the painter object
  * @param {Object} painter  - painter object to process
  * @param {string|boolean} frame_kind  - false for no frame or '3d' for special 3D mode
  * @desc Assigns DOM, creates and draw RCanvas and RFrame if necessary, add painter to pad list of painters
  * @return {Promise} for ready */
async function ensureRCanvas(painter, frame_kind) {
   if (!painter)
      return Promise.reject(Error('Painter not provided in ensureRCanvas'));

   // simple check - if canvas there, can use painter
   let pr = painter.getCanvSvg().empty() ? RCanvasPainter.draw(painter.getDom(), null /* , noframe */) : Promise.resolve(true);

   return pr.then(() => {
      if ((frame_kind !== false) && painter.getFrameSvg().select('.main_layer').empty())
         return RFramePainter.draw(painter.getDom(), null, isStr(frame_kind) ? frame_kind : '');
   }).then(() => {
      painter.addToPadPrimitives();
      return painter;
   });
}


/** @summary Function used for direct draw of RFrameTitle
  * @private */
function drawRFrameTitle(reason, drag) {
   let fp = this.getFramePainter();
   if (!fp)
      return console.log('no frame painter - no title');

   let rect         = fp.getFrameRect(),
       fx           = rect.x,
       fy           = rect.y,
       fw           = rect.width,
       // fh           = rect.height,
       ph           = this.getPadPainter().getPadHeight(),
       title        = this.getObject(),
       title_margin = this.v7EvalLength('margin', ph, 0.02),
       title_width  = fw,
       title_height = this.v7EvalLength('height', ph, 0.05),
       textFont     = this.v7EvalFont('text', { size: 0.07, color: 'black', align: 22 });

   if (reason == 'drag') {
      title_height = drag.height;
      title_margin = fy - drag.y - drag.height;
      let changes = {};
      this.v7AttrChange(changes, 'margin', title_margin / ph);
      this.v7AttrChange(changes, 'height', title_height / ph);
      this.v7SendAttrChanges(changes, false); // do not invoke canvas update on the server
   }

   this.createG();

   this.draw_g.attr('transform',`translate(${fx},${Math.round(fy-title_margin-title_height)})`);

   let arg = { x: title_width/2, y: title_height/2, text: title.fText, latex: 1 };

   this.startTextDrawing(textFont, 'font');

   this.drawText(arg);

   return this.finishTextDrawing().then(() => {
      if (!isBatchMode())
        addDragHandler(this, { x: fx, y: Math.round(fy-title_margin-title_height), width: title_width, height: title_height,
                               minwidth: 20, minheight: 20, no_change_x: true, redraw: d => this.redraw('drag', d) });
   });
}

////////////////////////////////////////////////////////////////////////////////////////////

registerMethods('ROOT::Experimental::RPalette', {

   extractRColor(rcolor) {
     return rcolor.fColor || 'black';
   },

   getColor(indx) {
      return this.palette[indx];
   },

   getContourIndex(zc) {
      let cntr = this.fContour, l = 0, r = cntr.length-1, mid;

      if (zc < cntr[0]) return -1;
      if (zc >= cntr[r]) return r-1;

      if (this.fCustomContour) {
         while (l < r-1) {
            mid = Math.round((l+r)/2);
            if (cntr[mid] > zc) r = mid; else l = mid;
         }
         return l;
      }

      // last color in palette starts from level cntr[r-1]
      return Math.floor((zc-cntr[0]) / (cntr[r-1] - cntr[0]) * (r-1));
   },

   getContourColor(zc) {
      let zindx = this.getContourIndex(zc);
      return (zindx < 0) ? '' : this.getColor(zindx);
   },

   getContour() {
      return this.fContour && (this.fContour.length > 1) ? this.fContour : null;
   },

   deleteContour() {
      delete this.fContour;
   },

   calcColor(value, entry1, entry2) {
      let dist = entry2.fOrdinal - entry1.fOrdinal,
          r1 = entry2.fOrdinal - value,
          r2 = value - entry1.fOrdinal;

      if (!this.fInterpolate || (dist <= 0))
         return (r1 < r2) ? entry2.fColor : entry1.fColor;

      // interpolate
      let col1 = rgb(this.extractRColor(entry1.fColor)),
          col2 = rgb(this.extractRColor(entry2.fColor)),
          color = rgb(Math.round((col1.r*r1 + col2.r*r2)/dist),
                         Math.round((col1.g*r1 + col2.g*r2)/dist),
                         Math.round((col1.b*r1 + col2.b*r2)/dist));

      return color.toString();
   },

   createPaletteColors(len) {
      let arr = [], indx = 0;

      while (arr.length < len) {
         let value = arr.length / (len-1);

         let entry = this.fColors[indx];

         if ((Math.abs(entry.fOrdinal - value) < 0.0001) || (indx == this.fColors.length - 1)) {
            arr.push(this.extractRColor(entry.fColor));
            continue;
         }

         let next = this.fColors[indx+1];
         if (next.fOrdinal <= value)
            indx++;
         else
            arr.push(this.calcColor(value, entry, next));
      }

      return arr;
   },

   getColorOrdinal(value) {
      // extract color with ordinal value between 0 and 1
      if (!this.fColors)
         return 'black';
      if ((typeof value != 'number') || (value < 0))
         value = 0;
      else if (value > 1)
         value = 1;

      // TODO: implement better way to find index

      let entry, next = this.fColors[0];
      for (let indx = 0; indx < this.fColors.length-1; ++indx) {
         entry = next;

         if (Math.abs(entry.fOrdinal - value) < 0.0001)
            return this.extractRColor(entry.fColor);

         next = this.fColors[indx+1];
         if (next.fOrdinal > value)
            return this.calcColor(value, entry, next);
      }

      return this.extractRColor(next.fColor);
   },

   setFullRange(min, max) {
      // set full z scale range, used in zooming
      this.full_min = min;
      this.full_max = max;
   },

   createContour(logz, nlevels, zmin, zmax, zminpositive) {
      this.fContour = [];
      delete this.fCustomContour;
      this.colzmin = zmin;
      this.colzmax = zmax;

      if (logz) {
         if (this.colzmax <= 0) this.colzmax = 1.;
         if (this.colzmin <= 0)
            if ((zminpositive === undefined) || (zminpositive <= 0))
               this.colzmin = 0.0001*this.colzmax;
            else
               this.colzmin = ((zminpositive < 3) || (zminpositive>100)) ? 0.3*zminpositive : 1;
         if (this.colzmin >= this.colzmax) this.colzmin = 0.0001*this.colzmax;

         let logmin = Math.log(this.colzmin)/Math.log(10),
             logmax = Math.log(this.colzmax)/Math.log(10),
             dz = (logmax-logmin)/nlevels;
         this.fContour.push(this.colzmin);
         for (let level=1; level<nlevels; level++)
            this.fContour.push(Math.exp((logmin + dz*level)*Math.log(10)));
         this.fContour.push(this.colzmax);
         this.fCustomContour = true;
      } else {
         if ((this.colzmin === this.colzmax) && (this.colzmin !== 0)) {
            this.colzmax += 0.01*Math.abs(this.colzmax);
            this.colzmin -= 0.01*Math.abs(this.colzmin);
         }
         let dz = (this.colzmax-this.colzmin)/nlevels;
         for (let level=0; level<=nlevels; level++)
            this.fContour.push(this.colzmin + dz*level);
      }

      if (!this.palette || (this.palette.length != nlevels))
         this.palette = this.createPaletteColors(nlevels);
   }

});

/** @summary draw RFont object
  * @private */
function drawRFont() {
   let font   = this.getObject(),
       svg    = this.getCanvSvg(),
       defs   = svg.select('.canvas_defs'),
       clname = 'custom_font_' + font.fFamily+font.fWeight+font.fStyle;

   if (defs.empty())
      defs = svg.insert('svg:defs', ':first-child').attr('class', 'canvas_defs');

   let entry = defs.select('.' + clname);
   if (entry.empty())
      entry = defs.append('style').attr('type', 'text/css').attr('class', clname);

   entry.text(`@font-face { font-family: "${font.fFamily}"; font-weight: ${font.fWeight ? font.fWeight : "normal"}; font-style: ${font.fStyle ? font.fStyle : "normal"}; src: ${font.fSrc}; }`);

   if (font.fDefault)
      this.getPadPainter()._dfltRFont = font;

   return true;
}

/** @summary draw RAxis object
  * @private */
function drawRAxis(dom, obj, opt) {
   let painter = new RAxisPainter(dom, obj, opt);
   painter.disable_zooming = true;
   return ensureRCanvas(painter, false)
           .then(() => painter.redraw())
           .then(() => painter);
}

/** @summary draw RFrame object
  * @private */
function drawRFrame(dom, obj, opt) {
   let p = new RFramePainter(dom, obj);
   if (opt == '3d') p.mode3d = true;
   return ensureRCanvas(p, false).then(() => p.redraw());
}

var RCanvasPainter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
ensureRCanvas: ensureRCanvas,
drawRPadSnapshot: drawRPadSnapshot,
drawRFrameTitle: drawRFrameTitle,
drawRFont: drawRFont,
drawRAxis: drawRAxis,
drawRFrame: drawRFrame,
RObjectPainter: RObjectPainter,
RPadPainter: RPadPainter,
RCanvasPainter: RCanvasPainter
});

/** @summary draw RText object
  * @private */
function drawText() {
   let text      = this.getObject(),
       pp        = this.getPadPainter(),
       onframe   = this.v7EvalAttr('onFrame', false) ? pp.getFramePainter() : null,
       clipping  = onframe ? this.v7EvalAttr('clipping', false) : false,
       p         = pp.getCoordinate(text.fPos, onframe),
       textFont  = this.v7EvalFont('text', { size: 12, color: 'black', align: 22 });

   this.createG(clipping ? 'main_layer' : (onframe ? 'upper_layer' : false));

   this.startTextDrawing(textFont, 'font');

   this.drawText({ x: p.x, y: p.y, text: text.fText, latex: 1 });

   return this.finishTextDrawing();
}

/** @summary draw RLine object
  * @private */
function drawLine() {

    let line     = this.getObject(),
        pp       = this.getPadPainter(),
        onframe  = this.v7EvalAttr('onFrame', false) ? pp.getFramePainter() : null,
        clipping = onframe ? this.v7EvalAttr('clipping', false) : false,
        p1       = pp.getCoordinate(line.fP1, onframe),
        p2       = pp.getCoordinate(line.fP2, onframe);

    this.createG(clipping ? 'main_layer' : (onframe ? 'upper_layer' : false));

    this.createv7AttLine();

    this.draw_g
        .append('svg:path')
        .attr('d',`M${p1.x},${p1.y}L${p2.x},${p2.y}`)
        .call(this.lineatt.func);
}

/** @summary draw RBox object
  * @private */
function drawBox() {

   let box      = this.getObject(),
       pp       = this.getPadPainter(),
       onframe  = this.v7EvalAttr('onFrame', false) ? pp.getFramePainter() : null,
       clipping = onframe ? this.v7EvalAttr('clipping', false) : false,
       p1       = pp.getCoordinate(box.fP1, onframe),
       p2       = pp.getCoordinate(box.fP2, onframe);

   this.createG(clipping ? 'main_layer' : (onframe ? 'upper_layer' : false));

   this.createv7AttLine('border_');

   this.createv7AttFill();

   this.draw_g
       .append('svg:path')
       .attr('d',`M${p1.x},${p1.y}H${p2.x}V${p2.y}H${p1.x}Z`)
       .call(this.lineatt.func)
       .call(this.fillatt.func);
}

/** @summary draw RMarker object
  * @private */
function drawMarker() {
    let marker   = this.getObject(),
        pp       = this.getPadPainter(),
        onframe  = this.v7EvalAttr('onFrame', false) ? pp.getFramePainter() : null,
        clipping = onframe ? this.v7EvalAttr('clipping', false) : false,
        p        = pp.getCoordinate(marker.fP, onframe);

    this.createG(clipping ? 'main_layer' : (onframe ? 'upper_layer' : false));

    this.createv7AttMarker();

    let path = this.markeratt.create(p.x, p.y);

    if (path)
       this.draw_g.append('svg:path')
                  .attr('d', path)
                  .call(this.markeratt.func);
}

/** @summary painter for RPalette
 *
 * @private
 */

class RPalettePainter extends RObjectPainter {

   /** @summary get palette */
   getHistPalette() {
      let drawable = this.getObject(),
          pal = drawable ? drawable.fPalette : null;

      if (pal && !pal.getColor)
         addMethods(pal, 'ROOT::Experimental::RPalette');

      return pal;
   }

   /** @summary Draw palette */
   drawPalette(drag) {

      let palette = this.getHistPalette(),
          contour = palette.getContour(),
          framep = this.getFramePainter();

      if (!contour)
         return console.log('no contour - no palette');

      // frame painter must  be there
      if (!framep)
         return console.log('no frame painter - no palette');

      let gmin         = palette.full_min,
          gmax         = palette.full_max,
          zmin         = contour[0],
          zmax         = contour[contour.length-1],
          rect         = framep.getFrameRect(),
          pad_width    = this.getPadPainter().getPadWidth(),
          pad_height   = this.getPadPainter().getPadHeight(),
          visible      = this.v7EvalAttr('visible', true),
          vertical     = this.v7EvalAttr('vertical', true),
          palette_x, palette_y, palette_width, palette_height;

      if (drag) {
         palette_width = drag.width;
         palette_height = drag.height;

         let changes = {};
         if (vertical) {
            this.v7AttrChange(changes, 'margin', (drag.x - rect.x - rect.width) / pad_width);
            this.v7AttrChange(changes, 'width', palette_width / pad_width);
         } else {
            this.v7AttrChange(changes, 'margin', (drag.y - rect.y - rect.height) / pad_width);
            this.v7AttrChange(changes, 'width', palette_height / pad_height);
         }
         this.v7SendAttrChanges(changes, false); // do not invoke canvas update on the server
      } else {
          if (vertical) {
            let margin = this.v7EvalLength('margin', pad_width, 0.02);
            palette_x = Math.round(rect.x + rect.width + margin);
            palette_width = this.v7EvalLength('width', pad_width, 0.05);
            palette_y = rect.y;
            palette_height = rect.height;
          } else {
            let margin = this.v7EvalLength('margin', pad_height, 0.02);
            palette_x = rect.x;
            palette_width = rect.width;
            palette_y = Math.round(rect.y + rect.height + margin);
            palette_height = this.v7EvalLength('width', pad_height, 0.05);
          }

          // x,y,width,height attributes used for drag functionality
          this.draw_g.attr('transform',`translate(${palette_x},${palette_y})`);
      }

      let g_btns = this.draw_g.select('.colbtns');
      if (g_btns.empty())
         g_btns = this.draw_g.append('svg:g').attr('class', 'colbtns');
      else
         g_btns.selectAll('*').remove();

      if (!visible) return;

      g_btns.append('svg:path')
          .attr('d', `M0,0H${palette_width}V${palette_height}H0Z`)
          .style('stroke', 'black')
          .style('fill', 'none');

      if ((gmin === undefined) || (gmax === undefined)) { gmin = zmin; gmax = zmax; }

      if (vertical)
         framep.z_handle.configureAxis('zaxis', gmin, gmax, zmin, zmax, true, [palette_height, 0], -palette_height, { reverse: false });
      else
         framep.z_handle.configureAxis('zaxis', gmin, gmax, zmin, zmax, false, [0, palette_width], palette_width, { reverse: false });

      for (let i = 0; i < contour.length-1; ++i) {
         let z0 = Math.round(framep.z_handle.gr(contour[i])),
             z1 = Math.round(framep.z_handle.gr(contour[i+1])),
             col = palette.getContourColor((contour[i]+contour[i+1])/2);

         let r = g_btns.append('svg:path')
                     .attr('d', vertical ? `M0,${z1}H${palette_width}V${z0}H0Z` : `M${z0},0V${palette_height}H${z1}V0Z`)
                     .style('fill', col)
                     .style('stroke', col)
                     .property('fill0', col)
                     .property('fill1', rgb(col).darker(0.5).toString());

         if (this.isTooltipAllowed())
            r.on('mouseover', function() {
               select(this).transition().duration(100).style('fill', select(this).property('fill1'));
            }).on('mouseout', function() {
               select(this).transition().duration(100).style('fill', select(this).property('fill0'));
            }).append('svg:title').text(contour[i].toFixed(2) + ' - ' + contour[i+1].toFixed(2));

         if (settings.Zooming)
            r.on('dblclick', () => framep.unzoom('z'));
      }

      framep.z_handle.maxTickSize = Math.round(palette_width*0.3);

      let promise = framep.z_handle.drawAxis(this.draw_g, vertical ? `translate(${palette_width},${palette_height})` : `translate(0,${palette_height})`, vertical ? -1 : 1);

      if (isBatchMode() || drag)
         return promise;

      return promise.then(() => {

         if (settings.ContextMenu)
            this.draw_g.on('contextmenu', evnt => {
               evnt.stopPropagation(); // disable main context menu
               evnt.preventDefault();  // disable browser context menu
               createMenu$1(evnt, this).then(menu => {
                  menu.add('header:Palette');
                  menu.addchk(vertical, 'Vertical', flag => { this.v7SetAttr('vertical', flag); this.redrawPad(); });
                  framep.z_handle.fillAxisContextMenu(menu, 'z');
                  menu.show();
               });
            });

         addDragHandler(this, { x: palette_x, y: palette_y, width: palette_width, height: palette_height,
                                minwidth: 20, minheight: 20, no_change_x: !vertical, no_change_y: vertical, redraw: d => this.drawPalette(d) });

         if (!settings.Zooming) return;

         let doing_zoom = false, sel1 = 0, sel2 = 0, zoom_rect, zoom_rect_visible, moving_labels, last_pos;

         const moveRectSel = evnt => {

            if (!doing_zoom) return;
            evnt.preventDefault();

            last_pos = pointer(evnt, this.draw_g.node());

            if (moving_labels)
               return framep.z_handle.processLabelsMove('move', last_pos);

            if (vertical)
               sel2 = Math.min(Math.max(last_pos[1], 0), palette_height);
            else
               sel2 = Math.min(Math.max(last_pos[0], 0), palette_width);

            let sz = Math.abs(sel2-sel1);

            if (!zoom_rect_visible && (sz > 1)) {
               zoom_rect.style('display', null);
               zoom_rect_visible = true;
            }

            if (vertical)
               zoom_rect.attr('y', Math.min(sel1, sel2)).attr('height', sz);
            else
               zoom_rect.attr('x', Math.min(sel1, sel2)).attr('width', sz);
         }, endRectSel = evnt => {
            if (!doing_zoom) return;

            evnt.preventDefault();
            select(window).on('mousemove.colzoomRect', null)
                             .on('mouseup.colzoomRect', null);
            zoom_rect.remove();
            zoom_rect = null;
            doing_zoom = false;

            if (moving_labels) {
               framep.z_handle.processLabelsMove('stop', last_pos);
            } else {
               let z = framep.z_handle.func, z1 = z.invert(sel1), z2 = z.invert(sel2);
               this.getFramePainter().zoom('z', Math.min(z1, z2), Math.max(z1, z2));
            }
         }, startRectSel = evnt => {
            // ignore when touch selection is activated
            if (doing_zoom) return;
            doing_zoom = true;

            evnt.preventDefault();
            evnt.stopPropagation();

            last_pos = pointer(evnt, this.draw_g.node());
            sel1 = sel2 = last_pos[vertical ? 1 : 0];
            zoom_rect_visible = false;
            moving_labels = false;
            zoom_rect = g_btns
                 .append('svg:rect')
                 .attr('class', 'zoom')
                 .attr('id', 'colzoomRect')
                 .style('display', 'none');
            if (vertical)
               zoom_rect.attr('x', 0).attr('width', palette_width).attr('y', sel1).attr('height', 1);
            else
               zoom_rect.attr('x', sel1).attr('width', 1).attr('y', 0).attr('height', palette_height);

            select(window).on('mousemove.colzoomRect', moveRectSel)
                             .on('mouseup.colzoomRect', endRectSel, true);

            setTimeout(() => {
               if (!zoom_rect_visible && doing_zoom)
                  moving_labels = framep.z_handle.processLabelsMove('start', last_pos);
            }, 500);
         },  assignHandlers = () => {
            this.draw_g.selectAll('.axis_zoom, .axis_labels')
                       .on('mousedown', startRectSel)
                       .on('dblclick', () => framep.unzoom('z'));

            if (settings.ZoomWheel)
               this.draw_g.on('wheel', evnt => {
                  evnt.stopPropagation();
                  evnt.preventDefault();

                  let pos = pointer(evnt, this.draw_g.node()),
                      coord = vertical ? (1 - pos[1] / palette_height) : pos[0] / palette_width;

                  let item = framep.z_handle.analyzeWheelEvent(evnt, coord);
                  if (item.changed)
                     framep.zoom('z', item.min, item.max);
               });
         };

         framep.z_handle.setAfterDrawHandler(assignHandlers);

         assignHandlers();
      });
   }

   /** @summary draw RPalette object */
   static async draw(dom, palette, opt) {
      let painter = new RPalettePainter(dom, palette, opt, 'palette');
      return ensureRCanvas(painter, false).then(() => {
         painter.createG(); // just create container, real drawing will be done by histogram
         return painter;
      });
   }

} // class RPalettePainter

var v7more = /*#__PURE__*/Object.freeze({
__proto__: null,
RPalettePainter: RPalettePainter,
drawText: drawText,
drawLine: drawLine,
drawBox: drawBox,
drawMarker: drawMarker
});

const ECorner = { kTopLeft: 1, kTopRight: 2, kBottomLeft: 3, kBottomRight: 4 };

/**
 * @summary Painter for RPave class
 *
 * @private
 */

class RPavePainter extends RObjectPainter {

   /** @summary Draw pave content
     * @desc assigned depending on pave class */
   async drawContent() { return this; }

   /** @summary Draw pave */
   async drawPave() {

      let rect = this.getPadPainter().getPadRect(),
          fp = this.getFramePainter();

      this.onFrame = fp && this.v7EvalAttr('onFrame', true);
      this.corner = this.v7EvalAttr('corner', ECorner.kTopRight);

      let visible      = this.v7EvalAttr('visible', true),
          offsetx      = this.v7EvalLength('offsetX', rect.width, 0.02),
          offsety      = this.v7EvalLength('offsetY', rect.height, 0.02),
          pave_width   = this.v7EvalLength('width', rect.width, 0.3),
          pave_height  = this.v7EvalLength('height', rect.height, 0.3);

      this.createG();

      this.draw_g.classed('most_upper_primitives', true); // this primitive will remain on top of list

      if (!visible)
         return this;

      this.createv7AttLine('border_');

      this.createv7AttFill();

      let pave_x = 0, pave_y = 0,
          fr = this.onFrame ? fp.getFrameRect() : rect;
      switch (this.corner) {
         case ECorner.kTopLeft:
            pave_x = fr.x + offsetx;
            pave_y = fr.y + offsety;
            break;
         case ECorner.kBottomLeft:
            pave_x = fr.x + offsetx;
            pave_y = fr.y + fr.height - offsety - pave_height;
            break;
         case ECorner.kBottomRight:
            pave_x = fr.x + fr.width - offsetx - pave_width;
            pave_y = fr.y + fr.height - offsety - pave_height;
            break;
         case ECorner.kTopRight:
         default:
            pave_x = fr.x + fr.width - offsetx - pave_width;
            pave_y = fr.y + offsety;
      }

      this.draw_g.attr('transform', `translate(${pave_x},${pave_y})`);

      this.draw_g.append('svg:rect')
                 .attr('x', 0)
                 .attr('width', pave_width)
                 .attr('y', 0)
                 .attr('height', pave_height)
                 .call(this.lineatt.func)
                 .call(this.fillatt.func);

      this.pave_width = pave_width;
      this.pave_height = pave_height;

      // here should be fill and draw of text

      return this.drawContent().then(() => {

         if (isBatchMode()) return this;

         // TODO: provide pave context menu as in v6
         if (settings.ContextMenu && this.paveContextMenu)
            this.draw_g.on('contextmenu', evnt => this.paveContextMenu(evnt));

         addDragHandler(this, { x: pave_x, y: pave_y, width: pave_width, height: pave_height,
                                minwidth: 20, minheight: 20, redraw: d => this.sizeChanged(d) });

         return this;
      });
   }

   /** @summary Process interactive moving of the stats box */
   sizeChanged(drag) {
      this.pave_width = drag.width;
      this.pave_height = drag.height;

      let pave_x = drag.x,
          pave_y = drag.y,
          rect = this.getPadPainter().getPadRect(),
          fr = this.onFrame ? this.getFramePainter().getFrameRect() : rect,
          offsetx = 0, offsety = 0, changes = {};

      switch (this.corner) {
         case ECorner.kTopLeft:
            offsetx = pave_x - fr.x;
            offsety = pave_y - fr.y;
            break;
         case ECorner.kBottomLeft:
            offsetx = pave_x - fr.x;
            offsety = fr.y + fr.height - pave_y - this.pave_height;
            break;
         case ECorner.kBottomRight:
            offsetx = fr.x + fr.width - pave_x - this.pave_width;
            offsety = fr.y + fr.height - pave_y - this.pave_height;
            break;
         case ECorner.kTopRight:
         default:
            offsetx = fr.x + fr.width - pave_x - this.pave_width;
            offsety = pave_y - fr.y;
      }

      this.v7AttrChange(changes, 'offsetX', offsetx / rect.width);
      this.v7AttrChange(changes, 'offsetY', offsety / rect.height);
      this.v7AttrChange(changes, 'width', this.pave_width / rect.width);
      this.v7AttrChange(changes, 'height', this.pave_height / rect.height);
      this.v7SendAttrChanges(changes, false); // do not invoke canvas update on the server

      this.draw_g.select('rect')
                 .attr('width', this.pave_width)
                 .attr('height', this.pave_height);

      this.drawContent();
   }

   /** @summary Redraw RPave object */
   async redraw(/*reason*/) {
      return this.drawPave();
   }

   /** @summary draw RPave object */
   static async draw(dom, pave, opt) {
      let painter = new RPavePainter(dom, pave, opt, 'pave');
      return ensureRCanvas(painter, false).then(() => painter.drawPave());
   }
}


/**
 * @summary Painter for RLegend class
 *
 * @private
 */

class RLegendPainter extends RPavePainter {

   /** @summary draw RLegend content */
   async drawContent() {
      let legend     = this.getObject(),
          textFont   = this.v7EvalFont('text', { size: 12, color: 'black', align: 22 }),
          width      = this.pave_width,
          height     = this.pave_height,
          nlines     = legend.fEntries.length,
          pp         = this.getPadPainter();

      if (legend.fTitle) nlines++;

      if (!nlines || !pp) return this;

      let stepy = height / nlines, posy = 0, margin_x = 0.02 * width;

      textFont.setSize(height/(nlines * 1.2));
      this.startTextDrawing(textFont, 'font');

      if (legend.fTitle) {
         this.drawText({ latex: 1, width: width - 2*margin_x, height: stepy, x: margin_x, y: posy, text: legend.fTitle });
         posy += stepy;
      }

      for (let i = 0; i < legend.fEntries.length; ++i) {
         let objp = null, entry = legend.fEntries[i], w4 = Math.round(width/4);

         this.drawText({ latex: 1, width: 0.75*width - 3*margin_x, height: stepy, x: 2*margin_x + w4, y: posy, text: entry.fLabel });

         if (entry.fDrawableId != 'custom') {
            objp = pp.findSnap(entry.fDrawableId, true);
         } else if (entry.fDrawable.fIO) {
            objp = new RObjectPainter(this.getDom(), entry.fDrawable.fIO);
            if (entry.fLine) objp.createv7AttLine();
            if (entry.fFill) objp.createv7AttFill();
            if (entry.fMarker) objp.createv7AttMarker();
         }

         if (objp && entry.fFill && objp.fillatt)
            this.draw_g
              .append('svg:path')
              .attr('d', `M${Math.round(margin_x)},${Math.round(posy + stepy*0.1)}h${w4}v${Math.round(stepy*0.8)}h${-w4}z`)
              .call(objp.fillatt.func);

         if (objp && entry.fLine && objp.lineatt)
            this.draw_g
              .append('svg:path')
              .attr('d', `M${Math.round(margin_x)},${Math.round(posy + stepy/2)}h${w4}`)
              .call(objp.lineatt.func);

         if (objp && entry.fError && objp.lineatt)
            this.draw_g
              .append('svg:path')
              .attr('d', `M${Math.round(margin_x + width/8)},${Math.round(posy + stepy*0.2)}v${Math.round(stepy*0.6)}`)
              .call(objp.lineatt.func);

         if (objp && entry.fMarker && objp.markeratt)
            this.draw_g.append('svg:path')
                .attr('d', objp.markeratt.create(margin_x + width/8, posy + stepy/2))
                .call(objp.markeratt.func);

         posy += stepy;
      }

      return this.finishTextDrawing();
   }

   /** @summary draw RLegend object */
   static async draw(dom, legend, opt) {
      let painter = new RLegendPainter(dom, legend, opt, 'legend');
      return ensureRCanvas(painter, false).then(() => painter.drawPave());
   }

} // class RLegendPainter


/**
 * @summary Painter for RPaveText class
 *
 * @private
 */

class RPaveTextPainter extends RPavePainter {

   /** @summary draw RPaveText content */
   drawContent() {
      let pavetext  = this.getObject(),
          textFont  = this.v7EvalFont('text', { size: 12, color: 'black', align: 22 }),
          width     = this.pave_width,
          height    = this.pave_height,
          nlines    = pavetext.fText.length;

      if (!nlines) return;

      let stepy = height / nlines, posy = 0, margin_x = 0.02 * width;

      textFont.setSize(height/(nlines * 1.2));

      this.startTextDrawing(textFont, 'font');

      for (let i = 0; i < pavetext.fText.length; ++i) {
         let line = pavetext.fText[i];

         this.drawText({ latex: 1, width: width - 2*margin_x, height: stepy, x: margin_x, y: posy, text: line });
         posy += stepy;
      }

      return this.finishTextDrawing(undefined, true);
   }

   /** @summary draw RPaveText object */
   static async draw(dom, pave, opt) {
      let painter = new RPaveTextPainter(dom, pave, opt, 'pavetext');
      return ensureRCanvas(painter, false).then(() => painter.drawPave());
   }

} // class RPaveTextPainter

/**
 * @summary Painter for RHistStats class
 *
 * @private
 */

class RHistStatsPainter extends RPavePainter {

   /** @summary clear entries from stat box */
   clearStat() {
      this.stats_lines = [];
   }

   /** @summary add text entry to stat box */
   addText(line) {
      this.stats_lines.push(line);
   }

   /** @summary update statistic from the server */
   updateStatistic(reply) {
      this.stats_lines = reply.lines;
      this.drawStatistic(this.stats_lines);
   }

   /** @summary fill statistic */
   fillStatistic() {
      let pp = this.getPadPainter();
      if (pp?._fast_drawing) return false;

      let obj = this.getObject();
      if (obj.fLines !== undefined) {
         this.stats_lines = obj.fLines;
         delete obj.fLines;
         return true;
      }

      if (this.v7OfflineMode()) {
         let main = this.getMainPainter();
         if (!isFunc(main?.fillStatistic)) return false;
         // we take statistic from main painter
         return main.fillStatistic(this, gStyle.fOptStat, gStyle.fOptFit);
      }

      // show lines which are exists, maybe server request will be recieved later
      return (this.stats_lines !== undefined);
   }

   /** @summary format float value as string
     * @private */
   format(value, fmt) {
      if (!fmt) fmt = 'stat';

      switch(fmt) {
         case 'stat' : fmt = gStyle.fStatFormat; break;
         case 'fit': fmt = gStyle.fFitFormat; break;
         case 'entries': if ((Math.abs(value) < 1e9) && (Math.round(value) == value)) return value.toFixed(0); fmt = '14.7g'; break;
         case 'last': fmt = this.lastformat; break;
      }

      let res = floatToString(value, fmt || '6.4g', true);

      this.lastformat = res[1];

      return res[0];
   }

   /** @summary Draw content */
   async drawContent() {
      if (this.fillStatistic())
         return this.drawStatistic(this.stats_lines);

      return this;
   }

   /** @summary Change mask */
   changeMask(nbit) {
      let obj = this.getObject(), mask = (1<<nbit);
      if (obj.fShowMask & mask)
         obj.fShowMask = obj.fShowMask & ~mask;
      else
         obj.fShowMask = obj.fShowMask | mask;

      if (this.fillStatistic())
         this.drawStatistic(this.stats_lines);
   }

   /** @summary Context menu */
   statsContextMenu(evnt) {
      evnt.preventDefault();
      evnt.stopPropagation(); // disable main context menu

      createMenu(evnt, this).then(menu => {
         let obj = this.getObject(),
             action = this.changeMask.bind(this);

         menu.add('header: StatBox');

         for (let n=0;n<obj.fEntries.length; ++n)
            menu.addchk((obj.fShowMask & (1<<n)), obj.fEntries[n], n, action);

         return this.fillObjectExecMenu(menu);
     }).then(menu => menu.show());
   }

   /** @summary Draw statistic */
   async drawStatistic(lines) {

      let textFont = this.v7EvalFont('stats_text', { size: 12, color: 'black', align: 22 }),
          first_stat = 0, num_cols = 0, maxlen = 0,
          width = this.pave_width,
          height = this.pave_height;

      if (!lines) return this;

      let nlines = lines.length;
      // adjust font size
      for (let j = 0; j < nlines; ++j) {
         let line = lines[j];
         if (j > 0) maxlen = Math.max(maxlen, line.length);
         if ((j == 0) || (line.indexOf('|') < 0)) continue;
         if (first_stat === 0) first_stat = j;
         let parts = line.split('|');
         if (parts.length > num_cols)
            num_cols = parts.length;
      }

      // for characters like 'p' or 'y' several more pixels required to stay in the box when drawn in last line
      let stepy = height / nlines, has_head = false, margin_x = 0.02 * width;

      let text_g = this.draw_g.select('.statlines');
      if (text_g.empty())
         text_g = this.draw_g.append('svg:g').attr('class', 'statlines');
      else
         text_g.selectAll('*').remove();

      textFont.setSize(height/(nlines * 1.2));
      this.startTextDrawing(textFont, 'font' , text_g);

      if (nlines == 1) {
         this.drawText({ width: width, height: height, text: lines[0], latex: 1, draw_g: text_g });
      } else
      for (let j = 0; j < nlines; ++j) {
         let posy = j*stepy;

         if (first_stat && (j >= first_stat)) {
            let parts = lines[j].split('|');
            for (let n = 0; n < parts.length; ++n)
               this.drawText({ align: 'middle', x: width * n / num_cols, y: posy, latex: 0,
                               width: width/num_cols, height: stepy, text: parts[n], draw_g: text_g });
         } else if (lines[j].indexOf('=') < 0) {
            if (j == 0) {
               has_head = true;
               let max_hlen = Math.max(maxlen, Math.round((width-2*margin_x)/stepy/0.65));
               if (lines[j].length > max_hlen + 5)
                  lines[j] = lines[j].slice(0,max_hlen+2) + '...';
            }
            this.drawText({ align: (j == 0) ? 'middle' : 'start', x: margin_x, y: posy,
                            width: width - 2*margin_x, height: stepy, text: lines[j], draw_g: text_g });
         } else {
            let parts = lines[j].split('='), args = [];

            for (let n = 0; n < 2; ++n) {
               let arg = {
                  align: (n == 0) ? 'start' : 'end', x: margin_x, y: posy,
                  width: width-2*margin_x, height: stepy, text: parts[n], draw_g: text_g,
                  _expected_width: width-2*margin_x, _args: args,
                  post_process(painter) {
                    if (this._args[0].ready && this._args[1].ready)
                       painter.scaleTextDrawing(1.05*(this._args[0].result_width && this._args[1].result_width)/this.__expected_width, this.draw_g);
                  }
               };
               args.push(arg);
            }

            for (let n = 0; n < 2; ++n)
               this.drawText(args[n]);
         }
      }

      let lpath = '';

      if (has_head)
         lpath += 'M0,' + Math.round(stepy) + 'h' + width;

      if ((first_stat > 0) && (num_cols > 1)) {
         for (let nrow = first_stat; nrow < nlines; ++nrow)
            lpath += 'M0,' + Math.round(nrow * stepy) + 'h' + width;
         for (let ncol = 0; ncol < num_cols - 1; ++ncol)
            lpath += 'M' + Math.round(width / num_cols * (ncol + 1)) + ',' + Math.round(first_stat * stepy) + 'V' + height;
      }

      if (lpath) this.draw_g.append('svg:path').attr('d',lpath) /*.call(this.lineatt.func)*/;

      return this.finishTextDrawing(text_g);
   }

   /** @summary Redraw stats box */
   async redraw(reason) {
      if (reason && isStr(reason) && (reason.indexOf('zoom') == 0) && this.v7NormalMode()) {
         let req = {
            _typename: 'ROOT::Experimental::RHistStatBoxBase::RRequest',
            mask: this.getObject().fShowMask // lines to show in stat box
         };

         this.v7SubmitRequest('stat', req, reply => this.updateStatistic(reply));
      }

      return this.drawPave();
   }

   /** @summary draw RHistStats object */
   static async draw(dom, stats, opt) {
      let painter = new RHistStatsPainter(dom, stats, opt, stats);
      return ensureRCanvas(painter, false).then(() => painter.drawPave());
   }

} // class RHistStatsPainter

var RPavePainter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
RPavePainter: RPavePainter,
RLegendPainter: RLegendPainter,
RPaveTextPainter: RPaveTextPainter,
RHistStatsPainter: RHistStatsPainter
});

/** @summary assign methods for the RAxis objects
  * @private */
function assignRAxisMethods(axis) {
   if ((axis._typename == 'ROOT::Experimental::RAxisEquidistant') || (axis._typename == 'ROOT::Experimental::RAxisLabels')) {
      if (axis.fInvBinWidth === 0) {
         axis.$dummy = true;
         axis.fInvBinWidth = 1;
         axis.fNBinsNoOver = 0;
         axis.fLow = 0;
      }

      axis.min = axis.fLow;
      axis.max = axis.fLow + axis.fNBinsNoOver/axis.fInvBinWidth;
      axis.GetNumBins = function() { return this.fNBinsNoOver; };
      axis.GetBinCoord = function(bin) { return this.fLow + bin/this.fInvBinWidth; };
      axis.FindBin = function(x,add) { return Math.floor((x - this.fLow)*this.fInvBinWidth + add); };
   } else if (axis._typename == 'ROOT::Experimental::RAxisIrregular') {
      axis.min = axis.fBinBorders[0];
      axis.max = axis.fBinBorders[axis.fBinBorders.length - 1];
      axis.GetNumBins = function() { return this.fBinBorders.length; };
      axis.GetBinCoord = function(bin) {
         let indx = Math.round(bin);
         if (indx <= 0) return this.fBinBorders[0];
         if (indx >= this.fBinBorders.length) return this.fBinBorders[this.fBinBorders.length - 1];
         if (indx==bin) return this.fBinBorders[indx];
         let indx2 = (bin < indx) ? indx - 1 : indx + 1;
         return this.fBinBorders[indx] * Math.abs(bin-indx2) + this.fBinBorders[indx2] * Math.abs(bin-indx);
      };
      axis.FindBin = function(x,add) {
         for (let k = 1; k < this.fBinBorders.length; ++k)
            if (x < this.fBinBorders[k]) return Math.floor(k-1+add);
         return this.fBinBorders.length - 1;
      };
   }

   // to support some code from ROOT6 drawing

   axis.GetBinCenter = function(bin) { return this.GetBinCoord(bin-0.5); };
   axis.GetBinLowEdge = function(bin) { return this.GetBinCoord(bin-1); };
}

/** @summary Returns real histogram impl
  * @private */
function getHImpl(obj) {
   return (obj && obj.fHistImpl) ? obj.fHistImpl.fIO : null;
}


/** @summary Base painter class for RHist objects
 *
 * @private
 */

class RHistPainter extends RObjectPainter {

   /** @summary Constructor
     * @param {object|string} dom - DOM element for drawing or element id
     * @param {object} histo - RHist object */
   constructor(dom, histo) {
      super(dom, histo);
      this.csstype = 'hist';
      this.draw_content = true;
      this.nbinsx = 0;
      this.nbinsy = 0;
      this.accept_drops = true; // indicate that one can drop other objects like doing Draw('same')
      this.mode3d = false;

      // initialize histogram methods
      this.getHisto(true);
   }

   /** @summary Returns true if RHistDisplayItem is used */
   isDisplayItem() {
      let obj = this.getObject();
      return obj && obj.fAxes ? true : false;
   }

   /** @summary get histogram */
   getHisto(force) {
      let obj = this.getObject(), histo = getHImpl(obj);

      if (histo && (!histo.getBinContent || force)) {
         if (histo.fAxes._2) {
            assignRAxisMethods(histo.fAxes._0);
            assignRAxisMethods(histo.fAxes._1);
            assignRAxisMethods(histo.fAxes._2);
            histo.getBin = function(x, y, z) { return (x-1) + this.fAxes._0.GetNumBins()*(y-1) + this.fAxes._0.GetNumBins()*this.fAxes._1.GetNumBins()*(z-1); };
            // FIXME: all normal ROOT methods uses indx+1 logic, but RHist has no underflow/overflow bins now
            histo.getBinContent = function(x, y, z) { return this.fStatistics.fBinContent[this.getBin(x, y, z)]; };
            histo.getBinError = function(x, y, z) {
               let bin = this.getBin(x, y, z);
               if (this.fStatistics.fSumWeightsSquared)
                  return Math.sqrt(this.fStatistics.fSumWeightsSquared[bin]);
               return Math.sqrt(Math.abs(this.fStatistics.fBinContent[bin]));
            };
         } else if (histo.fAxes._1) {
            assignRAxisMethods(histo.fAxes._0);
            assignRAxisMethods(histo.fAxes._1);
            histo.getBin = function(x, y) { return (x-1) + this.fAxes._0.GetNumBins()*(y-1); };
            // FIXME: all normal ROOT methods uses indx+1 logic, but RHist has no underflow/overflow bins now
            histo.getBinContent = function(x, y) { return this.fStatistics.fBinContent[this.getBin(x, y)]; };
            histo.getBinError = function(x, y) {
               let bin = this.getBin(x, y);
               if (this.fStatistics.fSumWeightsSquared)
                  return Math.sqrt(this.fStatistics.fSumWeightsSquared[bin]);
               return Math.sqrt(Math.abs(this.fStatistics.fBinContent[bin]));
            };
         } else {
            assignRAxisMethods(histo.fAxes._0);
            histo.getBin = function(x) { return x-1; };
            // FIXME: all normal ROOT methods uses indx+1 logic, but RHist has no underflow/overflow bins now
            histo.getBinContent = function(x) { return this.fStatistics.fBinContent[x-1]; };
            histo.getBinError = function(x) {
               if (this.fStatistics.fSumWeightsSquared)
                  return Math.sqrt(this.fStatistics.fSumWeightsSquared[x-1]);
               return Math.sqrt(Math.abs(this.fStatistics.fBinContent[x-1]));
            };
         }
      } else if (!histo && obj && obj.fAxes) {
         // case of RHistDisplayItem

         histo = obj;

         if (!histo.getBinContent || force) {
            if (histo.fAxes.length == 3) {
               assignRAxisMethods(histo.fAxes[0]);
               assignRAxisMethods(histo.fAxes[1]);
               assignRAxisMethods(histo.fAxes[2]);

               histo.nx = histo.fIndicies[1] - histo.fIndicies[0];
               histo.dx = histo.fIndicies[0] + 1;
               histo.stepx = histo.fIndicies[2];

               histo.ny = histo.fIndicies[4] - histo.fIndicies[3];
               histo.dy = histo.fIndicies[3] + 1;
               histo.stepy = histo.fIndicies[5];

               histo.nz = histo.fIndicies[7] - histo.fIndicies[6];
               histo.dz = histo.fIndicies[6] + 1;
               histo.stepz = histo.fIndicies[8];

               // this is index in original histogram
               histo.getBin = function(x, y, z) { return (x-1) + this.fAxes[0].GetNumBins()*(y-1) + this.fAxes[0].GetNumBins()*this.fAxes[1].GetNumBins()*(z-1); };

               // this is index in current available data
               if ((histo.stepx > 1) || (histo.stepy > 1) || (histo.stepz > 1))
                  histo.getBin0 = function(x, y, z) { return Math.floor((x-this.dx)/this.stepx) + this.nx/this.stepx*Math.floor((y-this.dy)/this.stepy) + this.nx/this.stepx*this.ny/this.stepy*Math.floor((z-this.dz)/this.stepz); };
               else
                  histo.getBin0 = function(x, y, z) { return (x-this.dx) + this.nx*(y-this.dy) + this.nx*this.ny*(z-dz); };

               histo.getBinContent = function(x, y, z) { return this.fBinContent[this.getBin0(x, y, z)]; };
               histo.getBinError = function(x, y, z) { return Math.sqrt(Math.abs(this.getBinContent(x, y, z))); };


            } else if (histo.fAxes.length == 2) {
               assignRAxisMethods(histo.fAxes[0]);
               assignRAxisMethods(histo.fAxes[1]);

               histo.nx = histo.fIndicies[1] - histo.fIndicies[0];
               histo.dx = histo.fIndicies[0] + 1;
               histo.stepx = histo.fIndicies[2];

               histo.ny = histo.fIndicies[4] - histo.fIndicies[3];
               histo.dy = histo.fIndicies[3] + 1;
               histo.stepy = histo.fIndicies[5];

               // this is index in original histogram
               histo.getBin = function(x, y) { return (x-1) + this.fAxes[0].GetNumBins()*(y-1); };

               // this is index in current available data
               if ((histo.stepx > 1) || (histo.stepy > 1))
                  histo.getBin0 = function(x, y) { return Math.floor((x-this.dx)/this.stepx) + this.nx/this.stepx*Math.floor((y-this.dy)/this.stepy); };
               else
                  histo.getBin0 = function(x, y) { return (x-this.dx) + this.nx*(y-this.dy); };

               histo.getBinContent = function(x, y) { return this.fBinContent[this.getBin0(x, y)]; };
               histo.getBinError = function(x, y) { return Math.sqrt(Math.abs(this.getBinContent(x, y))); };
            } else {
               assignRAxisMethods(histo.fAxes[0]);
               histo.nx = histo.fIndicies[1] - histo.fIndicies[0];
               histo.dx = histo.fIndicies[0] + 1;
               histo.stepx = histo.fIndicies[2];

               histo.getBin = function(x) { return x-1; };
               if (histo.stepx > 1)
                  histo.getBin0 = function(x) { return Math.floor((x-this.dx)/this.stepx); };
               else
                  histo.getBin0 = function(x) { return x-this.dx; };
               histo.getBinContent = function(x) { return this.fBinContent[this.getBin0(x)]; };
               histo.getBinError = function(x) { return Math.sqrt(Math.abs(this.getBinContent(x))); };
            }
         }
      }
      return histo;
   }

   /** @summary Decode options */
   decodeOptions(/*opt*/) {
      if (!this.options) this.options = { Hist : 1 };
   }

   /** @summary Copy draw options from other painter */
   copyOptionsFrom(src) {
      if (src === this) return;
      let o = this.options, o0 = src.options;
      o.Mode3D = o0.Mode3D;
   }

   /** @summary copy draw options to all other histograms in the pad*/
   copyOptionsToOthers() {
      this.forEachPainter(painter => {
         if ((painter !== this) && isFunc(painter.copyOptionsFrom))
            painter.copyOptionsFrom(this);
      }, 'objects');
   }

   /** @summary Clear 3d drawings - if any */
   clear3DScene() {
      let fp = this.getFramePainter();
      if (isFunc(fp?.create3DScene))
         fp.create3DScene(-1);
      this.mode3d = false;
   }

   /** @summary Cleanup hist painter */
   cleanup() {
      this.clear3DScene();

      delete this.options;

      super.cleanup();
   }

   /** @summary Returns histogram dimension */
   getDimension() { return 1; }

   /** @summary Scan histogram content
     * @abstract */
   scanContent(/*when_axis_changed*/) {
      // function will be called once new histogram or
      // new histogram content is assigned
      // one should find min,max,nbins, maxcontent values
      // if when_axis_changed === true specified, content will be scanned after axis zoom changed
   }

   /** @summary Draw axes */
   async drawFrameAxes() {
      // return true when axes was drawn
      let main = this.getFramePainter();
      if (!main)
         return false;

      if (!this.draw_content)
         return true;

      if (!this.isMainPainter()) {
         if (!this.options.second_x && !this.options.second_y)
            return true;

         main.setAxes2Ranges(this.options.second_x, this.getAxis('x'), this.xmin, this.xmax, this.options.second_y, this.getAxis('y'), this.ymin, this.ymax);
         return main.drawAxes2(this.options.second_x, this.options.second_y);
      }

      main.cleanupAxes();
      main.xmin = main.xmax = 0;
      main.ymin = main.ymax = 0;
      main.zmin = main.zmax = 0;
      main.setAxesRanges(this.getAxis('x'), this.xmin, this.xmax, this.getAxis('y'), this.ymin, this.ymax, this.getAxis('z'), this.zmin, this.zmax);
      return main.drawAxes();
   }

   /** @summary create attributes */
   createHistDrawAttributes() {
      this.createv7AttFill();
      this.createv7AttLine();
   }

   /** @summary update display item */
   updateDisplayItem(obj, src) {
      if (!obj || !src) return false;

      obj.fAxes = src.fAxes;
      obj.fIndicies = src.fIndicies;
      obj.fBinContent = src.fBinContent;
      obj.fContMin = src.fContMin;
      obj.fContMinPos = src.fContMinPos;
      obj.fContMax = src.fContMax;

      // update histogram attributes
      this.getHisto(true);

      return true;
   }

   /** @summary update histogram object */
   updateObject(obj /*, opt*/) {

      let origin = this.getObject();

      if (obj !== origin) {

         if (!this.matchObjectType(obj)) return false;

         if (this.isDisplayItem()) {

            this.updateDisplayItem(origin, obj);

         } else {

            let horigin = getHImpl(origin),
                hobj = getHImpl(obj);

            if (!horigin || !hobj) return false;

            // make it easy - copy statistics without axes
            horigin.fStatistics = hobj.fStatistics;

            origin.fTitle = obj.fTitle;
         }
      }

      this.scanContent();

      this.histogram_updated = true; // indicate that object updated

      return true;
   }

   /** @summary Get axis object */
   getAxis(name) {
      let histo = this.getHisto(), obj = this.getObject(), axis = null;

      if (obj && obj.fAxes) {
         switch(name) {
            case 'x': axis = obj.fAxes[0]; break;
            case 'y': axis = obj.fAxes[1]; break;
            case 'z': axis = obj.fAxes[2]; break;
            default: axis = obj.fAxes[0]; break;
         }
      } else if (histo && histo.fAxes) {
         switch(name) {
            case 'x': axis = histo.fAxes._0; break;
            case 'y': axis = histo.fAxes._1; break;
            case 'z': axis = histo.fAxes._2; break;
            default: axis = histo.fAxes._0; break;
         }
      }

      if (axis && !axis.GetBinCoord)
         assignRAxisMethods(axis);

      return axis;
   }

   /** @summary Get tip text for axis bin */
   getAxisBinTip(name, bin, step) {
      let pmain = this.getFramePainter(),
          handle = pmain[name+'_handle'],
          axis = this.getAxis(name),
          x1 = axis.GetBinCoord(bin);

      if (handle.kind === 'labels')
         return pmain.axisAsText(name, x1);

      let x2 = axis.GetBinCoord(bin+(step || 1));

      if (handle.kind === 'time')
         return pmain.axisAsText(name, (x1+x2)/2);

      return '[' + pmain.axisAsText(name, x1) + ', ' + pmain.axisAsText(name, x2) + ')';
   }

   /** @summary Extract axes ranges and bins numbers
     * @desc Also here ensured that all axes objects got their necessary methods */
   extractAxesProperties(ndim) {

      let histo = this.getHisto();
      if (!histo) return;

      this.nbinsx = this.nbinsy = this.nbinsz = 0;

      let axis = this.getAxis('x');
      this.nbinsx = axis.GetNumBins();
      this.xmin = axis.min;
      this.xmax = axis.max;

      if (ndim < 2) return;
      axis = this.getAxis('y');
      this.nbinsy = axis.GetNumBins();
      this.ymin = axis.min;
      this.ymax = axis.max;

      if (ndim < 3) return;
      axis = this.getAxis('z');
      this.nbinsz = axis.GetNumBins();
      this.zmin = axis.min;
      this.zmax = axis.max;
   }

   /** @summary Add interactive features, only main painter does it */
   addInteractivity() {
      // only first painter in list allowed to add interactive functionality to the frame

      let ismain =  this.isMainPainter(),
          second_axis = this.options.second_x || this.options.second_y,
          fp = ismain || second_axis ? this.getFramePainter() : null;
      return fp ? fp.addInteractivity(!ismain && second_axis) : true;
   }

   /** @summary Process item reply */
   processItemReply(reply, req) {
      if (!this.isDisplayItem())
         return console.error('Get item when display normal histogram');

      if (req.reqid === this.current_item_reqid) {

         if (reply !== null) {
            this.updateDisplayItem(this.getObject(), reply.item);
         }

         req.resolveFunc(true);
      }
   }

   /** @summary Special method to request bins from server if existing data insufficient
     * @return {Promise} when ready */
   async drawingBins(reason) {

      let is_axes_zoomed = false;
      if (reason && isStr(reason) && (reason.indexOf('zoom') == 0)) {
         if (reason.indexOf('0') > 0) is_axes_zoomed = true;
         if ((this.getDimension() > 1) && (reason.indexOf('1') > 0)) is_axes_zoomed = true;
         if ((this.getDimension() > 2) && (reason.indexOf('2') > 0)) is_axes_zoomed = true;
      }

      if (this.isDisplayItem() && is_axes_zoomed && this.v7NormalMode()) {

         let handle = this.prepareDraw({ only_indexes: true });

         // submit request if histogram data not enough for display
         if (handle.incomplete)
            return new Promise(resolveFunc => {
               // use empty kind to always submit request
               let req = this.v7SubmitRequest('', { _typename: 'ROOT::Experimental::RHistDrawableBase::RRequest' },
                                                  this.processItemReply.bind(this));
               if (req) {
                  this.current_item_reqid = req.reqid; // ignore all previous requests, only this one will be processed
                  req.resolveFunc = resolveFunc;
                  setTimeout(this.processItemReply.bind(this, null, req), 1000); // after 1 s draw something that we can
               } else {
                  resolveFunc(true);
               }
            });
      }

      return true;
   }

   /** @summary Toggle statbox drawing
     * @desc Not yet implemented */
   toggleStat(/*arg*/) {}

   /** @summary get selected index for axis */
   getSelectIndex(axis, size, add) {
      // be aware - here indexes starts from 0
      let indx = 0,
          taxis = this.getAxis(axis),
          nbins = this['nbins'+axis] || 0;

      if (this.options.second_x && axis == 'x') axis = 'x2';
      if (this.options.second_y && axis == 'y') axis = 'y2';

      let main = this.getFramePainter(),
          min = main ? main['zoom_' + axis + 'min'] : 0,
          max = main ? main['zoom_' + axis + 'max'] : 0;

      if ((min !== max) && taxis) {
         if (size == 'left')
            indx = taxis.FindBin(min, add || 0);
         else
            indx = taxis.FindBin(max, (add || 0) + 0.5);
         if (indx < 0) indx = 0; else if (indx>nbins) indx = nbins;
      } else {
         indx = (size == 'left') ? 0 : nbins;
      }

      return indx;
   }

   /** @summary Auto zoom into histogram non-empty range
     * @abstract */
   autoZoom() {}

   /** @summary Process click on histogram-defined buttons */
   clickButton(funcname) {
      // TODO: move to frame painter
      switch(funcname) {
         case 'ToggleZoom':
            if ((this.zoom_xmin !== this.zoom_xmax) || (this.zoom_ymin !== this.zoom_ymax) || (this.zoom_zmin !== this.zoom_zmax)) {
               this.unzoom();
               this.getFramePainter().zoomChangedInteractive('reset');
               return true;
            }
            if (this.draw_content) {
               this.autoZoom();
               return true;
            }
            break;
         case 'ToggleLogX': this.getFramePainter().toggleAxisLog('x'); break;
         case 'ToggleLogY': this.getFramePainter().toggleAxisLog('y'); break;
         case 'ToggleLogZ': this.getFramePainter().toggleAxisLog('z'); break;
         case 'ToggleStatBox': this.toggleStat(); return true;
      }
      return false;
   }

   /** @summary Fill pad toolbar with hist-related functions */
   fillToolbar(not_shown) {
      let pp = this.getPadPainter();
      if (!pp) return;

      pp.addPadButton('auto_zoom', 'Toggle between unzoom and autozoom-in', 'ToggleZoom', 'Ctrl *');
      pp.addPadButton('arrow_right', 'Toggle log x', 'ToggleLogX', 'PageDown');
      pp.addPadButton('arrow_up', 'Toggle log y', 'ToggleLogY', 'PageUp');
      if (this.getDimension() > 1)
         pp.addPadButton('arrow_diag', 'Toggle log z', 'ToggleLogZ');
      if (this.draw_content)
         pp.addPadButton('statbox', 'Toggle stat box', 'ToggleStatBox');
      if (!not_shown) pp.showPadButtons();
   }

   /** @summary get tool tips used in 3d mode */
   get3DToolTip(indx) {
      let histo = this.getHisto(),
          tip = { bin: indx, name: histo.fName || 'histo', title: histo.fTitle };
      switch (this.getDimension()) {
         case 1:
            tip.ix = indx + 1; tip.iy = 1;
            tip.value = histo.getBinContent(tip.ix);
            tip.error = histo.getBinError(tip.ix);
            tip.lines = this.getBinTooltips(indx-1);
            break;
         case 2:
            tip.ix = (indx % this.nbinsx) + 1;
            tip.iy = (indx - (tip.ix - 1)) / this.nbinsx + 1;
            tip.value = histo.getBinContent(tip.ix, tip.iy);
            tip.error = histo.getBinError(tip.ix, tip.iy);
            tip.lines = this.getBinTooltips(tip.ix-1, tip.iy-1);
            break;
         case 3:
            tip.ix = indx % this.nbinsx + 1;
            tip.iy = ((indx - (tip.ix - 1)) / this.nbinsx) % this.nbinsy + 1;
            tip.iz = (indx - (tip.ix - 1) - (tip.iy - 1) * this.nbinsx) / this.nbinsx / this.nbinsy + 1;
            tip.value = histo.getBinContent(tip.ix, tip.iy, tip.iz);
            tip.error = histo.getBinError(tip.ix, tip.iy, tip.iz);
            tip.lines = this.getBinTooltips(tip.ix-1, tip.iy-1, tip.iz-1);
            break;
      }

      return tip;
   }

   /** @summary Create contour levels for currently selected Z range */
   createContour(main, palette, args) {
      if (!main || !palette) return;

      if (!args) args = {};

      let nlevels = gStyle.fNumberContours,
          zmin = this.minbin, zmax = this.maxbin, zminpos = this.minposbin;

      if (args.scatter_plot) {
         if (nlevels > 50) nlevels = 50;
         zmin = this.minposbin;
      }

      if (zmin === zmax) { zmin = this.gminbin; zmax = this.gmaxbin; zminpos = this.gminposbin; }

      if (this.getDimension() < 3) {
         if (main.zoom_zmin !== main.zoom_zmax) {
            zmin = main.zoom_zmin;
            zmax = main.zoom_zmax;
         } else if (args.full_z_range) {
            zmin = main.zmin;
            zmax = main.zmax;
         }
      }

      palette.setFullRange(main.zmin, main.zmax);
      palette.createContour(main.logz, nlevels, zmin, zmax, zminpos);

      if (this.getDimension() < 3) {
         main.scale_zmin = palette.colzmin;
         main.scale_zmax = palette.colzmax;
      }
   }

   /** @summary Start dialog to modify range of axis where histogram values are displayed */
   changeValuesRange(menu, arg) {
      let pmain = this.getFramePainter();
      if (!pmain) return;
      let prefix = pmain.isAxisZoomed(arg) ? 'zoom_' + arg : arg,
          curr = '[' + pmain[prefix+'min'] + ',' + pmain[prefix+'max'] + ']';
      menu.input('Enter values range for axis ' + arg + ' like [0,100] or empty string to unzoom', curr).then(res => {
         res = res ? JSON.parse(res) : [];
         if (!isObject(res) || (res.length != 2) || !Number.isFinite(res[0]) || !Number.isFinite(res[1]))
            pmain.unzoom(arg);
         else
            pmain.zoom(arg, res[0], res[1]);
      });
   }

   /** @summary Fill histogram context menu */
   fillContextMenu(menu) {

      menu.add('header:v7histo::anyname');

      if (this.draw_content) {
         menu.addchk(this.toggleStat('only-check'), 'Show statbox', () => this.toggleStat());

         if (this.getDimension() == 2)
             menu.add('Values range', () => this.changeValuesRange(menu, 'z'));

         if (isFunc(this.fillHistContextMenu))
            this.fillHistContextMenu(menu);
      }

      let fp = this.getFramePainter();

      if (this.options.Mode3D) {
         // menu for 3D drawings

         if (menu.size() > 0)
            menu.add('separator');

         let main = this.getMainPainter() || this;

         menu.addchk(main.isTooltipAllowed(), 'Show tooltips', () => main.setTooltipAllowed('toggle'));

         menu.addchk(fp.enable_highlight, 'Highlight bins', () => {
            fp.enable_highlight = !fp.enable_highlight;
            if (!fp.enable_highlight && main.highlightBin3D && main.mode3d) main.highlightBin3D(null);
         });

         if (isFunc(fp?.render3D)) {
            menu.addchk(main.options.FrontBox, 'Front box', () => {
               main.options.FrontBox = !main.options.FrontBox;
               fp.render3D();
            });
            menu.addchk(main.options.BackBox, 'Back box', () => {
               main.options.BackBox = !main.options.BackBox;
               fp.render3D();
            });
         }

         if (this.draw_content) {
            menu.addchk(!this.options.Zero, 'Suppress zeros', () => {
               this.options.Zero = !this.options.Zero;
               this.redrawPad();
            });

            if ((this.options.Lego == 12) || (this.options.Lego == 14)) {
               if (this.fillPaletteMenu)
                  this.fillPaletteMenu(menu);
            }
         }

         if (isFunc(main.control?.reset))
            menu.add('Reset camera', () => main.control.reset());
      }

      menu.addAttributesMenu(this);

      if (this.histogram_updated && fp.zoomChangedInteractive())
         menu.add('Let update zoom', () => fp.zoomChangedInteractive('reset'));

      return true;
   }

   /** @summary Update palette drawing */
   updatePaletteDraw() {
      if (this.isMainPainter())
         this.getPadPainter().findPainterFor(undefined, undefined, 'ROOT::Experimental::RPaletteDrawable')?.drawPalette();
   }

   /** @summary Fill menu entries for palette */
   fillPaletteMenu(menu) {
      menu.addPaletteMenu(this.options.Palette || settings.Palette, arg => {
         // TODO: rewrite for RPalette functionality
         this.options.Palette = parseInt(arg);
         this.redraw(); // redraw histogram
      });
   }

   /** @summary Toggle 3D drawing mode */
   toggleMode3D() {
      this.options.Mode3D = !this.options.Mode3D;

      if (this.options.Mode3D) {
         if (!this.options.Surf && !this.options.Lego && !this.options.Error) {
            if ((this.nbinsx>=50) || (this.nbinsy>=50))
               this.options.Lego = this.options.Color ? 14 : 13;
            else
               this.options.Lego = this.options.Color ? 12 : 1;

            this.options.Zero = false; // do not show zeros by default
         }
      }

      this.copyOptionsToOthers();
      this.interactiveRedraw('pad', 'drawopt');
   }

   /** @summary Calculate histogram inidicies and axes values for each visible bin */
   prepareDraw(args) {

      if (!args) args = { rounding: true, extra: 0, middle: 0 };

      if (args.extra === undefined) args.extra = 0;
      if (args.right_extra === undefined) args.right_extra = args.extra;
      if (args.middle === undefined) args.middle = 0;

      let histo = this.getHisto(), xaxis = this.getAxis('x'), yaxis = this.getAxis('y'),
          pmain = this.getFramePainter(),
          hdim = this.getDimension(),
          i, j, x, y, binz, binarea,
          res = {
             i1: this.getSelectIndex('x', 'left', 0 - args.extra),
             i2: this.getSelectIndex('x', 'right', 1 + args.right_extra),
             j1: (hdim < 2) ? 0 : this.getSelectIndex('y', 'left', 0 - args.extra),
             j2: (hdim < 2) ? 1 : this.getSelectIndex('y', 'right', 1 + args.right_extra),
             k1: (hdim < 3) ? 0 : this.getSelectIndex('z', 'left', 0 - args.extra),
             k2: (hdim < 3) ? 1 : this.getSelectIndex('z', 'right', 1 + args.right_extra),
             stepi: 1, stepj: 1, stepk: 1,
             min: 0, max: 0, sumz: 0, xbar1: 0, xbar2: 1, ybar1: 0, ybar2: 1
          };

      if (this.isDisplayItem() && histo.fIndicies) {
         if (res.i1 < histo.fIndicies[0]) { res.i1 = histo.fIndicies[0]; res.incomplete = true; }
         if (res.i2 > histo.fIndicies[1]) { res.i2 = histo.fIndicies[1]; res.incomplete = true; }
         res.stepi = histo.fIndicies[2];
         if (res.stepi > 1) res.incomplete = true;
         if ((hdim > 1) && (histo.fIndicies.length > 5)) {
            if (res.j1 < histo.fIndicies[3]) { res.j1 = histo.fIndicies[3]; res.incomplete = true; }
            if (res.j2 > histo.fIndicies[4]) { res.j2 = histo.fIndicies[4]; res.incomplete = true; }
            res.stepj = histo.fIndicies[5];
            if (res.stepj > 1) res.incomplete = true;
         }
         if ((hdim > 2) && (histo.fIndicies.length > 8)) {
            if (res.k1 < histo.fIndicies[6]) { res.k1 = histo.fIndicies[6]; res.incomplete = true; }
            if (res.k2 > histo.fIndicies[7]) { res.k2 = histo.fIndicies[7]; res.incomplete = true; }
            res.stepk = histo.fIndicies[8];
            if (res.stepk > 1) res.incomplete = true;
         }
      }

      if (args.only_indexes) return res;

      // no need for Float32Array, plain Array is 10% faster
      // reserve more places to avoid complex boundary checks

      res.grx = new Array(res.i2+res.stepi+1);
      res.gry = new Array(res.j2+res.stepj+1);

      if (args.original) {
         res.original = true;
         res.origx = new Array(res.i2+1);
         res.origy = new Array(res.j2+1);
      }

      if (args.pixel_density) args.rounding = true;

      let funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y);

       // calculate graphical coordinates in advance
      for (i = res.i1; i <= res.i2; ++i) {
         x = xaxis.GetBinCoord(i + args.middle);
         if (funcs.logx && (x <= 0)) { res.i1 = i+1; continue; }
         if (res.origx) res.origx[i] = x;
         res.grx[i] = funcs.grx(x);
         if (args.rounding) res.grx[i] = Math.round(res.grx[i]);

         if (args.use3d) {
            if (res.grx[i] < -pmain.size_x3d) { res.i1 = i; res.grx[i] = -pmain.size_x3d; }
            if (res.grx[i] > pmain.size_x3d) { res.i2 = i; res.grx[i] = pmain.size_x3d; }
         }
      }

      if (args.use3d) {
         if ((res.i1 < res.i2-2) && (res.grx[res.i1] == res.grx[res.i1+1])) res.i1++;
         if ((res.i1 < res.i2-2) && (res.grx[res.i2-1] == res.grx[res.i2])) res.i2--;
      }

      // copy last valid value to higher indicies
      while (i < res.i2 + res.stepi + 1)
         res.grx[i++] = res.grx[res.i2];

      if (hdim === 1) {
         res.gry[0] = funcs.gry(0);
         res.gry[1] = funcs.gry(1);
      } else
      for (j = res.j1; j <= res.j2; ++j) {
         y = yaxis.GetBinCoord(j + args.middle);
         if (funcs.logy && (y <= 0)) { res.j1 = j+1; continue; }
         if (res.origy) res.origy[j] = y;
         res.gry[j] = funcs.gry(y);
         if (args.rounding) res.gry[j] = Math.round(res.gry[j]);

         if (args.use3d) {
            if (res.gry[j] < -pmain.size_y3d) { res.j1 = j; res.gry[j] = -pmain.size_y3d; }
            if (res.gry[j] > pmain.size_y3d) { res.j2 = j; res.gry[j] = pmain.size_y3d; }
         }
      }

      if (args.use3d && (hdim > 1)) {
         if ((res.j1 < res.j2-2) && (res.gry[res.j1] == res.gry[res.j1+1])) res.j1++;
         if ((res.j1 < res.j2-2) && (res.gry[res.j2-1] == res.gry[res.j2])) res.j2--;
      }

      // copy last valid value to higher indicies
      while ((hdim > 1) && (j < res.j2 + res.stepj + 1))
         res.gry[j++] = res.gry[res.j2];

      //  find min/max values in selected range
      this.maxbin = this.minbin = this.minposbin = null;

      for (i = res.i1; i < res.i2; i += res.stepi) {
         for (j = res.j1; j < res.j2; j += res.stepj) {
            binz = histo.getBinContent(i + 1, j + 1);
            if (!Number.isFinite(binz)) continue;
            res.sumz += binz;
            if (args.pixel_density) {
               binarea = (res.grx[i+res.stepi]-res.grx[i])*(res.gry[j]-res.gry[j+res.stepj]);
               if (binarea <= 0) continue;
               res.max = Math.max(res.max, binz);
               if ((binz > 0) && ((binz < res.min) || (res.min === 0))) res.min = binz;
               binz = binz/binarea;
            }
            if (this.maxbin === null) {
               this.maxbin = this.minbin = binz;
            } else {
               this.maxbin = Math.max(this.maxbin, binz);
               this.minbin = Math.min(this.minbin, binz);
            }
            if (binz > 0)
               if ((this.minposbin === null) || (binz < this.minposbin)) this.minposbin = binz;
         }
      }

      res.palette = pmain.getHistPalette();

      if (res.palette)
         this.createContour(pmain, res.palette, args);

      return res;
   }

} // class RHistPainter

/**
 * @summary Painter for RH1 classes
 *
 * @private
 */

class RH1Painter$2 extends RHistPainter {

   /** @summary Constructor
     * @param {object|string} dom - DOM element or id
     * @param {object} histo - histogram object */
   constructor(dom, histo) {
      super(dom, histo);
      this.wheel_zoomy = false;
   }

   /** @summary Scan content */
   scanContent(when_axis_changed) {
      // if when_axis_changed === true specified, content will be scanned after axis zoom changed

      let histo = this.getHisto();
      if (!histo) return;

      if (!this.nbinsx && when_axis_changed) when_axis_changed = false;

      if (!when_axis_changed)
         this.extractAxesProperties(1);

      let hmin = 0, hmin_nz = 0, hmax = 0, hsum = 0;

      if (this.isDisplayItem()) {
         // take min/max values from the display item
         hmin = histo.fContMin;
         hmin_nz = histo.fContMinPos;
         hmax = histo.fContMax;
         hsum = hmax;
      } else {

         let left = this.getSelectIndex('x', 'left'),
             right = this.getSelectIndex('x', 'right');

         if (when_axis_changed) {
            if ((left === this.scan_xleft) && (right === this.scan_xright)) return;
         }

         this.scan_xleft = left;
         this.scan_xright = right;

         let first = true, value, err;

         for (let i = 0; i < this.nbinsx; ++i) {
            value = histo.getBinContent(i+1);
            hsum += value;

            if ((i<left) || (i>=right)) continue;

            if (value > 0)
               if ((hmin_nz == 0) || (value<hmin_nz)) hmin_nz = value;
            if (first) {
               hmin = hmax = value;
               first = false;
            }

            err =  0;

            hmin = Math.min(hmin, value - err);
            hmax = Math.max(hmax, value + err);
         }
      }

      this.stat_entries = hsum;

      this.hmin = hmin;
      this.hmax = hmax;

      this.ymin_nz = hmin_nz; // value can be used to show optimal log scale

      if ((this.nbinsx == 0) || ((Math.abs(hmin) < 1e-300 && Math.abs(hmax) < 1e-300))) {
         this.draw_content = false;
      } else {
         this.draw_content = true;
      }

      if (this.draw_content) {
         if (hmin >= hmax) {
            if (hmin == 0) { this.ymin = 0; this.ymax = 1; }
            else if (hmin < 0) { this.ymin = 2 * hmin; this.ymax = 0; }
            else { this.ymin = 0; this.ymax = hmin * 2; }
         } else {
            let dy = (hmax - hmin) * 0.05;
            this.ymin = hmin - dy;
            if ((this.ymin < 0) && (hmin >= 0)) this.ymin = 0;
            this.ymax = hmax + dy;
         }
      }
   }

   /** @summary Count statistic */
   countStat(cond) {
      let histo = this.getHisto(), xaxis = this.getAxis('x'),
          left = this.getSelectIndex('x', 'left'),
          right = this.getSelectIndex('x', 'right'),
          stat_sumw = 0, stat_sumwx = 0, stat_sumwx2 = 0, stat_sumwy = 0, stat_sumwy2 = 0,
          i, xx = 0, w = 0, xmax = null, wmax = null;
          this.getFramePainter();
          let res = { name: 'histo', meanx: 0, meany: 0, rmsx: 0, rmsy: 0, integral: 0, entries: this.stat_entries, xmax: 0, wmax: 0 };

      for (i = left; i < right; ++i) {
         xx = xaxis.GetBinCoord(i+0.5);

         if (cond && !cond(xx)) continue;

         w = histo.getBinContent(i + 1);

         if ((xmax === null) || (w > wmax)) { xmax = xx; wmax = w; }

         stat_sumw += w;
         stat_sumwx += w * xx;
         stat_sumwx2 += w * xx**2;
      }

      res.integral = stat_sumw;

      if (Math.abs(stat_sumw) > 1e-300) {
         res.meanx = stat_sumwx / stat_sumw;
         res.meany = stat_sumwy / stat_sumw;
         res.rmsx = Math.sqrt(Math.abs(stat_sumwx2 / stat_sumw - res.meanx**2));
         res.rmsy = Math.sqrt(Math.abs(stat_sumwy2 / stat_sumw - res.meany**2));
      }

      if (xmax !== null) {
         res.xmax = xmax;
         res.wmax = wmax;
      }

      return res;
   }

   /** @summary Fill statistic */
   fillStatistic(stat, dostat/*, dofit*/) {

      let data = this.countStat(),
          print_name = dostat % 10,
          print_entries = Math.floor(dostat / 10) % 10,
          print_mean = Math.floor(dostat / 100) % 10,
          print_rms = Math.floor(dostat / 1000) % 10,
          print_under = Math.floor(dostat / 10000) % 10,
          print_over = Math.floor(dostat / 100000) % 10,
          print_integral = Math.floor(dostat / 1000000) % 10,
          print_skew = Math.floor(dostat / 10000000) % 10,
          print_kurt = Math.floor(dostat / 100000000) % 10;

      // make empty at the beginning
      stat.clearStat();

      if (print_name > 0)
         stat.addText(data.name);

      if (print_entries > 0)
         stat.addText('Entries = ' + stat.format(data.entries,'entries'));

      if (print_mean > 0)
         stat.addText('Mean = ' + stat.format(data.meanx));

      if (print_rms > 0)
         stat.addText('Std Dev = ' + stat.format(data.rmsx));

      if (print_under > 0)
         stat.addText('Underflow = ' + stat.format(histo.getBinContent(0), 'entries'));

      if (print_over > 0)
         stat.addText('Overflow = ' + stat.format(histo.getBinContent(this.nbinsx+1), 'entries'));

      if (print_integral > 0)
         stat.addText('Integral = ' + stat.format(data.integral,'entries'));

      if (print_skew > 0)
         stat.addText('Skew = <not avail>');

      if (print_kurt > 0)
         stat.addText('Kurt = <not avail>');

      return true;
   }

   /** @summary Draw histogram as bars */
   async drawBars(handle, funcs, width, height) {

      this.createG(true);

      let left = handle.i1, right = handle.i2, di = handle.stepi,
          pmain = this.getFramePainter(),
          histo = this.getHisto(), xaxis = this.getAxis('x'),
          i, x1, x2, grx1, grx2, y, gry1, gry2, w,
          bars = '', barsl = '', barsr = '';

      gry2 = pmain.swap_xy ? 0 : height;
      if (Number.isFinite(this.options.BaseLine))
         if (this.options.BaseLine >= funcs.scale_ymin)
            gry2 = Math.round(funcs.gry(this.options.BaseLine));

      for (i = left; i < right; i += di) {
         x1 = xaxis.GetBinCoord(i);
         x2 = xaxis.GetBinCoord(i+di);

         if (funcs.logx && (x2 <= 0)) continue;

         grx1 = Math.round(funcs.grx(x1));
         grx2 = Math.round(funcs.grx(x2));

         y = histo.getBinContent(i+1);
         if (funcs.logy && (y < funcs.scale_ymin)) continue;
         gry1 = Math.round(funcs.gry(y));

         w = grx2 - grx1;
         grx1 += Math.round(this.options.BarOffset*w);
         w = Math.round(this.options.BarWidth*w);

         if (pmain.swap_xy)
            bars += `M${gry2},${grx1}h${gry1-gry2}v${w}h${gry2-gry1}z`;
         else
            bars += `M${grx1},${gry1}h${w}v${gry2-gry1}h${-w}z`;

         if (this.options.BarStyle > 0) {
            grx2 = grx1 + w;
            w = Math.round(w / 10);
            if (pmain.swap_xy) {
               barsl += `M${gry2},${grx1}h${gry1-gry2}v${w}h${gry2-gry1}z`;
               barsr += `M${gry2},${grx2}h${gry1-gry2}v${-w}h${gry2-gry1}z`;
            } else {
               barsl += `M${grx1},${gry1}h${w}v${gry2-gry1}h${-w}z`;
               barsr += `M${grx2},${gry1}h${-w}v${gry2-gry1}h${w}z`;
            }
         }
      }

      if (this.fillatt.empty()) this.fillatt.setSolidColor('blue');

      if (bars)
         this.draw_g.append('svg:path')
                    .attr('d', bars)
                    .call(this.fillatt.func);

      if (barsl)
         this.draw_g.append('svg:path')
               .attr('d', barsl)
               .call(this.fillatt.func)
               .style('fill', rgb(this.fillatt.color).brighter(0.5).formatHex());

      if (barsr)
         this.draw_g.append('svg:path')
               .attr('d', barsr)
               .call(this.fillatt.func)
               .style('fill', rgb(this.fillatt.color).darker(0.5).formatHex());

       return true;
   }

   /** @summary Draw histogram as filled errors */
   async drawFilledErrors(handle, funcs /*, width, height*/) {
      this.createG(true);

      let left = handle.i1, right = handle.i2, di = handle.stepi,
          histo = this.getHisto(), xaxis = this.getAxis('x'),
          i, x, grx, y, yerr, gry1, gry2,
          bins1 = [], bins2 = [];

      for (i = left; i < right; i += di) {
         x = xaxis.GetBinCoord(i+0.5);
         if (funcs.logx && (x <= 0)) continue;
         grx = Math.round(funcs.grx(x));

         y = histo.getBinContent(i+1);
         yerr = histo.getBinError(i+1);
         if (funcs.logy && (y-yerr < funcs.scale_ymin)) continue;

         gry1 = Math.round(funcs.gry(y + yerr));
         gry2 = Math.round(funcs.gry(y - yerr));

         bins1.push({grx: grx, gry: gry1});
         bins2.unshift({grx: grx, gry: gry2});
      }

      let kind = (this.options.ErrorKind === 4) ? 'bezier' : 'line',
          path1 = buildSvgPath(kind, bins1),
          path2 = buildSvgPath('L'+kind, bins2);

      if (this.fillatt.empty()) this.fillatt.setSolidColor('blue');

      this.draw_g.append('svg:path')
                 .attr('d', path1.path + path2.path + 'Z')
                 .call(this.fillatt.func);

      return true;
   }

   /** @summary Draw 1D histogram as SVG */
   async draw1DBins() {

      let pmain = this.getFramePainter(),
          rect = pmain.getFrameRect();

      if (!this.draw_content || (rect.width <= 0) || (rect.height <= 0)) {
         this.removeG();
         return false;
      }

      this.createHistDrawAttributes();

      let handle = this.prepareDraw({ extra: 1, only_indexes: true }),
          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y);

      if (this.options.Bar)
         return this.drawBars(handle, funcs, rect.width, rect.height);

      if ((this.options.ErrorKind === 3) || (this.options.ErrorKind === 4))
         return this.drawFilledErrors(handle, funcs, rect.width, rect.height);

      return this.drawHistBins(handle, funcs, rect.width, rect.height);
   }

   /** @summary Draw histogram bins */
   async drawHistBins(handle, funcs, width, height) {
      this.createG(true);

      let options = this.options,
          left = handle.i1,
          right = handle.i2,
          di = handle.stepi,
          histo = this.getHisto(),
          want_tooltip = !isBatchMode() && settings.Tooltip,
          xaxis = this.getAxis('x'),
          res = '', lastbin = false,
          startx, currx, curry, x, grx, y, gry, curry_min, curry_max, prevy, prevx, i, bestimin, bestimax,
          exclude_zero = !options.Zero,
          show_errors = options.Error,
          show_markers = options.Mark,
          show_line = options.Line,
          show_text = options.Text,
          path_fill = null, path_err = null, path_marker = null, path_line = null,
          hints_err = null,
          endx = '', endy = '', dend = 0, my, yerr1, yerr2, bincont, binerr, mx1, mx2, midx,
          text_font;

      if (show_errors && !show_markers && (this.v7EvalAttr('marker_style',1) > 1))
         show_markers = true;

      if (options.ErrorKind === 2) {
         if (this.fillatt.empty()) show_markers = true;
                              else path_fill = '';
      } else if (options.Error) {
         path_err = '';
         hints_err = want_tooltip ? '' : null;
      }

      if (show_line) path_line = '';

      if (show_markers) {
         // draw markers also when e2 option was specified
         this.createv7AttMarker();
         if (this.markeratt.size > 0) {
            // simply use relative move from point, can optimize in the future
            path_marker = '';
            this.markeratt.resetPos();
         } else {
            show_markers = false;
         }
      }

      if (show_text) {
         text_font = this.v7EvalFont('text', { size: 20, color: 'black', align: 22 });

         if (!text_font.angle && !options.TextKind) {
             let space = width / (right - left + 1);
             if (space < 3 * text_font.size) {
                text_font.setAngle(270);
                text_font.setSize(Math.round(space*0.7));
             }
         }

         this.startTextDrawing(text_font, 'font');
      }

      // if there are too many points, exclude many vertical drawings at the same X position
      // instead define min and max value and made min-max drawing
      let use_minmax = ((right-left) > 3*width);

      if (options.ErrorKind === 1) {
         let lw = this.lineatt.width + gStyle.fEndErrorSize;
         endx = `m0,${lw}v${-2*lw}m0,${lw}`;
         endy = `m${lw},0h${-2*lw}m${lw},0`;
         dend = Math.floor((this.lineatt.width-1)/2);
      }

      let draw_markers = show_errors || show_markers;

      if (draw_markers || show_text || show_line) use_minmax = true;

      let draw_bin = besti => {
         bincont = histo.getBinContent(besti+1);
         if (!exclude_zero || (bincont !== 0)) {
            mx1 = Math.round(funcs.grx(xaxis.GetBinCoord(besti)));
            mx2 = Math.round(funcs.grx(xaxis.GetBinCoord(besti+di)));
            midx = Math.round((mx1+mx2)/2);
            my = Math.round(funcs.gry(bincont));
            yerr1 = yerr2 = 20;
            if (show_errors) {
               binerr = histo.getBinError(besti+1);
               yerr1 = Math.round(my - funcs.gry(bincont + binerr)); // up
               yerr2 = Math.round(funcs.gry(bincont - binerr) - my); // down
            }

            if (show_text && (bincont !== 0)) {
               let lbl = (bincont === Math.round(bincont)) ? bincont.toString() : floatToString(bincont, gStyle.fPaintTextFormat);

               if (text_font.angle)
                  this.drawText({ align: 12, x: midx, y: Math.round(my - 2 - text_font.size / 5), text: lbl, latex: 0 });
               else
                  this.drawText({ x: Math.round(mx1 + (mx2 - mx1) * 0.1), y: Math.round(my - 2 - text_font.size), width: Math.round((mx2 - mx1) * 0.8), height: text_font.size, text: lbl, latex: 0 });
            }

            if (show_line && (path_line !== null))
               path_line += ((path_line.length === 0) ? 'M' : 'L') + midx + ',' + my;

            if (draw_markers) {
               if ((my >= -yerr1) && (my <= height + yerr2)) {
                  if (path_fill !== null)
                     path_fill += `M${mx1},${my-yerr1}h${mx2-mx1}v${yerr1+yerr2+1}h${mx1-mx2}z`;
                  if (path_marker !== null)
                     path_marker += this.markeratt.create(midx, my);
                  if (path_err !== null) {
                     let edx = 5;
                     if (this.options.errorX > 0) {
                        edx = Math.round((mx2-mx1)*this.options.errorX);
                        let mmx1 = midx - edx, mmx2 = midx + edx;
                        path_err += `M${mmx1+dend},${my}${endx}h${mmx2-mmx1-2*dend}${endx}`;
                     }
                     path_err += `M${midx},${my-yerr1+dend}${endy}v${yerr1+yerr2-2*dend}${endy}`;
                     if (hints_err !== null)
                        hints_err += `M${midx-edx},${my-yerr1}h${2*edx}v${yerr1+yerr2}h${-2*edx}z`;
                  }
               }
            }
         }
      };

      for (i = left; i <= right; i += di) {

         x = xaxis.GetBinCoord(i);

         if (funcs.logx && (x <= 0)) continue;

         grx = Math.round(funcs.grx(x));

         lastbin = (i > right - di);

         if (lastbin && (left < right)) {
            gry = curry;
         } else {
            y = histo.getBinContent(i+1);
            gry = Math.round(funcs.gry(y));
         }

         if (res.length === 0) {
            bestimin = bestimax = i;
            prevx = startx = currx = grx;
            prevy = curry_min = curry_max = curry = gry;
            res = 'M'+currx+','+curry;
         } else
         if (use_minmax) {
            if ((grx === currx) && !lastbin) {
               if (gry < curry_min) bestimax = i; else
               if (gry > curry_max) bestimin = i;
               curry_min = Math.min(curry_min, gry);
               curry_max = Math.max(curry_max, gry);
               curry = gry;
            } else {

               if (draw_markers || show_text || show_line) {
                  if (bestimin === bestimax) { draw_bin(bestimin); } else
                     if (bestimin < bestimax) { draw_bin(bestimin); draw_bin(bestimax); } else {
                        draw_bin(bestimax); draw_bin(bestimin);
                     }
               }

               // when several points as same X differs, need complete logic
               if (!draw_markers && ((curry_min !== curry_max) || (prevy !== curry_min))) {

                  if (prevx !== currx)
                     res += 'h'+(currx-prevx);

                  if (curry === curry_min) {
                     if (curry_max !== prevy)
                        res += 'v' + (curry_max - prevy);
                     if (curry_min !== curry_max)
                        res += 'v' + (curry_min - curry_max);
                  } else {
                     if (curry_min !== prevy)
                        res += 'v' + (curry_min - prevy);
                     if (curry_max !== curry_min)
                        res += 'v' + (curry_max - curry_min);
                     if (curry !== curry_max)
                       res += 'v' + (curry - curry_max);
                  }

                  prevx = currx;
                  prevy = curry;
               }

               if (lastbin && (prevx !== grx))
                  res += 'h'+(grx-prevx);

               bestimin = bestimax = i;
               curry_min = curry_max = curry = gry;
               currx = grx;
            }
         } else
         if ((gry !== curry) || lastbin) {
            if (grx !== currx) res += 'h'+(grx-currx);
            if (gry !== curry) res += 'v'+(gry-curry);
            curry = gry;
            currx = grx;
         }
      }

      let close_path = '',
          fill_for_interactive = !isBatchMode() && this.fillatt.empty() && options.Hist && settings.Tooltip && !draw_markers && !show_line;
      if (!this.fillatt.empty() || fill_for_interactive) {
         let h0 = height + 3;
         if (fill_for_interactive) {
            let gry0 = Math.round(funcs.gry(0));
            if (gry0 <= 0)
               h0 = -3;
            else if (gry0 < height)
               h0 = gry0;
         }
         close_path = `L${currx},${h0}H${startx}Z`;
         if (res) res += close_path;
      }

      if (draw_markers || show_line) {
         if (path_fill)
            this.draw_g.append('svg:path')
                       .attr('d', path_fill)
                       .call(this.fillatt.func);

         if (path_err)
               this.draw_g.append('svg:path')
                   .attr('d', path_err)
                   .call(this.lineatt.func);

         if (hints_err)
               this.draw_g.append('svg:path')
                   .attr('d', hints_err)
                   .style('fill', 'none')
                   .style('pointer-events', isBatchMode() ? null : 'visibleFill');

         if (path_line) {
            if (!this.fillatt.empty())
               this.draw_g.append('svg:path')
                     .attr('d', options.Fill ? (path_line + close_path) : res)
                     .call(this.fillatt.func);

            this.draw_g.append('svg:path')
                   .attr('d', path_line)
                   .style('fill', 'none')
                   .call(this.lineatt.func);
         }

         if (path_marker)
            this.draw_g.append('svg:path')
                .attr('d', path_marker)
                .call(this.markeratt.func);

      } else if (res && options.Hist) {
         this.draw_g.append('svg:path')
                    .attr('d', res)
                    .style('stroke-linejoin','miter')
                    .call(this.lineatt.func)
                    .call(this.fillatt.func);
      }

      return show_text ? this.finishTextDrawing() : true;
   }

   /** @summary Provide text information (tooltips) for histogram bin */
   getBinTooltips(bin) {
      let tips = [],
          name = this.getObjectHint(),
          pmain = this.getFramePainter(),
          histo = this.getHisto(),
          xaxis = this.getAxis('x'),
          di = this.isDisplayItem() ? histo.stepx : 1,
          x1 = xaxis.GetBinCoord(bin),
          x2 = xaxis.GetBinCoord(bin+di),
          cont = histo.getBinContent(bin+1),
          xlbl = this.getAxisBinTip('x', bin, di);

      if (name) tips.push(name);

      if (this.options.Error || this.options.Mark) {
         tips.push('x = ' + xlbl, 'y = ' + pmain.axisAsText('y', cont));
         if (this.options.Error) {
            if (xlbl[0] == '[') tips.push('error x = ' + ((x2 - x1) / 2).toPrecision(4));
            tips.push('error y = ' + histo.getBinError(bin + 1).toPrecision(4));
         }
      } else {
         tips.push(`bin = ${bin+1}`);
         tips.push('x = ' + xlbl);
         if (histo['$baseh']) cont -= histo['$baseh'].getBinContent(bin+1);
         let lbl = 'entries = ' + (di > 1 ? '~' : '');
         if (cont === Math.round(cont))
            tips.push(lbl + cont);
         else
            tips.push(lbl + floatToString(cont, gStyle.fStatFormat));
      }

      return tips;
   }

   /** @summary Process tooltip event */
   processTooltipEvent(pnt) {
      if (!pnt || !this.draw_content || this.options.Mode3D || !this.draw_g) {
         if (this.draw_g)
            this.draw_g.select('.tooltip_bin').remove();
         return null;
      }

      let pmain = this.getFramePainter(),
          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),
          width = pmain.getFrameWidth(),
          height = pmain.getFrameHeight(),
          histo = this.getHisto(), xaxis = this.getAxis('x'),
          findbin = null, show_rect,
          grx1, midx, grx2, gry1, midy, gry2, gapx = 2,
          left = this.getSelectIndex('x', 'left', -1),
          right = this.getSelectIndex('x', 'right', 2),
          l = left, r = right;

      function GetBinGrX(i) {
         let xx = xaxis.GetBinCoord(i);
         return (funcs.logx && (xx <= 0)) ? null : funcs.grx(xx);
      }

      function GetBinGrY(i) {
         let yy = histo.getBinContent(i + 1);
         if (funcs.logy && (yy < funcs.scale_ymin))
            return funcs.swap_xy ? -1000 : 10*height;
         return Math.round(funcs.gry(yy));
      }

      let pnt_x = funcs.swap_xy ? pnt.y : pnt.x,
          pnt_y = funcs.swap_xy ? pnt.x : pnt.y;

      while (l < r-1) {
         let m = Math.round((l+r)*0.5),
             xx = GetBinGrX(m);
         if ((xx === null) || (xx < pnt_x - 0.5)) {
            if (funcs.swap_xy) r = m; else l = m;
         } else if (xx > pnt_x + 0.5) {
            if (funcs.swap_xy) l = m; else r = m;
         } else { l++; r--; }
      }

      findbin = r = l;
      grx1 = GetBinGrX(findbin);

      if (funcs.swap_xy) {
         while ((l>left) && (GetBinGrX(l-1) < grx1 + 2)) --l;
         while ((r<right) && (GetBinGrX(r+1) > grx1 - 2)) ++r;
      } else {
         while ((l>left) && (GetBinGrX(l-1) > grx1 - 2)) --l;
         while ((r<right) && (GetBinGrX(r+1) < grx1 + 2)) ++r;
      }

      if (l < r) {
         // many points can be assigned with the same cursor position
         // first try point around mouse y
         let best = height;
         for (let m=l;m<=r;m++) {
            let dist = Math.abs(GetBinGrY(m) - pnt_y);
            if (dist < best) { best = dist; findbin = m; }
         }

         // if best distance still too far from mouse position, just take from between
         if (best > height/10)
            findbin = Math.round(l + (r-l) / height * pnt_y);

         grx1 = GetBinGrX(findbin);
      }

      grx1 = Math.round(grx1);
      grx2 = Math.round(GetBinGrX(findbin+1));

      if (this.options.Bar) {
         let w = grx2 - grx1;
         grx1 += Math.round(this.options.BarOffset*w);
         grx2 = grx1 + Math.round(this.options.BarWidth*w);
      }

      if (grx1 > grx2)
         [grx1, grx2] = [grx2, grx1];

      midx = Math.round((grx1 + grx2)/2);

      midy = gry1 = gry2 = GetBinGrY(findbin);

      if (this.options.Bar) {
         show_rect = true;

         gapx = 0;

         gry1 = Math.round(funcs.gry(((this.options.BaseLine!==false) && (this.options.BaseLine > funcs.scale_ymin)) ? this.options.BaseLine : funcs.scale_ymin));

         if (gry1 > gry2)
            [gry1, gry2] = [gry2, gry1];

         if (!pnt.touch && (pnt.nproc === 1))
            if ((pnt_y < gry1) || (pnt_y > gry2)) findbin = null;

      } else if (this.options.Error || this.options.Mark) {

         show_rect = true;

         let msize = 3;
         if (this.markeratt) msize = Math.max(msize, this.markeratt.getFullSize());

         if (this.options.Error) {
            let cont = histo.getBinContent(findbin+1),
                binerr = histo.getBinError(findbin+1);

            gry1 = Math.round(funcs.gry(cont + binerr)); // up
            gry2 = Math.round(funcs.gry(cont - binerr)); // down

            let dx = (grx2-grx1)*this.options.errorX;
            grx1 = Math.round(midx - dx);
            grx2 = Math.round(midx + dx);
         }

         // show at least 6 pixels as tooltip rect
         if (grx2 - grx1 < 2*msize) { grx1 = midx-msize; grx2 = midx+msize; }

         gry1 = Math.min(gry1, midy - msize);
         gry2 = Math.max(gry2, midy + msize);

         if (!pnt.touch && (pnt.nproc === 1))
            if ((pnt_y<gry1) || (pnt_y>gry2)) findbin = null;

      } else if (this.options.Line) {

         show_rect = false;

      } else {

         // if histogram alone, use old-style with rects
         // if there are too many points at pixel, use circle
         show_rect = (pnt.nproc === 1) && (right-left < width);

         if (show_rect) {
            gry2 = height;

            if (!this.fillatt.empty()) {
               gry2 = Math.min(height, Math.max(0, Math.round(funcs.gry(0))));
               if (gry2 < gry1)
                  [gry1, gry2] = [gry2, gry1];
            }

            // for mouse events pointer should be between y1 and y2
            if (((pnt.y < gry1) || (pnt.y > gry2)) && !pnt.touch) findbin = null;
         }
      }

      if (findbin !== null) {
         // if bin on boundary found, check that x position is ok
         if ((findbin === left) && (grx1 > pnt_x + gapx))  findbin = null; else
         if ((findbin === right-1) && (grx2 < pnt_x - gapx)) findbin = null; else
         // if bars option used check that bar is not match
         if ((pnt_x < grx1 - gapx) || (pnt_x > grx2 + gapx)) findbin = null; else
         // exclude empty bin if empty bins suppressed
         if (!this.options.Zero && (histo.getBinContent(findbin+1) === 0)) findbin = null;
      }

      let ttrect = this.draw_g.select('.tooltip_bin');

      if ((findbin === null) || ((gry2 <= 0) || (gry1 >= height))) {
         ttrect.remove();
         return null;
      }

      let res = { name: 'histo', title: histo.fTitle,
                  x: midx, y: midy, exact: true,
                  color1: this.lineatt ? this.lineatt.color : 'green',
                  color2: this.fillatt ? this.fillatt.getFillColorAlt('blue') : 'blue',
                  lines: this.getBinTooltips(findbin) };

      if (pnt.disabled) {
         // case when tooltip should not highlight bin

         ttrect.remove();
         res.changed = true;
      } else if (show_rect) {

         if (ttrect.empty())
            ttrect = this.draw_g.append('svg:rect')
                                .attr('class','tooltip_bin h1bin')
                                .style('pointer-events','none');

         res.changed = ttrect.property('current_bin') !== findbin;

         if (res.changed)
            ttrect.attr('x', pmain.swap_xy ? gry1 : grx1)
                  .attr('width', pmain.swap_xy ? gry2-gry1 : grx2-grx1)
                  .attr('y', pmain.swap_xy ? grx1 : gry1)
                  .attr('height', pmain.swap_xy ? grx2-grx1 : gry2-gry1)
                  .style('opacity', '0.3')
                  .property('current_bin', findbin);

         res.exact = (Math.abs(midy - pnt_y) <= 5) || ((pnt_y>=gry1) && (pnt_y<=gry2));

         res.menu = res.exact; // one could show context menu
         // distance to middle point, use to decide which menu to activate
         res.menu_dist = Math.sqrt((midx-pnt_x)**2 + (midy-pnt_y)**2);

      } else {
         let radius = this.lineatt.width + 3;

         if (ttrect.empty())
            ttrect = this.draw_g.append('svg:circle')
                                .attr('class','tooltip_bin')
                                .style('pointer-events','none')
                                .attr('r', radius)
                                .call(this.lineatt.func)
                                .call(this.fillatt.func);

         res.exact = (Math.abs(midx - pnt.x) <= radius) && (Math.abs(midy - pnt.y) <= radius);

         res.menu = res.exact; // show menu only when mouse pointer exactly over the histogram
         res.menu_dist = Math.sqrt((midx-pnt.x)**2 + (midy-pnt.y)**2);

         res.changed = ttrect.property('current_bin') !== findbin;

         if (res.changed)
            ttrect.attr('cx', midx)
                  .attr('cy', midy)
                  .property('current_bin', findbin);
      }

      if (res.changed)
         res.user_info = { obj: histo,  name: 'histo',
                           bin: findbin, cont: histo.getBinContent(findbin+1),
                           grx: midx, gry: midy };

      return res;
   }

   /** @summary Fill histogram context menu */
   fillHistContextMenu(menu) {

      menu.add('Auto zoom-in', () => this.autoZoom());

      let opts = this.getSupportedDrawOptions();

      menu.addDrawMenu('Draw with', opts, arg => {
         if (arg === 'inspect')
            return this.showInspector();

         this.decodeOptions(arg); // obsolete, should be implemented differently

         if (this.options.need_fillcol && this.fillatt && this.fillatt.empty())
            this.fillatt.change(5,1001);

         // redraw all objects
         this.interactiveRedraw('pad', 'drawopt');
      });
   }

   /** @summary Perform automatic zoom inside non-zero region of histogram */
   autoZoom() {
      let left = this.getSelectIndex('x', 'left', -1),
          right = this.getSelectIndex('x', 'right', 1),
          dist = right - left, histo = this.getHisto(), xaxis = this.getAxis('x');

      if (dist == 0) return;

      // first find minimum
      let min = histo.getBinContent(left + 1);
      for (let indx = left; indx < right; ++indx)
         min = Math.min(min, histo.getBinContent(indx+1));
      if (min > 0) return; // if all points positive, no chance for autoscale

      while ((left < right) && (histo.getBinContent(left+1) <= min)) ++left;
      while ((left < right) && (histo.getBinContent(right) <= min)) --right;

      // if singular bin
      if ((left === right-1) && (left > 2) && (right < this.nbinsx-2)) {
         --left; ++right;
      }

      if ((right - left < dist) && (left < right))
         return this.getFramePainter().zoom(xaxis.GetBinCoord(left), xaxis.GetBinCoord(right));
   }

   /** @summary Checks if it makes sense to zoom inside specified axis range */
   canZoomInside(axis,min,max) {
      let xaxis = this.getAxis('x');

      if ((axis == 'x') && (xaxis.FindBin(max,0.5) - xaxis.FindBin(min,0) > 1)) return true;

      if ((axis == 'y') && (Math.abs(max-min) > Math.abs(this.ymax-this.ymin)*1e-6)) return true;

      return false;
   }

   /** @summary Call appropriate draw function */
   async callDrawFunc(reason) {
      let main = this.getFramePainter();

      if (main && (main.mode3d !== this.options.Mode3D) && !this.isMainPainter())
         this.options.Mode3D = main.mode3d;

      return this.options.Mode3D ? this.draw3D(reason) : this.draw2D(reason);
   }

   /** @summary Draw in 2d */
   async draw2D(reason) {
      this.clear3DScene();

      return this.drawFrameAxes().then(res => {
         return res ? this.drawingBins(reason) : false;
      }).then(res => {
         if (res)
            return this.draw1DBins().then(() => this.addInteractivity());
      }).then(() => this);
   }

   /** @summary Draw in 3d */
   async draw3D(reason) {
      console.log('3D drawing is disabled, load ./hist/RH1Painter.mjs');
      return this.draw2D(reason);
   }

   /** @summary Readraw histogram */
   async redraw(reason) {
      return this.callDrawFunc(reason);
   }

   static async _draw(painter, opt) {
      return ensureRCanvas(painter).then(() => {

         painter.setAsMainPainter();

         painter.options = { Hist: false, Bar: false, BarStyle: 0,
                             Error: false, ErrorKind: -1, errorX: gStyle.fErrorX,
                             Zero: false, Mark: false,
                             Line: false, Fill: false, Lego: 0, Surf: 0,
                             Text: false, TextAngle: 0, TextKind: '', AutoColor: 0,
                             BarOffset: 0., BarWidth: 1., BaseLine: false, Mode3D: false };

         let d = new DrawOptions(opt);
         if (d.check('R3D_', true))
            painter.options.Render3D = constants$1.Render3D.fromString(d.part.toLowerCase());

         let kind = painter.v7EvalAttr('kind', 'hist'),
             sub = painter.v7EvalAttr('sub', 0),
             has_main = !!painter.getMainPainter(),
             o = painter.options;

         o.Text = painter.v7EvalAttr('drawtext', false);
         o.BarOffset = painter.v7EvalAttr('baroffset', 0.);
         o.BarWidth = painter.v7EvalAttr('barwidth', 1.);
         o.second_x = has_main && painter.v7EvalAttr('secondx', false);
         o.second_y = has_main && painter.v7EvalAttr('secondy', false);

         switch(kind) {
            case 'bar': o.Bar = true; o.BarStyle = sub; break;
            case 'err': o.Error = true; o.ErrorKind = sub; break;
            case 'p': o.Mark = true; break;
            case 'l': o.Line = true; break;
            case 'lego': o.Lego = sub > 0 ? 10+sub : 12; o.Mode3D = true; break;
            default: o.Hist = true;
         }

         painter.scanContent();

         return painter.callDrawFunc();
      });
   }

   /** @summary draw RH1 object */
   static async draw(dom, histo, opt) {
      return RH1Painter$2._draw(new RH1Painter$2(dom, histo), opt);
   }

} // class RH1Painter

class RH1Painter extends RH1Painter$2 {

   /** @summary Draw 1-D histogram in 3D mode */
   draw3D(reason) {

      this.mode3d = true;

      let main = this.getFramePainter(), // who makes axis drawing
          is_main = this.isMainPainter(), // is main histogram
          zmult = 1 + 2*gStyle.fHistTopMargin,
          pr = Promise.resolve(this);

      if (reason == 'resize')  {
         if (is_main && main.resize3D()) main.render3D();
         return pr;
      }

      this.deleteAttr();

      this.scanContent(true); // may be required for axis drawings

      if (is_main) {
         assignFrame3DMethods(main);
         pr = main.create3DScene(this.options.Render3D).then(() => {
            main.setAxesRanges(this.getAxis('x'), this.xmin, this.xmax, null, this.ymin, this.ymax, null, 0, 0);
            main.set3DOptions(this.options);
            main.drawXYZ(main.toplevel, RAxisPainter, { use_y_for_z: true, zmult, zoom: settings.Zooming, ndim: 1, draw: true, v7: true });
         });
      }

      if (!main.mode3d)
         return pr;

      return pr.then(() => this.drawingBins(reason)).then(() => {

         // called when bins received from server, must be reentrant
         let main = this.getFramePainter();

         drawBinsLego(this, true);
         this.updatePaletteDraw();
         main.render3D();
         main.addKeysHandler();
         return this;
      });
   }

      /** @summary draw RH1 object */
   static async draw(dom, histo, opt) {
      return RH1Painter._draw(new RH1Painter(dom, histo), opt);
   }

} // class RH1Painter

var RH1Painter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
RH1Painter: RH1Painter
});

/**
 * @summary Painter for RH2 classes
 *
 * @private
 */

class RH2Painter$2 extends RHistPainter {

   /** @summary constructor
     * @param {object|string} dom - DOM element or id
     * @param {object} histo - histogram object */
   constructor(dom, histo) {
      super(dom, histo);
      this.wheel_zoomy = true;
   }

   /** @summary Cleanup painter */
   cleanup() {
      delete this.tt_handle;
      super.cleanup();
   }

   /** @summary Returns histogram dimension */
   getDimension() { return 2; }

   /** @summary Toggle projection */
   toggleProjection(kind, width) {

      if (kind == 'Projections') kind = '';

      if (isStr(kind) && (kind.length > 1)) {
          width = parseInt(kind.slice(1));
          kind = kind[0];
      }

      if (!width) width = 1;

      if (kind && (this.is_projection==kind)) {
         if (this.projection_width === width) {
            kind = '';
         } else {
            this.projection_width = width;
            return;
         }
      }

      delete this.proj_hist;

      let new_proj = (this.is_projection === kind) ? '' : kind;
      this.is_projection = ''; // disable projection redraw until callback
      this.projection_width = width;

      this.provideSpecialDrawArea(new_proj).then(() => { this.is_projection = new_proj; return this.redrawProjection(); });
   }

   /** @summary Readraw projections */
   redrawProjection(/* ii1, ii2 , jj1, jj2*/) {
      // do nothing for the moment

      if (!this.is_projection) return;
   }

   /** @summary Execute menu command */
   executeMenuCommand(method, args) {
      if (super.executeMenuCommand(method, args)) return true;

      if ((method.fName == 'SetShowProjectionX') || (method.fName == 'SetShowProjectionY')) {
         this.toggleProjection(method.fName[17], args && parseInt(args) ? parseInt(args) : 1);
         return true;
      }

      return false;
   }

   /** @summary Fill histogram context menu */
   fillHistContextMenu(menu) {
      menu.add('sub:Projections', () => this.toggleProjection());
      let kind = this.is_projection || '';
      if (kind) kind += this.projection_width;
      let kinds = ['X1', 'X2', 'X3', 'X5', 'X10', 'Y1', 'Y2', 'Y3', 'Y5', 'Y10'];
      for (let k = 0; k < kinds.length; ++k)
         menu.addchk(kind == kinds[k], kinds[k], kinds[k], arg => this.toggleProjection(arg));
      menu.add('endsub:');

      menu.add('Auto zoom-in', () => this.autoZoom());

      let opts = this.getSupportedDrawOptions();

      menu.addDrawMenu('Draw with', opts, arg => {
         if (arg === 'inspect')
            return this.showInspector();
         this.decodeOptions(arg);
         this.interactiveRedraw('pad', 'drawopt');
      });

      if (this.options.Color)
         this.fillPaletteMenu(menu);
   }

   /** @summary Process click on histogram-defined buttons */
   clickButton(funcname) {
      if (super.clickButton(funcname)) return true;

      switch(funcname) {
         case 'ToggleColor': this.toggleColor(); break;
         case 'Toggle3D': this.toggleMode3D(); break;
         default: return false;
      }

      // all methods here should not be processed further
      return true;
   }

   /** @summary Fill pad toolbar with RH2-related functions */
   fillToolbar() {
      super.fillToolbar(true);

      let pp = this.getPadPainter();
      if (!pp) return;

      pp.addPadButton('th2color', 'Toggle color', 'ToggleColor');
      pp.addPadButton('th2colorz', 'Toggle color palette', 'ToggleColorZ');
      pp.addPadButton('th2draw3d', 'Toggle 3D mode', 'Toggle3D');
      pp.showPadButtons();
   }

   /** @summary Toggle color drawing mode */
   toggleColor() {

      if (this.options.Mode3D) {
         this.options.Mode3D = false;
         this.options.Color = true;
      } else {
         this.options.Color = !this.options.Color;
      }

      this.redraw();
   }

   /** @summary Perform automatic zoom inside non-zero region of histogram */
   autoZoom() {
      let i1 = this.getSelectIndex('x', 'left', -1),
          i2 = this.getSelectIndex('x', 'right', 1),
          j1 = this.getSelectIndex('y', 'left', -1),
          j2 = this.getSelectIndex('y', 'right', 1),
          i,j, histo = this.getHisto(), xaxis = this.getAxis('x'), yaxis = this.getAxis('y');

      if ((i1 == i2) || (j1 == j2)) return;

      // first find minimum
      let min = histo.getBinContent(i1 + 1, j1 + 1);
      for (i = i1; i < i2; ++i)
         for (j = j1; j < j2; ++j)
            min = Math.min(min, histo.getBinContent(i+1, j+1));
      if (min > 0) return; // if all points positive, no chance for autoscale

      let ileft = i2, iright = i1, jleft = j2, jright = j1;

      for (i = i1; i < i2; ++i)
         for (j = j1; j < j2; ++j)
            if (histo.getBinContent(i + 1, j + 1) > min) {
               if (i < ileft) ileft = i;
               if (i >= iright) iright = i + 1;
               if (j < jleft) jleft = j;
               if (j >= jright) jright = j + 1;
            }

      let xmin, xmax, ymin, ymax, isany = false;

      if ((ileft === iright-1) && (ileft > i1+1) && (iright < i2-1)) { ileft--; iright++; }
      if ((jleft === jright-1) && (jleft > j1+1) && (jright < j2-1)) { jleft--; jright++; }

      if ((ileft > i1 || iright < i2) && (ileft < iright - 1)) {
         xmin = xaxis.GetBinCoord(ileft);
         xmax = xaxis.GetBinCoord(iright);
         isany = true;
      }

      if ((jleft > j1 || jright < j2) && (jleft < jright - 1)) {
         ymin = yaxis.GetBinCoord(jleft);
         ymax = yaxis.GetBinCoord(jright);
         isany = true;
      }

      if (isany)
         return this.getFramePainter().zoom(xmin, xmax, ymin, ymax);
   }

   /** @summary Scan content of 2-dim histogram */
   scanContent(when_axis_changed) {

      // no need to rescan histogram while result does not depend from axis selection
      if (when_axis_changed && this.nbinsx && this.nbinsy) return;

      let i, j, histo = this.getHisto();

      this.extractAxesProperties(2);

      if (this.isDisplayItem()) {
         // take min/max values from the display item
         this.gminbin = histo.fContMin;
         this.gminposbin = histo.fContMinPos > 0 ? histo.fContMinPos : null;
         this.gmaxbin = histo.fContMax;
      } else {
         // global min/max, used at the moment in 3D drawing
         this.gminbin = this.gmaxbin = histo.getBinContent(1, 1);
         this.gminposbin = null;
         for (i = 0; i < this.nbinsx; ++i) {
            for (j = 0; j < this.nbinsy; ++j) {
               let bin_content = histo.getBinContent(i+1, j+1);
               if (bin_content < this.gminbin) this.gminbin = bin_content; else
                  if (bin_content > this.gmaxbin) this.gmaxbin = bin_content;
               if (bin_content > 0)
                  if ((this.gminposbin === null) || (this.gminposbin > bin_content)) this.gminposbin = bin_content;
            }
         }
      }

      this.zmin = this.gminbin;
      this.zmax = this.gmaxbin;

      // this value used for logz scale drawing
      if (this.gminposbin === null) this.gminposbin = this.gmaxbin*1e-4;

      if (this.options.Axis > 0) { // Paint histogram axis only
         this.draw_content = false;
      } else {
         this.draw_content = this.gmaxbin > 0;
      }
   }

   /** @summary Count statistic */
   countStat(cond) {
      let histo = this.getHisto(),
          stat_sum0 = 0, stat_sumx1 = 0, stat_sumy1 = 0,
          stat_sumx2 = 0, stat_sumy2 = 0,
          xside, yside, xx, yy, zz,
          res = { name: 'histo', entries: 0, integral: 0, meanx: 0, meany: 0, rmsx: 0, rmsy: 0, matrix: [0,0,0,0,0,0,0,0,0], xmax: 0, ymax:0, wmax: null };

      let xleft = this.getSelectIndex('x', 'left'),
          xright = this.getSelectIndex('x', 'right'),
          yleft = this.getSelectIndex('y', 'left'),
          yright = this.getSelectIndex('y', 'right'),
          xi, yi, xaxis = this.getAxis('x'), yaxis = this.getAxis('y');

      // TODO: account underflow/overflow bins, now stored in different array and only by histogram itself
      for (xi = 1; xi <= this.nbinsx; ++xi) {
         xside = (xi <= xleft+1) ? 0 : (xi > xright+1 ? 2 : 1);
         xx = xaxis.GetBinCoord(xi - 0.5);

         for (yi = 1; yi <= this.nbinsy; ++yi) {
            yside = (yi <= yleft+1) ? 0 : (yi > yright+1 ? 2 : 1);
            yy = yaxis.GetBinCoord(yi - 0.5);

            zz = histo.getBinContent(xi, yi);

            res.entries += zz;

            res.matrix[yside * 3 + xside] += zz;

            if ((xside != 1) || (yside != 1)) continue;

            if (cond && !cond(xx,yy)) continue;

            if ((res.wmax === null) || (zz > res.wmax)) { res.wmax = zz; res.xmax = xx; res.ymax = yy; }

            stat_sum0 += zz;
            stat_sumx1 += xx * zz;
            stat_sumy1 += yy * zz;
            stat_sumx2 += xx**2 * zz;
            stat_sumy2 += yy**2 * zz;
         }
      }

      if (Math.abs(stat_sum0) > 1e-300) {
         res.meanx = stat_sumx1 / stat_sum0;
         res.meany = stat_sumy1 / stat_sum0;
         res.rmsx = Math.sqrt(Math.abs(stat_sumx2 / stat_sum0 - res.meanx**2));
         res.rmsy = Math.sqrt(Math.abs(stat_sumy2 / stat_sum0 - res.meany**2));
      }

      if (res.wmax === null) res.wmax = 0;
      res.integral = stat_sum0;
      return res;
   }

   /** @summary Fill statistic into statbox */
   fillStatistic(stat, dostat /*, dofit*/) {

      let data = this.countStat(),
          print_name = Math.floor(dostat % 10),
          print_entries = Math.floor(dostat / 10) % 10,
          print_mean = Math.floor(dostat / 100) % 10,
          print_rms = Math.floor(dostat / 1000) % 10,
          print_under = Math.floor(dostat / 10000) % 10,
          print_over = Math.floor(dostat / 100000) % 10,
          print_integral = Math.floor(dostat / 1000000) % 10,
          print_skew = Math.floor(dostat / 10000000) % 10,
          print_kurt = Math.floor(dostat / 100000000) % 10;

      stat.clearStat();

      if (print_name > 0)
         stat.addText(data.name);

      if (print_entries > 0)
         stat.addText('Entries = ' + stat.format(data.entries,'entries'));

      if (print_mean > 0) {
         stat.addText('Mean x = ' + stat.format(data.meanx));
         stat.addText('Mean y = ' + stat.format(data.meany));
      }

      if (print_rms > 0) {
         stat.addText('Std Dev x = ' + stat.format(data.rmsx));
         stat.addText('Std Dev y = ' + stat.format(data.rmsy));
      }

      if (print_integral > 0)
         stat.addText('Integral = ' + stat.format(data.matrix[4], 'entries'));

      if (print_skew > 0) {
         stat.addText('Skewness x = <undef>');
         stat.addText('Skewness y = <undef>');
      }

      if (print_kurt > 0)
         stat.addText('Kurt = <undef>');

      if ((print_under > 0) || (print_over > 0)) {
         let m = data.matrix;

         stat.addText('' + m[6].toFixed(0) + ' | ' + m[7].toFixed(0) + ' | '  + m[7].toFixed(0));
         stat.addText('' + m[3].toFixed(0) + ' | ' + m[4].toFixed(0) + ' | '  + m[5].toFixed(0));
         stat.addText('' + m[0].toFixed(0) + ' | ' + m[1].toFixed(0) + ' | '  + m[2].toFixed(0));
      }

      return true;
   }

   /** @summary Draw histogram bins as color */
   drawBinsColor() {
      const histo = this.getHisto(),
            handle = this.prepareDraw(),
            di = handle.stepi, dj = handle.stepj,
            entries = [];
      let colindx, cmd1, cmd2, i, j, binz, dx, dy, entry, last_entry;

      const flush_last_entry = () => {
         last_entry.path += `h${dx}v${last_entry.y2-last_entry.y}h${-dx}z`;
         last_entry.dy = 0;
         last_entry = null;
      };

      // now start build
      for (i = handle.i1; i < handle.i2; i += di) {
         dx = (handle.grx[i+di] - handle.grx[i]) || 1;

         for (j = handle.j1; j < handle.j2; j += dj) {
            binz = histo.getBinContent(i+1, j+1);
            colindx = handle.palette.getContourIndex(binz);
            if (binz === 0) {
               if (!this.options.Zero)
                  colindx = null;
               else if ((colindx === null) && this._show_empty_bins)
                  colindx = 0;
            }
            if (colindx === null) {
               if (last_entry) flush_last_entry();
               continue;
            }

            cmd1 = `M${handle.grx[i]},${handle.gry[j]}`;

            dy = (handle.gry[j+dj] - handle.gry[j]) || -1;

            entry = entries[colindx];

            if (entry === undefined) {
               entry = entries[colindx] = { path: cmd1 };
            } else if ((entry === last_entry)) {
               entry.y2 = handle.gry[j] + dy;
               continue;
            } else {
               cmd2 = `m${handle.grx[i]-entry.x},${handle.gry[j]-entry.y}`;
               entry.path += (cmd2.length < cmd1.length) ? cmd2 : cmd1;
            }
            if (last_entry) flush_last_entry();
            entry.x = handle.grx[i];
            entry.y = handle.gry[j];
            {
               entry.y2 = handle.gry[j] + dy;
               last_entry = entry;
            }
         }
         if (last_entry) flush_last_entry();
      }

      entries.forEach((entry,colindx) => {
        if (entry)
           this.draw_g
               .append('svg:path')
               .style('fill', handle.palette.getColor(colindx))
               .attr('d', entry.path);
      });

      this.updatePaletteDraw();

      return handle;
   }

   /** @summary Build histogram contour lines */
   buildContour(handle, levels, palette, contour_func) {
      let histo = this.getHisto(),
          kMAXCONTOUR = 2004,
          kMAXCOUNT = 2000,
          // arguments used in the PaintContourLine
          xarr = new Float32Array(2*kMAXCONTOUR),
          yarr = new Float32Array(2*kMAXCONTOUR),
          itarr = new Int32Array(2*kMAXCONTOUR),
          lj = 0, ipoly, poly, polys = [], np, npmax = 0,
          x = [0.,0.,0.,0.], y = [0.,0.,0.,0.], zc = [0.,0.,0.,0.], ir = [0,0,0,0],
          i, j, k, n, m, ix, ljfill, count,
          xsave, ysave, itars, jx,
          di = handle.stepi, dj = handle.stepj;

      function BinarySearch(zc) {
         for (let kk=0;kk<levels.length;++kk)
            if (zc<levels[kk]) return kk-1;
         return levels.length-1;
      }

      function PaintContourLine(elev1, icont1, x1, y1,  elev2, icont2, x2, y2) {
         /* Double_t *xarr, Double_t *yarr, Int_t *itarr, Double_t *levels */
         let vert = (x1 === x2),
             tlen = vert ? (y2 - y1) : (x2 - x1),
             n = icont1 +1,
             tdif = elev2 - elev1,
             ii = lj-1,
             maxii = kMAXCONTOUR/2 -3 + lj,
             icount = 0,
             xlen, pdif, diff, elev;

         while (n <= icont2 && ii <= maxii) {
            elev = levels[n];
            diff = elev - elev1;
            pdif = diff/tdif;
            xlen = tlen*pdif;
            if (vert) {
               xarr[ii] = x1;
               yarr[ii] = y1 + xlen;
            } else {
               xarr[ii] = x1 + xlen;
               yarr[ii] = y1;
            }
            itarr[ii] = n;
            icount++;
            ii +=2;
            n++;
         }
         return icount;
      }

      let arrx = handle.original ? handle.origx : handle.grx,
          arry = handle.original ? handle.origy : handle.gry;

      for (j = handle.j1; j < handle.j2-dj; j += dj) {

         y[1] = y[0] = (arry[j] + arry[j+dj])/2;
         y[3] = y[2] = (arry[j+dj] + arry[j+2*dj])/2;

         for (i = handle.i1; i < handle.i2-di; i += di) {

            zc[0] = histo.getBinContent(i+1, j+1);
            zc[1] = histo.getBinContent(i+1+di, j+1);
            zc[2] = histo.getBinContent(i+1+di, j+1+dj);
            zc[3] = histo.getBinContent(i+1, j+1+dj);

            for (k=0;k<4;k++)
               ir[k] = BinarySearch(zc[k]);

            if ((ir[0] !== ir[1]) || (ir[1] !== ir[2]) || (ir[2] !== ir[3]) || (ir[3] !== ir[0])) {
               x[3] = x[0] = (arrx[i] + arrx[i+1])/2;
               x[2] = x[1] = (arrx[i+1] + arrx[i+2])/2;

               if (zc[0] <= zc[1]) n = 0; else n = 1;
               if (zc[2] <= zc[3]) m = 2; else m = 3;
               if (zc[n] > zc[m]) n = m;
               n++;
               lj=1;
               for (ix=1;ix<=4;ix++) {
                  m = n%4 + 1;
                  ljfill = PaintContourLine(zc[n-1],ir[n-1],x[n-1],y[n-1],
                        zc[m-1],ir[m-1],x[m-1],y[m-1]);
                  lj += 2*ljfill;
                  n = m;
               }

               if (zc[0] <= zc[1]) n = 0; else n = 1;
               if (zc[2] <= zc[3]) m = 2; else m = 3;
               if (zc[n] > zc[m]) n = m;
               n++;
               lj=2;
               for (ix=1;ix<=4;ix++) {
                  if (n == 1) m = 4;
                  else        m = n-1;
                  ljfill = PaintContourLine(zc[n-1],ir[n-1],x[n-1],y[n-1],
                        zc[m-1],ir[m-1],x[m-1],y[m-1]);
                  lj += 2*ljfill;
                  n = m;
               }
               //     Re-order endpoints

               count = 0;
               for (ix=1; ix<=lj-5; ix +=2) {
                  //count = 0;
                  while (itarr[ix-1] != itarr[ix]) {
                     xsave = xarr[ix];
                     ysave = yarr[ix];
                     itars = itarr[ix];
                     for (jx=ix; jx<=lj-5; jx +=2) {
                        xarr[jx]  = xarr[jx+2];
                        yarr[jx]  = yarr[jx+2];
                        itarr[jx] = itarr[jx+2];
                     }
                     xarr[lj-3]  = xsave;
                     yarr[lj-3]  = ysave;
                     itarr[lj-3] = itars;
                     if (count > kMAXCOUNT) break;
                     count++;
                  }
               }

               if (count > kMAXCOUNT) continue;

               for (ix=1; ix<=lj-2; ix +=2) {

                  ipoly = itarr[ix-1];

                  if ((ipoly >= 0) && (ipoly < levels.length)) {
                     poly = polys[ipoly];
                     if (!poly)
                        poly = polys[ipoly] = createTPolyLine(kMAXCONTOUR*4, true);

                     np = poly.fLastPoint;
                     if (np < poly.fN-2) {
                        poly.fX[np+1] = Math.round(xarr[ix-1]); poly.fY[np+1] = Math.round(yarr[ix-1]);
                        poly.fX[np+2] = Math.round(xarr[ix]); poly.fY[np+2] = Math.round(yarr[ix]);
                        poly.fLastPoint = np+2;
                        npmax = Math.max(npmax, poly.fLastPoint+1);
                     }
                  }
               }
            } // end of if (ir[0]
         } // end of j
      } // end of i

      let polysort = new Int32Array(levels.length), first = 0;
      // find first positive contour
      for (ipoly=0;ipoly<levels.length;ipoly++) {
         if (levels[ipoly] >= 0) { first = ipoly; break; }
      }
      //store negative contours from 0 to minimum, then all positive contours
      k = 0;
      for (ipoly = first - 1; ipoly >= 0; ipoly--) { polysort[k] = ipoly; k++; }
      for (ipoly = first; ipoly < levels.length; ipoly++) { polysort[k] = ipoly; k++; }

      let xp = new Float32Array(2*npmax),
          yp = new Float32Array(2*npmax);

      for (k=0;k<levels.length;++k) {

         ipoly = polysort[k];
         poly = polys[ipoly];
         if (!poly) continue;

         let colindx = ipoly,
             xx = poly.fX, yy = poly.fY, np = poly.fLastPoint+1,
             istart = 0, iminus, iplus, xmin = 0, ymin = 0, nadd;

         while (true) {

            iminus = npmax;
            iplus  = iminus+1;
            xp[iminus]= xx[istart];   yp[iminus] = yy[istart];
            xp[iplus] = xx[istart+1]; yp[iplus]  = yy[istart+1];
            xx[istart] = xx[istart+1] = xmin;
            yy[istart] = yy[istart+1] = ymin;
            while (true) {
               nadd = 0;
               for (i = 2; i < np; i += 2) {
                  if ((iplus < 2*npmax-1) && (xx[i] === xp[iplus]) && (yy[i] === yp[iplus])) {
                     iplus++;
                     xp[iplus] = xx[i+1]; yp[iplus] = yy[i+1];
                     xx[i] = xx[i+1] = xmin;
                     yy[i] = yy[i+1] = ymin;
                     nadd++;
                  }
                  if ((iminus > 0) && (xx[i+1] === xp[iminus]) && (yy[i+1] === yp[iminus])) {
                     iminus--;
                     xp[iminus] = xx[i]; yp[iminus] = yy[i];
                     xx[i] = xx[i+1] = xmin;
                     yy[i] = yy[i+1] = ymin;
                     nadd++;
                  }
               }
               if (nadd == 0) break;
            }

            if ((iminus+1 < iplus) && (iminus >= 0))
               contour_func(colindx, xp, yp, iminus, iplus, ipoly);

            istart = 0;
            for (i=2;i<np;i+=2) {
               if (xx[i] !== xmin && yy[i] !== ymin) {
                  istart = i;
                  break;
               }
            }

            if (istart === 0) break;
         }
      }
   }

   /** @summary Draw histogram bins as contour */
   drawBinsContour(funcs, frame_w,frame_h) {
      let handle = this.prepareDraw({ rounding: false, extra: 100, original: this.options.Proj != 0 }),
          main = this.getFramePainter(),
          palette = main.getHistPalette(),
          levels = palette.getContour(),
          func = main.getProjectionFunc();

      let BuildPath = (xp,yp,iminus,iplus,do_close) => {
         let cmd = '', last, pnt, first, isany;
         for (let i = iminus; i <= iplus; ++i) {
            if (func) {
               pnt = func(xp[i], yp[i]);
               pnt.x = Math.round(funcs.grx(pnt.x));
               pnt.y = Math.round(funcs.gry(pnt.y));
            } else {
               pnt = { x: Math.round(xp[i]), y: Math.round(yp[i]) };
            }
            if (!cmd) {
               cmd = 'M' + pnt.x + ',' + pnt.y; first = pnt;
            } else if ((i == iplus) && first && (pnt.x == first.x) && (pnt.y == first.y)) {
               if (!isany) return ''; // all same points
               cmd += 'z'; do_close = false;
            } else if ((pnt.x != last.x) && (pnt.y != last.y)) {
               cmd +=  'l' + (pnt.x - last.x) + ',' + (pnt.y - last.y); isany = true;
            } else if (pnt.x != last.x) {
               cmd +=  'h' + (pnt.x - last.x); isany = true;
            } else if (pnt.y != last.y) {
               cmd +=  'v' + (pnt.y - last.y); isany = true;
            }
            last = pnt;
         }
         if (do_close) cmd += 'z';
         return cmd;
      };

      if (this.options.Contour === 14) {
         let dd = `M0,0h${frame_w}v${frame_h}h${-frame_w}z`;
         if (this.options.Proj) {
            let dj = handle.stepj, sz = parseInt((handle.j2 - handle.j1)/dj),
                xd = new Float32Array(sz*2), yd = new Float32Array(sz*2);
            for (let i=0;i<sz;++i) {
               xd[i] = handle.origx[handle.i1];
               yd[i] = (handle.origy[handle.j1]*(i*dj+0.5) + handle.origy[handle.j2]*(sz-0.5-i*dj))/sz;
               xd[i+sz] = handle.origx[handle.i2];
               yd[i+sz] = (handle.origy[handle.j2]*(i*dj+0.5) + handle.origy[handle.j1]*(sz-0.5-i*dj))/sz;
            }
            dd = BuildPath(xd,yd,0,2*sz-1,true);
         }

         this.draw_g
             .append('svg:path')
             .attr('d', dd)
             .style('fill', palette.getColor(0));
      }

      this.buildContour(handle, levels, palette,
         (colindx,xp,yp,iminus,iplus) => {
            let icol = palette.getColor(colindx),
                fillcolor = icol, lineatt;

            switch (this.options.Contour) {
               case 1: break;
               case 11: fillcolor = 'none'; lineatt = new TAttLineHandler({ color: icol }); break;
               case 12: fillcolor = 'none'; lineatt = new TAttLineHandler({ color:1, style: (colindx%5 + 1), width: 1 }); break;
               case 13: fillcolor = 'none'; lineatt = this.lineatt; break;
            }

            let dd = BuildPath(xp, yp, iminus, iplus, fillcolor != 'none');
            if (!dd) return;

            let elem = this.draw_g
                          .append('svg:path')
                          .attr('class','th2_contour')
                          .attr('d', dd)
                          .style('fill', fillcolor);

            if (lineatt)
               elem.call(lineatt.func);
         }
      );

      handle.hide_only_zeros = true; // text drawing suppress only zeros

      return handle;
   }

   /** @summary Create polybin */
   createPolyBin() {
      // see how TH2Painter is implemented
      return '';
   }

   /** @summary Draw RH2 bins as text */
   drawBinsText(handle) {
      let histo = this.getHisto(),
          i, j, binz, binw, binh, text, x, y, width, height;

      if (handle === null) handle = this.prepareDraw({ rounding: false });

      let textFont  = this.v7EvalFont('text', { size: 20, color: 'black', align: 22 }),
          text_offset = 0,
          text_g = this.draw_g.append('svg:g').attr('class','th2_text'),
          di = handle.stepi, dj = handle.stepj;

      if (this.options.BarOffset) text_offset = this.options.BarOffset;

      this.startTextDrawing(textFont, 'font', text_g);

      for (i = handle.i1; i < handle.i2; i += di)
         for (j = handle.j1; j < handle.j2; j += dj) {
            binz = histo.getBinContent(i+1, j+1);
            if ((binz === 0) && !this._show_empty_bins) continue;

            binw = handle.grx[i+di] - handle.grx[i];
            binh = handle.gry[j] - handle.gry[j+dj];

            text = (binz === Math.round(binz)) ? binz.toString() :
                      floatToString(binz, gStyle.fPaintTextFormat);

            if (textFont.angle) {
               x = Math.round(handle.grx[i] + binw*0.5);
               y = Math.round(handle.gry[j+dj] + binh*(0.5 + text_offset));
               width = height = 0;
            } else {
               x = Math.round(handle.grx[i] + binw*0.1);
               y = Math.round(handle.gry[j+dj] + binh*(0.1 + text_offset));
               width = Math.round(binw*0.8);
               height = Math.round(binh*0.8);
            }

            this.drawText({ align: 22, x, y, width, height, text, latex: 0, draw_g: text_g });
         }

      return this.finishTextDrawing(text_g, true).then(() => {

         handle.hide_only_zeros = true; // text drawing suppress only zeros

         return handle;
      });
   }

   /** @summary Draw RH2 bins as arrows */
   drawBinsArrow() {
      let histo = this.getHisto(), cmd = '',
          i,j, dn = 1e-30, dx, dy, xc,yc,
          dxn,dyn,x1,x2,y1,y2, anr,si,co,
          handle = this.prepareDraw({ rounding: false }),
          scale_x = (handle.grx[handle.i2] - handle.grx[handle.i1])/(handle.i2 - handle.i1 + 1-0.03)/2,
          scale_y = (handle.gry[handle.j2] - handle.gry[handle.j1])/(handle.j2 - handle.j1 + 1-0.03)/2,
          di = handle.stepi, dj = handle.stepj;

      const makeLine = (dx, dy) => {
         if (dx)
            return dy ? `l${dx},${dy}` : `h${dx}`;
         return dy ? `v${dy}` : '';
      };

      for (let loop = 0; loop < 2; ++loop)
         for (i = handle.i1; i < handle.i2; i += di)
            for (j = handle.j1; j < handle.j2; j += dj) {

               if (i === handle.i1) {
                  dx = histo.getBinContent(i+1+di, j+1) - histo.getBinContent(i+1, j+1);
               } else if (i >= handle.i2-di) {
                  dx = histo.getBinContent(i+1, j+1) - histo.getBinContent(i+1-di, j+1);
               } else {
                  dx = 0.5*(histo.getBinContent(i+1+di, j+1) - histo.getBinContent(i+1-di, j+1));
               }
               if (j === handle.j1) {
                  dy = histo.getBinContent(i+1, j+1+dj) - histo.getBinContent(i+1, j+1);
               } else if (j >= handle.j2-dj) {
                  dy = histo.getBinContent(i+1, j+1) - histo.getBinContent(i+1, j+1-dj);
               } else {
                  dy = 0.5*(histo.getBinContent(i+1, j+1+dj) - histo.getBinContent(i+1, j+1-dj));
               }

               if (loop === 0) {
                  dn = Math.max(dn, Math.abs(dx), Math.abs(dy));
               } else {
                  xc = (handle.grx[i] + handle.grx[i+di])/2;
                  yc = (handle.gry[j] + handle.gry[j+dj])/2;
                  dxn = scale_x*dx/dn;
                  dyn = scale_y*dy/dn;
                  x1  = xc - dxn;
                  x2  = xc + dxn;
                  y1  = yc - dyn;
                  y2  = yc + dyn;
                  dx = Math.round(x2-x1);
                  dy = Math.round(y2-y1);

                  if ((dx !== 0) || (dy !== 0)) {
                     cmd += 'M'+Math.round(x1)+','+Math.round(y1) + makeLine(dx,dy);
                     if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                        anr = Math.sqrt(2/(dx**2 + dy**2));
                        si  = Math.round(anr*(dx + dy));
                        co  = Math.round(anr*(dx - dy));
                        if (si || co)
                           cmd += `m${-si},${co}` + makeLine(si,-co) + makeLine(-co,-si);                     }
                  }
               }
            }

      this.draw_g
         .append('svg:path')
         .attr('d', cmd)
         .style('fill', 'none')
         .call(this.lineatt.func);

      return handle;
   }

   /** @summary Draw RH2 bins as boxes */
   drawBinsBox() {

      let histo = this.getHisto(),
          handle = this.prepareDraw({ rounding: false }),
          main = this.getFramePainter();

      if (main.maxbin === main.minbin) {
         main.maxbin = this.gmaxbin;
         main.minbin = this.gminbin;
         main.minposbin = this.gminposbin;
      }
      if (main.maxbin === main.minbin)
         main.minbin = Math.min(0, main.maxbin-1);

      let absmax = Math.max(Math.abs(main.maxbin), Math.abs(main.minbin)),
          absmin = Math.max(0, main.minbin),
          i, j, binz, absz, res = '', cross = '', btn1 = '', btn2 = '',
          zdiff, dgrx, dgry, xx, yy, ww, hh,
          xyfactor, uselogz = false, logmin = 0,
          di = handle.stepi, dj = handle.stepj;

      if (main.logz && (absmax > 0)) {
         uselogz = true;
         let logmax = Math.log(absmax);
         if (absmin > 0)
            logmin = Math.log(absmin);
         else if ((main.minposbin >= 1) && (main.minposbin < 100))
            logmin = Math.log(0.7);
          else
            logmin = (main.minposbin > 0) ? Math.log(0.7*main.minposbin) : logmax - 10;
         if (logmin >= logmax) logmin = logmax - 10;
         xyfactor = 1. / (logmax - logmin);
      } else {
         xyfactor = 1. / (absmax - absmin);
      }

      // now start build
      for (i = handle.i1; i < handle.i2; i += di) {
         for (j = handle.j1; j < handle.j2; j += dj) {
            binz = histo.getBinContent(i + 1, j + 1);
            absz = Math.abs(binz);
            if ((absz === 0) || (absz < absmin)) continue;

            zdiff = uselogz ? ((absz > 0) ? Math.log(absz) - logmin : 0) : (absz - absmin);
            // area of the box should be proportional to absolute bin content
            zdiff = 0.5 * ((zdiff < 0) ? 1 : (1 - Math.sqrt(zdiff * xyfactor)));
            // avoid oversized bins
            if (zdiff < 0) zdiff = 0;

            ww = handle.grx[i+di] - handle.grx[i];
            hh = handle.gry[j] - handle.gry[j+dj];

            dgrx = zdiff * ww;
            dgry = zdiff * hh;

            xx = Math.round(handle.grx[i] + dgrx);
            yy = Math.round(handle.gry[j+dj] + dgry);

            ww = Math.max(Math.round(ww - 2*dgrx), 1);
            hh = Math.max(Math.round(hh - 2*dgry), 1);

            res += `M${xx},${yy}v${hh}h${ww}v${-hh}z`;

            if ((binz < 0) && (this.options.BoxStyle === 10))
               cross += `M${xx},${yy}l${ww},${hh}M${xx+ww},${yy}l${-ww},${hh}`;

            if ((this.options.BoxStyle === 11) && (ww>5) && (hh>5)) {
               let pww = Math.round(ww*0.1),
                   phh = Math.round(hh*0.1),
                   side1 = `M${xx},${yy}h${ww}l${-pww},${phh}h${2*pww-ww}v${hh-2*phh}l${-pww},${phh}z`,
                   side2 = `M${xx+ww},${yy+hh}v${-hh}l${-pww},${phh}v${hh-2*phh}h${2*pww-ww}l${-pww},${phh}z`;
               if (binz < 0) { btn2 += side1; btn1 += side2; }
                        else { btn1 += side1; btn2 += side2; }
            }
         }
      }

      if (res) {
         let elem = this.draw_g
                        .append('svg:path')
                        .attr('d', res)
                        .call(this.fillatt.func);
         if ((this.options.BoxStyle !== 11) && this.fillatt.empty())
            elem.call(this.lineatt.func);
      }

      if (btn1 && this.fillatt.hasColor())
         this.draw_g.append('svg:path')
                    .attr('d', btn1)
                    .call(this.fillatt.func)
                    .style('fill', rgb(this.fillatt.color).brighter(0.5).formatHex());

      if (btn2)
         this.draw_g.append('svg:path')
                    .attr('d', btn2)
                    .call(this.fillatt.func)
                    .style('fill', !this.fillatt.hasColor() ? 'red' : rgb(this.fillatt.color).darker(0.5).formatHex());

      if (cross) {
         let elem = this.draw_g.append('svg:path')
                               .attr('d', cross)
                               .style('fill', 'none');
         if (!this.lineatt.empty())
            elem.call(this.lineatt.func);
      }

      return handle;
   }

   /** @summary Draw RH2 bins as scatter plot */
   drawBinsScatter() {
      let histo = this.getHisto(),
          handle = this.prepareDraw({ rounding: true, pixel_density: true, scatter_plot: true }),
          colPaths = [], currx = [], curry = [], cell_w = [], cell_h = [],
          colindx, cmd1, cmd2, i, j, binz, cw, ch, factor = 1.,
          scale = this.options.ScatCoef * ((this.gmaxbin) > 2000 ? 2000. / this.gmaxbin : 1.),
          di = handle.stepi, dj = handle.stepj;

      let rnd = new TRandom(handle.sumz);

      if (scale*handle.sumz < 1e5) {
         // one can use direct drawing of scatter plot without any patterns

         this.createv7AttMarker();

         this.markeratt.resetPos();

         let path = '', k, npix;
         for (i = handle.i1; i < handle.i2; i += di) {
            cw = handle.grx[i+di] - handle.grx[i];
            for (j = handle.j1; j < handle.j2; j += dj) {
               ch = handle.gry[j] - handle.gry[j+dj];
               binz = histo.getBinContent(i + 1, j + 1);

               npix = Math.round(scale*binz);
               if (npix <= 0) continue;

               for (k = 0; k < npix; ++k)
                  path += this.markeratt.create(
                            Math.round(handle.grx[i] + cw * rnd.random()),
                            Math.round(handle.gry[j+1] + ch * rnd.random()));
            }
         }

         this.draw_g
              .append('svg:path')
              .attr('d', path)
              .call(this.markeratt.func);

         return handle;
      }

      // limit filling factor, do not try to produce as many points as filled area;
      if (this.maxbin > 0.7) factor = 0.7/this.maxbin;

      // let nlevels = Math.round(handle.max - handle.min);

      // now start build
      for (i = handle.i1; i < handle.i2; i += di) {
         for (j = handle.j1; j < handle.j2; j += dj) {
            binz = histo.getBinContent(i + 1, j + 1);
            if ((binz <= 0) || (binz < this.minbin)) continue;

            cw = handle.grx[i+di] - handle.grx[i];
            ch = handle.gry[j] - handle.gry[j+dj];
            if (cw*ch <= 0) continue;

            colindx = handle.palette.getContourIndex(binz/cw/ch);
            if (colindx < 0) continue;

            cmd1 = `M${handle.grx[i]},${handle.gry[j+dj]}`;
            if (colPaths[colindx] === undefined) {
               colPaths[colindx] = cmd1;
               cell_w[colindx] = cw;
               cell_h[colindx] = ch;
            } else {
               cmd2 = `m${handle.grx[i]-currx[colindx]},${handle.gry[j+dj] - curry[colindx]}`;
               colPaths[colindx] += (cmd2.length < cmd1.length) ? cmd2 : cmd1;
               cell_w[colindx] = Math.max(cell_w[colindx], cw);
               cell_h[colindx] = Math.max(cell_h[colindx], ch);
            }

            currx[colindx] = handle.grx[i];
            curry[colindx] = handle.gry[j+dj];

            colPaths[colindx] += `v${ch}h${cw}v${-ch}z`;
         }
      }

      let layer = this.getFrameSvg().select('.main_layer'),
          defs = layer.select('def');
      if (defs.empty() && (colPaths.length > 0))
         defs = layer.insert('svg:defs', ':first-child');

      this.createv7AttMarker();

      let cntr = handle.palette.getContour();

      for (colindx = 0; colindx < colPaths.length; ++colindx)
        if ((colPaths[colindx] !== undefined) && (colindx<cntr.length)) {
           let pattern_class = 'scatter_' + colindx,
               pattern = defs.select('.' + pattern_class);
           if (pattern.empty())
              pattern = defs.append('svg:pattern')
                            .attr('class', pattern_class)
                            .attr('id', 'jsroot_scatter_pattern_' + internals.id_counter++)
                            .attr('patternUnits','userSpaceOnUse');
           else
              pattern.selectAll('*').remove();

           let npix = Math.round(factor*cntr[colindx]*cell_w[colindx]*cell_h[colindx]);
           if (npix < 1) npix = 1;

           let arrx = new Float32Array(npix), arry = new Float32Array(npix);

           if (npix === 1) {
              arrx[0] = arry[0] = 0.5;
           } else {
              for (let n = 0; n < npix; ++n) {
                 arrx[n] = rnd.random();
                 arry[n] = rnd.random();
              }
           }

           // arrx.sort();

           this.markeratt.resetPos();

           let path = '';

           for (let n = 0; n < npix; ++n)
              path += this.markeratt.create(arrx[n] * cell_w[colindx], arry[n] * cell_h[colindx]);

           pattern.attr('width', cell_w[colindx])
                  .attr('height', cell_h[colindx])
                  .append('svg:path')
                  .attr('d',path)
                  .call(this.markeratt.func);

           this.draw_g
               .append('svg:path')
               .attr('scatter-index', colindx)
               .style('fill', `url(#${pattern.attr('id')})`)
               .attr('d', colPaths[colindx]);
        }

      return handle;
   }

   /** @summary Draw RH2 bins in 2D mode */
   async draw2DBins() {

      if (!this.draw_content) {
         this.removeG();
         return false;
      }

      this.createHistDrawAttributes();

      this.createG(true);

      let pmain = this.getFramePainter(),
          rect = pmain.getFrameRect(),
          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),
          handle = null, pr = null;

      // if (this.lineatt.empty()) this.lineatt.color = 'cyan';

      if (this.options.Scat)
         handle = this.drawBinsScatter();
      else if (this.options.Color)
         handle = this.drawBinsColor();
      else if (this.options.Box)
         handle = this.drawBinsBox();
      else if (this.options.Arrow)
         handle = this.drawBinsArrow();
      else if (this.options.Contour > 0)
         handle = this.drawBinsContour(funcs, rect.width, rect.height);

      if (this.options.Text)
         pr = this.drawBinsText(handle);

      if (!handle && !pr)
         handle = this.drawBinsColor();

      if (!pr) pr = Promise.resolve(handle);

      return pr.then(h => {
         this.tt_handle = h;
         return this;
      });
   }

   /** @summary Provide text information (tooltips) for histogram bin */
   getBinTooltips(i, j) {
      let lines = [],
           histo = this.getHisto(),
           binz = histo.getBinContent(i+1,j+1),
           di = 1, dj = 1;

      if (this.isDisplayItem()) {
         di = histo.stepx || 1;
         dj = histo.stepy || 1;
      }

      lines.push(this.getObjectHint() || 'histo<2>');
      lines.push('x = ' + this.getAxisBinTip('x', i, di),
                 'y = ' + this.getAxisBinTip('y', j, dj));

      lines.push(`bin = ${i+1}, ${j+1}`);

      if (histo.$baseh) binz -= histo.$baseh.getBinContent(i+1,j+1);

      let lbl = 'entries = ' + ((di > 1) || (dj > 1) ? '~' : '');

      if (binz === Math.round(binz))
         lines.push(lbl + binz);
      else
         lines.push(lbl + floatToString(binz, gStyle.fStatFormat));

      return lines;
   }

   /** @summary Provide text information (tooltips) for poly bin */
   getPolyBinTooltips() {
      // see how TH2Painter is implemented
      return [];
   }

   /** @summary Process tooltip event */
   processTooltipEvent(pnt) {
      if (!pnt || !this.draw_content || !this.draw_g || !this.tt_handle || this.options.Proj) {
         if (this.draw_g)
            this.draw_g.select('.tooltip_bin').remove();
         return null;
      }

      let histo = this.getHisto(),
          h = this.tt_handle,
          ttrect = this.draw_g.select('.tooltip_bin');

      if (h.poly) {
         // process tooltips from TH2Poly - see TH2Painter
         return null;
      }

      let i, j, binz = 0, colindx = null;

      // search bins position
      for (i = h.i1; i < h.i2; ++i)
         if ((pnt.x>=h.grx[i]) && (pnt.x<=h.grx[i+1])) break;

      for (j = h.j1; j < h.j2; ++j)
         if ((pnt.y>=h.gry[j+1]) && (pnt.y<=h.gry[j])) break;

      if ((i < h.i2) && (j < h.j2)) {
         binz = histo.getBinContent(i+1,j+1);
         if (this.is_projection) {
            colindx = 0; // just to avoid hide
         } else if (h.hide_only_zeros) {
            colindx = (binz === 0) && !this._show_empty_bins ? null : 0;
         } else {
            colindx = h.palette.getContourIndex(binz);
            if ((colindx === null) && (binz === 0) && this._show_empty_bins) colindx = 0;
         }
      }

      if (colindx === null) {
         ttrect.remove();
         return null;
      }

      let res = { name: 'histo', title: histo.fTitle || 'title',
                  x: pnt.x, y: pnt.y,
                  color1: this.lineatt ? this.lineatt.color : 'green',
                  color2: this.fillatt ? this.fillatt.getFillColorAlt('blue') : 'blue',
                  lines: this.getBinTooltips(i, j), exact: true, menu: true };

      if (this.options.Color) res.color2 = h.palette.getColor(colindx);

      if (pnt.disabled && !this.is_projection) {
         ttrect.remove();
         res.changed = true;
      } else {
         if (ttrect.empty())
            ttrect = this.draw_g.append('svg:rect')
                                .attr('class','tooltip_bin h1bin')
                                .style('pointer-events','none');

         let i1 = i, i2 = i+1,
             j1 = j, j2 = j+1,
             x1 = h.grx[i1], x2 = h.grx[i2],
             y1 = h.gry[j2], y2 = h.gry[j1],
             binid = i*10000 + j;

         if (this.is_projection == 'X') {
            x1 = 0; x2 = this.getFramePainter().getFrameWidth();
            if (this.projection_width > 1) {
               let dd = (this.projection_width-1)/2;
               if (j2+dd >= h.j2) { j2 = Math.min(Math.round(j2+dd), h.j2); j1 = Math.max(j2 - this.projection_width, h.j1); }
                             else { j1 = Math.max(Math.round(j1-dd), h.j1); j2 = Math.min(j1 + this.projection_width, h.j2); }
            }
            y1 = h.gry[j2]; y2 = h.gry[j1];
            binid = j1*777 + j2*333;
         } else if (this.is_projection == 'Y') {
            y1 = 0; y2 = this.getFramePainter().getFrameHeight();
            if (this.projection_width > 1) {
               let dd = (this.projection_width-1)/2;
               if (i2+dd >= h.i2) { i2 = Math.min(Math.round(i2+dd), h.i2); i1 = Math.max(i2 - this.projection_width, h.i1); }
                             else { i1 = Math.max(Math.round(i1-dd), h.i1); i2 = Math.min(i1 + this.projection_width, h.i2); }
            }
            x1 = h.grx[i1], x2 = h.grx[i2],
            binid = i1*777 + i2*333;
         }

         res.changed = ttrect.property('current_bin') !== binid;

         if (res.changed)
            ttrect.attr('x', x1)
                  .attr('width', x2 - x1)
                  .attr('y', y1)
                  .attr('height', y2 - y1)
                  .style('opacity', '0.7')
                  .property('current_bin', binid);

         if (this.is_projection && res.changed)
            this.redrawProjection(i1, i2, j1, j2);
      }

      if (res.changed)
         res.user_info = { obj: histo, name: 'histo',
                           bin: histo.getBin(i+1, j+1), cont: binz, binx: i+1, biny: j+1,
                           grx: pnt.x, gry: pnt.y };

      return res;
   }

   /** @summary Checks if it makes sense to zoom inside specified axis range */
   canZoomInside(axis,min,max) {
      if (axis == 'z') return true;
      let obj = this.getAxis(axis);
      return obj.FindBin(max,0.5) - obj.FindBin(min,0) > 1;
   }

   /** @summary Performs 2D drawing of histogram
     * @return {Promise} when ready */
   async draw2D(reason) {
      this.clear3DScene();

      return this.drawFrameAxes().then(res => {
        return res ? this.drawingBins(reason) : false;
      }).then(res => {
         if (res) return this.draw2DBins().then(() => this.addInteractivity());
      }).then(() => this);
   }

   /** @summary Performs 3D drawing of histogram
     * @return {Promise} when ready */
   async draw3D(reason) {
      console.log('3D drawing is disabled, load ./hist/RH1Painter.mjs');
      return this.draw2D(reason);
   }

   /** @summary Call drawing function depending from 3D mode */
   async callDrawFunc(reason) {
      let main = this.getFramePainter();

      if (main && (main.mode3d !== this.options.Mode3D) && !this.isMainPainter())
         this.options.Mode3D = main.mode3d;

      return this.options.Mode3D ? this.draw3D(reason) : this.draw2D(reason);
   }

   /** @summary Redraw histogram */
   async redraw(reason) {
      return this.callDrawFunc(reason);
   }

   /** @summary Draw histogram using painter instance
     * @private */
   static async _draw(painter /*, opt*/) {
      return ensureRCanvas(painter).then(() => {

         painter.setAsMainPainter();

         painter.options = { Hist: false, Error: false, Zero: false, Mark: false,
                             Line: false, Fill: false, Lego: 0, Surf: 0,
                             Text: true, TextAngle: 0, TextKind: '',
                             BaseLine: false, Mode3D: false, AutoColor: 0,
                             Color: false, Scat: false, ScatCoef: 1, Box: false, BoxStyle: 0, Arrow: false, Contour: 0, Proj: 0,
                             BarOffset: 0., BarWidth: 1., minimum: kNoZoom, maximum: kNoZoom };

         let kind = painter.v7EvalAttr('kind', ''),
             sub = painter.v7EvalAttr('sub', 0),
             o = painter.options;

         o.Text = painter.v7EvalAttr('drawtext', false);

         switch(kind) {
            case 'lego': o.Lego = sub > 0 ? 10+sub : 12; o.Mode3D = true; break;
            case 'surf': o.Surf = sub > 0 ? 10+sub : 1; o.Mode3D = true; break;
            case 'box': o.Box = true; o.BoxStyle = 10 + sub; break;
            case 'err': o.Error = true; o.Mode3D = true; break;
            case 'cont': o.Contour = sub > 0 ? 10+sub : 1; break;
            case 'arr': o.Arrow = true; break;
            case 'scat': o.Scat = true; break;
            case 'col': o.Color = true; break;
            default: if (!o.Text) o.Color = true;
         }

         // here we deciding how histogram will look like and how will be shown
         // painter.decodeOptions(opt);

         painter._show_empty_bins = false;

         painter.scanContent();

         return painter.callDrawFunc();
      });
   }

   /** @summary draw RH2 object */
   static async draw(dom, obj, opt) {
      // create painter and add it to canvas
      return RH2Painter$2._draw(new RH2Painter$2(dom, obj), opt);
   }

} //  class RH2Painter

class RH2Painter extends RH2Painter$2 {

   /** Draw histogram bins in 3D, using provided draw options */
   draw3DBins() {

      if (!this.draw_content) return;

      if (this.options.Surf)
         return drawBinsSurf3D(this, true);

      if (this.options.Error)
         return drawBinsError3D(this, true);

      if (this.options.Contour)
         return drawBinsContour3D(this, true, true);

      drawBinsLego(this, true);
      this.updatePaletteDraw();
   }

   draw3D(reason) {

      this.mode3d = true;

      let main = this.getFramePainter(), // who makes axis drawing
          is_main = this.isMainPainter(), // is main histogram
          pr = Promise.resolve(this);

      if (reason == 'resize') {
         if (is_main && main.resize3D()) main.render3D();

         return pr;
      }

      let zmult = 1 + 2*gStyle.fHistTopMargin;

      this.zmin = main.logz ? this.gminposbin * 0.3 : this.gminbin;
      this.zmax = this.gmaxbin;
      if (this.options.minimum !== kNoZoom) this.zmin = this.options.minimum;
      if (this.options.maximum !== kNoZoom) { this.zmax = this.options.maximum; zmult = 1; }
      if (main.logz && (this.zmin <= 0)) this.zmin = this.zmax * 1e-5;

      this.deleteAttr();

      if (is_main) {
         assignFrame3DMethods(main);
         pr = main.create3DScene(this.options.Render3D).then(() => {
            main.setAxesRanges(this.getAxis('x'), this.xmin, this.xmax, this.getAxis('y'), this.ymin, this.ymax, null, this.zmin, this.zmax);
            main.set3DOptions(this.options);
            main.drawXYZ(main.toplevel, RAxisPainter, { zmult, zoom: settings.Zooming, ndim: 2, draw: true, v7: true });
         });
      }

      if (!main.mode3d)
         return pr;

      return pr.then(() => this.drawingBins(reason)).then(() => {
         // called when bins received from server, must be reentrant
         let main = this.getFramePainter();

         this.draw3DBins();
         main.render3D();
         main.addKeysHandler();

         return this;
      });
   }

      /** @summary draw RH2 object */
   static async draw(dom, obj, opt) {
      // create painter and add it to canvas
      return RH2Painter._draw(new RH2Painter(dom, obj), opt);
   }

} // class RH2Painter

var RH2Painter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
RH2Painter: RH2Painter
});

/**
 * @summary Painter for RH3 classes
 *
 * @private
 */

class RH3Painter extends RHistPainter {

   /** @summary Returns histogram dimension */
   getDimension() { return 3; }

   scanContent(when_axis_changed) {

      // no need to rescan histogram while result does not depend from axis selection
      if (when_axis_changed && this.nbinsx && this.nbinsy && this.nbinsz) return;

      let histo = this.getHisto();
      if (!histo) return;

      this.extractAxesProperties(3);

      // global min/max, used at the moment in 3D drawing

      if (this.isDisplayItem()) {
         // take min/max values from the display item
         this.gminbin = histo.fContMin;
         this.gminposbin = histo.fContMinPos > 0 ? histo.fContMinPos : null;
         this.gmaxbin = histo.fContMax;
      } else {
         this.gminbin = this.gmaxbin = histo.getBinContent(1,1,1);

         for (let i = 0; i < this.nbinsx; ++i)
            for (let j = 0; j < this.nbinsy; ++j)
               for (let k = 0; k < this.nbinsz; ++k) {
                  let bin_content = histo.getBinContent(i+1, j+1, k+1);
                  if (bin_content < this.gminbin) this.gminbin = bin_content; else
                  if (bin_content > this.gmaxbin) this.gmaxbin = bin_content;
               }
      }

      this.draw_content = this.gmaxbin > 0;
   }

  /** @summary Count histogram statistic */
   countStat() {
      let histo = this.getHisto(),
          xaxis = this.getAxis('x'),
          yaxis = this.getAxis('y'),
          zaxis = this.getAxis('z'),
          stat_sum0 = 0, stat_sumx1 = 0, stat_sumy1 = 0,
          stat_sumz1 = 0, stat_sumx2 = 0, stat_sumy2 = 0, stat_sumz2 = 0,
          i1 = this.getSelectIndex('x', 'left'),
          i2 = this.getSelectIndex('x', 'right'),
          j1 = this.getSelectIndex('y', 'left'),
          j2 = this.getSelectIndex('y', 'right'),
          k1 = this.getSelectIndex('z', 'left'),
          k2 = this.getSelectIndex('z', 'right');
          this.getFramePainter();
          let res = { name: histo.fName, entries: 0, integral: 0, meanx: 0, meany: 0, meanz: 0, rmsx: 0, rmsy: 0, rmsz: 0 },
          xi, yi, zi, xx, xside, yy, yside, zz, zside, cont;

      for (xi = 1; xi <= this.nbinsx; ++xi) {

         xx = xaxis.GetBinCoord(xi - 0.5);
         xside = (xi <= i1+1) ? 0 : (xi > i2+1 ? 2 : 1);

         for (yi = 1; yi <= this.nbinsy; ++yi) {

            yy = yaxis.GetBinCoord(yi - 0.5);
            yside = (yi <= j1+1) ? 0 : (yi > j2+1 ? 2 : 1);

            for (zi = 1; zi <= this.nbinsz; ++zi) {

               zz = zaxis.GetBinCoord(zi - 0.5);
               zside = (zi <= k1+1) ? 0 : (zi > k2+1 ? 2 : 1);

               cont = histo.getBinContent(xi, yi, zi);
               res.entries += cont;

               if ((xside == 1) && (yside == 1) && (zside == 1)) {
                  stat_sum0 += cont;
                  stat_sumx1 += xx * cont;
                  stat_sumy1 += yy * cont;
                  stat_sumz1 += zz * cont;
                  stat_sumx2 += xx**2 * cont;
                  stat_sumy2 += yy**2 * cont;
                  stat_sumz2 += zz**2 * cont;
               }
            }
         }
      }

      if (Math.abs(stat_sum0) > 1e-300) {
         res.meanx = stat_sumx1 / stat_sum0;
         res.meany = stat_sumy1 / stat_sum0;
         res.meanz = stat_sumz1 / stat_sum0;
         res.rmsx = Math.sqrt(Math.abs(stat_sumx2 / stat_sum0 - res.meanx**2));
         res.rmsy = Math.sqrt(Math.abs(stat_sumy2 / stat_sum0 - res.meany**2));
         res.rmsz = Math.sqrt(Math.abs(stat_sumz2 / stat_sum0 - res.meanz**2));
      }

      res.integral = stat_sum0;

      if (histo.fEntries > 1)
         res.entries = histo.fEntries;

      return res;
   }

   /** @summary Fill statistic */
   fillStatistic(stat, dostat /*, dofit */) {

      let data = this.countStat(),
          print_name = dostat % 10,
          print_entries = Math.floor(dostat / 10) % 10,
          print_mean = Math.floor(dostat / 100) % 10,
          print_rms = Math.floor(dostat / 1000) % 10,
          // print_under = Math.floor(dostat / 10000) % 10,
          // print_over = Math.floor(dostat / 100000) % 10,
          print_integral = Math.floor(dostat / 1000000) % 10;
          // print_skew = Math.floor(dostat / 10000000) % 10;
          // print_kurt = Math.floor(dostat / 100000000) % 10;

      stat.clearStat();

      if (print_name > 0)
         stat.addText(data.name);

      if (print_entries > 0)
         stat.addText('Entries = ' + stat.format(data.entries,'entries'));

      if (print_mean > 0) {
         stat.addText('Mean x = ' + stat.format(data.meanx));
         stat.addText('Mean y = ' + stat.format(data.meany));
         stat.addText('Mean z = ' + stat.format(data.meanz));
      }

      if (print_rms > 0) {
         stat.addText('Std Dev x = ' + stat.format(data.rmsx));
         stat.addText('Std Dev y = ' + stat.format(data.rmsy));
         stat.addText('Std Dev z = ' + stat.format(data.rmsz));
      }

      if (print_integral > 0) {
         stat.addText('Integral = ' + stat.format(data.integral,'entries'));
      }

      return true;
   }

   /** @summary Provide text information (tooltips) for histogram bin */
   getBinTooltips(ix, iy, iz) {
      let lines = [], histo = this.getHisto(),
          dx = 1, dy = 1, dz = 1;

      if (this.isDisplayItem()) {
         dx = histo.stepx || 1;
         dy = histo.stepy || 1;
         dz = histo.stepz || 1;
      }

      lines.push(this.getObjectHint());

      lines.push(`x = ${this.getAxisBinTip('x', ix, dx)}  xbin=${ix+1}`);
      lines.push(`y = ${this.getAxisBinTip('y', iy, dy)}  ybin=${iy+1}`);
      lines.push(`z = ${this.getAxisBinTip('z', iz, dz)}  zbin=${iz+1}`);

      let binz = histo.getBinContent(ix+1, iy+1, iz+1),
          lbl = 'entries = '+ ((dx > 1) || (dy > 1) || (dz > 1) ? '~' : '');
      if (binz === Math.round(binz))
         lines.push(lbl + binz);
      else
         lines.push(lbl + floatToString(binz, gStyle.fStatFormat));

      return lines;
   }

   /** @summary Try to draw 3D histogram as scatter plot
     * @desc If there are too many points, returns promise with false */
   async draw3DScatter(handle) {

      let histo = this.getHisto(),
          main = this.getFramePainter(),
          i1 = handle.i1, i2 = handle.i2, di = handle.stepi,
          j1 = handle.j1, j2 = handle.j2, dj = handle.stepj,
          k1 = handle.k1, k2 = handle.k2, dk = handle.stepk,
          i, j, k, bin_content;

      if ((i2 <= i1) || (j2 <= j1) || (k2 <= k1))
         return true;

      // scale down factor if too large values
      let coef = (this.gmaxbin > 1000) ? 1000/this.gmaxbin : 1,
          numpixels = 0, sumz = 0, content_lmt = Math.max(0, this.gminbin);

      for (i = i1; i < i2; i += di) {
         for (j = j1; j < j2; j += dj) {
            for (k = k1; k < k2; k += dk) {
               bin_content = histo.getBinContent(i+1, j+1, k+1);
               sumz += bin_content;
               if (bin_content <= content_lmt) continue;
               numpixels += Math.round(bin_content*coef);
            }
         }
      }

      // too many pixels - use box drawing
      if (numpixels > (main.webgl ? 100000 : 30000))
         return false;

      let pnts = new PointsCreator(numpixels, main.webgl, main.size_x3d/200),
          bins = new Int32Array(numpixels), nbin = 0,
          xaxis = this.getAxis('x'), yaxis = this.getAxis('y'), zaxis = this.getAxis('z'),
          rnd = new TRandom(sumz);

      for (i = i1; i < i2; i += di) {
         for (j = j1; j < j2; j += dj) {
            for (k = k1; k < k2; k += dk) {
               bin_content = histo.getBinContent(i+1, j+1, k+1);
               if (bin_content <= content_lmt) continue;
               let num = Math.round(bin_content*coef);

               for (let n=0;n<num;++n) {
                  let binx = xaxis.GetBinCoord(i + rnd.random()),
                      biny = yaxis.GetBinCoord(j + rnd.random()),
                      binz = zaxis.GetBinCoord(k + rnd.random());

                  // remember bin index for tooltip
                  bins[nbin++] = histo.getBin(i+1, j+1, k+1);

                  pnts.addPoint(main.grx(binx), main.gry(biny), main.grz(binz));
               }
            }
         }
      }

      return pnts.createPoints({ color: this.v7EvalColor('fill_color', 'red') }).then(mesh => {
         main.toplevel.add(mesh);

         mesh.bins = bins;
         mesh.painter = this;
         mesh.tip_color = 0x00FF00;

         mesh.tooltip = function(intersect) {
            if (!Number.isInteger(intersect.index)) {
               console.error(`intersect.index not provided, three.js version ${REVISION}`);
               return null;
            }

            let indx = Math.floor(intersect.index / this.nvertex);
            if ((indx < 0) || (indx >= this.bins.length)) return null;

            let p = this.painter,
                main = p.getFramePainter(),
                tip = p.get3DToolTip(this.bins[indx]);

            tip.x1 = main.grx(p.getAxis('x').GetBinLowEdge(tip.ix));
            tip.x2 = main.grx(p.getAxis('x').GetBinLowEdge(tip.ix+di));
            tip.y1 = main.gry(p.getAxis('y').GetBinLowEdge(tip.iy));
            tip.y2 = main.gry(p.getAxis('y').GetBinLowEdge(tip.iy+dj));
            tip.z1 = main.grz(p.getAxis('z').GetBinLowEdge(tip.iz));
            tip.z2 = main.grz(p.getAxis('z').GetBinLowEdge(tip.iz+dk));
            tip.color = this.tip_color;
            tip.opacity = 0.3;

            return tip;
         };

         return true;
      });
   }

   /** @summary Drawing of 3D histogram */
   draw3DBins(handle) {

      let fillcolor = this.v7EvalColor('fill_color', 'red'),
          main = this.getFramePainter(),
          buffer_size = 0, use_lambert = false,
          use_helper = false, use_colors = false, use_opacity = 1, use_scale = true,
          single_bin_verts, single_bin_norms,
          tipscale = 0.5;

      if (this.options.Sphere) {

         // drawing spheres
         tipscale = 0.4;
         use_lambert = true;
         if (this.options.Sphere === 11) use_colors = true;

         let geom = main.webgl ? new SphereGeometry(0.5, 16, 12) : new SphereGeometry(0.5, 8, 6);
         geom.applyMatrix4( new Matrix4().makeRotationX( Math.PI / 2 ) );
         geom.computeVertexNormals();

         let indx = geom.getIndex().array,
             pos = geom.getAttribute('position').array,
             norm = geom.getAttribute('normal').array;

         buffer_size = indx.length*3;
         single_bin_verts = new Float32Array(buffer_size);
         single_bin_norms = new Float32Array(buffer_size);

         for (let k=0;k<indx.length;++k) {
            let iii = indx[k]*3;
            single_bin_verts[k*3] = pos[iii];
            single_bin_verts[k*3+1] = pos[iii+1];
            single_bin_verts[k*3+2] = pos[iii+2];
            single_bin_norms[k*3] = norm[iii];
            single_bin_norms[k*3+1] = norm[iii+1];
            single_bin_norms[k*3+2] = norm[iii+2];
         }

      } else {

         let indicies = Box3D.Indexes,
             normals = Box3D.Normals,
             vertices = Box3D.Vertices;

         buffer_size = indicies.length*3;
         single_bin_verts = new Float32Array(buffer_size);
         single_bin_norms = new Float32Array(buffer_size);

         for (let k = 0, nn = -3; k < indicies.length; ++k) {
            let vert = vertices[indicies[k]];
            single_bin_verts[k*3]   = vert.x-0.5;
            single_bin_verts[k*3+1] = vert.y-0.5;
            single_bin_verts[k*3+2] = vert.z-0.5;

            if (k%6 === 0) nn+=3;
            single_bin_norms[k*3]   = normals[nn];
            single_bin_norms[k*3+1] = normals[nn+1];
            single_bin_norms[k*3+2] = normals[nn+2];
         }
         use_helper = true;

         if (this.options.Box == 11) { use_colors = true; } else
         if (this.options.Box == 12) { use_colors = true; use_helper = false; }  else
         if (this.options.Color) { use_colors = true; use_opacity = 0.5; use_scale = false; use_helper = false; use_lambert = true; }
      }

      if (use_scale)
         use_scale = (this.gminbin || this.gmaxbin) ? 1 / Math.max(Math.abs(this.gminbin), Math.abs(this.gmaxbin)) : 1;

      let histo = this.getHisto(),
          i1 = handle.i1, i2 = handle.i2, di = handle.stepi,
          j1 = handle.j1, j2 = handle.j2, dj = handle.stepj,
          k1 = handle.k1, k2 = handle.k2, dk = handle.stepk,
          palette = null;

      if (use_colors) {
         palette = main.getHistPalette();
         this.createContour(main, palette);
      }

      if ((i2 <= i1) || (j2 <= j1) || (k2 <= k1))
         return true;

      let xaxis = this.getAxis('x'), yaxis = this.getAxis('y'), zaxis = this.getAxis('z'),
          scalex = (main.grx(xaxis.GetBinCoord(i2)) - main.grx(xaxis.GetBinCoord(i1))) / (i2 - i1) * di,
          scaley = (main.gry(yaxis.GetBinCoord(j2)) - main.gry(yaxis.GetBinCoord(j1))) / (j2 - j1) * dj,
          scalez = (main.grz(zaxis.GetBinCoord(k2)) - main.grz(zaxis.GetBinCoord(k1))) / (k2 - k1) * dk;

      let nbins = 0, i, j, k, wei, bin_content, cols_size = [], num_colors = 0, cols_sequence = [];

      for (i = i1; i < i2; i += di) {
         for (j = j1; j < j2; j += dj) {
            for (k = k1; k < k2; k += dk) {
               bin_content = histo.getBinContent(i+1, j+1, k+1);
               if (!this.options.Color && ((bin_content === 0) || (bin_content < this.gminbin))) continue;
               wei = use_scale ? Math.pow(Math.abs(bin_content*use_scale), 0.3333) : 1;
               if (wei < 1e-3) continue; // do not draw empty or very small bins

               nbins++;

               if (!use_colors) continue;

               let colindx = palette.getContourIndex(bin_content);
               if (colindx >= 0) {
                  if (cols_size[colindx] === undefined) {
                     cols_size[colindx] = 0;
                     cols_sequence[colindx] = num_colors++;
                  }
                  cols_size[colindx]+=1;
               } else {
                  console.error(`not found color for value = ${bin_content}`);
               }
            }
         }
      }

      if (!use_colors) {
         cols_size.push(nbins);
         num_colors = 1;
         cols_sequence = [0];
      }

      let cols_nbins = new Array(num_colors),
          bin_verts = new Array(num_colors),
          bin_norms = new Array(num_colors),
          bin_tooltips = new Array(num_colors),
          helper_kind = new Array(num_colors),
          helper_indexes = new Array(num_colors),  // helper_kind == 1, use original vertices
          helper_positions = new Array(num_colors);  // helper_kind == 2, all vertices copied into separate buffer

      for(let ncol = 0; ncol < cols_size.length; ++ncol) {
         if (!cols_size[ncol]) continue; // ignore dummy colors

         nbins = cols_size[ncol]; // how many bins with specified color
         let nseq = cols_sequence[ncol];

         cols_nbins[nseq] = 0; // counter for the filled bins

         helper_kind[nseq] = 0;

         // 1 - use same vertices to create helper, one can use maximal 64K vertices
         // 2 - all vertices copied into separate buffer
         if (use_helper)
            helper_kind[nseq] = (nbins * buffer_size / 3 > 0xFFF0) ? 2 : 1;

         bin_verts[nseq] = new Float32Array(nbins * buffer_size);
         bin_norms[nseq] = new Float32Array(nbins * buffer_size);
         bin_tooltips[nseq] = new Int32Array(nbins);

         if (helper_kind[nseq] === 1)
            helper_indexes[nseq] = new Uint16Array(nbins * Box3D.MeshSegments.length);

         if (helper_kind[nseq] === 2)
            helper_positions[nseq] = new Float32Array(nbins * Box3D.Segments.length * 3);
      }

      let binx, grx, biny, gry, binz, grz;
      xaxis = this.getAxis('x'),
      yaxis = this.getAxis('y'),
      zaxis = this.getAxis('z');

      for (i = i1; i < i2; i += di) {
         binx = xaxis.GetBinCenter(i+1); grx = main.grx(binx);
         for (j = j1; j < j2; j += dj) {
            biny = yaxis.GetBinCenter(j+1); gry = main.gry(biny);
            for (k = k1; k < k2; k +=dk) {
               bin_content = histo.getBinContent(i+1, j+1, k+1);
               if (!this.options.Color && ((bin_content === 0) || (bin_content < this.gminbin))) continue;

               wei = use_scale ? Math.pow(Math.abs(bin_content*use_scale), 0.3333) : 1;
               if (wei < 1e-3) continue; // do not show very small bins

               let nseq = 0;
               if (use_colors) {
                  let colindx = palette.getContourIndex(bin_content);
                  if (colindx < 0) continue;
                  nseq = cols_sequence[colindx];
               }

               nbins = cols_nbins[nseq];

               binz = zaxis.GetBinCenter(k+1); grz = main.grz(binz);

               // remember bin index for tooltip
               bin_tooltips[nseq][nbins] = histo.getBin(i+1, j+1, k+1);

               let vvv = nbins * buffer_size, bin_v = bin_verts[nseq], bin_n = bin_norms[nseq];

               // Grab the coordinates and scale that are being assigned to each bin
               for (let vi = 0; vi < buffer_size; vi+=3, vvv+=3) {
                  bin_v[vvv]   = grx + single_bin_verts[vi]*scalex*wei;
                  bin_v[vvv+1] = gry + single_bin_verts[vi+1]*scaley*wei;
                  bin_v[vvv+2] = grz + single_bin_verts[vi+2]*scalez*wei;

                  bin_n[vvv]   = single_bin_norms[vi];
                  bin_n[vvv+1] = single_bin_norms[vi+1];
                  bin_n[vvv+2] = single_bin_norms[vi+2];
               }

               if (helper_kind[nseq] === 1) {
                  // reuse vertices created for the mesh
                  let helper_segments = Box3D.MeshSegments;
                  vvv = nbins * helper_segments.length;
                  let shift = Math.round(nbins * buffer_size/3),
                      helper_i = helper_indexes[nseq];
                  for (let n = 0; n < helper_segments.length; ++n)
                     helper_i[vvv+n] = shift + helper_segments[n];
               }

               if (helper_kind[nseq] === 2) {
                  let helper_segments = Box3D.Segments,
                      helper_p = helper_positions[nseq];
                  vvv = nbins * helper_segments.length * 3;
                  for (let n = 0; n < helper_segments.length; ++n, vvv += 3) {
                     let vert = Box3D.Vertices[helper_segments[n]];
                     helper_p[vvv]   = grx + (vert.x-0.5)*scalex*wei;
                     helper_p[vvv+1] = gry + (vert.y-0.5)*scaley*wei;
                     helper_p[vvv+2] = grz + (vert.z-0.5)*scalez*wei;
                  }
               }

               cols_nbins[nseq] = nbins+1;
            }
         }
      }

      for (let ncol = 0; ncol < cols_size.length; ++ncol) {
         if (!cols_size[ncol]) continue; // ignore dummy colors

         let nseq = cols_sequence[ncol];

         // BufferGeometries that store geometry of all bins
         let all_bins_buffgeom = new BufferGeometry();

         // Create mesh from bin buffergeometry
         all_bins_buffgeom.setAttribute('position', new BufferAttribute(bin_verts[nseq], 3));
         all_bins_buffgeom.setAttribute('normal', new BufferAttribute(bin_norms[nseq], 3));

         if (use_colors) fillcolor = palette.getColor(ncol);

         let material = use_lambert ? new MeshLambertMaterial({ color: fillcolor, opacity: use_opacity, transparent: (use_opacity < 1), vertexColors: false })
                                    : new MeshBasicMaterial({ color: fillcolor, opacity: use_opacity, vertexColors: false });

         let combined_bins = new Mesh(all_bins_buffgeom, material);

         combined_bins.bins = bin_tooltips[nseq];
         combined_bins.bins_faces = buffer_size/9;
         combined_bins.painter = this;

         combined_bins.scalex = tipscale*scalex;
         combined_bins.scaley = tipscale*scaley;
         combined_bins.scalez = tipscale*scalez;
         combined_bins.tip_color = 0x00FF00;
         combined_bins.use_scale = use_scale;

         combined_bins.tooltip = function(intersect) {
            if (!Number.isInteger(intersect.faceIndex)) {
               console.error(`intersect.faceIndex not provided, three.js version ${REVISION}`);
               return null;
            }
            let indx = Math.floor(intersect.faceIndex / this.bins_faces);
            if ((indx < 0) || (indx >= this.bins.length)) return null;

            let p = this.painter,
                main = p.getFramePainter(),
                tip = p.get3DToolTip(this.bins[indx]),
                grx = main.grx(p.getAxis('x').GetBinCoord(tip.ix-0.5)),
                gry = main.gry(p.getAxis('y').GetBinCoord(tip.iy-0.5)),
                grz = main.grz(p.getAxis('z').GetBinCoord(tip.iz-0.5)),
                wei = this.use_scale ? Math.pow(Math.abs(tip.value*this.use_scale), 0.3333) : 1;

            tip.x1 = grx - this.scalex*wei; tip.x2 = grx + this.scalex*wei;
            tip.y1 = gry - this.scaley*wei; tip.y2 = gry + this.scaley*wei;
            tip.z1 = grz - this.scalez*wei; tip.z2 = grz + this.scalez*wei;

            tip.color = this.tip_color;

            return tip;
         };

         main.toplevel.add(combined_bins);

         if (helper_kind[nseq] > 0) {
            let lcolor = this.v7EvalColor('line_color', 'lightblue'),
                helper_material = new LineBasicMaterial({ color: lcolor }),
                lines = null;

            if (helper_kind[nseq] === 1) {
               // reuse positions from the mesh - only special index was created
               lines = createLineSegments(bin_verts[nseq], helper_material, helper_indexes[nseq]);
            } else {
               lines = createLineSegments(helper_positions[nseq], helper_material);
            }

            main.toplevel.add(lines);
         }
      }

      if (use_colors)
         this.updatePaletteDraw();
   }

   draw3D() {

      if (!this.draw_content)
         return false;

      //this.options.Scatter = false;
      //this.options.Box = true;

      let handle = this.prepareDraw({ only_indexes: true, extra: -0.5, right_extra: -1 });

      let pr = this.options.Scatter ? this.draw3DScatter(handle) : Promise.resolve(false);

      return pr.then(res => {
         return res ? res : this.draw3DBins(handle);
      });
   }


   /** @summary Redraw histogram*/
   redraw(reason) {

      let main = this.getFramePainter(); // who makes axis and 3D drawing

      if (reason == 'resize') {
         if (main.resize3D()) main.render3D();
         return this;
      }

      assignFrame3DMethods(main);
      return main.create3DScene(this.options.Render3D).then(() => {
         main.setAxesRanges(this.getAxis('x'), this.xmin, this.xmax, this.getAxis('y'), this.ymin, this.ymax, this.getAxis('z'), this.zmin, this.zmax);
         main.set3DOptions(this.options);
         main.drawXYZ(main.toplevel, RAxisPainter, { zoom: settings.Zooming, ndim: 3, draw: true, v7: true });
         return this.drawingBins(reason);
      }).then(() => this.draw3D()).then(() => {
         main.render3D();
         main.addKeysHandler();
         return this;
      });
   }

   /** @summary Fill pad toolbar with RH3-related functions */
   fillToolbar() {
      let pp = this.getPadPainter();
      if (!pp) return;

      pp.addPadButton('auto_zoom', 'Unzoom all axes', 'ToggleZoom', 'Ctrl *');
      if (this.draw_content)
         pp.addPadButton('statbox', 'Toggle stat box', 'ToggleStatBox');
      pp.showPadButtons();
   }

   /** @summary Checks if it makes sense to zoom inside specified axis range */
   canZoomInside(axis, min, max) {
      let obj = this.getHisto();
      if (obj) obj = obj['f'+axis.toUpperCase()+'axis'];
      return !obj || (obj.FindBin(max,0.5) - obj.FindBin(min,0) > 1);
   }

   /** @summary Perform automatic zoom inside non-zero region of histogram */
   autoZoom() {
      let i1 = this.getSelectIndex('x', 'left'),
          i2 = this.getSelectIndex('x', 'right'),
          j1 = this.getSelectIndex('y', 'left'),
          j2 = this.getSelectIndex('y', 'right'),
          k1 = this.getSelectIndex('z', 'left'),
          k2 = this.getSelectIndex('z', 'right'),
          i, j, k, histo = this.getHisto();

      if ((i1 === i2) || (j1 === j2) || (k1 === k2)) return;

      // first find minimum
      let min = histo.getBinContent(i1 + 1, j1 + 1, k1+1);
      for (i = i1; i < i2; ++i)
         for (j = j1; j < j2; ++j)
            for (k = k1; k < k2; ++k)
               min = Math.min(min, histo.getBinContent(i+1, j+1, k+1));

      if (min > 0) return; // if all points positive, no chance for autoscale

      let ileft = i2, iright = i1, jleft = j2, jright = j1, kleft = k2, kright = k1;

      for (i = i1; i < i2; ++i)
         for (j = j1; j < j2; ++j)
            for (k = k1; k < k2; ++k)
               if (histo.getBinContent(i+1, j+1, k+1) > min) {
                  if (i < ileft) ileft = i;
                  if (i >= iright) iright = i + 1;
                  if (j < jleft) jleft = j;
                  if (j >= jright) jright = j + 1;
                  if (k < kleft) kleft = k;
                  if (k >= kright) kright = k + 1;
               }

      let xmin, xmax, ymin, ymax, zmin, zmax, isany = false;

      if ((ileft === iright-1) && (ileft > i1+1) && (iright < i2-1)) { ileft--; iright++; }
      if ((jleft === jright-1) && (jleft > j1+1) && (jright < j2-1)) { jleft--; jright++; }
      if ((kleft === kright-1) && (kleft > k1+1) && (kright < k2-1)) { kleft--; kright++; }

      if ((ileft > i1 || iright < i2) && (ileft < iright - 1)) {
         xmin = this.getAxis('x').GetBinLowEdge(ileft+1);
         xmax = this.getAxis('x').GetBinLowEdge(iright+1);
         isany = true;
      }

      if ((jleft > j1 || jright < j2) && (jleft < jright - 1)) {
         ymin = this.getAxis('y').GetBinLowEdge(jleft+1);
         ymax = this.getAxis('y').GetBinLowEdge(jright+1);
         isany = true;
      }

      if ((kleft > k1 || kright < k2) && (kleft < kright - 1)) {
         zmin = this.getAxis('z').GetBinLowEdge(kleft+1);
         zmax = this.getAxis('z').GetBinLowEdge(kright+1);
         isany = true;
      }

      if (isany)
         return this.getFramePainter().zoom(xmin, xmax, ymin, ymax, zmin, zmax);
   }

   /** @summary Fill histogram context menu */
   fillHistContextMenu(menu) {

      let opts = this.getSupportedDrawOptions();

      menu.addDrawMenu('Draw with', opts, arg => {
         if (arg === 'inspect')
            return this.showInspector();

         this.decodeOptions(arg);

         this.interactiveRedraw(true, 'drawopt');
      });
   }

   /** @summary draw RH3 object */
  static async draw(dom, histo /*, opt*/) {
      let painter = new RH3Painter(dom, histo);
      painter.mode3d = true;

      return ensureRCanvas(painter, '3d').then(() => {

         painter.setAsMainPainter();

         painter.options = { Box: 0, Scatter: false, Sphere: 0, Color: false, minimum: kNoZoom, maximum: kNoZoom };

         let kind = painter.v7EvalAttr('kind', ''),
             sub = painter.v7EvalAttr('sub', 0),
             o = painter.options;

         switch(kind) {
            case 'box': o.Box = 10 + sub; break;
            case 'sphere': o.Sphere = 10 + sub; break;
            case 'col': o.Color = true; break;
            case 'scat': o.Scatter = true;  break;
            default: o.Box = 10;
         }

         painter.scanContent();
         return painter.redraw();
      });
   }

} // class RH3Painter

/** @summary draw RHistDisplayItem  object
  * @private */
function drawHistDisplayItem(dom, obj, opt) {
   if (!obj)
      return null;

   if (obj.fAxes.length == 1)
      return RH1Painter.draw(dom, obj, opt);

   if (obj.fAxes.length == 2)
      return RH2Painter.draw(dom, obj, opt);

   if (obj.fAxes.length == 3)
      return RH3Painter.draw(dom, obj, opt);

   return null;
}

var RH3Painter$1 = /*#__PURE__*/Object.freeze({
__proto__: null,
RH3Painter: RH3Painter,
drawHistDisplayItem: drawHistDisplayItem
});

exports.BIT = BIT;
exports.BasePainter = BasePainter;
exports.BatchDisplay = BatchDisplay;
exports.BrowserLayout = BrowserLayout;
exports.CustomDisplay = CustomDisplay;
exports.DrawOptions = DrawOptions;
exports.EAxisBits = EAxisBits;
exports.FileProxy = FileProxy;
exports.FlexibleDisplay = FlexibleDisplay;
exports.GridDisplay = GridDisplay;
exports.HierarchyPainter = HierarchyPainter;
exports.MDIDisplay = MDIDisplay;
exports.ObjectPainter = ObjectPainter;
exports.TGeoPainter = TGeoPainter;
exports.TH1Painter = TH1Painter;
exports.TH2Painter = TH2Painter;
exports.TH3Painter = TH3Painter;
exports.TRandom = TRandom;
exports.TSelector = TSelector;
exports.TabsDisplay = TabsDisplay;
exports._ensureJSROOT = _ensureJSROOT;
exports._loadJSDOM = _loadJSDOM;
exports.addDrawFunc = addDrawFunc;
exports.addMethods = addMethods;
exports.atob_func = atob_func;
exports.browser = browser$1;
exports.btoa_func = btoa_func;
exports.buildGUI = buildGUI;
exports.buildSvgPath = buildSvgPath;
exports.clTAttCanvas = clTAttCanvas;
exports.clTAttFill = clTAttFill;
exports.clTAttLine = clTAttLine;
exports.clTAttMarker = clTAttMarker;
exports.clTAttText = clTAttText;
exports.clTAxis = clTAxis;
exports.clTBox = clTBox;
exports.clTCanvas = clTCanvas;
exports.clTClonesArray = clTClonesArray;
exports.clTColor = clTColor;
exports.clTCutG = clTCutG;
exports.clTF1 = clTF1;
exports.clTF2 = clTF2;
exports.clTGaxis = clTGaxis;
exports.clTGeoNode = clTGeoNode;
exports.clTGeoNodeMatrix = clTGeoNodeMatrix;
exports.clTGeoVolume = clTGeoVolume;
exports.clTGraph = clTGraph;
exports.clTGraphPolargram = clTGraphPolargram;
exports.clTGraphTime = clTGraphTime;
exports.clTH1 = clTH1;
exports.clTH2 = clTH2;
exports.clTH3 = clTH3;
exports.clTHashList = clTHashList;
exports.clTLatex = clTLatex;
exports.clTLegend = clTLegend;
exports.clTLegendEntry = clTLegendEntry;
exports.clTLine = clTLine;
exports.clTList = clTList;
exports.clTMap = clTMap;
exports.clTMathText = clTMathText;
exports.clTMultiGraph = clTMultiGraph;
exports.clTNamed = clTNamed;
exports.clTObjArray = clTObjArray;
exports.clTObjString = clTObjString;
exports.clTObject = clTObject;
exports.clTPad = clTPad;
exports.clTPaletteAxis = clTPaletteAxis;
exports.clTPave = clTPave;
exports.clTPaveStats = clTPaveStats;
exports.clTPaveText = clTPaveText;
exports.clTPolyLine = clTPolyLine;
exports.clTPolyLine3D = clTPolyLine3D;
exports.clTPolyMarker3D = clTPolyMarker3D;
exports.clTProfile = clTProfile;
exports.clTProfile2D = clTProfile2D;
exports.clTString = clTString;
exports.clTStyle = clTStyle;
exports.clTText = clTText;
exports.cleanup = cleanup;
exports.clone = clone;
exports.compressSVG = compressSVG;
exports.constants = constants$1;
exports.create = create$1;
exports.createGeoPainter = createGeoPainter;
exports.createHistogram = createHistogram;
exports.createHttpRequest = createHttpRequest;
exports.createTGraph = createTGraph;
exports.createTHStack = createTHStack;
exports.createTMultiGraph = createTMultiGraph;
exports.createTPolyLine = createTPolyLine;
exports.d3_select = select;
exports.decodeUrl = decodeUrl;
exports.draw = draw;
exports.drawRawText = drawRawText;
exports.drawingJSON = drawingJSON;
exports.findFunction = findFunction;
exports.floatToString = floatToString;
exports.gStyle = gStyle;
exports.getAbsPosInCanvas = getAbsPosInCanvas;
exports.getActivePad = getActivePad;
exports.getDocument = getDocument;
exports.getElementCanvPainter = getElementCanvPainter;
exports.getElementMainPainter = getElementMainPainter;
exports.getElementRect = getElementRect;
exports.getHPainter = getHPainter;
exports.getMethods = getMethods;
exports.getPromise = getPromise;
exports.httpRequest = httpRequest;
exports.injectCode = injectCode;
exports.internals = internals;
exports.isArrayProto = isArrayProto;
exports.isBatchMode = isBatchMode;
exports.isFunc = isFunc;
exports.isNodeJs = isNodeJs;
exports.isObject = isObject;
exports.isPromise = isPromise;
exports.isRootCollection = isRootCollection;
exports.isStr = isStr;
exports.kNoZoom = kNoZoom;
exports.loadOpenui5 = loadOpenui5;
exports.loadScript = loadScript;
exports.makeSVG = makeSVG;
exports.openFile = openFile;
exports.parse = parse;
exports.parseMulti = parseMulti;
exports.readStyleFromURL = readStyleFromURL;
exports.redraw = redraw;
exports.registerForResize = registerForResize;
exports.registerMethods = registerMethods;
exports.resize = resize;
exports.selectActivePad = selectActivePad;
exports.setBatchMode = setBatchMode;
exports.setDefaultDrawOpt = setDefaultDrawOpt;
exports.setHPainter = setHPainter;
exports.setSaveFile = setSaveFile;
exports.settings = settings;
exports.toJSON = toJSON;
exports.treeDraw = treeDraw;
exports.version = version;
exports.version_date = version_date;
exports.version_id = version_id;

Object.defineProperty(exports, '__esModule', { value: true });

}));
