if(NOT ROOT_root7_FOUND)
  return()
endif()

# Generate common dictionary for custom class
ROOTTEST_GENERATE_DICTIONARY(
  rntuple_event_dict
  ${CMAKE_CURRENT_SOURCE_DIR}/ntuple_makeproject_header.h
  LINKDEF ${CMAKE_CURRENT_SOURCE_DIR}/ntuple_makeproject_header_LinkDef.h
  # Otherwise TFile::MakeProject will find the dictionary module and will not generate the corresponding class header
  NO_ROOTMAP NO_CXXMODULE
  FIXTURES_SETUP generated_event_dictionary_rntuple
)

# Write the RNTuple with the custom class field
ROOTTEST_GENERATE_EXECUTABLE(
  write_rntuple
  LIBRARIES Core RIO ROOTNTuple
  FIXTURES_REQUIRED generated_event_dictionary_rntuple
  FIXTURES_SETUP write_rntuple_executable)

# Specify more than one input source for the generated executable
target_sources(
  write_rntuple
  PRIVATE write_rntuple.cxx rntuple_event_dict.cxx
)

ROOTTEST_ADD_TEST(write_rntuple
                  EXEC ./write_rntuple
                  FIXTURES_REQUIRED write_rntuple_executable
                  FIXTURES_SETUP written_rntuple)

# Call MakeProject on the output file
ROOTTEST_GENERATE_EXECUTABLE(
  makeproject_rntuple
  makeproject_rntuple.cxx
  LIBRARIES Core RIO ROOTNTuple
  FIXTURES_SETUP makeproject_rntuple)

ROOTTEST_ADD_TEST(makeproject_rntuple
                  EXEC ./makeproject_rntuple
                  FIXTURES_REQUIRED "written_rntuple;makeproject_rntuple"
                  FIXTURES_SETUP makeproject_rntuple_called)

# Read back the class instance thanks to the shared library generated by MakeProject.
# Make sure it corresponds to the data stored in the original custom class
if(MSVC)
  # Windows is more picky with the library name, provide full path to the test lib
  set(RNTUPLESTLTESTLIB ${CMAKE_CURRENT_BINARY_DIR}/librntuplestltest/librntuplestltest.lib)
else()
  set(RNTUPLESTLTESTLIB rntuplestltest)
endif()
ROOTTEST_GENERATE_EXECUTABLE(
  read_rntuple
  read_rntuple.cxx
  LIBRARIES ${ROOT_LIBRARIES} GTest::gtest GTest::gtest_main GTest::gmock GTest::gmock_main ${RNTUPLESTLTESTLIB} ROOTNTuple
  FIXTURES_REQUIRED makeproject_rntuple_called
  FIXTURES_SETUP read_rntuple_executable
)
target_include_directories(read_rntuple PRIVATE ${CMAKE_CURRENT_BINARY_DIR})
target_link_directories(read_rntuple PRIVATE ${CMAKE_CURRENT_BINARY_DIR}/librntuplestltest)

# Need to also explicitly set the LD_LIBRARY_PATH (at least on MacOS), so that
# the generated library with the custom class can be loaded by the read test.
# Setting the value of ${ld_library_path} in the ENVIRONMENT argument of the
# ROOTTEST_ADD_TEST function will not work, because that function sets the same
# variable internally, thus overriding our choice. The simplest thing to do is
# to append our directory to the ${ROOTTEST_ENV_LIBRARYPATH} contents, which
# are automatically used by ROOTTEST_ADD_TEST
set(_roottest_env_librarypath ${ROOTTEST_ENV_LIBRARYPATH})
set(ROOTTEST_ENV_LIBRARYPATH "${ROOTTEST_ENV_LIBRARYPATH}:${CMAKE_CURRENT_BINARY_DIR}/librntuplestltest")
ROOTTEST_ADD_TEST(read_rntuple
                  EXEC ./read_rntuple
                  FIXTURES_REQUIRED read_rntuple_executable
                  # PATH is used on Windows to find libraries for loading
                  ENVIRONMENT PATH=${CMAKE_CURRENT_BINARY_DIR}/librntuplestltest)
set(ROOTTEST_ENV_LIBRARYPATH ${_roottest_env_librarypath})

