# Generate common dictionary for custom class
ROOTTEST_GENERATE_DICTIONARY(
  ttree_event_dict
  ${CMAKE_CURRENT_SOURCE_DIR}/ntuple_makeproject_header.h
  LINKDEF ${CMAKE_CURRENT_SOURCE_DIR}/ntuple_makeproject_header_LinkDef.h
  # Otherwise TFile::MakeProject will find the dictionary module and will not generate the corresponding class header
  NO_ROOTMAP NO_CXXMODULE
  FIXTURES_SETUP generated_event_dictionary_ttree
)

# MakeProject with TTree data
# Write the TTree with the custom class branch
ROOTTEST_GENERATE_EXECUTABLE(
  write_ttree
  LIBRARIES Core RIO Tree
  FIXTURES_REQUIRED generated_event_dictionary_ttree
  FIXTURES_SETUP write_ttree_executable)

# Specify more than one input source for the generated executable
target_sources(
  write_ttree
  PRIVATE write_ttree.cxx ttree_event_dict.cxx
)
ROOTTEST_ADD_TEST(write_ttree
                  EXEC ./write_ttree
                  FIXTURES_REQUIRED write_ttree_executable
                  FIXTURES_SETUP written_ttree)

# Call MakeProject on the output file
ROOTTEST_GENERATE_EXECUTABLE(
  makeproject_ttree
  makeproject_ttree.cxx
  LIBRARIES Core RIO Tree
  FIXTURES_SETUP makeproject_ttree)

ROOTTEST_ADD_TEST(makeproject_ttree
                  EXEC ./makeproject_ttree
                  FIXTURES_REQUIRED "written_ttree;makeproject_ttree"
                  FIXTURES_SETUP makeproject_ttree_called)

# Read back the class instance thanks to the shared library generated by MakeProject.
# Make sure it corresponds to the data stored in the original custom class
if(MSVC)
  # Windows is more picky with the library name, provide full path to the test lib
  set(TTREESTLTESTLIB ${CMAKE_CURRENT_BINARY_DIR}/libttreestltest/libttreestltest.lib)
else()
  set(TTREESTLTESTLIB ttreestltest)
endif()
ROOTTEST_GENERATE_EXECUTABLE(
  read_ttree
  read_ttree.cxx
  LIBRARIES ${ROOT_LIBRARIES} GTest::gtest GTest::gtest_main GTest::gmock GTest::gmock_main ${TTREESTLTESTLIB}
  FIXTURES_REQUIRED makeproject_ttree_called
  FIXTURES_SETUP read_ttree_executable
)
target_include_directories(read_ttree PRIVATE ${CMAKE_CURRENT_BINARY_DIR})
target_link_directories(read_ttree PRIVATE ${CMAKE_CURRENT_BINARY_DIR}/libttreestltest)

# Need to also explicitly set the LD_LIBRARY_PATH (at least on MacOS), so that
# the generated library with the custom class can be loaded by the read test.
# Setting the value of ${ld_library_path} in the ENVIRONMENT argument of the
# ROOTTEST_ADD_TEST function will not work, because that function sets the same
# variable internally, thus overriding our choice. The simplest thing to do is
# to append our directory to the ${ROOTTEST_ENV_LIBRARYPATH} contents, which
# are automatically used by ROOTTEST_ADD_TEST
set(_roottest_env_librarypath ${ROOTTEST_ENV_LIBRARYPATH})
set(ROOTTEST_ENV_LIBRARYPATH "${ROOTTEST_ENV_LIBRARYPATH}:${CMAKE_CURRENT_BINARY_DIR}/libttreestltest")
ROOTTEST_ADD_TEST(read_ttree
                  EXEC ./read_ttree
		  FIXTURES_REQUIRED read_ttree_executable
      # PATH is used on Windows to find libraries for loading
      ENVIRONMENT PATH=${CMAKE_CURRENT_BINARY_DIR}/libttreestltest)
set(ROOTTEST_ENV_LIBRARYPATH ${_roottest_env_librarypath})
